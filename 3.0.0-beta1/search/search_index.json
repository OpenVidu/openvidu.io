{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"/","title":"Home","text":"<ul> <li> <p> Ready to use app</p> <p>You get OpenVidu Call with every OpenVidu installation.A fully-fledged videoconference application with all the features you expect: multiparty, device selection, screen share, chat, recording, virtual background and more!</p> </li> <li> <p> All is customizable</p> <p>If you want to integrate OpenVidu into your own application, there are UI Components that are quickly to setup but also highly customizable. If you want total control, you can use SDKs to fine-tune the integration of OpenVidu in your app. Learn more at Developing your OpenVidu app.</p> </li> <li> <p> Self-hosted</p> <p>OpenVidu is designed from the ground up to be self-hosted in your own servers. With OpenVidu you can easily deploy and manage a production-ready live-video solution in your own infrastructure, whether it is on premises or in your favorite cloud provider. Leverage your hardware and regain control of your users' data!</p> </li> <li> <p> Professional support</p> <p>We are experts in WebRTC. We have been developing real time tools and supporting customers building their solutions for over a decade. Let's work together to make your project a success! Contact us now.</p> </li> </ul> <ul> <li> <p> Easy to deploy</p> <p>What could take a whole DevOps team days of work, with OpenVidu you can have it ready in minutes: an easy installation, configuration and administration experience to your self-hosted, production grade, real-time solution. Install now.</p> </li> <li> <p> Cost effective</p> <p>OpenVidu COMMUNITY is open source, free and can handle a significant user load. With OpenVidu PRO you can handle more simultaneous Rooms in the same hardware thanks to mediasoup integration. This allows reducing the cost of each Room, making OpenVidu PRO truly cost-effective as a self-hosted solution. See Pricing.</p> </li> <li> <p> Performant</p> <p>OpenVidu is built to be incredibly powerful. It is based on the best open source WebRTC stacks: LiveKit and mediasoup. By combining the best of both worlds, OpenVidu provides outstanding performance.</p> </li> <li> <p> Scalable</p> <p>OpenVidu has been designed from the outset with scalability in mind. Host videoconference rooms and large live streams with hundreds of participants. Autoscale your cluster to adapt to the demand and optimize your resources.</p> </li> <li> <p> Fault tolerant</p> <p>OpenVidu offers fault tolerance in all its components. Deploy a reliable cluster knowing that if one of your node goes down, others will be able to continue working with no downtime.</p> </li> <li> <p> Observable</p> <p>OpenVidu brings everything necessary to monitor the status, health, load and history of your deployment. It automatically collects events, metrics and logs and provides OpenVidu Dashboard and a Grafana stack to navigate them.</p> </li> </ul> <ul> <li> <p> WebRTC</p> <p>Achieve ultra-low latency in your videoconference or live streaming app thanks to WebRTC.</p> </li> </ul> <ul> <li> <p> Security at all levels</p> <p>E2E encryption, fine-grained access control and highly secure deployments for the most demanding security requirements.</p> </li> <li> <p> Multiplatform</p> <p>Chrome, Firefox, Safari, Android, iOS, Unity, Windows, MacOS, Linux... OpenVidu is compatible with all of them.</p> </li> <li> <p> Up to 4K video and HQ audio</p> <p>HD up to 4K video resolution, and crisp audio quality with noise cancellation and echo suppression.</p> </li> <li> <p> Recording</p> <p>Record your videocalls with complete freedom. You can use predefined layouts or easily build your own.</p> </li> <li> <p> Broadcast to YouTube/Twitch</p> <p>OpenVidu allows you to easily broadcast your sessions to live-streaming platforms such as YouTube or Twitch.</p> </li> <li> <p> Screen sharing</p> <p>Screen share from browsers or native applications with ease, always with the best quality.</p> </li> <li> <p> Virtual Backgrounds</p> <p>Apply effects to your videos, blurring the background or replacing it with an image.</p> </li> <li> <p> Server side processing</p> <p>For the most advanced use cases: you can add pipelines to process video and audio streams in real time in your servers.</p> </li> </ul> Build, deploy on-premises and scale your videoconferencing or live streaming app with ease. Contact us if you need it : we are here to help! Talk to an expert"},{"location":"#get-started","title":"Create your real-time video and audio application with ease","text":""},{"location":"#get-started","title":"Self-host a production-ready live-video platform with advanced capabilities typically reserved for SaaS solutions","text":""},{"location":"#get-started","title":"All the features you need to quickly build your perfect real-time application","text":""},{"location":"/account/","title":"Account","text":""},{"location":"/pricing/","title":"Pricing","text":""},{"location":"/pricing/#pricing","title":"Pricing","text":"OpenVidu COMMUNITY OpenVidu PRO Price Free 0.0006$ core/minuteFree while in beta! * Type of deployment OpenVidu Single Node OpenVidu Elastic OpenVidu High Availability Suitability For applications with medium user load For applications with dynamic user load that require scalability For applications where both scalability and fault tolerance are critical Features Custom LiveKit distribution with Redis, Egress, Ingress, S3 storage and observability Same benefits as OpenVidu Single Node plus 2x performance, scalability and advanced observability Same benefits as OpenVidu Single Node and OpenVidu Elastic plus fault tolerance Number of servers 1 Node 1 Master Node +N Media Nodes  4 Master Nodes +N Media Nodes Installation instructions Install Install Install <p>About OpenVidu Pro free beta period</p> <ul> <li>OpenVidu Pro is currently in beta and will remain completely free until GA.</li> <li>All users running a beta version of OpenVidu Pro will be notified weeks before the free beta period ends, giving time to upgrade to the final GA version if desired.</li> <li>Active OpenVidu Pro clusters in beta version will eventually shut down automatically after the free beta period ends.</li> </ul>"},{"location":"/pricing/#how-is-openvidu-pro-priced","title":"How is OpenVidu Pro priced?There is a 15-day free trial period waiting for you!","text":"<p>OpenVidu Pro follows a simple pricing model based on the number of cores used by the OpenVidu Pro cluster:</p> $0.0006 per core per minute available for your OpenVidu PRO cluster  <p>Taking into account the following points:</p> <ul> <li>You only pay for your OpenVidu Pro cluster(s) for the time they are running. Usage will be registered the moment you start your cluster and will stop as soon as you shut your cluster down. When turned on, your cluster will be charged even in idle state (without active Rooms).</li> <li>You pay for every available core at any given time: if you cluster grows for one hour, that hour you will pay more. If your cluster decreases the next hour, next hour will be cheaper. Master Nodes and Media Nodes have the same core per minute price.</li> <li>Your OpenVidu Pro cluster(s) need to allow outbound traffic to domain <code>accounts.openvidu.io</code> port <code>443</code>. If you are behind a very restrictive corporate firewall that doesn't allow this, please contact us through commercial@openvidu.io.</li> </ul> Get an OpenVidu License"},{"location":"/pricing/#why-is-openvidu-pro-priced-like-this","title":"Why is OpenVidu Pro priced like this?","text":"<p>There are deliberate reasons for this pricing model in OpenVidu Pro:</p> <ul> <li>We believe that a platform specifically designed to be self-hosted should have a pricing model that is as close to hardware as possible: that is the total number of cores available to the cluster over time.</li> <li>This pricing model is simple, transparent and easy to predict: you pay only for the time the cluster is running and always according to its size.</li> <li>The cost is directly proportional to the size of your cluster: larger clusters pay more, smaller clusters pay less.</li> <li>Elasticity is encouraged: adjust the size of your cluster according to the load at any given time to minimize costs.</li> </ul>"},{"location":"/pricing/#when-and-how-are-you-charged","title":"When and how are you charged?","text":"<p>Users must create an OpenVidu account and get an OpenVidu License. This license will be required to deploy an OpenVidu Pro cluster (OpenVidu Elastic or OpenVidu High Availability).</p> <p>When purchasing an OpenVidu License, you will have to indicate your billing address and a credit card. You will receive a 15-day free trial period during which you will not be charged at all.</p> <p>After the free trial period, a monthly billing cycle will charge all your expenses to your credit card. Therefore, you will receive an invoice each month. You can review your upcoming expenses and your past invoices in your OpenVidu account page. And don't worry: we don't store any credit card data. The entire billing process is securely done via Stripe.</p> <p>OpenVidu Pro clusters will automatically report their usage on a recurring basis. That's why they need outbound access to domain <code>accounts.openvidu.io</code> port <code>443</code>. If you are behind a very restrictive corporate firewall that doesn't allow this, please contact us through commercial@openvidu.io.</p>"},{"location":"/pricing/#pricing-examples","title":"Pricing examplesThere is a 15-day free trial period waiting for you!","text":"<p>As explained above, every minute of an OpenVidu Pro cluster is charged according to the number of cores available for the cluster. So let's see some actual examples, first noting the following points:</p> <ul> <li>The examples represent a continuous usage of the cluster, but remember that you can shut it down whenever you are not using it and that you can drop nodes to save resources.</li> <li>Each example shows in a table the price for 8 hours, 1 day and 1 month of continuous usage, as well as the approximated amount of video Tracks and Rooms of 8 participants the cluster would support. This is done to provide a basic insight into the capacity of each cluster. These 8-to-8 Rooms assume 64 video Tracks (640x480) and 64 audio Tracks in them (2 tracks published and 14 tracks subscribed per Participant), with no Egress, Ingress or other additional features.</li> </ul> Get an OpenVidu License"},{"location":"/pricing/#openvidu-elastic-with-12-cores-in-total","title":"OpenVidu Elastic with 12 cores in total","text":"<p>This OpenVidu Pro Elastic cluster has 1 Master Node of 4 cores and 2 Media Nodes of 4 cores each.</p> Number of video Tracks 2000  Number of Rooms with 8 Participants 250 8 hours $3.46  24 hours (1 day of uninterrupted use) $10.37  720 hours (1 month of uninterrupted use) $311.04"},{"location":"/pricing/#openvidu-elastic-with-20-cores-in-total","title":"OpenVidu Elastic with 20 cores in total","text":"<p>This OpenVidu Pro Elastic cluster has 1 Master Node of 4 cores and 4 Media Nodes of 4 cores each.</p> Number of video Tracks 4000  Number of Rooms with 8 Participants 500 8 hours $5.76  24 hours (1 day of uninterrupted use) $17.28  720 hours (1 month of uninterrupted use) $518.40"},{"location":"/pricing/#openvidu-high-availability-with-32-cores-in-total","title":"OpenVidu High Availability with 32 cores in total","text":"<p>This OpenVidu Pro HA cluster has 4 Master Nodes of 4 cores each and 4 Media Nodes of 4 cores each. The number of simultaneous Rooms and Tracks will be the same as in the previous example, but this cluster will provide fault tolerance thanks to the replication of the Master Nodes.</p> Number of video Tracks 4000  Number of Rooms with 8 Participants 500 8 hours $9.21  24 hours (1 day of uninterrupted use) $27.65  720 hours (1 month of uninterrupted use) $829.44"},{"location":"/pricing/#openvidu-elastic-with-a-variable-number-of-cores","title":"OpenVidu Elastic with a variable number of cores","text":"<p>This OpenVidu Pro Elastic cluster takes advantage of the elasticity of the platform. It has a fixed Master Node of 4 cores, but a variable number of Media Nodes. Let's imagine a scenario where our days are divided in three phases according to the user load:</p> <ul> <li>First 8 hours of the day the demand is low. 1 Media Node of 4 cores is enough to handle it.</li> <li>The next 8 hours of the day the user load increases significantly (this is very typical if our application is used more during working hours). We add another Media Node of 8 cores to handle this new demand.</li> <li>The last 8 hours of the day the demand decreases, and we are able to remove the Media Node of 8 cores and keep only the Media Node of 4 cores.</li> </ul> First 8 hours of the day with low demand(8 cores in total) Video Tracks1000 8x8 Rooms125Price$2.30  Next 8 hours of the day with high demand(16 cores in total) Price$4.61 Video Tracks3000 8x8 Rooms375 Last 8 hours of the day with low demand(8 cores in total) Price$2.30 Video Tracks1000 8x8 Rooms125 Total for 1 day $9.21 Total for 1 month $276.30"},{"location":"/support/","title":"Support","text":"<p>Self-hosting your own solutions can be challenging. We have built OpenVidu to make this task as easy as possible. But of course you may encounter difficulties in the process, or your particular use case may require customized assistance. The OpenVidu team specializes in customer support. Together we will make your project a success!</p>"},{"location":"/support/#commercial-support","title":"Commercial support","text":"<p>Do not hesitate to contact us at commercial@openvidu.io. We provide consultancy, prioritizing bug fixes or new features, custom app development, etc.</p> <p>Let's work together and build something great!</p> <p>Info</p> <p>Do you need help updating from OpenVidu 2 to OpenVidu 3? Write us to pro.support.v2apps@openvidu.io and we will be happy to guide you through the process.</p>"},{"location":"/support/#community-support","title":"Community support","text":"<p>The public forum  is the right place to ask any questions that do not involve private information, so that the whole community can benefit from the exchange of ideas.</p>"},{"location":"/blog/","title":"Blog","text":""},{"location":"/conditions/cookie-policy/","title":"Cookie Policy","text":""},{"location":"/conditions/cookie-policy/#what-are-cookies","title":"What are cookies?","text":"<p>TIKAL TECHNOLOGIES SL web page uses cookies, which are small files that it exchanges with the visitor's web browser for different purposes. That is done in a totally \"invisible\" and harmless way for the visitor, so your visit to the page is more fluid and you are not interrupted by some functions. The following explains which is the usage of cookies in TIKAL TECHNOLOGIES SL website and how you can disable them if you don't agree.</p>"},{"location":"/conditions/cookie-policy/#what-kind-of-information-do-we-collect","title":"What kind of information do we collect?","text":"<p>TIKAL TECHNOLOGIES SL web page uses cookies for the following purposes</p> <ul> <li>Functional cookies: they are used to improve the visitor's navigation through the website, making it more user-friendly. It is important to understand that cookies do not contain any kind of specific personal information, and most of them are deleted from the hard disk at the end of the browser session.</li> <li>Analytical Cookies: TIKAL TECHNOLOGIES SL website uses cookies from Google Analytics, to analyze how visitors use the page. This way, TIKAL TECHNOLOGIES SL can offer improvements in the usability of the webpage. Google Analytics only collects and processes anonymous data through the TIKAL TECHNOLOGIES SL website. There is further information about the management of Google Analytics' web analysis services at www.google.com/analytics.</li> </ul>"},{"location":"/conditions/cookie-policy/#how-are-users-able-to-change-the-cookies-configuration-in-their-browsers","title":"How are users able to change the cookies configuration in their browsers?","text":"<p>Any browser allows you to make adjustments on the actions to perform whenever a website asks you to store a cookie. You can:</p> <ul> <li>Allow web pages to deposit cookies in the browser.</li> <li>Allow the cookies of the visited web pages only to remain in the browser as long as the page remains open.</li> <li>Do not allow web pages to deposit cookies in the browser. Please note that in this case, some website functions will not be operational or the full page could even not work at all.</li> <li>Allow one by one which web pages will be able to deposit cookies in the browser. Please note that in unauthorized pages some website functions will not be operational or the full page could even not work at all.</li> </ul> <p>The modification of the cookies configuration can be done in the option \"Configuration\" of the browser, in the \"Privacy\" section.</p>"},{"location":"/conditions/privacy-policy/","title":"Privacy Policy","text":"<p>In accordance with the provisions of Regulation (EU) 2016/679 and the Organic Law 3/2018 of 5 December, on the protection of personal data and guarantee of digital rights, we inform you that the data you provide will be incorporated to the treatment system owned by TIKAL TECHNOLOGIES SL with CIF B85986669 and address at Calle Chile, N\u00ba 10, 28290 - Las Rozas de Madrid (Madrid), for the purpose of ELECTRONIC COMMERCE, CUSTOMER MANAGEMENT, AND OTHER PURPOSES. Your data may be processed by third parties (they will be data processors recipients of your data for contractual purposes for example, our computer maintenance company) requiring the same level of established rights, obligations and responsibilities. Your details will be kept for the time only strictly necessary. They will be deleted when a period of time has elapsed without any use being made of it. You agree to notify us of any changes in the data. You will be able to exercise your access rights, rectification, limitation of treatment, deletion, portability and opposition to processing of your personal data by addressing your request to the management or to the e-mail info@naevatec.com. You can contact the appropriate supervisory authority to make any complaint you may consider necessary.</p>"},{"location":"/conditions/terms-of-service/","title":"Terms of Service","text":"<p>The purpose of the following terms and conditions is to explain our obligations as providers of the service, as well as your obligations as a client. Please read them carefully. </p> <p>The aforementioned terms and conditions shall be applied from the moment TIKAL TECHNOLOGIES provides you with access to the service, thus it is understood that you have voluntarily accepted them as part of the contractual obligations between the parties involved, that is, between TIKAL TECHNOLOGIES (TIKAL form now on) and you as client. OpenVidu PRO is a service which will vary with time, so as to adapt to its clients and users\u00b4 new requirements, which in turn, will likely affect the terms and conditions so that they suit the changes and variations made to TIKAL. </p> <p>TIKAL reserves the right to change the terms and conditions at any given moment, notwithstanding, it shall always endeavour to communicate these via e-mail or through the application itself; consequently, we strongly advise you to ensure that you have read and understood the terms and conditions whose most recent, updated version, is available on our website.</p>"},{"location":"/conditions/terms-of-service/#first-definitions","title":"First. Definitions.","text":"<p>For the legal purposes of this contract, the following definitions will apply:</p> <ol> <li>Software application: a set of instructions which will be interpreted, utilized and executed by a computer system. Even when there may be many of them, the present contract may refer to them in singular, and likewise when pertaining to its backup files.</li> <li>Telematics application: a software application within a server which is connected to the Internet such that it can be accessed remotely through electronic networks. The assignment of the license to use the telematics application OpenVidu PRO is the subject of the present contract.</li> <li>Client of the telematics application: the natural or legal person who benefits from the licence to use the telematics application, thus assuming all obligations arising from the present contract.</li> <li>User of the telematics application: the natural person authorized by the client to use the telematics application, who in turn assumes all obligations arising from the present contract and said utilization.</li> <li>Parties: TIKAL and the client.</li> <li>Exploitation rights over the telematics application: TIKAL TECHNOLOGIES SL</li> <li>Third parties: any natural or legal person alien to the present contractual relation, who, for any reason, enters into a formal, legally binding agreement with either TIKAL or the client.</li> <li>The service, all supporting infrastructure provided by TIKAL that allows the client to register, download, provision bill, and operate its instance of the telematics application</li> <li>Hardware: electronic, mechanic or magnetic devices necessary for the telematics application, and its complementary parts, to work properly.</li> <li>Personal data: any information regarding an identified or identifiable natural person.</li> <li>Updates: new versions of the telematics application and/or its modules, which include new functionalities and improvements when compared to earlier versions.</li> <li>Telematics application modules: parts of the telematics application which manage specific functionalities, and whose licence to use them, the client must acquire separately.</li> </ol>"},{"location":"/conditions/terms-of-service/#second-purpose","title":"Second. Purpose","text":"<ol> <li>The purpose of the present contract is the licensing of the right to use the telematics application OpenVidu PRO by TIKAL TECHNOLOGIES SL. to the client, so that it may be use in the management of their business. Subject to the terms and conditions provided in this agreement, TIKAL hereby grants to the client a non-exclusive, non-sublicensable, non-transferable license to use the telematics application OpenVidu PRO (from now on \u201ctelematics application\u201d). Under no circumstances however, does said licence grant the client sales rights over the telematics application whose ownership remains entirely with TIKAL TECHNOLOGIES SL.</li> <li>The client\u00b4s rights to use the telematics application are subjected and limited by both the duration, and the terms and conditions established in the present contract.</li> <li>Hereby the client agrees to use the telematics application in compliance with the law, the present contract, and the good and rational will inherently present in any civilized society.</li> <li>The client acknowledges having examined that OpenVidu PRO features fulfil their needs, and that it has been appropriately informed by TIKAL about them.</li> </ol>"},{"location":"/conditions/terms-of-service/#third-use-limitations-and-duty-of-care","title":"Third. Use limitations and duty of care.","text":"<ol> <li>The client must protect and guard the telematics application; thus, it may not share any information whatsoever with third parties. It is specifically forbidden the use of the telematics application outside the business sphere for which it has been acquired, or outside any of the dispositions stipulated in this contract. The client may not sell, lease, transfer, or otherwise sublicense the telematics application or take part in any act which may result in the violation of their duty of care and protection. The client may not assign, transfer, pledge or make any other disposition of the rights acquired through this contract, of any part of the contract, or of any of the rights, claims or obligations under the contract.</li> <li>The client is obligated to refrain from using the telematics application for illegal purposes or any other purposes contrary to what is established in the present contract, or any action that may be injurious to TIKAL\u00b4s rights and interests, to the owner of the telematics application, as well as to any third parties involved. Said actions include, but are not limited to, any deed that may harm, overload, disrupt, or otherwise render useless the telematics application, thus preventing other clients and users from making use of it.</li> <li>Changes to the telematics application are strictly forbidden. These include, but are not limited to, such things as reverse engineering, decompiling, disassembling, reproducing, translating, modifying, commercializing, cloning, transforming or transmitting to any natural or legal person, partially or entirely, by any means, whether mechanic, magnetic, photocopies, etc\u2026 or to eliminate or block any proprietary notice or logos pertaining to the telematics application. The components and elements subject to the aforementioned restrictions include, but are not limited to, such things as the logical diagrams, source codes, object and/or data model; except prior, written authorization from TIKAL. These restrictions stand, even when said actions where needed for the interoperability with other computer programs or telematics applications.</li> <li>The client or the user must protect and safeguard, both physically and intellectually, the telematics application, namely, its contents, logical procedures, and access protocols, by establishing the necessary means in order to guarantee the non-disclosure, cloning, reproduction, altering, translation, transformation, access by third parties, or any other action that shall imply a violation of the duty of care or of any intellectual and industrial property right.</li> <li>The telematics application may only be used by the client or authorized user, for processing the client\u00b4s own data and their products, but under no circumstances shall it be used to process third parties \u2018data.</li> <li>TIKAL cannot guarantee uninterrupted access to the service throughout the entire validity period of this contract due to unforeseeable factors such as network issues, telecommunications service providers, breakdown in computers, as well as other contingencies such as repair and maintenance work, and software updates. Notwithstanding this, TIKAL reserves the right to adopt any necessary measures to limit the service, should it be considered that improper and/or irresponsible use of the telematics application is occurring, specially when said uses run counter to the terms and conditions provided in the present contract.</li> <li>Should the client or user breach the terms of contract, in a continuous and sustained fashion, or acting in bad faith, TIKAL shall terminate the provision of the service, without reimbursing any amount, on the grounds of abusive and improper use.</li> <li>Interpretation and scope. Any other right which has not been stated or directly mentioned in the present contract, remains reserved to TIKAL. Under no circumstances shall the terms and conditions of this contract be interpreted or applied in such a fashion that could be injurious to TIKAL or in any manner that runs counter to the regular exploitation framework of a telematics application.</li> </ol>"},{"location":"/conditions/terms-of-service/#fourth-liability","title":"Fourth. Liability.","text":"<ol> <li>TIKAL\u00b4s telematics application is access-ready in its current state and configuration. Should the application contain any deficiency attributable to TIKAL TECHNOLOGIES SL, the latter pledges to make use of all the resources available to them in order to solve the issue as promptly as possible. Nonetheless, it declines any liability and does not give any guarantee regarding violations perpetrated by third parties, marketability, satisfactory quality or suitability for a specific purpose.</li> <li>TIKAL shall act with due diligence and professionalism by making use of all its resources available so as to ensure the quality, reliability, and security of the telematics application. In any case, TIKAL\u00b4s assumes no liability for any damages, direct or indirect, incidental or special, including, but not limited to, such things as damages or financial loss, work disruptions, failure, breakdown, or any losses, even when the possibility of such inconveniences occurring, which include third-party complaints, were previously notified to a member of TIKAL\u00b4s staff.</li> <li>The client accepts, within reason, to tolerate specific, isolated disruptions in connectivity and hereby forfeits the right to claim any liability, contractual or otherwise, as well as damages owing to possible failures, slowness or access errors. TIKAL declines any liability concerning data loss, accidental or otherwise, resulting from the client\u00b4s actions or activities.</li> <li>The client or user is solely responsible for the provision and payment of the costs necessary to ensure compatibility between the telematics application and their equipment, including all hardware, software, electronic components, and any other component required to access the telematics application, these include, but are not limited to, such things as telecommunication services, Internet access and connectivity, operating systems, or any other program, equipment or services, required to access and use the telematics application.</li> <li>TIKAL declines any liability regarding any content that the client or user may host within the telematics application OpenVidu PRO, since at no moment, does TIKAL intervene in the internal processing of said content. Therefore, and in accordance with art.16 of LSSI-CE, TIKAL is not legally bound to remove any content from the server, provided there is no \u201cactual knowledge\u201d that the activity or information stored is illegal, libellous, or injurious to third-party rights or assets. In this regard, it shall be understood that \u201cactual knowledge\u201d exits, when there is a court or administrative decision, ordering to block or remove content and that the contractor (TIKAL) has been made aware of it. Notwithstanding, TIKAL reserves the right to remove this type of content out of its own volition, once it has been detected, whilst the client waives any right to claim or demand compensation. Should the application be in any way damaged due to the introduction of malign software or content (virus, trojan,\u2026) TIKAL reserves the right to automatically terminate the contract without having to pay any compensation whatsoever. On the other hand, TIKAL hereby reserves the right to demand compensation from the client or user for any damages caused to the system.</li> <li>The client or user shall burden all legal costs incurred when the cause is attributable to them, these include TIKAL lawyers\u2019 fees, even when a final court decision has yet to be reached.</li> <li>TIKAL uses information security protocols which are broadly accepted and observed by the industry such as firewalls, access-control procedures, and crypto mechanisms in order to avoid any unauthorized access to the data. For this purpose, the client hereby grants TIKAL access to data so that it can perform access-control authentication. The licensing process or any process which entails the introduction of personal data shall always conducted under a rigorous communication protocol so as to ensure no third parties have access to data transmitted electronically.</li> </ol>"},{"location":"/conditions/terms-of-service/#fifth-intellectual-and-industrial-property-rights","title":"Fifth. Intellectual and industrial property rights.","text":"<ol> <li>The exploitation rights of the telematics application are owned by TIKAL and protected by Spanish Intellectual Property Laws applicable in any country where it is used. The structure, organization and coding of the telematics application constitute confidential and valuable industrial and commercial secrets which belong to TIKAL. Therefore, the client must treat the telematics application in the same fashion they would when utilizing any material protected by intellectual property rights, thus copying, duplicating, or cloning the application is strictly forbidden.</li> <li>The present licence to use the telematics application does not imply, either explicitly or implicitly, the assignment of the intellectual and industrial rights over said application, the hardware, or the data model.</li> <li>Brands must be utilized in accordance with the commercial uses of brands, including acknowledging the proprietor\u2019s name of the brand. Brands may only be used in order identify those printouts produced by the telematics application. Said utilization does not imply or grant any property rights over the application.</li> <li>The knowledge and expertise intrinsic to the telematics application, as well as the knowledge utilized to configure it, is confidential information which belongs to the owner of the telematics application TIKAL. The client acknowledges this and assumes all liability regarding fraudulent use, or illegal copy or duplication of said application, or complementary programs, or utilization of this information by third parties, being liable for any breach of the present contract, by them or by any person or persons depending or associated with the client, or when these individuals have been granted access, directly or indirectly, to the telematics application by the client.</li> <li>Updates: For the entire validity period of the present contract, and in accordance with the terms and conditions stipulated in the next paragraph, the client is entitled to have access to the updates of the telematics application as they arise. The client assumes all legal liability for the updates, regarding limitations and duty of care, in the same fashion as with the original computer application. Updates to additional modules of the telematics application shall be given to those clients who have acquired from TIKAL the licence to use said modules.</li> <li>Hereby the client gives TIKAL consent to incorporate them as such into their business portfolio, thus allowing TIKAL to use their brand and logo on its website as well as in documents which may be given to other potential clients, for the sole purpose of said portfolio, and provided that the client does not express opposition to them being used in such a fashion.</li> </ol>"},{"location":"/conditions/terms-of-service/#sixth-right-to-amend","title":"Sixth. Right to amend.","text":"<p>TIKAL reserves the right to update the telematics application to the latest version available on the market. Said updates may include, but are not limited to, such things as new functionalities, improvements, and modifications and legal updates to the telematics application, which may vary, at any moment such things as its features, performance, and configuration of the telematics application content. </p> <p>TIKAL pledges to evaluate and take into consideration suggestions and requests made by clients and users of the telematics application so that they may be incorporated in the new versions of said application; however, it is TIKAL\u00b4s right, not the client\u00b4s to decide which modifications or improvements may be included in the aforementioned versions. </p> <p>TIKAL reserves the right to modify, at any moment, the characteristics, features, and conditions of TIKAL for the benefit and development of the service. With this in mind, TIKAL may only have to observe the formality of having to notify the client via an on-line notice, or by modifying any clause in this contract. Notwithstanding the foregoing, TIKAL shall endeavour to promptly notify the client so that the latter may adapt them.</p>"},{"location":"/conditions/terms-of-service/#seventh-exclusion-and-termination-of-licensing","title":"Seventh. Exclusion and termination of licensing.","text":"<ol> <li>TIKAL reserves the right to exclude and/or terminate, temporarily or in a definite manner, the client\u00b4s right to use the telematics application, in case the following occurring:<ul> <li>Breach of any of the terms and conditions of the present contract.</li> <li>Breach of law and order and/or improper, illegal, or negligent professional behavior.</li> <li>When a court, administrative, or official decision is made to do so.</li> </ul> </li> <li>The exclusion clause, or termination of this contract, does not imply that TIKAL forfeits the right to take legal actions or file for financial compensation when the client has acted in bad faith to damage, directly or indirectly, the telematics application.</li> </ol>"},{"location":"/conditions/terms-of-service/#eighth-communications","title":"Eighth. Communications.","text":"<ol> <li>For the purposes of establishing a line of communication regarding the present contract both parties agree to use the place of residence which appears in it. The client pledges to keep the e-mail account provided in this licensing agreement, operational, activated and updated for the purposes of communications with TIKAL, which constitutes TIKAL\u00b4s preferred line of communication (albeit not the only one). In general terms, the client pledges to keep their personal details updated, and must communicate TIKAL, in a clear, unambiguous manner, of any changes.</li> <li>Should the client fail to notify said changes, notifications or notices delivered to the address(es) given by the client in the licensing agreement, shall be considered valid.</li> <li>The client consents that telephone conversations with TIKAL may be recorded with the intent to improve the quality and security of the service.</li> </ol>"},{"location":"/conditions/terms-of-service/#ninth-duration","title":"Ninth. Duration.","text":"<ol> <li>The contract shall be valid indefinitely from the moment the client requests it. The client can also put the end to the contract at any time he wishes, being obliged to pay the pending consumed service.</li> <li>As long as the period contract holds it is understood that the validity of the contract published on TIKAL\u00b4s website and containing all updates, prevails.</li> </ol>"},{"location":"/conditions/terms-of-service/#tenth-terms-of-payment","title":"Tenth. Terms of payment.","text":"<ol> <li>The price, payment method, billing and payment of the telematics application licensing, object of the present contract, is stipulated in the Current Official Rates Section published on TIKAL\u00b4s website (https://openvidu.io at the time of writing), which are considered part of a whole to all intents and purposes.</li> <li>The price stipulated in the aforementioned Current Official Rates Section, do not include valued added tax (VAT), nor does it include any other taxes or fees established by law whose current rates shall be applied for the provision of the service when signing the present contract. Therefore, said amounts may be increased according to current tax rates.</li> <li>Payment will be done monthly and will cover the whole amount of the service consumed during last month period according to the currently published rates from TIKAL.</li> <li>Monthly payments include both the basic rate for the provision of the service, and the corresponding rate(s) for any optional or additional service hired.</li> <li>Payments must be made effective by the credit or debit card that the client has agreed with TIKAL when first hiring the service. Visa and MasterCard shall be the accepted cards.</li> <li>Total or partial delay in payment by the client for the amount(s) TIKAL has billed them shall grant TIKAL the right to cancel or terminate all contracted obligations in accordance with the present contract. Suspension of the service provision shall be realized within the next fifteen natural days after the contract has reached its expiry date, prior notice to the client. After said fifteen natural days from the day the service was suspended, and prior notification to the client, TIKAL may terminate the contract. If the client pays the full amount owed to TIKAL during said period, the latter shall re-establish the service as promptly as possible from the moment it is notified that the debt has been settled. Notwithstanding the foregoing, TIKAL reserves the right to ask for a two-month deposit as a guarantee before re-establishing the service. The client accepts all liability for any legal costs incurred due to claims made by TIKAL regarding breach of payment after the contract has reached its expiry date, including, but not limited to, such things as the return of invoices and late-payment interest.      When the client returns, for any cause alien to TIKAL, two or more direct-debit invoices, TIKAL shall be entitled to unilaterally opt for the annual hiring and billing of the service.</li> <li>When the client has defaulted on a payment, either totally or partially, during three months, for the amount owed to TIKAL, the latter has the right to rescind the contract between the two parties, as well as the direct and definite termination and cancellation of the service hired by the client, including the database linked to the client\u00b4s services, without prior notice from TIKAL.</li> <li>TIKAL shall apply upon its rates any current deals and offers existing at the time the client hires the service, provided they comply with the terms and conditions of said deals and offers so that they may benefit from them. The client acknowledges and accepts the fact they may obtain detailed information, at any given time, regarding said deals and offers on TIKAL\u00b4s website or through the habitual communication channels with which TIKAL provides its clients.</li> </ol>"},{"location":"/conditions/terms-of-service/#eleventh-data-protection","title":"Eleventh. Data Protection.","text":"<p>The parties involved agree that they know, comply with, and are subject to, the Spanish and European laws and legislation regarding Personal Data Protection, thus they must give proper use and treatment to all data arising from any activity subjected to the terms and conditions of this contract.</p>"},{"location":"/conditions/terms-of-service/#data-controller-agreement-between-the-client-and-tikal","title":"Data Controller agreement between the client and TIKAL.","text":"<p>In accordance with the Spanish Data Protection Laws, TIKAL\u00b4s access to the client\u00b4s personal files shall not be considered a violation of said laws, insofar as TIKAL is effectively the Data Controller and said access is necessary for the provision of the service which is the subject of this contract. </p> <p>In this regard, and for the purposes of Data Protection regulation, TIKAL shall be regarded as the \u201cData Controller\u201d of the client\u00b4s data. Notwithstanding the foregoing, TIKAL pledges that it shall treat said data in conformity with the client\u00b4s instructions provided in this contract, and that under no circumstances shall it utilise them for any other purposes outside of what the parties have agreed in this contract, nor shall it transfer or communicate them to a third party, not even for back-up or storage purposes. At the same time, the duration and validity of this agreement shall correspond to the type of service hired by the client. </p> <p>Once the provision of said service terminates and the data shall no longer be necessary to perform the aforementioned Data Controller role, all personal data shall be either destroyed or returned to the person, persons or entity responsible for it, as well as any storage medium, documents or files containing personal data. </p> <p>In order to provide the service and what said provision entails, TIKAL shall be granted access to the following information:</p> <ol> <li>Contact details</li> <li>Company profile data</li> <li>Assets and billed services data</li> <li>Tax identification data</li> </ol> <p>TIKAL\u00b4s obligations as Data Controller are described as follows:</p> <ol> <li>Treat all data in accordance with the instructions received by the person, persons or entity in charge of its treatment and only for the purposes provided in this contract.</li> <li>To not communicate or transfer any data to third parties, except prior consent by the body in charge of its treatment, or in cases provided for by the law.</li> <li>TIKAL may not outsource, either totally or partially, the provision of the service(s) described in the present contract, except prior authorization from the client whom shall be informed with due notice about the outsourcing entity as well as the services being outsourced. In this case, TIKAL shall draft and execute a new contract with said outsourcing entity, always in accordance with the current Data Protection laws.</li> <li>To not disclose any personal data to which TIKAL may have had access, even after the termination of this contract.</li> <li>To guarantee that the staff managing personal data pledge to keep the confidentiality which said data entails and that they comply with the proper security protocols.</li> <li>To assist the person or body responsible for data treatment regarding data protection.</li> <li>To provide the person or body responsible for data protection with support and assistance when performing an impact assessment, or when consulting the regulatory authorities, if applicable. Additionally, to provide said person or body with the necessary information so that it may prove their compliance with the rules and regulations.</li> <li>Notwithstanding the foregoing, said person or body has mechanisms in place so as to guarantee the confidentiality, integrity, and availability of the systems and services concerning data protection, as well as to restore the access and availability to data in case of system failure. Additionally, it is endowed with capabilities so as to regularly verify and assess the efficacy of the security protocol.</li> </ol> <p>Duties of the responsible for data treatment:</p> <ol> <li>To guarantee, at all times, compliance with the Data Protection Laws.</li> <li>Make all necessary enquiries beforehand.</li> <li>To supervise that proper data treatment is occurring.</li> <li>To provide the data controller with all necessary data for the provision of the service.</li> </ol> <p>TIKAL\u00b4s duties as Data Controller:</p> <ol> <li>To guarantee, at all times, compliance with the Data Protection Laws.</li> <li>Make all necessary enquiries beforehand.</li> <li>To supervise that proper data treatment is occurring.</li> <li>To provide the data controller with all necessary data for the provision of the service.</li> </ol>"},{"location":"/conditions/terms-of-service/#twelfth-confidentiality","title":"Twelfth. Confidentiality.","text":"<ol> <li>All data and information transmitted between the parties is strictly confidential and property of TIKAL and the client, and its protection is of the utmost importance. To this intent, both parties hereby contract the obligation to safeguard said data and information by adopting all appropriate measures to ensure that only authorized individuals shall have access to it; authorized individuals being understood as those employees which are needed by the parties involved so as to keep the provision of the service, which is the object of this contract, in good working order.</li> <li>In this regard, the signatory parties are hereby subject to the following confidential agreement:<ul> <li>Hereby TIKAL pledges to keep confidential all data and information supplied by, and concerning the client, as well as the output arisen from the service provided. In this regard, TIKAL possesses strict internal controls whose objective and end are to guarantee the integrity of the present confidential agreement.</li> <li>The client therefore agrees to keep confidential all data and information arising from TIKAL\u00b4s internal processes, specially the existence, utilization, and functionalities of any process used in the provision of the service.</li> <li>The present confidential agreement shall remain valid even after the termination of the present contractual relation and extends indefinitely to all members of staff that have been granted access to said confidential information.</li> </ul> </li> </ol>"},{"location":"/conditions/terms-of-service/#thirteenth-termination-rescission-nullity","title":"Thirteenth. Termination. Rescission. Nullity.","text":"<ol> <li>The present contract shall be considered void for infringement, committed by any of the parties involved, of the Spanish Civil Code, and in particular, of the Spanish Commercial Code, and the obligations arising from the following:<ul> <li>Mutual consent of the parties involved.</li> <li>When the present contract has reached its expiry date which is specified in clause tenth, or within the subsequent extensions thereof.</li> <li>By unilateral rescission provided that the party wishing to rescind communicates this at least one month in advance.</li> <li>When any of the parties has been officially put into administration, has filed for bankruptcy protection, is under bankruptcy or insolvency proceedings, or is under liquidation or dissolution.</li> <li>Due to any other reason(s) provided for in law.</li> <li>Should any of the parties involved breach the contracted obligations provided in the present contract, the other party may consider it as void. Said consideration warrants no prior notice or compensation of any kind, but for the need to communicate the decision to the other party; unless the unaccrued obligations owed by the party are performed within the next fifteen days, counting from the moment said party was notified that they are in breach of the contract . Notwithstanding the foregoing, the other party reserves the right to claim or file for damages caused by this infringement.</li> </ul> </li> <li>TIKAL pledges to destroy all data provided by the client once the contractual relation is extinguished. Likewise, TIKAL shall destroy or return any document or storage medium containing any IT-related data arising from said contractual relation. Once said contractual relation terminates, the client may request TIKAL to supply them with a hard, back-up copy of all data pertaining to and arising from said relation, to any address the client wishes, prior to a written request to do so, which must be sent within the week after the end of the contract. The client shall burden the costs incurred arising from the handling and mailing of said request.</li> <li>The client may cease or cancel the use of the telematics application whenever they wish to do so. Should the client or any authorized user by them request the cancellation of the service at TIKAL\u00b4s offices, it shall become effective on the same day said request was made. Therefore, it is advised to carefully observe said process to avoid any resources or data loss that the client or user may have in their TIKAL\u00b4s account. Should it not be possible for them to initiate said cancellation process at TIKAL\u00b4s offices, the client may request it by contacting TIKAL\u00b4s customer service via any of the channels provided in this contract. Said cancellation shall become effective on the day stipulated by the client, provided that the request has been made with enough time to be processed correctly.</li> </ol>"},{"location":"/conditions/terms-of-service/#fourteenth-applicable-legislation-and-jurisdiction","title":"Fourteenth. Applicable legislation and jurisdiction.","text":"<p>The present is a business contract regulated by Spanish laws. The parties involved agree that any discrepancy, legal or civil action, claim or complain arising from the interpretation and execution of the present contract, shall be, directly or indirectly, taken to the Court of Madrid, thus all parties involved hereby renounce to take any matters pertaining to this agreement to any other jurisdiction. </p> <p>The present document constitutes the total agreement of the parties in relation to the matters covered in this agreement, thus substitutes all previous obligations, liabilities, and agreements, both written and verbal, existing prior to the signature and execution of this contract. </p> <p>The following website (www.naevatec.com) belongs to: TIKAL TECHNOLOGIES SL TAX ID: B85986669 10 Chile Rd/St 28290 \u2013 Las Rozas de Madrid (Madrid City) Spain. Registered in the Madrid\u00b4s Trade Register, volume/tome 28043. Book 0 Section 8th of the Registry Book, Page 37, Sheet M-505315.</p>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/","title":"Comparing OpenVidu","text":"<p>This section compares OpenVidu to other videoconference/streaming solutions, to better understand what it is, what it is not, and what advantages and disadvantages it may have over them.</p>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/#openvidu-vs-livekit","title":"OpenVidu vs LiveKit","text":"<p>First of all, and perhaps the most obvious question, how does OpenVidu differ from LiveKit, and what kind of relationship is there between them? This can be answer with four simple points:</p> <ul> <li>OpenVidu is a fork of LiveKit. It is 100% compatible with LiveKit: any application built for LiveKit is compatible with OpenVidu.</li> <li>OpenVidu is a superset of LiveKit. It provides all of the open source features of LiveKit and supports all of its SDKs, but it also extends LiveKit with extra features, APIs and internal enhancements, most notably integration with mediasoup.</li> <li>OpenVidu is a production-ready self-hosted solution. It offers an easy deployment process to self-host a high performance, fault tolerant, scalable and observable cluster. OpenVidu provides an interactive installer that manages all of the complexities, so you can quickly host a production deployment that would otherwise require advanced devops/SRE expertise.</li> <li>OpenVidu is a support team for self-hosted deployments. The OpenVidu team is made up of real-time experts with over a decade of experience in the field. We specialize in customer support and are always ready to help you bring your ideas to life.</li> </ul> <p> </p> OpenVidu is a custom fork of LiveKit, 100% compatible in terms of its API and SDKs, with the power of mediasoup at its core. This and other integrations provide improved performance, new features and facilitate the deployment and management of your cluster. <p>LiveKit comes in two flavors: LiveKit Open Source and LiveKit Cloud.</p>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/#openvidu-community-vs-livekit-open-source","title":"OpenVidu COMMUNITY vs LiveKit Open Source","text":"<p>LiveKit Open Source is probably the most advanced and feature-rich open source WebRTC stack available today. It has a simple but very versatile API design, and has a large collection of SDKs to integrate into your application on both the frontend and backend. Regardless of your technology stack, there is sure to be a LiveKit Open Source SDK available for you! This is why OpenVidu is fully compatible with LiveKit protocols. You can use any LiveKit SDK to build your application, and it will work seamlessly with an OpenVidu deployment.</p> <p>What does OpenVidu Community bring over LiveKit Open Source?</p> <p>With OpenVidu Community you get a handful of features on top of LiveKit Open Source that will help with the development of your application:</p> <ul> <li>Egress and Ingress services already integrated with a Redis instance: LiveKit allows you to export media from a Room (for example recording it) or import media into a Room (for example ingesting a video file), using Egress and Ingress services respectively. These modules are independent of LiveKit Server and must be correctly configured and connected via a shared Redis. When running OpenVidu Community you will have all these services properly integrated, so you can focus on developing your app without worrying about anything else.</li> <li>S3 compatible storage for Egress recordings: OpenVidu Community comes with an S3 compatible storage already configured to store Egress recordings (Minio).</li> <li>Administration dashboard to monitor your Rooms: OpenVidu comes with an administration dashboard that allows you to monitor the status of your Rooms. Not only in real time, but also historically: the number of participants, the number of published tracks, Egress and Ingress processes... This is a great tool to have when developing your app, as it can help spotting issues and debugging your application's logic. See more.</li> <li>OpenVidu Call: a fully-fledged videoconference application that you can customize and adapt to your needs. See more.</li> <li>Powerful and easy to use local development environment: OpenVidu provides a Docker Compose based deployment designed for development and testing devices on your local network. It comes with automatic certificate management that makes it easy to test mobile devices in your LAN. See more.</li> </ul>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/#openvidu-pro-vs-livekit-open-source","title":"OpenVidu PRO vs LiveKit Open Source","text":"<p>Deploying LiveKit Open Source in production requires devops/SRE experience to operate your own network of media servers, load balance between them, maintain high uptime and monitor the health of your deployment. OpenVidu Pro makes this an easy process, hiding most of the complexities of such an advanced deployment. With OpenVidu Pro you can self-host a fault-tolerant, scalable and observable cluster, while doubling the original LiveKit Open Source performance to handle twice as many media streams with the same hardware.</p>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/#openvidu-pro-vs-livekit-cloud","title":"OpenVidu PRO vs LiveKit Cloud","text":"<p>LiveKit Cloud is the official SaaS solution for LiveKit. They manage the infrastructure, with a pricing model based on the total bandwidth consumed by your application. It offers certain advantages over LiveKit Open Source:</p> <ul> <li>Analytics and telemetry dashboard. LiveKit Open Source does not export any metrics or logs out-of-the-box.</li> <li>Massive Rooms for livestreams, where a theoretically unlimited number of viewers can be established for published tracks. In LiveKit Open Source one Room must fit in a single server. LiveKit Cloud overcomes this limitation with a mesh architecture where one media server can connect to other media servers to distribute the load.</li> </ul> <p>Where does OpenVidu Pro stand in relation to LiveKit Cloud? OpenVidu Pro aims to deliver the same advanced benefits as LiveKit Cloud, but as a self-hosted solution. We intend to provide a performant, fault tolerant, scalable and observable cluster that is easy to deploy, configure and administrate in your own infrastructure. For now, OpenVidu Pro brings:</p> <ul> <li>OpenVidu Pro provides a complete observability stack with Grafana, Loki, Promtail and Mimir, as well as OpenVidu Dashboard to visualize the data. See more.</li> <li>We are currently working on supporting the same scalability as LiveKit Cloud to support big videoconferences and massive live streams. See more.</li> </ul>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/#openvidu-vs-saas-solutions","title":"OpenVidu vs SaaS solutions","text":"<p>This includes many services like Agora, GetStream, Daily, Vonage, Jitsi as a Service, Whereby, Zoom SDK, Dolby Millicast, Amazon Chime SDK.</p> <p>The main difference between OpenVidu and these services is who owns the infrastructure, and where your users' data flows. All these SaaS solutions provide:</p> <ul> <li>A public endpoint that your application connects to, so all media is routed through their servers.</li> <li>Different sets of SDKs to integrate with your application. Some more complete than others, and maybe some low-code options.</li> <li>A pricing model usually based on one of this two options: minutes-per-participant or total GBs of bandwidth consumed.</li> </ul> <p>Using a SaaS provider is a great option for some use cases, but not all. OpenVidu is designed to be self-hosted. This allows you to have full control over your infrastructure and data, taking the most out of your own resources and complying with the most strict regulations. While having the best features provided by SaaS: scalability, fault tolerance, observability. See Production ready for more information.</p>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/#openvidu-vs-sfus","title":"OpenVidu vs SFUs","text":"<p>This includes projects such as Kurento, mediasoup, Pion, Janus, Jitsi Videobridge or Medooze.</p> <p>These are all media servers. More specifically, they fall under the umbrella of the so-called SFUs (Selective Forwarding Units): they are able to receive media streams from different clients and selectively forward them to other clients, usually without transcoding or mixing the media.</p> <p>SFUs are generally low-level tools. Using them directly to implement real-time applications requires a deep understanding of signaling protocols, codecs, networking and other low-level concepts. OpenVidu is a higher-level abstraction compared to SFUs. It internally uses SFUs to rely the media streams (more specifically Pion and mediasoup), but hides all complexities to offer a simpler way to develop videoconferencing and live streaming applications.</p>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/#openvidu-vs-mediasoup","title":"OpenVidu vs mediasoup","text":"<p>mediasoup is a WebRTC SFU. It is a minimalist media server with a super low level API that allows building custom real-time applications. Compared to other SFUs, mediasoup is well known for its outstanding performance.</p> <p>OpenVidu uses mediasoup internally to transmit media streams. We have embedded mediasoup as the WebRTC engine right at the core of LiveKit Open Source, which allows OpenVidu to offer the fantastic APIs and SDKs of LiveKit while providing the cutting-edge performance of mediasoup. Learn more about mediasoup integration in section Performance.</p>"},{"location":"/3.0.0-beta1/docs/comparing-openvidu/#openvidu-vs-microsoft-teams-google-meet-zoom","title":"OpenVidu vs Microsoft Teams, Google Meet, Zoom","text":"<p>All these well-known video conferencing tools are final applications that provide little to no customization at all. They are proprietary, closed-source apps designed to be used as-is, and they are not intended to be integrated into other systems.</p> <p>OpenVidu is inherently different, as it provides a set of APIs and SDKs to integrate real-time video capabilities into your own application. In other words: with OpenVidu you can easily build your own custom Microsoft Teams, Google Meet or Zoom-like application. See Use cases for some examples of what you can build with OpenVidu.</p>"},{"location":"/3.0.0-beta1/docs/getting-started/","title":"Getting started","text":""},{"location":"/3.0.0-beta1/docs/getting-started/#what-is-openvidu","title":"What is OpenVidu?","text":"<p>OpenVidu is a platform that allows you to implement real-time applications. You can build your brand new OpenVidu app from scratch, but it is also very easy to integrate OpenVidu in your already existing application.</p> <p>OpenVidu is based on WebRTC technology and allows developing any kind of use case you can imagine: one-to-one calls, video conference rooms, massive live streaming events, management and processing of drones and camera feeds...</p> <p>OpenVidu is built on the best open source technologies: LiveKit, from which it inherits all its amazing SDKs to integrate it into your front-end and back-end applications, and mediasoup, from which it inherits the best performance and optimization for media routing.</p> <p> </p> OpenVidu is a custom fork of LiveKit, 100% compatible in terms of its API and SDKs, with the power of mediasoup at its core. This and other integrations provide improved performance, new features and facilitate the deployment and management of your self-hosted, production-grade cluster."},{"location":"/3.0.0-beta1/docs/getting-started/#use-cases","title":"Use cases","text":"<p>OpenVidu is a super versatile platform that can be used to build just about any kind of real-time application you can think of. Most common use cases can be classified into one of the following categories:</p>"},{"location":"/3.0.0-beta1/docs/getting-started/#video-conferencing","title":"Video conferencing","text":"<p>Video conferencing rooms are virtual spaces where two or more users can send video and audio and interact with each other in real-time. They can scale in size, from a simple 1-to-1 call to a massive video conference with thousands of participants. For example:</p> <ul> <li>A 1-to-1 video-call center to attend your customers face to face.</li> <li>An e-health application where doctors can treat their patients directly from it, in a private and secure manner using end-to-end encryption.</li> <li>A banking application where customers may sign a contract, live and recording the call as proof of it.</li> <li>A webinar platform where speakers can give their talks to large audiences, with the possibility of viewers temporarily turning their cameras to ask questions.</li> </ul>"},{"location":"/3.0.0-beta1/docs/getting-started/#live-streaming","title":"Live streaming","text":"<p>Live streaming applications allow one publisher to broadcast video to many viewers. It can be a single video feed, multiple video feeds (webcam and screen share) or there could be even multiple publishers. The general rule is that the ratio of viewers to publishers is very high, in the order of thousands.</p> <p>Ultra-low latency live streaming (below 300ms) allows for actual real-time interaction between the viewers and the publishers. This differs from traditional live streaming platforms where the latency is usually in the order of seconds. In this way you can build applications like:</p> <ul> <li>A TEDx-like application, where a speaker can give a talk to a massive audience of thousands of viewers, which may communicate through a chat. Real time subtitles and translations can be added to the stream.</li> <li>An application to stream sport events, where viewers can switch between different cameras to watch the game from different angles to increase fan engagement.</li> <li>A global live auction platform where the auctioneer can be seen by the bidders in real-time with sub-second latency all around the world.</li> </ul>"},{"location":"/3.0.0-beta1/docs/getting-started/#robotics-and-embedded-systems","title":"Robotics and embedded systems","text":"<p>The future lies in the integration of cameras and sensors in all kinds of devices, everywhere: industry, homes, public spaces, emergency services... OpenVidu can be used to receive and process video and audio streams from these devices, and doing so in real-time. For example:</p> <ul> <li>A security system to receive the feed of IP cameras and sending an alert when detecting a person.</li> <li>A drone control system to receive the video feed from each drone camera and securely record it. Any other sensor reading could also be sent to be synchronized later with the recorded video feed.</li> <li>A real-time translation app that uses the latest AI models to provide high-quality translations of spoken language in real time.</li> </ul>"},{"location":"/3.0.0-beta1/docs/getting-started/#openvidu-application-architecture","title":"OpenVidu application architecture","text":"<p>Any OpenVidu application has 3 different parts:</p> <ul> <li>Your OpenVidu deployment: provides all the necessary infrastructure for streaming real-time audio and video. It is built upon LiveKit server and mediasoup server. It can usually be treated as a black box in which its internal aspects are not important: you just deploy it and connect your application to it. It can be a single server or a cluster, deployed on premises or in your cloud provider.</li> <li>Your Application client: runs in your user devices and interacts with the OpenVidu server through any LiveKit client SDK. As OpenVidu server is 100% compatible with LiveKit protocol, you can integrate any LiveKit client SDK in your Application client. Your users will join rooms as participants to send and receive real-time audio and video tracks. It needs a token generated by the Application server to join a room.</li> <li>Your Application server: interacts with the OpenVidu deployment through any LiveKit server SDK. As OpenVidu server is 100% compatible with LiveKit protocol, you can integrate any LiveKit server SDK in your application server. At a minimum, it is responsible for the generation of tokens for the Application client to join a room. But you can implement your own business logic managing rooms, participants and tracks from the safety of your Application server.</li> </ul>"},{"location":"/3.0.0-beta1/docs/getting-started/#basic-concepts","title":"Basic concepts","text":""},{"location":"/3.0.0-beta1/docs/getting-started/#room","title":"Room","text":"<p>A Room is a virtual space where Participants can connect to send and receive media Tracks. Two Participants can only communicate if they are connected to the same Room.</p>"},{"location":"/3.0.0-beta1/docs/getting-started/#participant","title":"Participant","text":"<p>A Participant is a user connected to a specific Room. Each Participant can publish as many video and audio Tracks as needed, and subscribe to any other Participant's Tracks, as long as they are connected to the same Room.</p>"},{"location":"/3.0.0-beta1/docs/getting-started/#track","title":"Track","text":"<p>A Track is a data flow of audio or video. Participants create them from a local media source (a webcam, a microphone, a screen share) and publish them into a Room. Other Participants of the same Room can subscribe to them.</p> <p>With these three concepts you can build any kind of real-time application you can think of. The figure below shows two simple examples.</p> <p> </p> Room \"Daily meeting\" has 2 Participants: \"Alice\" is publishing Track \"Webcam\" and \"Mic\" and is receiving Track \"Screen\" from \"Bob\". \"Bob\" is publishing Track \"Screen\" and receiving Tracks \"Webcam\" and \"Mic\" from \"Alice\". <p> </p> Room \"Remote support\" has 3 Participants: Participant \"Dan\" is not publishing any Track, but receiving all Tracks in the Room. Participant \"Erin\" is only receiving Track \"Mic\" from Participant \"Carol\", but not Track \"Screen\"."},{"location":"/3.0.0-beta1/docs/getting-started/#openvidu-editions","title":"OpenVidu Editions","text":"<p>OpenVidu is available in two editions:</p> <ul> <li>OpenVidu COMMUNITY: free to use. It is a single-server deployment and provides a custom LiveKit distribution with Egress, Ingress, S3 storage and monitoring. Ideal for development and testing, but also for medium-scale production deployments. You can host hundreds of simultaneous participants in your rooms by running OpenVidu Community in a sufficiently powerful server!</li> <li>OpenVidu PRO: OpenVidu commercial edition. It is a multi-server deployment with all the features of OpenVidu Community plus 2x performance, scalability, fault tolerance and improved monitoring and observability. Ideal for large-scale production deployments with heavy traffic that require the highest standards. You can start with OpenVidu Community and upgrade to OpenVidu Pro when needed.</li> </ul> <p></p> Type of deployment OpenViduLocal (development) OpenViduSingle Node OpenViduElastic OpenViduHigh Availability OpenVidu Edition COMMUNITY PRO COMMUNITY PRO PRO Suitability For local development in your laptop For applications with medium user load For applications with dynamic user load that require scalability For applications where both scalability and fault tolerance are critical Features Friendly Docker Compose setup with Redis, Egress, Ingress, S3 storage and observability. With automatic certificate management to test across devices in your network Custom LiveKit distribution with Redis, Egress, Ingress, S3 storage and observability Same benefits as OpenVidu Single Node plus 2x performance, scalability and advanced observability Same benefits as OpenVidu Single Node and OpenVidu Elastic plus fault tolerance Number of servers Your laptop 1 Node 1 Master Node +N Media Nodes 4 Master Nodes +N Media Nodes Installation instructions Install Install Install Install"},{"location":"/3.0.0-beta1/docs/releases/","title":"Releases","text":""},{"location":"/3.0.0-beta1/docs/releases/#300-beta1","title":"3.0.0-beta1","text":"Version table Artifact Version Info Link livekit/livekit-server v1.6.0 mediasoup 3.12.16 livekit/egress v1.8.2 livekit/ingress v1.2.0 MinIO 2024.06.13 Caddy 2.7.6 MongoDB 7.0.11 Redis 7.2.5 Grafana 10.3.3 Prometheus 2.50.1 Promtail / Loki 2.8.9 Mimir 2.11.0"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/","title":"Developing your OpenVidu application","text":"<p>Here's a high-level overview of the steps involved in building an OpenVidu application:</p> <ol> <li>Launch an OpenVidu deployment</li> <li>Use LiveKit Server SDK in your application server</li> <li>Build the UI of your client application</li> <li>Deploy OpenVidu and your application</li> </ol>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/#1-launch-an-openvidu-deployment","title":"1. Launch an OpenVidu deployment","text":"<p>The quickest way is to use OpenVidu local deployment.</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/#2-use-livekit-server-sdk-in-your-application-server","title":"2. Use LiveKit Server SDK in your application server","text":"<p>OpenVidu is fully compatibly with LiveKit APIs. This means that any LiveKit Server SDK can be used in your application server.</p> <p>The only mandatory task to perform in your application server is:</p> <ul> <li>Creating access tokens. Your Participants will only be able to connect to your Rooms by using a valid access token. Visit the official documentation about Authentication to learn how to generate access tokens and which permissions you can assign to them.</li> </ul> <p>There are also other optional tasks that you can perform from your application server, depending on your requirements:</p> <ul> <li>Manage your Rooms and Participants: although most of your application logic will be in the frontend, you can also manage the logic of your Rooms and Participants from the security of your application backend. You can list, create, update and destroy Rooms and Participants. This is the official LiveKit documentation with all the available methods of the <code>RoomServiceClient</code> exposed by the Server API. These methods are also available in all LiveKit Server SDKs.</li> <li>Manage Egress and Ingress: if your application needs some kind of recording, broadcasting or media ingestion, this operations must all be performed by your application server.</li> <li>Receive Webhook events: you can also listen to Webhook events in your application backend. In this way you can react to events happening in your Rooms: a Room has started, a Room has finished, a Participant has joined a Room, a Track has been published... Visit the official documentation about Webhooks.</li> <li>Publish Tracks from your backend: this is only for advanced applications that require server-side media publishing. Publishing media from your backend is possible by using LiveKit CLI, Python SDK, Go SDK, Node SDK or Rust SDK.</li> </ul> <p>To get you started, here is a list of all available LiveKit Server SDKs and an application server tutorial using them. These tutorials are all set up to generate access tokens and receive webhook events, so they are perfect starting points for your application server.</p>  Node Go Ruby Java Python Rust PHP .NET Server API <p> Node Tutorial</p> <p> Reference Docs</p> <p> Go Tutorial</p> <p> Reference Docs</p> <p> Ruby Tutorial</p> <p> GitHub Repository</p> <p> Java Tutorial</p> <p> GitHub Repository</p> <p> Python Tutorial</p> <p> GitHub Repository</p> <p> Rust Tutorial</p> <p> Reference Docs</p> <p> PHP Tutorial</p> <p> GitHub Repository</p> <p> .NET Tutorial</p> <p>There is no .NET SDK for LiveKit available. Visit the tutorial to learn how to create tokens and receive Webhook events directly from your .NET application server.</p> <p>If your backend technology does not have its own SDK, you have two different options:</p> <ol> <li> <p>Consume the Server API directly:  Reference Docs</p> </li> <li> <p>Use the livekit-cli:  GitHub Repository</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/#3-build-the-ui-of-your-client-application","title":"3. Build the UI of your client application","text":"<p>There are two main strategies to build the UI of your client application:</p> <ul> <li>Use a high-level UI Components library: you can use Angular Components and React Components to quickly set up your UI with building blocks that manage the events and state of the Room for you.</li> <li>Use a low-level client SDK: if you want extensive control and maximum flexibility when designing your UI, use any of the LiveKit Client SDKs.</li> </ul> <p>The table below summarizes the key differences between these two strategies to help you make an informed decision:</p> UI Components Low-level client SDKs What is it? Frontend libraries offering videoconferencing components to build your own application. There are Angular Components or React Components Integrate OpenVidu from scratch in your web, mobile or desktop application using LiveKit Client SDKs Pros <ul><li>Very flexible components: adapt, extend or replace any component</li><li>Have your first version running in minutes, work on your customizations from there</li><li>Easily keep your client code up to date with the latest features</li></ul> <ul><li>Unlimited level of customization: build your own UI from scratch as you please</li><li>Available for all client platforms: browsers, iOS, Android, Flutter, React Native, Unity...</li></ul> Cons <ul><li>Only available for Angular and React web apps</li></ul> <ul><li>Higher complexity, although there are plenty of tutorials to smooth the learning curve</li></ul> Tutorials Angular Components tutorials Application client tutorials <p>Whatever strategy you choose to build the UI of your application, most common steps to perform are:</p> <ul> <li>Connect to a Room with an access token: the application client will connect to a Room with an access token generated by your application server. Once connected, the client becomes a Participant of the Room.</li> <li>Publish Tracks to the Room: the application client may create Tracks of any kind (audio from the microphone, video from the camera device, screen sharing from an application...) and publish them to the Room.</li> <li>Subscribe to Tracks from other Participants: the application client may receive the Tracks published by other Participants in the Room. It is possible to perform selective subscription, so the client can choose which Tracks to specifically subscribe to.</li> <li>Mute and unmute Tracks: the application client may mute and unmute its own Tracks, and also may disable the reception of any Track published by other Participants.</li> </ul> <p>Of course, depending on the use case, this may not be necessary for all users, or other additional steps may need to be taken. For example, in a live streaming application, only presenters will publish Tracks, while all other viewers will only subscribe to them. Or it is possible that users may need exchange messages through a chat. Each specific application will need to refine its use of the UI Components or client SDKs to meet its requirements.</p> <p>Here is the list of all LiveKit Client SDKs: LiveKit Client SDKs. Below is a list of application client tutorials, which are perfect starting points for your client application. </p> <p> JavaScript</p> <p> React</p> <p> Angular</p> <p> Vue</p> <p> Electron</p> <p> Ionic</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/#4-deploy-openvidu-and-your-application","title":"4. Deploy OpenVidu and your application","text":"<p>You have different options to deploy OpenVidu in a production-ready environment, depending on the level of scalability, fault tolerance and observability you need. See Deployment types for more information.</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/","title":"How to develop your OpenVidu application","text":"<p>This page is a collection of the most common operations you may want to perform in your application while integrating OpenVidu. Depending on the scope of the operation, these operations will be performed on the client side using a LiveKit Client SDK, or on the server side using a LiveKit Server SDK (or directly using the HTTP server API). Consider the architecture of an OpenVidu application:</p> <p></p> <p>You can use this page as a cheat sheet to know at a glance how to do something, and you have links to the LiveKit reference documentation of each operation for a more detailed explanation.</p> <p>All client side operations are exemplified using the LiveKit JS Client SDK. For other client SDKs, refer to the corresponding LiveKit reference documentation.</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#generate-access-tokens","title":"Generate access tokens","text":"<p>The application client needs an access token to connect to a Room. This token must be generated by the application server. Visit LiveKit reference documentation to learn how to generate access tokens:</p> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#manage-rooms","title":"Manage Rooms","text":""},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#connect-to-a-room","title":"Connect to a Room","text":"<p>To connect to a Room you need the URL of your OpenVidu deployment (which is a WebSocket URL) and the access token generated by your application server.</p> <pre><code>import { Room } from \"livekit-client\";\n\nconst room = new Room();\nawait room.connect(wsUrl, token);\n</code></pre> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#disconnect-from-a-room","title":"Disconnect from a Room","text":"<pre><code>await room.disconnect();\n</code></pre> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#publish-a-track","title":"Publish a Track","text":"<p>You can directly publish the default camera and microphone of the device using methods <code>setCameraEnabled</code> and <code>setMicrophoneEnabled</code> of the <code>LocalParticipant</code> object:</p> <pre><code>// Publish a video track from the default camera\nawait room.localParticipant.setCameraEnabled(true);\n// Publish an audio track from the default microphone\nawait room.localParticipant.setMicrophoneEnabled(true);\n</code></pre> <p>It is also possible to publish both of them at the same time using method <code>LocalParticipant.enableCameraAndMicrophone</code>, which has the advantage of showing a single permission dialog to the user:</p> <pre><code>// Publish both default video and audio tracks triggering a single permission dialog\nawait room.localParticipant.enableCameraAndMicrophone();\n</code></pre> <p>To craft a custom Track, you can use the <code>LocalParticipant.createTracks</code> method and publish them with <code>LocalParticipant.publishTrack</code>:</p> <pre><code>var tracks = await room.localParticipant.createTracks({\n  audio: {\n    deviceId: \"default\",\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true\n  },\n  video: {\n    deviceId: 'frontcamera';\n    facingMode: 'user'\n  },\n});\nawait Promise.all([\n    room.localParticipant.publishTrack(tracks[0]),\n    room.localParticipant.publishTrack(tracks[1]),\n]);\n</code></pre> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#muteunmute-a-track","title":"Mute/Unmute a Track","text":"<p>To mute the default camera and microphone Tracks:</p> <pre><code>await room.localParticipant.setCameraEnabled(false);\nawait room.localParticipant.setMicrophoneEnabled(false);\n</code></pre> <p>To mute/unmute a custom Track:</p> <pre><code>// Mute the track\nawait track.mute();\n\n// Unmute the track\nawait track.unmute();\n</code></pre> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#unpublish-a-track","title":"Unpublish a Track","text":"<p>To completely stop sending a Track to the Room, you must unpublish it:</p> <pre><code>await room.localParticipant.unpublishTrack(track, true);\n</code></pre> <p>The second boolean parameter indicates if the local Track should be stopped. This usually means freeing the device capturing it (switching off the camera LED, for example).</p> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#send-messages","title":"Send messages","text":"<p>You can share information between Participants of a Room in different ways.</p> <p>First of all, you can set Room metadata that will be available for all clients in the <code>Room</code> object. You do so in your application server when calling the <code>CreateRoom</code> API (available for all LiveKit Server SDKs and the HTTP Server API). The Room metadata will be available in the client side like this:</p> <pre><code>console.log(room.metadata);\n</code></pre> <p>You can update the Room metadata at any time from your application server with the <code>UpdateRoomMetadata</code> API (available for all LiveKit Server SDKs and the HTTP Server API). The client side will be notified of the change with the <code>roomMetadataChanged</code> event of the <code>Room</code> object:</p> <pre><code>room.on('roomMetadataChanged', (metadata) =&gt; {\n  console.log('New room metadata', metadata);\n});\n</code></pre> <p>Secondly, you can also set Participant metadata. You do so when creating an access token in your application server, setting <code>metadata</code> field of the JWT.</p> <p>Participants can also update their own metadata from the client side, if their access token was created with grant <code>canUpdateOwnMetadata</code>.</p> <pre><code>room.localParticipant.setMetadata('new metadata');\n</code></pre> <p>The client side will be notified of the change with the <code>participantMetadataChanged</code> event of the <code>Room</code> and/or <code>Participant</code> object:</p> <pre><code>// To handle all metadata changes of all participants\nroom.on(RoomEvent.ParticipantMetadataChanged, (previousMetadata: string, participant) =&gt; {\n  console.log('New metadata for participant', participant.identity, participant.metadata);\n});\n\n// To handle only metadata changes of a specific participant\nparticipant.on(ParticipantEvent.ParticipantMetadataChanged, (previousMetadata) =&gt; {\n    console.log('New metadata for participant', participant.identity, participant.metadata);\n});\n</code></pre> <p>Finally, you can send messages to Participants in the Room using the <code>LocalParticipant.publishData</code> method:</p> <pre><code>const data: Uint8Array = new TextEncoder().encode(JSON.stringify(''));\nroom.localParticipant.publishData(data, { reliable: true, topic: 'chat', destinationIdentities: ['participant-identity'] });\n</code></pre> <p>The <code>DataPublishOptions</code> allow setting the reliability of the message (depending on the nature of the message it can be sent as a reliable or lossy message), a topic to easily filter messages, and the participants that will receive the message.</p> <p>The client side will be notified of the message with the <code>dataReceived</code> event of the <code>Room</code> and/or <code>Participant</code> object:</p> <pre><code>// To receive all messages from the Room\nroom.on(RoomEvent.DataReceived, (payload: Uint8Array, participant: Participant, kind: DataPacket_Kind) =&gt; {\n  const strData = new TextDecoder().decode(payload);\n  console.log('Received data from', participant.identity, strData);\n});\n\n// To receive messages only from a specific participant\nparticipant.on(ParticipantEvent.DataReceived, (payload: Uint8Array, kind: DataPacket_Kind) =&gt; {\n  const strData = new TextDecoder().decode(payload);\n  console.log('Received data from', participant.identity, strData);\n});\n</code></pre> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#from-your-application-server","title":"From your application server","text":"<p>Except for the generation of access tokens, it is possible for all the logic of your application to be contained entirely on the client side. Nonetheless, some use cases may require the management of the Rooms from the server side.</p> <p>These operations are only available in the server SDKs, and not in the client SDKs:</p> <ul> <li>Closing a Room. From the client side, a user can only leave his own Room.</li> <li>Removing any Participant from a Room. From the client side, a user can only leave his own Room.</li> <li>Muting any Track of any Participant. From the client side, a user can only mute/unmute his own Tracks.</li> <li>Updating the metadata of any Participant. From the client side, a user can only update his own metadata.</li> <li>Updating the metadata of the Room. From the client side this is not possible.</li> <li>Egress operations. Egress cannot be started and stopped on demand by users from the client side.</li> <li>Ingress operations. Ingress cannot be started and stopped on demand by users from the client side.</li> </ul> <p>You have here the complete list of the server-side operations, documented for the HTTP Server API. All the LiveKit Server SDKs have the same operations.</p> <ul> <li>RoomService: to manage Rooms and Participants.</li> <li>Egress: to manage egress operations.</li> <li>Ingress: to manage ingress operations.</li> </ul>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#screen-sharing","title":"Screen Sharing","text":"<p>To quickly publish a screen sharing Track:</p> <pre><code>await room.localParticipant.setScreenShareEnabled(true);\n</code></pre> <p>You can also create custom screen tracks, for example capturing the audio of the screen and fine-tuning the video capture options (checkout the ScreenTrackOptions interface for detailed information):</p> <pre><code>const screenTracks = await room.localParticipant.createScreenTracks({\n    audio: true,\n    contentHint: \"detail\",\n    preferCurrentTab: true,\n    video: {\n        displaySurface: \"window\"\n    }\n});\nawait Promise.all([\n    room.localParticipant.publishTrack(screenTracks[0]),\n    room.localParticipant.publishTrack(screenTracks[1]),\n]);\n</code></pre> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#virtual-background","title":"Virtual Background","text":"<p>It is possible to apply a virtual background to video tracks. In this way you can blur the background or replace it with an image.</p> <p>It is necessary to install an additional dependency to use this feature:</p> <pre><code>npm add @livekit/track-processors\n</code></pre> <p>To blur the background:</p> <pre><code>import { BackgroundBlur } from '@livekit/track-processors';\n\nconst videoTrack = await createLocalVideoTrack();\nconst blur = BackgroundBlur(10);\nawait videoTrack.setProcessor(blur);\n</code></pre> <p>To replace the background with an image:</p> <pre><code>import { VirtualBackground } from '@livekit/track-processors';\n\nconst videoTrack = await createLocalVideoTrack();\nconst image = VirtualBackground('https://picsum.photos/400');\nawait videoTrack.setProcessor(image);\n</code></pre> <p> GitHub Repository</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#recording","title":"Recording","text":"<p>You can record your Rooms using the Egress module. Egress allows exporting media from a Room in different formats, including</p> <ul> <li>Room Composite Egress: a single video output with all the Tracks of a Room composited in a layout. You can even create your custom layouts.</li> <li>Track Composite Egress: a single video output combining an audio Track and a video Track.</li> <li>Track Egress: individual outputs for each Track of a Room.</li> </ul> <p>Visit the LiveKit reference documentation for a detailed explanation of Egress:</p> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/developing-your-openvidu-app/how-to/#webhooks","title":"Webhooks","text":"<p>Your application server may receive webhooks coming from the OpenVidu deployment. These webhooks inform about events happening in the Rooms, including when a Room is created and finished, when a Participant joins and leaves a Room, when a Track is published and unpublished, and when Egress/Ingress operations take place in a Room.</p> <p>Every application server tutorial here is ready to receive webhooks: Application Server Tutorials.</p> <p>Visit the LiveKit reference documentation for a detailed explanation of each webhook event:</p> <p> Reference docs</p>"},{"location":"/3.0.0-beta1/docs/openvidu-call/","title":"OpenVidu Call","text":"OpenVidu Call   The videoconference application built on top of OpenVidu  <ul> <li> <p> Ready to use</p> <p>Experience all the features you need only with a click: multiparty videoconferences, screen sharing, chat, and more</p> <p>Try it</p> </li> <li> <p> Fully Customizable</p> <p>Built on an open-source license, OpenVidu Call offers full customization to fit your needs</p> <p>Customize it</p> </li> <li> <p> Deploy Anywhere</p> <p>Install OpenVidu Call on your own servers or any cloud provider.</p> <p>Install it</p> </li> </ul>  Features  <ul> <li> <p> Secure room access</p> <p>OpenVidu Call offers a straightforward authentication system enabling users to join rooms with a single click.</p> <p>Additionally, it automatically generates unique room names, providing a distinct URL for each room. This allows users to easily share the URL with friends and colleagues to join the room.</p> </li> </ul> <p></p> <p></p> <ul> <li> <p> Setting up your room</p> <p>OpenVidu Call provides users with various options and configurations to personalize their experience before and after entering a room.</p> <p>This includes testing and selecting audio and video devices, choosing a nickname, and adjusting the preferred language.</p> </li> </ul> <ul> <li> <p> Multi-party videoconference</p> <p>OpenVidu Call offers a multi-party videoconference feature that allows users to connect with multiple participants in a single room.</p> <p>Flexible and easy to use, it allows you to see all participants at once, making it ideal for team meetings, webinars, and more.</p> </li> </ul> <p></p> <ul> <li> <p> Chatting time!</p> <p>Chatting is an essential feature for any videoconference application.</p> <p>OpenVidu Call offers a chat feature that allows users to communicate with each other during a videoconference.</p> </li> </ul> <ul> <li> <p> Recording your sessions for posterity</p> <p>Recording your videoconference sessions is a great way to keep a record of important meetings, webinars, and more.</p> <p>Record, playback, download and share your videoconference sessions with OpenVidu Call's recording feature.</p> </li> </ul> <ul> <li> <p> Background effects</p> <p>Virtual backgrounds are a fun and useful feature that allows users to change their background during a videoconference.</p> <p>OpenVidu Call offers a virtual background feature that allows users to choose from a variety of backgrounds for enhancing privacy and professionalism.</p> </li> </ul> <ul> <li> <p> Recording Management</p> <p>Allow administrators to manage recordings, including deleting, downloading, and sharing them.</p> <p>The admin dashboard provides a simple interface to manage all recordings.</p> </li> </ul> <p></p>      And much more...    <ul> <li> <p> Broadcasting (Live Streaming)</p> <p>Allows live streaming of the video conference to platforms like YouTube, Twitch, and others for a wider audience</p> </li> <li> <p> Automatic Reconnection</p> <p>Ensures that users are automatically reconnected to the call in case of temporary network issues</p> </li> <li> <p> Speaker Detection</p> <p>Highlights the active speaker automatically, making it easier for participants to follow the conversation</p> </li> <li> <p> Screen Sharing</p> <p>Allow users to share their screen and their camera at the same time with other participants in the call</p> </li> <li> <p> Fullscreen Mode</p> <p>Offers a fullscreen mode for users to focus on the videoconference without any distractions</p> </li> <li> <p> Powerful Layout</p> <p>Offers a powerful layout where users can view multiple participants simultaneously in a grid layout or focus on a single participant</p> </li> </ul>      All the features you need to quickly build your perfect real-time application    <p>Try it</p> <p>Customize it</p> <p>Install it</p>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/","title":"OpenVidu Call Documentation","text":"<p>Source code </p> <p>Introducing OpenVidu Call, the premier videoconference application that showcases the full potential of the OpenVidu platform. OpenVidu Call is not just any videoconferencing tool; it\u2019s the default and flagship app built with the robust and versatile OpenVidu Components.</p> <p> </p> OpenVidu Call"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#run-openvidu-call","title":"Run OpenVidu Call","text":""},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p> <p>Accessible via openvidu-local-deployment</p> <p>A pre-built OpenVidu Call application is launched as part of the openvidu-local-deployment and it can be accessible  by visiting <code>http://localhost:7880/openvidu-call/</code>.</p> <p>If you want to explore and run the OpenVidu Call code locally, follow the instructions below.</p>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#2-download-openvidu-call-code","title":"2. Download OpenVidu Call code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-call.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#3-run-the-openvidu-call-backend","title":"3. Run the OpenVidu Call backend","text":"<ol> <li> <p>Navigate to the <code>openvidu-call-back</code> directory:</p> <pre><code>cd openvidu-call/openvidu-call-back\n</code></pre> </li> <li> <p>Install the dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Start the application:</p> <pre><code>npm run dev:start\n</code></pre> </li> </ol>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#4-run-the-openvidu-call-frontend","title":"4. Run the OpenVidu Call frontend","text":"<p>Launching another terminal, under the <code>openvidu-call</code> directory:</p> <ol> <li> <p>Navigate to the <code>openvidu-call-front</code> directory:</p> <pre><code>cd openvidu-call/openvidu-call-front\n</code></pre> </li> <li> <p>Install the dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Start the application:</p> <pre><code>npm run dev:start\n</code></pre> </li> </ol> <p>The application will be available at <code>http://localhost:5080</code>.</p>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#architecture","title":"Architecture","text":"<p>The OpenVidu Call architecture is divided into two main components:</p> <ul> <li>OpenVidu Call frontend which is the client-side application built with Angular and OpenVidu Components.</li> <li>OpenVidu Call backend which is the server-side application built with Node.js and Express and uses the LiveKit Server SDK library to interact with the OpenVidu Server.</li> </ul> <p> </p> OpenVidu Call Architecture  OpenVidu Call frontend OpenVidu Call backend <p>The client-side application built with Angular that provides the user interface for the videoconference. It uses the OpenVidu Components library to create the videoconference layout with ease.</p> <p>The project architecture is divided into the following directories:</p> <ul> <li><code>components</code>: Contains the components that define the UI elements.</li> <li><code>services</code>: Contains the services that interact with the OpenVidu Call backend in a RESTful manner.</li> </ul> <p>Additionally, the project hosts the following files:</p> <ul> <li><code>app.component.ts</code>: The main file that initializes the Angular application.</li> <li><code>app-routing.module.ts</code>: Contains the routes that define the application navigation.</li> </ul> <p>The server-side application built with Node.js and Express that manages the communication between the OpenVidu Server and the OpenVidu Call Frontend.</p> <p>It uses the LiveKit Server SDK library to interact with the OpenVidu Server and handle the authentication, videoconference rooms, recordings, broadcasts, and other features.</p> <p>The project architecture is divided into the following directories:</p> <ul> <li><code>controllers</code>: Contains the controllers that handle the HTTP requests.</li> <li><code>services</code>: Contains the services that interact with the OpenVidu Server.</li> <li><code>models</code>: Contains the models that define the data structures.</li> <li><code>helpers</code>: Contains the helper functions.</li> </ul> <p>Additionally, the project hosts the following files:</p> <ul> <li><code>server.ts</code>: The main file that initializes the Express application.</li> <li><code>routes.ts</code>: Contains the routes that define the API endpoints.</li> <li><code>config.ts</code>: Contains the configuration settings for the application.</li> </ul>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#features","title":"Features","text":""},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#authentication","title":"Authentication","text":"<p>OpenVidu Call provides user authentication to ensure that only authorized users can access the videoconference rooms. The authentication process is handled by the OpenVidu Call backend, which uses Basic Authentication to verify the user credentials.</p>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#video-conferencing","title":"Video conferencing","text":""},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#essential-features","title":"Essential Features","text":"<p>OpenVidu Call offers essential features that make video conferencing simple and intuitive for users. These features include:</p> <ul> <li> <p> Multilingual</p> <p>Supports for multiple languages, allowing users to select their preferred language for the interface</p> </li> <li> <p> Device Selection</p> <p>Users can choose their preferred audio and video devices before and during the call</p> </li> <li> <p> Fullscreen Mode</p> <p>Offers a fullscreen mode for users to focus on the videoconference without any distractions</p> </li> <li> <p> Screen Sharing</p> <p>Allow users to share their screen and their camera at the same time with other participants in the call</p> </li> <li> <p> Powerful Layout</p> <p>Offers a powerful layout where users can view multiple participants simultaneously in a grid layout or focus on a single participant</p> </li> <li> <p> Chat Integration</p> <p>Built-in chat functionality enabling participants to send text messages to the group</p> </li> </ul> <p></p>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#advanced-features","title":"Advanced Features","text":"<p>The advanced features of OpenVidu Call enhance the video conferencing experience by providing additional functionalities that improve collaboration and productivity.</p> <ul> <li> <p> Speaker Detection</p> <p>Highlights the active speaker automatically, making it easier for participants to follow the conversation</p> </li> <li> <p> Automatic Reconnection</p> <p>Ensures that users are automatically reconnected to the call in case of temporary network issues</p> </li> <li> <p> Recording</p> <p>Supports recording of video conferences for later playback</p> </li> <li> <p> Broadcasting (Live Streaming)</p> <p>Allows live streaming of the video conference to platforms like YouTube, Twitch, and others for a wider audience</p> </li> <li> <p> Virtual Backgrounds</p> <p>Enables users to use virtual backgrounds during the call, enhancing privacy and professionalism</p> </li> </ul>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#admin-dashboard","title":"Admin Dashboard","text":"<p>An admin dashboard is integrated into OpenVidu Call to provide additional functionalities for the admin user.</p> <ul> <li> <p> Admin Authentication</p> <p>Provides admin authentication to ensure that only authorized users can access the admin dashboard</p> </li> <li> <p> Recording Management</p> <p>Allows the admin user to view, download, and delete the recordings stored in the OpenVidu Server</p> </li> </ul>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#build-and-deployment","title":"Build and Deployment","text":""},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#docker-image","title":"Docker Image","text":"<p>The process to build a Docker image of OpenVidu call is really easy, you just need to run the following instructions:</p> <ol> <li> <p>Build the Docker image:</p> <pre><code>cd docker\n./create_image.sh openvidu-call\n</code></pre> <p>This script will create a Docker image with the name <code>openvidu-call</code>.</p> </li> <li> <p>Run the Docker container:</p> <pre><code>docker run -p 5000:5000 \\\n-e LIVEKIT_URL=wss://your-livekit-server-url \\\n-e LIVEKIT_API_KEY=your-livekit-api-key \\\n-e LIVEKIT_API_SECRET=your-livekit-api-secret \\\nopenvidu-call\n</code></pre> <p>Once the container is running, you can access the OpenVidu Call application by visiting <code>http://localhost:5000</code>.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/openvidu-call/docs/#package-bundle","title":"Package bundle","text":"<p>To build the OpenVidu Call application without using Docker, you can follow the instructions:</p> <ol> <li> <p>Build the frontend application:</p> <pre><code>cd openvidu-call-front\nnpm install\nnpm run prod:build\n</code></pre> </li> <li> <p>Build the backend application:</p> <pre><code>cd openvidu-call-back\nnpm install\nnpm run build\n</code></pre> </li> <li> <p>Start the backend application:</p> <pre><code>cd dist\nnode server.js\n</code></pre> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/deployment-types/","title":"Deployment types","text":"<p>OpenVidu offers user-friendly installers that facilitate quick on-premises deployments, so you can self-host your real-time solution in your own infrastructure or any cloud provider.</p> <p>There are different deployment options available, depending on your needs:</p> Type of deployment OpenViduLocal (development) OpenViduSingle Node OpenViduElastic OpenViduHigh Availability OpenVidu Edition COMMUNITY PRO COMMUNITY PRO PRO Suitability For local development in your laptop For applications with medium user load For applications with dynamic user load that require scalability For applications where both scalability and fault tolerance are critical Features Friendly Docker Compose setup with Redis, Egress, Ingress, S3 storage and observability. With automatic certificate management to test across devices in your network Custom LiveKit distribution with Redis, Egress, Ingress, S3 storage and observability Same benefits as OpenVidu Single Node plus 2x performance, scalability and advanced observability Same benefits as OpenVidu Single Node and OpenVidu Elastic plus fault tolerance Number of servers Your laptop 1 Node 1 Master Node +N Media Nodes 4 Master Nodes +N Media Nodes Installation instructions Install Install Install Install <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/deployment-types/#openvidu-local-development","title":"OpenVidu Local (development)","text":"<p>To run OpenVidu in your local machine, this is the quickest option. It is a Docker Compose setup that includes all the necessary services to run OpenVidu in your LAN, including automated SSL certificates that will be valid across all devices in your network.</p> <p> </p> OpenVidu Local (development)"},{"location":"/3.0.0-beta1/docs/self-hosting/deployment-types/#openvidu-single-node","title":"OpenVidu Single Node","text":"<p>This is the simplest production-ready OpenVidu deployment available. It provides all the features you need, but lacks scalability and fault tolerance. But make no mistake about it: it is perfectly suitable for medium-scale production deployments. For most projects OpenVidu Single Node will be enough, at least until your user load gets serious. You can host hundreds of simultaneous participants in your rooms by running OpenVidu Community on a sufficiently powerful server!</p> <p>It is composed of a single OpenVidu Node hosting all the necessary services in a monolithic setup.</p> <p> </p> OpenVidu Single Node"},{"location":"/3.0.0-beta1/docs/self-hosting/deployment-types/#openvidu-elastic","title":"OpenVidu Elastic","text":"<p>This is the intermediate OpenVidu deployment. It provides scalability for your video rooms. Suitable for applications with dynamic load in the media plane that require scalability.</p> <p>It is composed of two different types of nodes, one of them running on a cluster of multiple servers and the other running as a single monolithic server:</p> <ul> <li>A cluster of Media Nodes hosting all the media-related services. Your video rooms scale up and down thanks to this cluster.</li> <li>A single Master Node hosting all the support services in a monolithic setup.</li> </ul> <p> </p> OpenVidu Elastic"},{"location":"/3.0.0-beta1/docs/self-hosting/deployment-types/#openvidu-high-availability","title":"OpenVidu High Availability","text":"<p>This is the most complete OpenVidu deployment. It provides scalability for your video rooms and fault tolerance in all its services. Suitable for applications where both scalability and availability are critical.</p> <p>It is composed of two different types of nodes running on two separate clusters:</p> <ul> <li>A cluster of Media Nodes hosting all the media-related services. Your video rooms scale up and down thanks to this cluster. The minimum number of nodes in this cluster is 1, and it is designed to scale up and down dynamically according to workload.</li> <li>A cluster of Master Nodes hosting all the support services in their high availability format. Your deployment is fault tolerant thanks to this cluster. The minimum number of nodes in this cluster is 4, and it is designed to have a fixed number of nodes at all times.</li> </ul> <p> </p> OpenVidu High Availability cluster"},{"location":"/3.0.0-beta1/docs/self-hosting/deployment-types/#node-services","title":"Node services","text":"<p>OpenVidu is composed of several services that work together to provide a complete videoconferencing solution. Every service runs as a Docker container, coordinated with Docker Compose.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/deployment-types/#master-node-services","title":"Master Node services","text":"SERVICE DESCRIPTION OpenVidu Dashboard Web application interface for managing your cluster and visualizing your Rooms. Default Application (OpenVidu Call) A fully fledged videoconference web application ready to be used out-of-the-box. OpenVidu Operator Module that supervises the high availability services and updates the loadbalancing configuration dynamically. Redis Database used to share transient information between Media Nodes and coordinate them. In OpenVidu High Availability this is an instance of a Redis Cluster. MongoDB Database used to store analytics and monitoring persistent data. In OpenVidu High Availability this is an instance of a MongoDB Replica Set. Minio S3 bucket used to store recordings and common node configurations. In OpenVidu High Availability this is an instance of a Minio Multi-Node. Caddy Reverse proxy used as a loadbalancer to distribute client connections across your nodes and automatically manage your TLS certificate. Mimir (observability) Module used to store metrics from Prometheus. Promtail (observability) Module used to collect logs from all services and send them to Loki. Loki (observability) Module used to store logs. Grafana (observability) Module used to visualize logs and metrics in dashboards."},{"location":"/3.0.0-beta1/docs/self-hosting/deployment-types/#media-node-services","title":"Media Node services","text":"SERVICE DESCRIPTION OpenVidu Server Media server used to stream real-time video, audio and data. Based on SFUs LiveKit and mediasoup. Egress Server Module used to export media from a Room (for example, recordings or RTMP broadcasting). See Egress. Ingress Server Module used to import media into a Room (for example, an MP4 video or an RTSP stream). See Ingress. Caddy Reverse proxy used as a loadbalancer to distribute the load generated by the Media Nodes over the Minio, Mimir and Loki cluster. Prometheus (observability) Module used to collect metrics from OpenVidu Server and send them to Loki. Promtail (observability) Module used to collect logs from all services and send them to Loki."},{"location":"/3.0.0-beta1/docs/self-hosting/faq/","title":"Installation FAQs","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#common-issues","title":"Common issues","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#everything-looks-alright-but-i-cannot-see-any-remote-video","title":"Everything looks alright, but I cannot see any remote video.","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#my-local-video-is-not-showing-up-on-the-browser","title":"My local video is not showing up on the browser","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#any-tips-to-make-easier-the-development-of-my-webrtc-application","title":"Any tips to make easier the development of my WebRTC application?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#test-applications-in-my-network-with-multiple-devices","title":"Test applications in my network with multiple devices.","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#does-my-app-need-a-server-side","title":"Does my app need a server-side?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#caddy-certificates-are-not-working-what-can-i-do","title":"Caddy certificates are not working. What can I do?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#my-commercial-certificate-is-not-working-what-can-i-do","title":"My commercial certificate is not working. What can I do?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#how-can-i-customize-the-caddy-configuration","title":"How can I customize the Caddy configuration?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#openvidu-does-not-work-for-clients-behind-restrictive-firewalls","title":"OpenVidu does not work for clients behind restrictive firewalls.","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#fundamentals-knowledge","title":"Fundamentals Knowledge","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#what-is-a-domain-name-and-how-can-i-get-one","title":"What is a domain name and how can I get one?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#what-is-an-aws-elastic-ip-and-how-can-i-create-one","title":"What is an AWS Elastic IP and how can I create one?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#what-is-a-vpc-and-a-subnet-in-aws","title":"What is a VPC and a subnet in AWS?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#what-is-a-dns-record-and-how-can-i-create-one","title":"What is a DNS record and how can I create one?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#what-means-each-type-of-certificate-in-openvidu","title":"What means each type of certificate in OpenVidu?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#what-is-stun-and-turn-and-why-do-i-need-them","title":"What is STUN and TURN and why do I need them?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#what-is-a-caddy-server-and-why-is-it-used-in-openvidu","title":"What is a Caddy server and why is it used in OpenVidu?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/faq/#what-is-the-operator-service-in-openvidu","title":"What is the \"operator\" service in OpenVidu?","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/local/","title":"OpenVidu Local Installation (Development)","text":"<p>For development purposes, we provide an easy to install local deployment based on Docker Compose which will automatically configure all the necessary services for OpenVidu to develop and test your applications seamlessly.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/local/#installation-instructions","title":"Installation instructions","text":"<p>First, make sure you have the following prerequisites:</p>  Windows macOS Linux <ul> <li>Install Docker Desktop</li> </ul> <ul> <li>Install Docker Desktop</li> </ul> <ul> <li>Install Docker</li> <li>Install Docker Compose</li> </ul> <p>The installation consists of cloning a repository and running a script to configure your local IP address in the deployment. Then, you can start, stop, and manage your deployment with Docker Compose.</p> <p>To install OpenVidu locally, follow these steps:</p> OpenVidu COMMUNITYOpenVidu PRO <ol> <li> <p>Clone the following repository:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> <p>Info</p> <p>To use a specific OpenVidu version, switch to the desired tag with <code>git checkout &lt;version&gt;</code>, e.g., <code>git checkout 3.0.0</code>. By default, the latest version is used.</p> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <ol> <li> <p>Clone the following repository:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> <p>Info</p> <p>To use a specific OpenVidu version, switch to the desired tag with <code>git checkout &lt;version&gt;</code>, e.g., <code>git checkout 3.0.0</code>. By default, the latest version is used.</p> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/pro\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/pro\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/pro\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>Info</p> <p>OpenVidu PRO runs locally in evaluation mode for free for development and testing purposes. Some limits apply:</p> <ul> <li>Maximum 2 concurrent Rooms</li> <li>Maximum 8 Participants per Room</li> <li>Maximum 5 minutes duration per Room</li> </ul> <p>For a production environment, you need to create an OpenVidu account to get a license key. There's a 15 day free trial waiting for you!</p> <p>The deployment is ready when you see the following message:</p> <pre><code> =========================================\n \ud83c\udf89 OpenVidu is ready! \ud83c\udf89\n =========================================\n\n OpenVidu Server &amp;&amp; LiveKit Server URLs:\n\n     - From this machine:\n\n         - http://localhost:7880\n         - ws://localhost:7880\n\n     - From other devices in your LAN:\n\n         - https://xxx-yyy-zzz-www.openvidu-local.dev:7443\n         - wss://xxx-yyy-zzz-www.openvidu-local.dev:7443\n\n =========================================\n\n OpenVidu Developer UI (services and passwords):\n\n     - http://localhost:7880\n     - https://xxx-yyy-zzz-www.openvidu-local.dev:7443\n\n =========================================\n</code></pre> <p>By visiting http://localhost:7880 you have the OpenVidu Developer UI available with a summary of the services and passwords deployed. You can access the following services:</p> <ul> <li>OpenVidu API (LiveKit compatible) (http://localhost:7880): the main API endpoint for your OpenVidu and LiveKit applications. OpenVidu v2 compatibility API is only available in OpenVidu PRO.</li> <li>OpenVidu Dashboard (http://localhost:7880/dashboard): a web application interface to visualize your Rooms, Ingress and Egress services.</li> <li>MinIO (http://localhost:7880/minio-console): as an S3 storage service for recordings.</li> <li>OpenVidu Call (Default Application) (http://localhost:7880/openvidu-call): an optional ready-to-use videoconferencing application.</li> </ul> <p>You just need to point your OpenVidu and LiveKit applications to <code>http://localhost:7880</code> or <code>ws://localhost:7880</code> and start developing. Check our tutorials if you want a step-by-step guide to develop your first application using OpenVidu.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/local/#accessing-your-local-deployment-from-other-devices-on-your-network","title":"Accessing your local deployment from other devices on your network","text":"<p>Testing WebRTC applications can be challenging because devices require a secure context (HTTPS) to access the camera and microphone. When using LiveKit Open Source, this isn't an issue if you access your app from the same computer where the LiveKit Server is running, as <code>localhost</code> is considered a secure context even over plain HTTP. Consider the following architecture:</p> <p>The simplest way to test your application is:</p> <ol> <li>Run LiveKit Server on your computer.</li> <li>Connect your app to LiveKit Server through <code>localhost</code>.</li> <li>Serve both your application client and server from the same computer.</li> <li>Access your app from <code>localhost</code> in a browser on the same computer.</li> </ol> <p>This setup is straightforward, but what if you need to test your app from multiple devices simultaneously, including real mobile devices? In this case, you must use a secure context (HTTPS), which introduces two challenges:</p> <ol> <li>LiveKit Server open source does not natively support HTTPS. You'll need a reverse proxy to serve LiveKit Server over HTTPS.</li> <li>Even with HTTPS, your SSL certificate might not be valid for local network addresses. You'll need to accept it in the browser for web apps, and install it on mobile devices.</li> </ol> <p>OpenVidu Local Deployment addresses these issues by providing a magic domain name <code>openvidu-local.dev</code> that resolves to any IP specified as a subdomain and provides a valid wildcard certificate for HTTPS. This is similar to services like nip.io, traefik.me, or localtls.</p> <p>When using OpenVidu Local Deployment, you can access OpenVidu Server (which is 100% LiveKit compatible) and your app from any device on your local network with a valid HTTPS certificate. The following table shows the URLs to access the deployment and your application locally and from other devices on your network:</p> Local access Access from devices in your local network Usage Access only from the development machine Access from any device connected to your local network. In the URLs below, replace <code>xxx-yyy-zzz-www</code> with the local IP address of the development machine, replacing the dots (<code>.</code>) with dashes (<code>-</code>). You can find the configured local IP in the <code>.env</code> file in the <code>LAN_PRIVATE_IP</code> variable Application Client (frontend) http://localhost:5080 https://xxx-yyy-zzz-www.openvidu-local.dev:5443 Application Server (backend) http://localhost:6080 https://xxx-yyy-zzz-www.openvidu-local.dev:6443 OpenVidu (LiveKit Compatible) URL http://localhost:7880 https://xxx-yyy-zzz-www.openvidu-local.dev:7443 <p>Info</p> <ul> <li>If you are developing locally, use <code>localhost</code> to access the services, but if you want to test your application from other devices on your network, use the <code>openvidu-local.dev</code> URLs.</li> <li>Replace <code>xxx-yyy-zzz-www</code> with your local IP address. You can find it in the <code>.env</code> file in the <code>LAN_PRIVATE_IP</code> variable.</li> </ul> <p>Warning</p> <p>If the URL isn't working because the IP address is incorrect or the installation script couldn't detect it automatically, you can update the <code>LAN_PRIVATE_IP</code> value in the <code>.env</code> file and restart the deployment with <code>docker compose up</code>.</p> <p>When developing web applications with this deployment, you can use the following code snippet to dynamically determine the appropriate URLs for the application server and the OpenVidu server based on the browser's current location. This approach allows you to seamlessly run your application on both your development machine and other devices within your local network without needing to manually adjust the URLs in your code.</p> <pre><code>if (window.location.hostname === \"localhost\") {\n  APPLICATION_SERVER_URL = \"http://localhost:6080\";\n  OPENVIDU_URL = \"wss://localhost:7443\";\n} else {\n  APPLICATION_SERVER_URL = \"https://\" + window.location.hostname + \":6443\";\n  OPENVIDU_URL = \"ws://\" + window.location.hostname + \":7880\";\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/local/#about-openvidu-localdev-domain-and-ssl-certificates","title":"About <code>openvidu-local.dev</code> domain and SSL certificates","text":"<p>This setup simplifies the configuration of local OpenVidu deployments with SSL, making it easier to develop and test your applications securely on your local network by using the <code>openvidu-local.dev</code> domain and a wildcard SSL certificate valid for <code>*.openvidu-local.dev</code>. However, it\u2019s important to note that these certificates are publicly available and do not provide an SSL certificate for production use.</p> <p>The HTTPS offered by <code>openvidu-local.dev</code> is intended for development or testing purposes with the only goal of making your local devices trust your application (which is mandatory in WebRTC applications). For any other use case, it should be treated with the same security considerations as plain HTTP.</p> <p>For production, you should consider deploying a production-grade OpenVidu deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/","title":"OpenVidu Elastic installation","text":"<p>OpenVidu Elastic is part of the PRO edition of OpenVidu. You have the following deployment options:</p> <ul> <li>On-premises Installation: Set up OpenVidu Elastic on your own servers.</li> <li>AWS Installation: Deploy OpenVidu Elastic on Amazon Web Services.</li> </ul> <p>Once your deployment is complete, refer to the following sections for configuration and management:</p> <ul> <li>On-premises: Configuration and Administration</li> <li>AWS: Configuration and Administration</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/","title":"OpenVidu Elastic Configuration and Administration: AWS","text":"<p>The deployment of OpenVidu Elastic on AWS is automated using AWS CloudFormation, with Media Nodes managed within an Auto Scaling Group. This group dynamically adjusts the number of instances based on a target average CPU utilization. Internally, the AWS deployment mirrors the on-premises setup, allowing you to follow the same administration and configuration guidelines provided in the On Premises Elastic documentation. However, there are specific considerations unique to the AWS environment that are worth taking into account.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/#cluster-shutdown-and-startup","title":"Cluster Shutdown and Startup","text":"<p>The Master Node is an EC2 instance, while the Media Nodes are part of an Auto Scaling Group. The process for starting and stopping these components differs. The following sections detail the procedures.</p> Shutdown the ClusterStartup the Cluster <p>To shut down the cluster, you need to stop the Media Nodes first and then stop the Master Node. This way, any ongoing session will not be interrupted.</p> <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu Elastic.</li> <li>In the \"Resources\" tab, locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code>, and click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>Set the \"Desired capacity\", \"Min desired capacity\", and \"Max desired capacity\" to 0, and click on \"Update\".      </li> <li> <p>Wait until the \"Instance Management\" tab shows that there are no instances in the Auto Scaling Group.      </p> <p>Warning</p> <p>It may happen that some instances are still in the \"Terminating:Wait\" lifecycle state after setting the desired capacity to 0. This is because the Auto Scaling Group waits for the instances to finish processing any ongoing room, ingress, or egress operations before terminating them. This can take a few minutes. If you want to force the termination of the instances, you can manually terminate them from the EC2 Dashboard.</p> </li> <li> <p>After confirming that all Media Node instances are terminated, go back to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMasterNode</code>. Click on it to go to the EC2 Dashboard with the Master Node instance selected.      </p> </li> <li>Right-click on the instance and select \"Stop instance\".      </li> </ol> <p>To start the cluster, we recommend starting the Master Node first and then the Media Nodes.</p> <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu Elastic.</li> <li>Locate the resource with the logical ID: <code>OpenViduMasterNode</code>. Click on it to go to the EC2 Dashboard with the Master Node instance selected.      </li> <li>Right-click on the instance and select \"Start instance\".      </li> <li>Wait until the instance is running.</li> <li>Go back to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>Set the \"Desired capacity\", \"Min desired capacity\", and \"Max desired capacity\" to the desired number of Media Nodes, and click on \"Update\". In this example, we set the desired capacity to 2.      </li> <li>Wait until the \"Instance Management\" tab shows that there are the desired number of instances in the Auto Scaling Group.      </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/#change-the-instance-type","title":"Change the instance type","text":"<p>It is possible to change the instance type of both the Master Node and the Media Nodes. However, since the Media Nodes are part of an Auto Scaling Group, the process differs. The following section details the procedures.</p> Master NodesMedia Nodes <p>Warning</p> <p>This procedure requires downtime, as it involves stopping the Master Node.</p> <ol> <li> <p>Shutdown the cluster.</p> <p>Info</p> <p>You can stop only the Master Node instance to change its instance type, but it is recommended to stop the whole cluster to avoid any issues.</p> </li> <li> <p>Go to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMasterNode</code>. Click on it to go to the EC2 Dashboard with the Master Node instance selected.      </p> </li> <li>Right-click on the instance and select \"Instance Settings &gt; Change Instance Type\".      </li> <li>Select the new instance type and click on \"Apply\".</li> <li>Start the cluster.</li> </ol> <ol> <li>Go to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu Elastic.</li> <li>Locate the resource with the logical ID: <code>OpenViduMediaNodeLaunchTemplate</code>. Click on it to go to the Launch Template Dashboard with the Launch Template of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Modify template (Create new version)\".      </li> <li>In the \"Instance type\" section, select the new instance type and click on \"Create template version\".      </li> <li>Go to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li> <p>In the Launch Template section, select the new version of the launch template we just created at step 5, which is the highest version number.</p> <p>Then, click on \"Update\".</p> <p>Info</p> <p>By configuring \"Latest\" as the launch template version, you no longer need to update the Auto Scaling Group every time you modify the launch template. The Auto Scaling Group will automatically use the latest version of the launch template.</p> <p></p> </li> <li> <p>Terminate the old instances manually from the EC2 Dashboard if you want to force the termination of the instances. New instances will be launched with the new instance type.</p> <p>Info</p> <p>If you want to avoid downtime, you can wait until the Auto Scaling Group replaces the old instances with the new ones. But you will need to increase the desired capacity to force the replacement of the instances and then decrease it to the desired number of instances.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/#media-nodes-autoscaling-configuration","title":"Media Nodes Autoscaling Configuration","text":"<p>To configure the Auto Scaling settings for the Media Nodes, follow the steps outlined below. This configuration allows you to set the parameters that control how the Auto Scaling Group will scale based on the target average CPU utilization.</p> Media Nodes Autoscaling Configuration <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu Elastic.</li> <li>In the \"Resources\" tab, locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code> and click on it to go to the Auto Scaling Group Dashboard.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>To configure scaling policies, navigate to the \"Automatic scaling\" tab within the Auto Scaling Group Dashboard, select the unique \"Target tracking scaling\" autoscaling policy, and click on \"Actions &gt; Edit\".      </li> <li> <p>It will open a panel where you can configure multiple parameters. In this example, we set the target average CPU utilization to 30%. Then, click on \"Update\".      </p> <p>Info</p> <p>OpenVidu Elastic is by default configured with a \"Target tracking scaling\" policy that scales based on the target average CPU utilization, however, you can configure different autoscaling policies according to your needs. For more information on the various types of autoscaling policies and how to implement them, refer to the AWS Auto Scaling documentation.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/#fixed-number-of-media-nodes","title":"Fixed Number of Media Nodes","text":"<p>If you need to maintain a fixed number of Media Nodes instead of allowing the Auto Scaling Group to dynamically adjust based on CPU utilization, you can configure the desired capacity settings accordingly. Follow the steps below to set a fixed number of Media Nodes:</p> Set Fixed Number of Media Nodes <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu Elastic.</li> <li>In the \"Resources\" tab, locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code> and click on it to go to the Auto Scaling Group Dashboard.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>Set the \"Desired capacity\", \"Min desired capacity\", and \"Max desired capacity\" to the fixed number of Media Nodes you require, and click on \"Update\". In this example, we set the desired capacity to 2.      </li> <li>Wait until the \"Instance Management\" tab shows that the Auto Scaling Group has the fixed number of instances running.      </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/#configuration-management","title":"Configuration Management","text":"<p>This section explains how to manage and update the configuration settings for your OpenVidu Elastic deployment. It is divided into three parts:</p> <ol> <li>Configuring CloudFormation YAML for Node Services Configuration: Details how to pre-configure settings in the CloudFormation template to avoid manual interventions post-deployment.</li> <li>Global Configuration: Covers parameters that affect the entire cluster when the CloudFormation stack is already deployed.</li> <li>Node Services Configuration: Focuses on settings specific to Master and Media Nodes services when the CloudFormation stack is already deployed.</li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/#configuring-cloudformation-yaml-for-node-services-configuration","title":"Configuring CloudFormation YAML for Node Services Configuration","text":"<p>To avoid manual intervention after deployment, you can pre-configure the node services configuration directly in the CloudFormation YAML template. This ensures that the necessary configurations are applied automatically upon deployment.</p> Master NodeMedia Nodes <ol> <li>Get the CloudFormation YAML template used to deploy OpenVidu Elastic on AWS.</li> <li> <p>Locate the section defining the Launch Template for the Master Node and update the <code>UserData</code> property with the required configuration parameters. The section looks like this:</p> <pre><code>OpenViduMasterNode:\n    Type: AWS::EC2::Instance\n    Properties:\n        UserData:\n            Fn::Base64: !Sub |\n                #!/bin/bash\n                ...\n                ...\n                # Install OpenVidu\n                /usr/local/bin/install.sh || { echo \"[OpenVidu] error installing OpenVidu\"; exit 1; }\n\n                ######### APPLY CUSTOM CONFIGURATIONS #########\n                # If you want to apply any modification to the configuration files\n                # of the OpenVidu services at /opt/openvidu, you can do it here.\n                # Examples:\n                #\n                # - Change minio public port\n                # yq eval '.apps.http.servers.minio.listen[0] = \":9001\"' -i /opt/openvidu/config/caddy.yaml\n                #\n                # - Disable dashboard access\n                # yq eval 'del(.apps.http.servers.public.routes[] | \\\n                #  select(.handle[]?.handler == \"subroute\" and \\\n                #  .handle[].routes[].handle[].strip_path_prefix == \"/dashboard\"))' \\\n                #  -i /opt/openvidu/config/caddy.yaml\n\n\n\n                ######### END CUSTOM CONFIGURATIONS #########\n\n                # Start OpenVidu\n                systemctl start openvidu || { echo \"[OpenVidu] error starting OpenVidu\"; exit 1; }\n                ...\n                ...\n</code></pre> <p>The area between <code>APPLY CUSTOM CONFIGURATIONS</code> and <code>END CUSTOM CONFIGURATIONS</code> is where you can add your custom configuration commands. You can use <code>yq</code> to modify the configuration files of the OpenVidu services. The example shows how to change the <code>minio</code> public port and how to disable dashboard access in the <code>caddy.yaml</code> configuration file.</p> </li> <li> <p>Save the YAML file and use it to deploy your CloudFormation stack. This will apply the Master Node configuration automatically during the deployment process.</p> </li> </ol> <ol> <li>Get the CloudFormation YAML template used to deploy OpenVidu Elastic on AWS.</li> <li> <p>Locate the section defining the Launch Template for the Media Nodes and update the <code>UserData</code> property with the required configuration parameters. The section looks like this:</p> <pre><code>OpenViduMediaNodeLaunchTemplate:\n    Type: \"AWS::EC2::LaunchTemplate\"\n    Properties:\n    LaunchTemplateData:\n        UserData:\n            Fn::Base64: !Sub |\n                #!/bin/bash\n                ...\n                ...\n                # Install OpenVidu #\n                /usr/local/bin/install.sh || { echo \"[OpenVidu] error installing OpenVidu\"; /usr/local/bin/set_as_unhealthy.sh; exit 1; }\n\n                ######### APPLY CUSTOM CONFIGURATIONS #########\n                # If you want to apply any modification to the configuration files\n                # of the OpenVidu services at /opt/openvidu, you can do it in this section.\n                # Examples:\n                #\n                # - Announce specific IP address for the Media Node\n                # yq eval '.rtc.node_ip = 1.2.3.4' -i /opt/openvidu/config/livekit.yaml\n                #\n                # - Add webhooks to livekit\n                # yq eval '.webhook.urls += [\"http://new-endpoint.example.com/webhook\"]' -i /opt/openvidu/config/livekit.yaml\n\n\n\n                ######### END CUSTOM CONFIGURATIONS #########\n\n                # Start OpenVidu\n                systemctl start openvidu || { echo \"[OpenVidu] error starting OpenVidu\"; /usr/local/bin/set_as_unhealthy.sh; exit 1; }\n</code></pre> <p>The area between <code>APPLY CUSTOM CONFIGURATIONS</code> and <code>END CUSTOM CONFIGURATIONS</code> is where you can add your custom configuration commands. You can use <code>yq</code> to modify the configuration files of the OpenVidu services. The example shows how to change the <code>rtc.node_ip</code> parameter and how to add a webhook to the <code>livekit.yaml</code> configuration file.</p> </li> <li> <p>Save the YAML file and use it to deploy your CloudFormation stack. This will apply the node services configuration automatically during the deployment process.</p> </li> </ol> <p>By pre-configuring the CloudFormation template, you streamline the deployment process and reduce the need for post-deployment manual configuration.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/#global-configuration","title":"Global Configuration","text":"<p>The global configuration parameters for the OpenVidu Elastic deployment are stored in a secret resource deployed by the CloudFormation stack. These parameters can affect the configuration of all the nodes in the cluster. To update any of these parameters, follow the steps below:</p> Update Global Configuration Parameters <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu Elastic.</li> <li>In the \"Resources\" tab, locate the resource with the logical ID: <code>OpenViduSharedInfo</code> and click on it to view the secret in AWS Secrets Manager.      </li> <li>Click on \"Retrieve secret value\" to view the parameters.      </li> <li>Edit the desired parameters within the secret. For example, you can change the <code>RTC_ENGINE</code> parameter to <code>pion</code> or <code>mediasoup</code> depending on the WebRTC engine you want to use. Just click on \"Edit\", modify the value, and click on \"Save\".      </li> <li>To apply the changes, stop the cluster and then start it again following the procedures outlined in the Cluster Shutdown and Startup section.</li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/admin/#node-services-configuration","title":"Node Services Configuration","text":"<p>The configuration for individual node services can be managed through different methods depending on the node type.</p> Master NodeMedia Node <p>The Master Node's configuration can be directly modified on the internal machine since it is an EC2 instance. To update the configuration:</p> <ol> <li>Connect to the Master Node EC2 instance using SSH.</li> <li>Edit the configuration files as necessary. Check the On Premises Elastic documentation related to the Master Node configuration.</li> </ol> <p>Once the changes are made, restart the OpenVidu Server to apply the new configuration.</p> <pre><code>sudo systemctl restart openvidu\n</code></pre> <p>Warning</p> <p>Take into account that some changes may require modifying the Master Nodes configuration as well. Check the On Premises Elastic Advanced Configuration for more information.</p> <p>Media Node configurations require changes to be made in the Launch Template \"User Data\" section. To update the configuration:</p> <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu Elastic.</li> <li>Locate the resource with the logical ID: <code>OpenViduMediaNodeLaunchTemplate</code>. Click on it to go to the Launch Template Dashboard with the Launch Template of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Modify template (Create new version)\".      </li> <li>Go to the \"Advanced details\" section and modify the \"User data\" field with the new configuration. You can modify the configuration parameters of the services running on the Media Nodes following the same script structure as the one used in the Automatic installation and configuration of nodes for the Media Nodes. When you finish, click on \"Create template version\".      </li> <li>Go to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li> <p>In the Launch Template section, select the new version of the launch template we just created at step 5, which is the highest version number. Then, click on \"Update\".</p> <p>Info</p> <p>By configuring \"Latest\" as the launch template version, you no longer need to update the Auto Scaling Group every time you modify the launch template. The Auto Scaling Group will automatically use the latest version of the launch template.</p> <p></p> </li> <li> <p>Terminate the old instances manually from the EC2 Dashboard if you want to force the termination of the instances. New instances will be launched with the new configuration.</p> <p>Warning</p> <p>This process requires downtime, as it involves terminating the old instances and launching new ones with the updated configuration.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/","title":"OpenVidu Elastic Installation: AWS","text":"<p>Info</p> <p>OpenVidu Elastic is part of OpenVidu PRO. Before deploying, you need to create an OpenVidu account to get your license key. There's a 15-day free trial waiting for you!</p> <p>This section contains the instructions to deploy a production-ready OpenVidu Elastic deployment in AWS. Deployed services are the same as the On Premises Elastic Installation but automate the process with AWS CloudFormation.</p> <p>First of all, import the template in the AWS CloudFormation console. You can click the following button...</p> <p>Deploy OpenVidu Elastic in </p> <p>...or access your AWS CloudFormation console and manually set this S3 URL in the <code>Specify template</code> section:</p> <pre><code>https://s3.eu-west-1.amazonaws.com/get.openvidu.io/pro/elastic/latest/aws/cf-openvidu-elastic.yaml\n</code></pre> Architecture overview <p>This is how the architecture of the deployment looks:</p> <p> OpenVidu Elastic AWS Architecture </p> <ul> <li>The Master Node acts as a Load Balancer, managing the traffic and distributing it among the Media Nodes and deployed services in the Master Node.</li> <li>The Master Node has its own Caddy server acting as a Layer 4 (for TURN with TLS and RTMPS) and Layer 7 (for OpenVidu Dashboard, OpenVidu Call, etc., APIs) reverse proxy.</li> <li>WebRTC traffic (SRTP/SCTP/STUN/TURN) is routed directly to the Media Nodes.</li> <li>An autoscaling group of Media Nodes is created to scale the number of Media Nodes based on the system load.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#cloudformation-parameters","title":"CloudFormation Parameters","text":"<p>Depending on your needs, you need to fill in the following CloudFormation parameters:</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#domain-and-ssl-certificate-configuration","title":"Domain and SSL Certificate Configuration","text":"<p>These are the three possible scenarios you may have to configure in this section:</p> Let's Encrypt Certificate (recommended)Self-Signed CertificateCustom Certificates <p>For a production-ready setup, this scenario is ideal when you have an FQDN (Fully Qualified Domain Name) and an Elastic IP at your disposal. It leverages the services of Let's Encrypt to automatically generate valid certificates.</p> <p>First, you need to have the FQDN pointing to the Elastic IP you are going to use.</p> <p>Then, you need to fill in the following parameters:</p> <p></p> <p>As you can see, you need to specify the DomainName with your FQDN, the PublicElasticIP with the Elastic IP that the domain points to, and the LetsEncryptEmail with your email address for Let\u2019s Encrypt notifications. These parameters are mandatory.</p> <p>This is the most straightforward option for deploying OpenVidu on AWS when you do not have a Fully Qualified Domain Name (FQDN). This method allows for the immediate use of OpenVidu in AWS using CloudFormation.</p> <p>However, this convenience comes with the caveat that users will need to manually accept the certificate in their web browsers. Please be aware that this configuration is solely for developmental and testing purposes and is not suitable for a production environment.</p> <p>These are the parameters needed in this section to use self-signed certificates:</p> <p></p> <p>You don\u2019t need to specify any parameters; just select the CertificateType as self-signed. The domain name used will be an AWS-generated one.</p> <p>Opt for this method if you possess your own certificate for an existing FQDN. It enables you to deploy OpenVidu on AWS using your certificates.</p> <p>You need to have a Fully Qualified Domain Name (FQDN) pointing to a previously created Elastic IP.</p> <p>Also, you need a temporary HTTP server hosting your private and public certificate under a specific URL. These URLs are needed for the instance to be able to download and install your certificates.</p> <p>The configured parameters would look like this:</p> <p></p> <p>You need to specify at OwnPublicCertificate and OwnPrivateCertificate the URLs where the public and private certificates are hosted, respectively. The DomainName and PublicElasticIP are mandatory parameters.</p> <p>Certificates need to be in PEM format and the URLs must be accessible from the instance.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#openvidu-elastic-configuration","title":"OpenVidu Elastic Configuration","text":"<p>In this section, you need to specify some properties needed for the OpenVidu Elastic deployment.</p> OpenVidu Elastic Configuration <p>The parameters in this section might appear as follows:</p> <p></p> <p>Make sure to provide the OpenViduLicense parameter with the license key. If you don't have one, you can request one here.</p> <p>For the RTCEngine parameter, you can choose between Pion (the engine used by LiveKit) and Mediasoup (experimental).</p> <p>Warning</p> <p>mediasoup integration in OpenVidu is experimental, and should not be used in production environments. There are some limitations that are currently being worked on, expected to be ironed out in the near future.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#ec2-instance-configuration","title":"EC2 Instance Configuration","text":"<p>You need to specify some properties for the EC2 instances that will be created.</p> EC2 Instance configuration <p>The parameters in this section may look like this:</p> <p></p> <p>Simply select the type of instance you want to deploy at MasterNodeInstanceType and MediaNodeInstanceType, the SSH key you want to use to access the machine at KeyName, and the Amazon Image ID (AMI) to use at AmiId.</p> <p>By default, the parameter AmiId is configured to use the latest LTS Ubuntu AMI, so ideally you don\u2019t need to modify this.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#media-nodes-autoscaling-group-configuration","title":"Media Nodes Autoscaling Group Configuration","text":"<p>The number of Media Nodes can scale up or down based on the system load. You can configure the minimum and maximum number of Media Nodes and a target CPU utilization to trigger the scaling up or down.</p> Media Nodes Autoscaling Group Configuration <p>The parameters in this section may look like this:</p> <p></p> <p>The InitialNumberOfMediaNodes parameter specifies the initial number of Media Nodes to deploy. The MinNumberOfMediaNodes and MaxNumberOfMediaNodes parameters specify the minimum and maximum number of Media Nodes that you want to be deployed.</p> <p>The ScaleTargetCPU parameter specifies the target CPU utilization to trigger the scaling up or down. The goal is to keep the CPU utilization of the Media Nodes close to this value. The autoscaling policy is based on Target Tracking Scaling Policy.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#vpc-configuration","title":"VPC Configuration","text":"<p>In this section, you need to specify the VPC and Subnet configuration for the deployment.</p> VPC Configuration <p>The parameters in this section may look like this:</p> <p></p> <p>The OpenViduVPC parameter specifies the VPC where the deployment will be created.</p> <p>The OpenViduMasterNodeSubnet and OpenViduMediaNodeSubnet parameters specify the subnets where the Master and Media Nodes will be deployed. All of them must be in the previously specified OpenViduVPC.</p> <p>Warning</p> <p>You must use public subnets for the Master Nodes and Media Nodes and have enabled the auto-assign public IP option.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#optional-turn-server-configuration-with-tls","title":"(Optional) TURN server configuration with TLS","text":"<p>This section is optional. It is useful when your users are behind a restrictive firewall that blocks UDP traffic. This parameter will only works if you are using <code>letsencrypt</code> or <code>owncert</code> as the CertificateType parameter.</p> TURN server configuration with TLS <p>The parameters in this section may look like this:</p> <p></p> <p>Set the TurnDomainName parameter to the domain name you intend to use for your TURN server. It should be pointing to the <code>PublicElasticIP</code> specified in the previous section.</p> <p>If you are using <code>letsencrypt</code> as the CertificateType parameter, you can leave the TurnOwnPublicCertificate and TurnOwnPrivateCertificate parameters empty. If you are using <code>owncert</code>, you need to specify the URLs where the public and private certificates are hosted.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#deploying-the-stack","title":"Deploying the Stack","text":"<p>When you are ready with your CloudFormation parameters, just click on \"Next\", specify in \"Stack failure options\" the option \"Preserve successfully provisioned resources\" to be able to troubleshoot the deployment in case of error, click on \"Next\" again, and finally \"Submit\".</p> <p>When everything is ready, you will see the following links in the \"Outputs\" section of CloudFormation:</p> CloudFormation Outputs <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#deployment-credentials","title":"Deployment Credentials","text":"<p>The Output Key ServicesAndCredentials of the previous section points to an AWS Secret Manager secret that contains all URLs and credentials to access the services deployed. You can access the secret by clicking on the link in the Output Value column.</p> <p>Then, click on Retrieve secret value to get the JSON with all the information.</p> <p></p> <p></p> <p>To point your applications to your OpenVidu deployment, check the values of the JSON secret. All access credentials of all services are defined in this object.</p> <p>Your authentication credentials and URL to point your applications would be:</p> <ul> <li> <p>Applications developed with LiveKit SDK:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_NAME</code> as a URL. It could be <code>wss://openvidu.example.io/</code> or <code>https://openvidu.example.io/</code> depending on the SDK you are using.</li> <li>API Key: The value in <code>.env</code> of <code>LIVEKIT_API_KEY</code></li> <li>API Secret: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> <li> <p>Applications developed with OpenVidu v2:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_NAME</code> as a URL. For example, <code>https://openvidu.example.io/</code></li> <li>Username: <code>OPENVIDUAPP</code></li> <li>Password: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#troubleshooting-initial-cloudformation-stack-creation","title":"Troubleshooting Initial CloudFormation Stack Creation","text":"<p>If something goes wrong during the initial CloudFormation stack creation, your stack may reach the <code>CREATE_FAILED</code> status for multiple reasons. It could be due to a misconfiguration in the parameters, a lack of permissions, or a problem with the AWS services. When this happens, the following steps can help you troubleshoot the issue and identify what went wrong:</p> <ol> <li> <p>While deploying the stack, make sure at \"Stack failure options\" you have selected the option \"Preserve successfully provisioned resources\" to be able to troubleshoot the deployment in case of an error.</p> Disable Rollback on failure <p> </p> </li> <li> <p>Check if the EC2 instance or instances are running. If they are not, check the CloudFormation events for any error messages.</p> </li> <li> <p>If the EC2 instance or instances are running, SSH into the instance and check the logs of the following files:</p> <ul> <li><code>/var/log/cloud-init-output.log</code></li> <li><code>/var/log/cloud-init.log</code></li> </ul> <p>These logs will give you more information about the CloudFormation stack creation process.</p> </li> <li> <p>If everything seems fine, check the status and the logs of the installed OpenVidu services in the Master Node and Media Nodes.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/aws/install/#configuration-and-administration","title":"Configuration and administration","text":"<p>When your CloudFormation stack reaches the <code>CREATE_COMPLETE</code> status, your OpenVidu Elastic deployment is ready to use. You can check the Configuration and Administration section to learn how to manage your OpenVidu Elastic deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/","title":"OpenVidu Elastic Configuration and Administration: On-premises","text":"<p>The OpenVidu installer offers an easy way to deploy OpenVidu Elastic on-premises. However, once the deployment is complete, you may need to perform administrative tasks based on your specific requirements, such as changing passwords, specifying custom configurations, and starting or stopping services.</p> <p>This section provides details on configuration parameters and common administrative tasks for on-premises OpenVidu Elastic deployments.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#openvidu-configuration","title":"OpenVidu configuration","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#directory-structure","title":"Directory structure","text":"<p>OpenVidu Elastic is composed of two types of nodes: Master and Media nodes. The directory structure of OpenVidu Elastic is as follows for each type of node:</p> Master NodeMedia Node <p>The OpenVidu Elastic Master Node is installed at <code>/opt/openvidu/</code> and has a systemd service located at <code>/etc/systemd/system/openvidu.service</code>.</p> <p>The directory structure of the Master Node is as follows:</p> <pre><code>|-- /opt/openvidu\n    |-- config/\n    |-- custom-layout/\n    |-- data/\n    |-- deployment-info.yaml\n    |-- docker-compose.override.yml\n    |-- docker-compose.yml\n    |-- .env\n    |-- owncert/\n    `-- recordings/\n</code></pre> <ul> <li><code>config/</code>: Contains the configuration files for the services deployed with the Master Node.</li> <li><code>custom-layout/</code>: An empty directory where you can place Custom Recording Templates for the Egress service. It also serves for OpenVidu V2 compatibility custom layouts.</li> <li><code>data/</code>: Contains the data generated by the services deployed with the Master Node.</li> <li><code>deployment-info.yaml</code>: Contains the deployment information of the Master Node.</li> <li><code>docker-compose.override.yml</code>: Contains the service with the Default App (OpenVidu Call) deployed with OpenVidu Elastic.</li> <li><code>docker-compose.yml</code>: Contains the main services deployed for the Master Node.</li> <li><code>.env</code>: Contains parameters managed by multiple services.</li> <li><code>owncert/</code>: Contains the custom certificates for the Caddy server if you are using your own certificates.</li> <li><code>recordings/</code>: Contains the recordings generated by the OpenVidu V2 compatibility service when <code>V2COMPAT_OPENVIDU_PRO_RECORDING_STORAGE</code> is set to <code>local</code>.</li> </ul> <p>The OpenVidu Elastic Media Node is installed at <code>/opt/openvidu/</code> and has a systemd service located at <code>/etc/systemd/system/openvidu.service</code>.</p> <p>The directory structure of the Media Node is as follows:</p> <pre><code>|-- /opt/openvidu\n    |-- config/\n    |-- data/\n    |-- deployment-info.yaml\n    |-- docker-compose.yml\n    `-- .env\n</code></pre> <ul> <li><code>config/</code>: Contains the configuration files for the services deployed with the Media Node.</li> <li><code>data/</code>: Contains the data generated by the services deployed with the Media Node.</li> <li><code>deployment-info.yaml</code>: Contains the deployment information of the Media Node.</li> <li><code>docker-compose.yml</code>: Contains the main services deployed for the Media Node.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#services-configuration","title":"Services Configuration","text":"<p>Some services deployed with OpenVidu have their own configuration files located in the <code>/opt/openvidu/config/</code> directory, while others are configured in the <code>.env</code> file. Below are the services and their respective configuration files and parameters:</p> <p>Info</p> <p>The installer provides default configurations that work out of the box. However, you can modify these configurations to suit your specific requirements.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#configuration-files","title":"Configuration Files","text":"Master NodeMedia Node Service Description Configuration File Location Reference documentation Caddy Server Serves OpenVidu services and handles HTTPS. <code>/opt/openvidu/config/caddy.yaml</code> Caddy JSON Structure Loki Service Used for log aggregation. <code>/opt/openvidu/config/loki.yaml</code> Loki Config Promtail Service Collects logs and sends them to Loki. <code>/opt/openvidu/config/promtail.yaml</code> Promtail Config Mimir Service Service for long-term prometheus storage <code>/opt/openvidu/config/mimir.yaml</code> Mimir Config Grafana Service Used for visualizing monitoring data. <code>/opt/openvidu/config/grafana_config/</code> Grafana Config Service Description Configuration File Location Reference documentation OpenVidu Server Manages video rooms. It is compatible with LiveKit configuration and includes its own OpenVidu configuration parameters <code>/opt/openvidu/config/livekit.yaml</code> LiveKit Config Ingress Service Imports video from other sources into OpenVidu rooms. <code>/opt/openvidu/config/ingress.yaml</code> LiveKit Ingress Config Egress Service Exports video from OpenVidu rooms for recording or streaming. <code>/opt/openvidu/config/egress.yaml</code> LiveKit Egress Config Prometheus Service Used for monitoring. <code>/opt/openvidu/config/prometheus.yaml</code> Prometheus Config Promtail Service Collects logs and sends them to Loki. <code>/opt/openvidu/config/promtail.yaml</code> Promtail Config"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#environment-variables","title":"Environment variables","text":"Master NodeMedia Node Service Description Environment Variables Grafana Service Used for visualizing monitoring data. <ul><li> <code>GRAFANA_ADMIN_USERNAME</code>: The username to access the Grafana dashboard.</li><li><code>GRAFANA_ADMIN_PASSWORD</code>: The password to access the Grafana dashboard.</li></ul> OpenVidu Dashboard Used to visualize OpenVidu Server Rooms, Ingress, and Egress services. <ul><li><code>DASHBOARD_ADMIN_USERNAME</code>: The username to access the OpenVidu Dashboard.</li><li><code>DASHBOARD_ADMIN_PASSWORD</code>: The password to access the OpenVidu Dashboard.</li></ul> Default App (OpenVidu Call) Default ready-to-use video conferencing app. <ul><li><code>CALL_PRIVATE_ACCESS</code>: If set to <code>true</code>, the app will be private and require authentication. If set to <code>false</code>, the app will be public and accessible without authentication. The user is configured with <code>CALL_USER</code> and <code>CALL_SECRET</code> parameters.</li><li><code>CALL_USER</code>: The username to access the app. This parameter is only used if <code>CALL_PRIVATE_ACCESS</code> is set to <code>true</code>.</li><li><code>CALL_SECRET</code>: The password to access the app. This parameter is only used if <code>CALL_PRIVATE_ACCESS</code> is set to <code>true</code>.</li><li><code>CALL_ADMIN_USERNAME</code>: The username to access the OpenVidu Call Admin Panel.</li><li><code>CALL_ADMIN_SECRET</code>: The password to access the OpenVidu Call Admin Panel.</li><li><code>LIVEKIT_API_KEY</code>: The API key to access the LiveKit service.</li><li><code>LIVEKIT_API_SECRET</code>: The API secret to access the LiveKit service.</li></ul> Redis Service Used as a shared memory database for OpenVidu and Ingress/Egress services. <ul><li><code>REDIS_PASSWORD</code>: The password for the Redis service.</li></ul> If you need to change the Redis password after the installation, check the advanced configuration section. MinIO Service Used for storing recordings. <ul><li><code>MINIO_ACCESS_KEY</code>: The access key for the MinIO service.</li><li><code>MINIO_SECRET_KEY</code>: The secret key for the MinIO service.</li></ul> If you need to change the MinIO access key and secret key after the installation, check the advanced configuration section. MongoDB Service Used for storing analytics and monitoring data. <ul><li><code>MONGO_ADMIN_USERNAME</code>: The username to access the MongoDB database.</li><li><code>MONGO_ADMIN_PASSWORD</code>: The password to access the MongoDB database.</li></ul> If you need to change the MongoDB username and password after the installation, check the advanced configuration section. OpenVidu v2 compatibility Service Used to enable compatibility with OpenVidu v2. Check the OpenVidu v2 Compatibility Configuration Parameters to see all the available parameters. <p>Warning</p> <p>Ensure that <code>MASTER_NODE_PRIVATE_IP</code> and <code>MEDIA_NODE_PRIVATE_IP</code> are static IP addresses. If these IP addresses change after the installation, you must update the <code>.env</code> file and the configuration files in the Media Node.</p> Service Description Environment Variables OpenVidu Server Manages video rooms. <ul><li><code>MASTER_NODE_PRIVATE_IP</code>: The private IP address of the Master Node. Used to connect to the Master Node services.</li><li><code>MEDIA_NODE_PRIVATE_IP</code>: The private IP address of the Media Node. On startup, the OpenVidu Server will register itself with this IP address so that the Caddy server from the Master Node can route the requests to the Media Node.</li></ul> Ingress Service Imports video from other sources into OpenVidu rooms. <ul><li><code>MASTER_NODE_PRIVATE_IP</code>: The private IP address of the Master Node. Used to connect to the Master Node services.</li></ul> Egress Service Exports video from OpenVidu rooms for recording or streaming. <ul><li><code>MASTER_NODE_PRIVATE_IP</code>: The private IP address of the Master Node. Used to connect to the Master Node services.</li></ul> Prometheus Service Used for monitoring. <ul><li><code>MASTER_NODE_PRIVATE_IP</code>: The private IP address of the Master Node. Used to connect to the Master Node services.</li></ul> Promtail Service Collects logs and sends them to Loki. <ul><li><code>MASTER_NODE_PRIVATE_IP</code>: The private IP address of the Master Node. Used to connect to the Master Node services.</li></ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#openvidu-configuration-parameters","title":"OpenVidu Configuration Parameters","text":"<p>OpenVidu Server is built on top of LiveKit and offers extra configuration options. You can find the configuration file at <code>/opt/openvidu/config/livekit.yaml</code>. Additional parameters for configuring OpenVidu Server are:</p> <pre><code>openvidu:\n    license: &lt;YOUR_OPENVIDU_PRO_LICENSE&gt; # (1)\n    cluster_id: &lt;YOUR_DOMAIN_NAME&gt; # (2)\n    analytics: # (3)\n        enabled: true # (4)\n        interval: 10s # (5)\n        expiration: 768h # (6)\n        mongo_url: &lt;MONGO_URL&gt; # (7)\n    rtc:\n        engine: pion # (8)\n    mediasoup:\n        debug: \"\" # (9)\n        log_level: error # (10)\n        log_tags: [info, ice, rtp, rtcp, message] # (11)\n</code></pre> <ol> <li>Specify your OpenVidu Pro license key. If you don't have one, you can request one here.</li> <li>The cluster ID for the OpenVidu deployment. It is configured by default by OpenVidu Installer with the domain name of the deployment.</li> <li>The <code>analytics</code> configuration should be defined at the <code>openvidu</code> level in the <code>livekit.yaml</code> file.</li> <li>This must be set to <code>true</code> to send analytics data to MongoDB. If set to <code>false</code>, no analytics data will be sent.</li> <li>Time interval to send analytics data to MongoDB.</li> <li>Time to keep the analytics data in MongoDB. In this example, it is set to 32 days.</li> <li>MongoDB URL. This is the connection string to the MongoDB database where the analytics data will be stored.</li> <li>The <code>rtc.engine</code> parameter is set to <code>pion</code> by default. This is the WebRTC engine used by OpenVidu. Depending on your requirements, you can use:<ul> <li><code>pion</code></li> <li><code>mediasoup</code></li> </ul> </li> <li>Global toggle to enable debugging logs from MediaSoup. In most debugging cases, using just an asterisk (\"*\") here is enough, but this can be fine-tuned for specific log levels. More info.<ul> <li>Default is an empty string.</li> </ul> </li> <li>Logging level for logs generated by MediaSoup. More info.<ul> <li>Valid values are: <code>debug</code>, <code>warn</code>, <code>error</code>, <code>none</code>.</li> <li>Default is <code>error</code>.</li> </ul> </li> <li>Comma-separated list of log tag names, for debugging. More info.<ul> <li>Valid values are: <code>info</code>, <code>ice</code>, <code>dtls</code>, <code>rtp</code>, <code>srtp</code>, <code>rtcp</code>, <code>rtx</code>, <code>bwe</code>, <code>score</code>, <code>simulcast</code>, <code>svc</code>, <code>sctp</code>, <code>message</code>.</li> <li>Default is <code>[info, ice, rtp, rtcp, message]</code>.</li> </ul> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#openvidu-v2-compatibility-configuration-parameters","title":"OpenVidu v2 Compatibility Configuration Parameters","text":"<p>If you are using in <code>COMPOSE_PROFILES</code> at the <code>.env</code> file the <code>v2compatibility</code> profile, you will need to set the following parameters in the <code>.env</code> file for the OpenVidu V2 Compatibility service:</p> Parameter Description Default Value <code>V2COMPAT_OPENVIDU_SECRET</code> OpenVidu secret used to authenticate the OpenVidu V2 Compatibility service. In the <code>.env</code> file, this value is defined with <code>LIVEKIT_API_SECRET</code>. The value of <code>LIVEKIT_API_SECRET</code> in the <code>.env</code> file. <code>V2COMPAT_OPENVIDU_WEBHOOK</code> <code>true</code> to enable OpenVidu Webhook service. <code>false</code> otherwise. Valid values are <code>true</code> or <code>false</code>. <code>false</code> <code>V2COMPAT_OPENVIDU_WEBHOOK_ENDPOINT</code> HTTP(S) endpoint to send OpenVidu V2 Webhook events. Must be a valid URL. Example:  <code>V2COMPAT_OPENVIDU_WEBHOOK_ENDPOINT=http://myserver.com/webhook</code> - <code>V2COMPAT_OPENVIDU_WEBHOOK_HEADERS</code> JSON Array list of headers to send in the OpenVidu V2 Webhook events. Example:  <code>V2COMPAT_OPENVIDU_WEBHOOK_HEADERS=[\"Content-Type: application/json\"]</code> <code>[]</code> <code>V2COMPAT_OPENVIDU_WEBHOOK_EVENTS</code> Comma-separated list of OpenVidu V2 Webhook events to send. Example:  <code>V2COMPAT_OPENVIDU_WEBHOOK_EVENTS=sessionCreated,sessionDestroyed</code> <code>sessionCreated</code>, <code>sessionDestroyed,</code> <code>participantJoined,</code> <code>participantLeft,</code> <code>webrtcConnectionCreated,</code> <code>webrtcConnectionDestroyed,</code> <code>recordingStatusChanged,</code> <code>signalSent</code> (All available events) <code>V2COMPAT_OPENVIDU_PRO_AWS_S3_BUCKET</code> S3 Bucket where to store recording files. <code>openvidu</code> <code>V2COMPAT_OPENVIDU_PRO_AWS_S3_SERVICE_ENDPOINT</code> S3 Endpoint where to store recording files. <code>http://localhost:9100</code> <code>V2COMPAT_OPENVIDU_PRO_AWS_ACCESS_KEY</code> S3 Access Key of the S3 Bucket where to store recording files. - <code>V2COMPAT_OPENVIDU_PRO_AWS_SECRET_KEY</code> S3 Secret Key of the S3 Bucket where to store recording files. - <code>V2COMPAT_OPENVIDU_PRO_AWS_REGION</code> S3 Region of the S3 Bucket where to store recording files. <code>us-east-1</code> <p>| <code>V2COMPAT_OPENVIDU_RECORDING_PATH</code> | OpenVidu Recording directory used to save the OpenVidu recording videos when <code>V2COMPAT_OPENVIDU_PRO_RECORDING_STORAGE</code> is set to <code>true</code>. Change it with the folder you want to use from your host. By default, it is bound in the container to <code>/opt/openvidu/recordings</code> | <code>/opt/openvidu/recordings</code> | | <code>V2COMPAT_OPENVIDU_PRO_RECORDING_STORAGE</code> | Where to store recording files. Can be 'local' (local storage) or 's3' (S3 compatible storage). | <code>local</code> |</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#starting-stopping-and-restarting-openvidu","title":"Starting, stopping, and restarting OpenVidu","text":"<p>For every OpenVidu node, a systemd service is created during the installation process. This service allows you to start, stop, and restart the OpenVidu services easily.</p> <p>Start OpenVidu</p> <pre><code>sudo systemctl start openvidu\n</code></pre> <p>Stop OpenVidu</p> <pre><code>sudo systemctl stop openvidu\n</code></pre> <p>Restart OpenVidu</p> <pre><code>sudo systemctl restart openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#checking-the-status-of-services","title":"Checking the status of services","text":"<p>You can check the status of the OpenVidu services using the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose ps\n</code></pre> <p>Depending on the node type, you will see different services running.</p> Master NodeMedia Node <p>The services are operating correctly if you see an output similar to the following and there are no restarts from any of the services:</p> <pre><code>NAME                       IMAGE                                              COMMAND                  SERVICE                    CREATED          STATUS\napp                        docker.io/openvidu/openvidu-call                   \"docker-entrypoint.s\u2026\"   app                        12 seconds ago   Up 10 seconds\ncaddy                      docker.io/openvidu/openvidu-pro-caddy              \"/bin/caddy run --co\u2026\"   caddy                      12 seconds ago   Up 10 seconds\ndashboard                  docker.io/openvidu/openvidu-pro-dashboard          \"./openvidu-dashboard\"   dashboard                  12 seconds ago   Up 10 seconds\ngrafana                    docker.io/grafana/grafana                          \"/run.sh\"                grafana                    11 seconds ago   Up 8 seconds\nloki                       docker.io/grafana/loki                             \"/usr/bin/loki -conf\u2026\"   loki                       11 seconds ago   Up 9 seconds\nmimir                      docker.io/grafana/mimir                            \"/bin/mimir -config.\u2026\"   mimir                      11 seconds ago   Up 9 seconds\nminio                      docker.io/bitnami/minio                            \"/opt/bitnami/script\u2026\"   minio                      11 seconds ago   Up 9 seconds\nmongo                      docker.io/mongo                                    \"docker-entrypoint.s\u2026\"   mongo                      11 seconds ago   Up 9 seconds\nopenvidu-v2compatibility   docker.io/openvidu/openvidu-v2compatibility        \"/bin/server\"            openvidu-v2compatibility   12 seconds ago   Up 10 seconds\noperator                   docker.io/openvidu/openvidu-operator               \"/bin/operator\"          operator                   12 seconds ago   Up 10 seconds\npromtail                   docker.io/grafana/promtail                         \"/usr/bin/promtail -\u2026\"   promtail                   11 seconds ago   Up 9 seconds\nredis                      docker.io/redis                                    \"docker-entrypoint.s\u2026\"   redis                      12 seconds ago   Up 10 seconds\n</code></pre> <p>The services are operating correctly if you see an output similar to the following and there are no restarts from any of the services:</p> <pre><code>NAME         IMAGE                                          COMMAND                  SERVICE      CREATED          STATUS\negress       docker.io/livekit/egress                       \"/entrypoint.sh\"         egress       53 seconds ago   Up 51 seconds\ningress      docker.io/livekit/ingress                      \"ingress\"                ingress      53 seconds ago   Up 52 seconds\nopenvidu     docker.io/openvidu/openvidu-server-pro         \"/livekit-server --c\u2026\"   openvidu     53 seconds ago   Up 52 seconds\nprometheus   docker.io/prom/prometheus                      \"/bin/prometheus --c\u2026\"   prometheus   53 seconds ago   Up 51 seconds\npromtail     docker.io/grafana/promtail                     \"/usr/bin/promtail -\u2026\"   promtail     53 seconds ago   Up 52 seconds\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#checking-logs","title":"Checking logs","text":"<p>If any of the services are not working as expected, you can check the logs of the services using the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs &lt;service-name&gt;\n</code></pre> <p>Replace <code>&lt;service-name&gt;</code> with the name of the service you want to check. For example, to check the logs of the OpenVidu Server, use the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs openvidu\n</code></pre> <p>To check the logs of all services, use the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs\n</code></pre> <p>You can also review your logs using the Grafana dashboard provided with OpenVidu. To access it, go to https://&lt;your-domain.com&gt;/grafana and use the credentials located in <code>/opt/openvidu/.env</code> to log in. Once inside, navigate to the \"Home\" section, select \"Dashboard\", and then click on:</p> <ul> <li>\"OpenVidu &gt; OpenVidu Cluster Nodes Logs\": To check the logs of the OpenVidu services organized per node.</li> <li>\"OpenVidu &gt; OpenVidu Cluster Services Logs\": To check the logs of the OpenVidu services organized per service.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#adding-media-nodes","title":"Adding Media Nodes","text":"<p>To add a new Media Node, simply spin up a new VM and run the OpenVidu installer script to integrate it into the existing cluster. Run the installation command on the new Media Node.</p> <p>Warning</p> <p>This installation command should be the same as the one you used to install the first Media Node. Make sure to use the same parameters and values as the first Media Node. In case you've changed the <code>.env</code> file in the Master Node, you will need to update the <code>.env</code> file or update the installation command with the new values.</p> <p>To automate the configuration of new nodes, check this section.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#removing-media-nodes-gracefully","title":"Removing Media Nodes Gracefully","text":"<p>To stop a Media Node gracefully, you need to stop the containers <code>openvidu</code>, <code>ingress</code>, and <code>egress</code> with a <code>SIGINT</code> signal. Here is a simple script that you can use to stop all these containers gracefully:</p> <pre><code>#!/bin/bash\n# Stop OpenVidu, Ingress, and Egress containers gracefully (1)\ndocker container kill --signal=SIGINT openvidu || true\ndocker container kill --signal=SIGINT ingress || true\ndocker container kill --signal=SIGINT egress || true\n\n# Wait for the containers to stop (2)\nwhile [ $(docker inspect -f '{{.State.Running}}' openvidu 2&gt;/dev/null) == \"true\" ] || \\\n    [ $(docker inspect -f '{{.State.Running}}' ingress 2&gt;/dev/null) == \"true\" ] || \\\n    [ $(docker inspect -f '{{.State.Running}}' egress 2&gt;/dev/null) == \"true\" ]; do\n    echo \"Waiting for containers to stop...\"\n    sleep 5\ndone\n</code></pre> <ol> <li>This script stops the OpenVidu, Ingress, and Egress containers gracefully. The <code>true</code> at the end of each command is to avoid the script from stopping if the container is not running.</li> <li>This script waits for the containers to stop before exiting.</li> </ol> <p>When all the containers are stopped, you can then stop the systemd service and remove the VM:</p> <pre><code>sudo systemctl stop openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#removing-media-nodes-forcefully","title":"Removing Media Nodes Forcefully","text":"<p>To remove a Media Node forcefully, without considering the rooms, ingress, and egress processes running in the node, you can simply stop the OpenVidu service in the Media Node and delete the VM.</p> <pre><code>sudo systemctl stop openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#advanced-configuration","title":"Advanced Configuration","text":"<p>This section addresses advanced configuration scenarios for customizing your OpenVidu Elastic deployment. It includes automating the installation with personalized settings, enabling or disabling OpenVidu modules, and modifying global parameters such as the domain name, passwords, and API keys.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#automatic-installation-and-configuration-of-nodes","title":"Automatic installation and configuration of nodes","text":"<p>For environments like the cloud, where instances are frequently spun up and down, automating the application of custom configurations to Master Node and Media Nodes may be useful for you.</p> Master NodeMedia Node <p>If you need to apply custom configurations to the Master Node, you can use the following script template:</p> <pre><code># 1. First install the Master Node (1)\nsh &lt;(curl -fsSL http://get.openvidu.io/pro/elastic/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    ... # Add the rest of the arguments (2)\n\n# 2. Add custom configurations (3)\n######### APPLY CUSTOM CONFIGURATIONS #########\n# If you want to apply any modification to the configuration files\n# of the OpenVidu services at /opt/openvidu, you can do it in this section.\n\n# Example 1: Change Minio public port\nyq eval '.apps.http.servers.minio.listen[0] = \":9001\"' \\\n    -i /opt/openvidu/config/caddy.yaml\n\n# Example 2: Disable the /dashboard route in Caddy\nyq eval 'del(.apps.http.servers.public.routes[] | \\\n    select(.handle[]?.handler == \"subroute\" and \\\n    .handle[].routes[].handle[].strip_path_prefix == \"/dashboard\"))' \\\n    -i /opt/openvidu/config/caddy.yaml\n\n######### END CUSTOM CONFIGURATIONS #########\n\n# 3. Start OpenVidu (4)\nsystemctl start openvidu\n</code></pre> <ol> <li>First, install the Master Node using the OpenVidu installer. Check the installation guide for more information.</li> <li>Add the parameters you need to install the Master Node. You can find all the available parameters in the installation guide.</li> <li>Add the custom configurations you need to apply to the Master Node services. You can use <code>yq</code> or other tools to modify the configuration files. You can find more information about <code>yq</code> here.</li> <li>Start the Master Node.</li> </ol> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Just install the Master Node first with the installer and then run some extra commands to apply the custom configurations. This way, you can automate the process of installing the Master Node and applying custom configurations.</p> <p>If you need to apply custom configurations to the Media Node, you can use the following script template:</p> <pre><code># 1. First install the Media Node (1)\nsh &lt;(curl -fsSL http://get.openvidu.io/pro/elastic/latest/install_ov_media_node.sh) \\\n    --node-role='media-node' \\\n    ... # Add the rest of the arguments (2)\n\n# 2. Add custom configurations (3)\n######### APPLY CUSTOM CONFIGURATIONS #########\n# If you want to apply any modification to the configuration files\n# of the OpenVidu services at /opt/openvidu, you can do it in this section.\n\n# Example 1: Change the public IP address announced by OpenVidu for WebRTC connections\nyq eval '.rtc.node_ip = 1.2.3.4' \\\n    -i /opt/openvidu/config/livekit.yaml\n\n# Example 2: Add a webhook to LiveKit\nyq eval '.webhook.urls += [\"http://new-endpoint.example.com/webhook\"]' \\\n    -i /opt/openvidu/config/livekit.yaml\n\n######### END CUSTOM CONFIGURATIONS #########\n\n# 3. Start OpenVidu (4)\nsystemctl start openvidu\n</code></pre> <ol> <li>First, install the Media Node using the OpenVidu installer. Check the installation guide for more information.</li> <li>Add the parameters you need to install the Media Node. You can find all the available parameters in the installation guide.</li> <li>Add the custom configurations you need to apply to the Media Node services. You can use <code>yq</code> or other tools to modify the configuration files. You can find more information about <code>yq</code> here.</li> <li>Start the Media Node.</li> </ol> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Just install the Media Node first with the installer and then run some extra commands to apply the custom configurations. This way, you can automate the process of installing the Media Node and applying custom configurations.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#enabling-and-disabling-openvidu-modules","title":"Enabling and Disabling OpenVidu Modules","text":"<p>The <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file in Master and Media Nodes allows you to enable or disable specific modules in OpenVidu. The following modules can be enabled or disabled:</p> Observability moduleV2 Compatibility module (Default App)App module <p>In case you have installed OpenVidu with the <code>observability</code> module, you just need to enable the <code>observability</code> module in the <code>.env</code> file in all nodes.</p> <p>Otherwise, you can follow these steps to enable the <code>observability</code> module:</p> <ol> <li> <p>Stop the Master Node, all Media Nodes, and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>In the Master Node, update the <code>.env</code> with the following changes:</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>observability</code> module. Also, make sure to set up the <code>GRAFANA_ADMIN_USERNAME</code> and <code>GRAFANA_ADMIN_PASSWORD</code> parameters.</p> <p>If you have only the observability module enabled, your <code>.env</code> file should have the following environment variables:</p> <pre><code>GRAFANA_ADMIN_USERNAME=\"&lt;GRAFANA_ADMIN_USERNAME&gt;\"\nGRAFANA_ADMIN_PASSWORD=\"&lt;GRAFANA_ADMIN_PASSWORD&gt;\"\n\nCOMPOSE_PROFILES=\"observability\"\n</code></pre> </li> <li> <p>In the Media Nodes, enable the <code>observability</code> module:</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>observability</code> module in the <code>.env</code> file. If you have only the <code>observability</code> module enabled, your <code>.env</code> file should have the following environment variable:</p> <pre><code>COMPOSE_PROFILES=\"observability\"\n</code></pre> <p>Then, add the following parameter in the <code>config/livekit.yaml</code> file:</p> <pre><code>prometheus_port: 6789\n</code></pre> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Disabling the <code>observability</code> module</p> <p>If you have the <code>observability</code> module enabled and you want to disable it, just remove the <code>observability</code> module from the <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file of all nodes.</p> <p>In case you have installed OpenVidu with the <code>app</code> module, you just need to enable the <code>app</code> module in the <code>.env</code> file in all nodes.</p> <p>Otherwise, you can follow these steps to enable the <code>app</code> module:</p> <ol> <li> <p>Stop the Master Node, all Media Nodes, and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>In the Master Node, update the <code>.env</code> with the following changes:</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>v2compatibility</code> module.</p> <p>If you have only the <code>v2compatibility</code> module enabled, your <code>.env</code> file should have the following environment variable:</p> <pre><code>COMPOSE_PROFILES=\"v2compatibility\"\n</code></pre> </li> <li> <p>In the Media Nodes, update the LiveKit configuration to send webhooks to the V2 Compatibility service</p> <p>Just add the following parameter in the <code>config/livekit.yaml</code> file:</p> <pre><code>webhook:\n    api_key: \"&lt;LIVEKIT_API_KEY&gt;\"\n    urls:\n        - http://master-node:4443/livekit/webhook\n</code></pre> <p>Where <code>&lt;LIVEKIT_API_KEY&gt;</code> is the <code>LIVEKIT_API_KEY</code> parameter in the <code>.env</code> file.</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Disabling the <code>app</code> module</p> <p>If you have the <code>app</code> module enabled and you want to disable it, just remove the <code>app</code> module from the <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file of all nodes.</p> <p>In case you have installed OpenVidu without the <code>app</code> module, you just need to enable the <code>app</code> module in the <code>.env</code> file in all nodes.</p> <p>Otherwise, you can follow these steps to enable the <code>app</code> module:</p> <ol> <li> <p>Stop the Master Node, all Media Nodes, and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>In the Master Node, update the <code>.env</code> with the following changes:</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>app</code> module.</p> <p>If you have only the <code>app</code> module enabled, your <code>.env</code> file should have the following environment variable:</p> <pre><code>COMPOSE_PROFILES=\"app\"\n</code></pre> </li> <li> <p>In the Media Nodes, update the LiveKit configuration to send webhooks to the Default App</p> <p>Just add the following parameter in the <code>config/livekit.yaml</code> file:</p> <pre><code>webhook:\n    api_key: \"&lt;LIVEKIT_API_KEY&gt;\"\n    urls:\n        - http://master-node:6080/api/webhook\n</code></pre> <p>Where <code>&lt;LIVEKIT_API_KEY&gt;</code> is the <code>LIVEKIT_API_KEY</code> parameter in the <code>.env</code> file.</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Disabling the <code>app</code> module</p> <p>If you have the <code>app</code> module enabled and you want to disable it, just remove the <code>app</code> module from the <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file of all nodes.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#global-configuration-changes","title":"Global configuration changes","text":"<p>Some configuration parameters may require modifying multiple configuration files. Below are some examples of advanced configurations and how to apply them:</p> <p>Info</p> <p>Usually, this is not needed because the installer takes care of generating all of this parameters. However, it is necessary if any password, credential, or domain change is needed.</p> <p>Danger</p> <p>Advanced configurations should be performed with caution. Incorrect configurations can lead to service failures or unexpected behavior.</p> <p>Before making any changes, make sure to back up your installation by creating a snapshot of your server or by copying the <code>/opt/openvidu/</code> directory to a safe location. For example:</p> <pre><code>sudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> Changing <code>DOMAIN_OR_PUBLIC_IP</code>Changing <code>REDIS_PASSWORD</code>Changing <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>Changing <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code>Changing <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> <p>To change all occurrences of the domain or public IP address in the configuration files, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in the Master Node and all Media Nodes and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Find the current locations of <code>DOMAIN_OR_PUBLIC_IP</code> in your Master Node</p> <p>With the following commands, you can find all occurrences of the current domain or public IP address in the configuration files:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_DOMAIN_OR_PUBLIC_IP=\"$(grep '^DOMAIN_OR_PUBLIC_IP' /opt/openvidu/.env | cut -d '=' -f 2)\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> <p>Warning</p> <p>Keep the value of <code>CURRENT_DOMAIN_OR_PUBLIC_IP</code> as you will need it to update the configuration files in the Media Nodes.</p> Example output <p>The output should look similar to the following:</p> <pre><code>./.env:DOMAIN_OR_PUBLIC_IP=&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:        - certificate: /owncert/&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;.cert\n./config/caddy.yaml:          key: /owncert/&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;.key\n./config/caddy.yaml:            - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                    - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                        - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                    - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                        - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                  - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/promtail.yaml:          cluster_id: &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n</code></pre> <p>Note</p> <p>Don't worry if some values are different in your output. It varies depending on the parameters you've used to install OpenVidu.</p> </li> <li> <p>Update the Following Files in your Master Node</p> <p>Based on the output from the previous step, update the following files with the new domain or public IP address:</p> <ul> <li><code>.env</code></li> <li><code>config/caddy.yaml</code></li> <li><code>config/promtail.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Master Node</p> <p>These commands will list all occurrences of the new <code>DOMAIN_OR_PUBLIC_IP</code> in the configuration files. The output should match the locations found in the initial search but with the new domain or public IP address.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_DOMAIN_OR_PUBLIC_IP=\"&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> </li> <li> <p>Find the current locations of <code>CURRENT_DOMAIN_OR_PUBLIC_IP</code> in your Media Nodes</p> <p>With the <code>CURRENT_DOMAIN_OR_PUBLIC_IP</code> value obtained in step 2, you can find all occurrences of the current domain or public IP address in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_DOMAIN_OR_PUBLIC_IP=\"&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> Example output <p>The output should look similar to the following:</p> <pre><code>./config/promtail.yaml:          cluster_id: &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/livekit.yaml:    cluster_id: &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/livekit.yaml:    rtmp_base_url: rtmps://&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;:1935/rtmp\n./config/livekit.yaml:    whip_base_url: https://&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;/whip\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new domain or public IP address:</p> <ul> <li><code>config/promtail.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>DOMAIN_OR_PUBLIC_IP</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new domain or public IP address.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_DOMAIN_OR_PUBLIC_IP=\"&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 5 to 7 for all your Media Nodes</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Some notes on changing the <code>DOMAIN_OR_PUBLIC_IP</code> parameter:</p> <ul> <li>If you are using your own certificates, you need to place the new ones at <code>/opt/openvidu/owncert/&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;.cert</code> and <code>/opt/openvidu/owncert/&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;.key</code>.</li> <li>Make sure your new domain is pointing correctly to the machine where OpenVidu is installed.</li> </ul> <p>To change the <code>REDIS_PASSWORD</code> parameter, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in the Master Node and all Media Nodes and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Replace at the Master Node the <code>REDIS_PASSWORD</code> in the <code>.env</code> file with your new value</p> <p>Warning</p> <p>Keep the previous value of <code>REDIS_PASSWORD</code> as you will need it to update the configuration files in the Media Nodes. We will refer to this value as <code>&lt;CURRENT_REDIS_PASSWORD&gt;</code>.</p> </li> <li> <p>Find the current locations of <code>REDIS_PASSWORD</code> in your Media Nodes</p> <p>With the <code>CURRENT_REDIS_PASSWORD</code> value obtained in step 2, you can find all occurrences of the current Redis password in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_REDIS_PASSWORD=\"&lt;CURRENT_REDIS_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_REDIS_PASSWORD\" .\n</code></pre> Example output <p>The output should look similar to the following:</p> <pre><code>./config/egress.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n./config/ingress.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n./config/livekit.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new Redis password:</p> <ul> <li><code>config/egress.yaml</code></li> <li><code>config/ingress.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>REDIS_PASSWORD</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new Redis password.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_REDIS_PASSWORD=\"&lt;NEW_REDIS_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_REDIS_PASSWORD\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 3 to 5 for all your Media Nodes</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in the Master Node and all Media Nodes and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Replace at the Master Node the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in the <code>.env</code> file with your new values</p> <p>Warning</p> <p>Keep the previous values of <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> as you will need them to update the configuration files in the Media Nodes. We will refer to these values as <code>&lt;CURRENT_LIVEKIT_API_KEY&gt;</code> and <code>&lt;CURRENT_LIVEKIT_API_SECRET&gt;</code>.</p> </li> <li> <p>Find the current locations of <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in your Media Nodes</p> <p>With the <code>CURRENT_LIVEKIT_API_KEY</code> and <code>CURRENT_LIVEKIT_API_SECRET</code> values obtained in step 2, you can find all occurrences of the current LiveKit API key and secret in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_LIVEKIT_API_KEY=\"&lt;CURRENT_LIVEKIT_API_KEY&gt;\"\nCURRENT_LIVEKIT_API_SECRET=\"&lt;CURRENT_LIVEKIT_API_SECRET&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_LIVEKIT_API_KEY\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_LIVEKIT_API_SECRET\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>LIVEKIT_API_KEY</code>:</p> <pre><code>./config/egress.yaml:api_key: &lt;CURRENT_LIVEKIT_API_KEY&gt;\n./config/ingress.yaml:api_key: &lt;CURRENT_LIVEKIT_API_KEY&gt;\n./config/livekit.yaml:    &lt;CURRENT_LIVEKIT_API_KEY&gt;: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/livekit.yaml:    api_key: &lt;CURRENT_LIVEKIT_API_KEY&gt;\n</code></pre> <p>And for <code>LIVEKIT_API_SECRET</code>:</p> <pre><code>./config/egress.yaml:8:api_secret: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/ingress.yaml:8:api_secret: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/livekit.yaml:48:    &lt;CURRENT_LIVEKIT_API_KEY&gt;: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>config/egress.yaml</code></li> <li><code>config/ingress.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_LIVEKIT_API_KEY=\"&lt;NEW_LIVEKIT_API_KEY&gt;\"\nNEW_LIVEKIT_API_SECRET=\"&lt;NEW_LIVEKIT_API_SECRET&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_LIVEKIT_API_KEY\" .\ngrep --exclude-dir=data -IHnr \"$NEW_LIVEKIT_API_SECRET\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 3 to 5 for all your Media Nodes</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in the Master Node and all Media Nodes and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Replace at the Master Node the <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> in the <code>.env</code> file with your new values</p> <p>Take into account that if you are using the <code>v2compatibility</code> module in <code>COMPOSE_PROFILES</code>, you will need to change the <code>V2COMPAT_OPENVIDU_PRO_AWS_ACCESS_KEY</code> and <code>V2COMPAT_OPENVIDU_PRO_AWS_SECRET_KEY</code> parameters in the <code>.env</code> file.</p> <p>Warning</p> <p>Keep the previous values of <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> as you will need them to update the configuration files in the Media Nodes. We will refer to these values as <code>&lt;CURRENT_MINIO_ACCESS_KEY&gt;</code> and <code>&lt;CURRENT_MINIO_SECRET_KEY&gt;</code>.</p> </li> <li> <p>Find the current locations of <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> in your Media Nodes</p> <p>With the <code>CURRENT_MINIO_ACCESS_KEY</code> and <code>CURRENT_MINIO_SECRET_KEY</code> values obtained in step 2, you can find all occurrences of the current MinIO access key and secret in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_MINIO_ACCESS_KEY=\"&lt;CURRENT_MINIO_ACCESS_KEY&gt;\"\nCURRENT_MINIO_SECRET_KEY=\"&lt;CURRENT_MINIO_SECRET_KEY&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_MINIO_ACCESS_KEY\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_MINIO_SECRET_KEY\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>MINIO_ACCESS_KEY</code>:</p> <pre><code>./config/egress.yaml:    access_key: &lt;CURRENT_MINIO_ACCESS_KEY&gt;\n</code></pre> <p>And for <code>MINIO_SECRET_KEY</code>:</p> <pre><code>./config/egress.yaml:    secret: &lt;CURRENT_MINIO_SECRET_KEY&gt;\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>config/egress.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_MINIO_ACCESS_KEY=\"&lt;NEW_MINIO_ACCESS_KEY&gt;\"\nNEW_MINIO_SECRET_KEY=\"&lt;NEW_MINIO_SECRET_KEY&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_MINIO_ACCESS_KEY\" .\ngrep --exclude-dir=data -IHnr \"$NEW_MINIO_SECRET_KEY\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 3 to 5 for all your Media Nodes</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in the Master Node and all Media Nodes and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Replace at the Master Node the <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in the <code>.env</code> file with your new values</p> <p>Warning</p> <p>Keep the previous values of <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> as you will need them to update the configuration files in the Media Nodes. We will refer to these values as <code>&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;</code> and <code>&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;</code>.</p> </li> <li> <p>Find the current locations of <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in your Media Nodes</p> <p>With the <code>CURRENT_MONGO_ADMIN_USERNAME</code> and <code>CURRENT_MONGO_ADMIN_PASSWORD</code> values obtained in step 2, you can find all occurrences of the current MongoDB admin username and password in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_MONGO_ADMIN_USERNAME=\"&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;\"\nCURRENT_MONGO_ADMIN_PASSWORD=\"&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_MONGO_ADMIN_USERNAME\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_MONGO_ADMIN_PASSWORD\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>MONGO_ADMIN_USERNAME</code>:</p> <pre><code>./config/livekit.yaml:        mongo_url: mongodb://&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;:&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;@master-node:20000\n</code></pre> <p>And for <code>MONGO_ADMIN_PASSWORD</code>:</p> <pre><code>./config/livekit.yaml:        mongo_url: mongodb://&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;:&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;@master-node:20000\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_MONGO_ADMIN_USERNAME=\"&lt;NEW_MONGO_ADMIN_USERNAME&gt;\"\nNEW_MONGO_ADMIN_PASSWORD=\"&lt;NEW_MONGO_ADMIN_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_MONGO_ADMIN_USERNAME\" .\ngrep --exclude-dir=data -IHnr \"$NEW_MONGO_ADMIN_PASSWORD\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 3 to 5 for all your Media Nodes</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/admin/#uninstalling-openvidu","title":"Uninstalling OpenVidu","text":"<p>To uninstall any OpenVidu Node, just execute the following commands:</p> <pre><code>sudo su\nsystemctl stop openvidu\nrm -rf /opt/openvidu/\nrm /etc/systemd/system/openvidu.service\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/install/","title":"OpenVidu Elastic Installation: On-premises","text":"<p>Info</p> <p>OpenVidu Elastic is part of OpenVidu PRO. Before deploying, you need to create an OpenVidu account to get your license key. There's a 15-day free trial waiting for you!</p> <p>This section contains the instructions to deploy a production-ready OpenVidu Elastic deployment on-premises. The deployment requires one Master Node and any number of Media Nodes. Media Nodes are elastic and can be scaled up and down according to the workload.</p> Architecture overview <p>This is how the architecture of the deployment looks like:</p> <p> OpenVidu Elastic On Premises </p> <ul> <li>The Master Node acts as a Load Balancer, managing the traffic and distributing it among the Media Nodes and deployed services in the Master Node.</li> <li>The Master Node has its own Caddy server acting as a Layer 4 (For TURN with TLS and RTMPS) and Layer 7 (For OpenVidu Dashboard, OpenVidu Call, etc., APIs) reverse proxy.</li> <li>WebRTC traffic (SRTP/SCTP/STUN/TURN) is routed directly to the Media Nodes.</li> </ul> <p>For the Master Node, the following services are configured:</p> <ul> <li>OpenVidu Dashboard, a web application interface to visualize your Rooms, Ingress, and Egress services.</li> <li>MinIO as an S3 storage service for recordings.</li> <li>Redis as a shared database for OpenVidu Server PRO and Ingress/Egress services.</li> <li>MongoDB as a database for storing analytics and monitoring data.</li> <li>Caddy as a reverse proxy. It can be deployed with self-signed certificates, Let's Encrypt certificates, or custom certificates. Provides optional TLS for the TURN server.</li> <li>OpenVidu V2 Compatibility (v2compatibility module) is an optional service that provides an API designed to maintain compatibility for applications developed with OpenVidu version 2.</li> <li>OpenVidu Call (Default Application module), an optional ready-to-use videoconferencing application.</li> <li>Grafana, Mimir, Promtail, and Loki (Observability module) form an optional observability stack for monitoring, allowing you to keep track of logs and deployment statistics for OpenVidu.</li> </ul> <p>For the Media Nodes, the following services are configured:</p> <ul> <li>OpenVidu Server PRO (LiveKit compatible).</li> <li>Ingress and Egress services.</li> <li>Prometheus and Loki (Observability module). Used to send metrics and logs to the observability stack.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/install/#prerequisites","title":"Prerequisites","text":"<ul> <li>At least 2 machines, each with a minimum of 4GB RAM, 4 CPU cores, and Linux installed (Ubuntu is recommended). One machine will serve as the Master Node, while the others will function as Media Nodes.</li> <li>Significant disk space on the Master Node, with 100GB recommended, especially if you plan to record your sessions (Egress). Media Nodes require less space; however, account for the space needed for ongoing recordings on these nodes.</li> <li>Each machine must be assigned a Public IP. Additionally, the machine designated as the Master Node must have a Fully Qualified Domain Name (FQDN) that resolves to its Public IP.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/install/#port-rules-master-node","title":"Port rules (Master Node)","text":"<p>Ensure all these rules are configured in your firewall, security group, or any kind of network configuration that you have in your Master Node.</p> <p>Inbound port rules:</p> Protocol Ports Source Description TCP 80 0.0.0.0/0, ::/0 Redirect HTTP traffic to HTTPS and Let's Encrypt validation. TCP 443 0.0.0.0/0, ::/0 Allows access to the following: <ul><li>Livekit API.</li><li>OpenVidu v2 Compatibility API</li><li>OpenVidu Dashboard.</li><li>OpenVidu Call (Default Application).</li><li>WHIP API.</li><li>TURN with TLS.</li><li>Custom layouts</li></ul> TCP 1935 0.0.0.0/0, ::/0 (Optional), only needed if you want to ingest RTMP streams using Ingress service. TCP 9000 0.0.0.0/0, ::/0 (Optional), only needed if you want to expose MinIO publicly. TCP 4443 Media Nodes (Optional. Only needed when 'OpenVidu v2 Compatibility' module is used) Media Nodes need access to this port to reach OpenVidu V2 compatibility service TCP 6080 Media Nodes (Optional. Only needed when 'Default App' module is used) Media Nodes need access to this port to reach OpenVidu Call (Default Application). TCP 3100 Media Nodes (Optional. Only needed when 'Observability' module is used) Media Nodes need access to this port to reach Loki. TCP 9009 Media Nodes (Optional. Only needed when 'Observability' module is used) Media Nodes need access to this port to reach Mimir. TCP 7000 Media Nodes Media Nodes need access to this port to reach Redis Service. TCP 9100 Media Nodes Media Nodes need access to this port to reach MinIO. TCP 20000 Media Nodes Media Nodes need access to this port to reach MongoDB. <p>Outbound port rules:</p> <p>Typically, all outbound traffic is allowed.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/install/#port-rules-media-nodes","title":"Port rules (Media Nodes)","text":"<p>Ensure all these rules are configured in your firewall, security group, or any kind of network configuration that you have in your Media Nodes:</p> <p>Inbound port rules:</p> Protocol Ports Source Description UDP 443 0.0.0.0/0, ::/0 STUN/TURN over UDP. TCP 7881 0.0.0.0/0, ::/0 (Optional). Only needed if you want to allow WebRTC over TCP. UDP 7885 0.0.0.0/0, ::/0 (Optional). Only needed if you want to ingest WebRTC using WHIP. UDP 50000-60000 0.0.0.0/0, ::/0 WebRTC Media traffic. TCP 1935 Master Node (Optional). Only needed if you want to ingest RTMP streams using Ingress service. Master Node needs access to this port to reach Ingress RTMP service and expose it using TLS (RTMPS). TCP 5349 Master Node (Optional). Only needed if you want to expose TURN service with TLS. Master Node needs access to this port to reach TURN service and expose it using TLS (TURNS). TCP 7880 Master Node LiveKit API. Master Node needs access to load balance LiveKit API and expose it through HTTPS. TCP 8080 Master Node (Optional). Only needed if you want to ingest WebRTC streams using WHIP. Master Node needs access to this port to reach WHIP HTTP service."},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/install/#guided-installation","title":"Guided Installation","text":"<p>Before the installation, ensure that all your machines meet the prerequisites and the port rules for the Master Node and Media Nodes are correctly configured.</p> <p>To install OpenVidu Elastic, begin by generating the commands required for setting up all nodes in the cluster. This is a simple and straightforward process; simply run the following command on any machine that has Docker installed:</p> <pre><code>docker run -it openvidu/openvidu-installer:latest \\\n    --deployment-type=elastic\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>A wizard will guide you through the installation process. You will be asked for the following information:</p> <ul> <li>Write the 'Master Node' Private IP: Write the private IP of the machine where you are going to install the Master Node.</li> <li>Write your OpenVidu PRO License: Write your OpenVidu PRO License.</li> </ul> <p>Info</p> <p>If you don't have a license key for OpenVidu PRO, you can get a 15-day free trial license key by creating an OpenVidu account.</p> <ul> <li>Select which certificate type to use:<ul> <li>Self Signed Certificate: It will generate a self-signed certificate. It is not recommended for production environments, but it is useful for testing or development purposes.</li> <li>Let's Encrypt: It will automatically generate a certificate for your domain. The Let's Encrypt email is required and will be asked later in the wizard.</li> <li>ZeroSSL: It will automatically generate a certificate for your domain using ZeroSSL. An API Key is required and will be asked later in the wizard.</li> <li>Own Certificate: It will ask you for the certificate and key files. Just copy and paste the content of the files when the wizard asks for them.</li> </ul> </li> <li>Domain name: The domain name for your deployment. It must be an FQDN pointing to the machine where you are deploying OpenVidu.</li> <li>(Optional) Turn domain name: The domain name for your TURN server with TLS. It must be an FQDN pointing to the machine where you are deploying OpenVidu and must be different from the OpenVidu domain name. Recommended if users who are going to connect to your OpenVidu deployment are behind restrictive firewalls.</li> <li> <p>Select which RTC engine to use: Select the WebRTC engine you want to use. You can choose between Pion (The engine used by Livekit) or Mediasoup(Experimental).</p> <p>Warning</p> <p>mediasoup integration in OpenVidu is experimental, and should not be used in production environments. There are some limitations that are currently being worked on, expected to be ironed out in the near future.</p> </li> <li> <p>Modules to enable: Select the modules you want to enable. You can enable the following modules:</p> <ul> <li>Observability: Grafana stack, which includes logs and monitoring stats.</li> <li>Default App: OpenVidu Call, a ready-to-use videoconferencing application.</li> <li>OpenVidu V2 Compatibility: Compatibility API for applications developed with OpenVidu v2.</li> </ul> </li> </ul> <p>The rest of the parameters are secrets, usernames, and passwords. If empty, the wizard will generate random values for them.</p> <p>This command will output the following instructions, which you should follow:</p> <ol> <li>Firewall Configuration for 'Master Node': These rules are the same as those specified in the instructions. Depending on the modules you have selected, some rules defined at Port rules (Master Node) may not appear (Optional ports). Double-check and modify it if you see something that can be enabled/disabled in your current port rules.</li> <li> <p>Installation Commands for 'Master Node': This is the command needed to install your Master Node. It should look like this:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/elastic/latest/install_ov_master_node.sh) \\\n    --no-tty --install \\\n    --deployment-type='elastic' \\\n    --node-role='master-node' \\\n...\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Execute that command in your Master Node to install it. When the installation process finishes, you will see the following output:</p> <pre><code>&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n&gt;                                                                             &lt;\n&gt;  \ud83c\udf89 OpenVidu Elastic 'Master Node' Installation Finished Successfully! \ud83c\udf89   &lt;\n&gt;                                                                             &lt;\n&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n</code></pre> <p>The Master Node will be installed at <code>/opt/openvidu</code> and configured as a systemd service. You can start the service with the following command:</p> <pre><code>systemctl start openvidu\n</code></pre> </li> <li> <p>Firewall Configuration for 'Media Nodes': These rules are the same as those defined previously as with the Master Node. Double-check the Port rules (Media Nodes) and modify them if you see something that can be enabled/disabled in your current port rules.</p> </li> <li> <p>Installation Commands for 'Media Nodes': This is the command needed to install your Media Nodes. It should look like this:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/elastic/latest/install_ov_media_node.sh) \\\n    --no-tty --install \\\n    --deployment-type='elastic' \\\n    --node-role='media-node' \\\n...\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Execute that command on your Media Nodes to install them. When the installation process finishes, you will see the following output:</p> <pre><code>&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n&gt;                                                                             &lt;\n&gt;  \ud83c\udf89 OpenVidu Elastic 'Media Node' Installation Finished Successfully! \ud83c\udf89    &lt;\n&gt;                                                                             &lt;\n&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n</code></pre> <p>The Media Node in each machine will be installed at <code>/opt/openvidu</code> and configured as a systemd service. You can start the service with the following command:</p> <pre><code>systemctl start openvidu\n</code></pre> </li> </ol> <p>If everything goes well, all containers will be up and running without restarts, and you will be able to access any of the following services:</p> <ul> <li>OpenVidu Call (Default Application): https://openvidu.example.io/</li> <li>OpenVidu Dashboard: https://openvidu.example.io/dashboard</li> <li>MinIO: https://openvidu.example.io/minio-console</li> <li>Grafana: https://openvidu.example.io/grafana</li> </ul> <p>OpenVidu Server PRO URL (LiveKit compatible) will be available also in:</p> <ul> <li>OpenVidu Server PRO: https://openvidu.example.io/</li> <li>LiveKit API: https://openvidu.example.io/ and wss://openvidu.example.io/</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/install/#deployment-credentials","title":"Deployment Credentials","text":"<p>To point your applications to your OpenVidu deployment, check the file at <code>/opt/openvidu/.env</code>. All access credentials for all services are defined in this file.</p> <p>Your authentication credentials and URL to point your applications would be:</p> <ul> <li> <p>Applications developed with LiveKit SDK:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_OR_PUBLIC_IP</code> as a URL. It could be <code>wss://openvidu.example.io/</code> or <code>https://openvidu.example.io/</code> depending on the SDK you are using.</li> <li>API Key: The value in <code>.env</code> of <code>LIVEKIT_API_KEY</code></li> <li>API Secret: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> <li> <p>Applications developed with OpenVidu v2:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_OR_PUBLIC_IP</code> as a URL. For example, <code>https://openvidu.example.io/</code></li> <li>Username: <code>OPENVIDUAPP</code></li> <li>Password: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/install/#non-interactive-installation","title":"Non-interactive installation","text":"<p>To automate the installation process, you just need to execute the specified command in the Guided Installation section and execute the generated commands.</p> <p>Each installation command for each type of node looks like this:</p> Master NodeMedia Node <p>The Master Node can be configured with multiple kinds of certificates. Here are the examples for each type of certificate:</p> Let's Encrypt certificatesSelf-signed certificatesCustom certificates <p>Example using Let's Encrypt certificates:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/elastic/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    --openvidu-pro-license='xxxxx' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --private-ip='1.2.3.4' \\\n    --certificate-type='letsencrypt' \\\n    --letsencrypt-email='example@example.io'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Notes:</p> <ul> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> <li><code>--private-ip</code> is very important. It should not change and Media Nodes should be able to reach the Master Node using this IP.</li> </ul> <p>Example using self-signed certificates:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/elastic/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    --openvidu-pro-license='xxxxx' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --private-ip='1.2.3.4' \\\n    --certificate-type='selfsigned'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <ul> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> <li><code>--private-ip</code> is very important. It should not change and Media Nodes should be able to reach the Master Node using this IP.</li> </ul> <p>Example using custom certificates:</p> <pre><code>CERT_PRIVATE_KEY=$(cat privkey.pem | base64 -w 0)\nCERT_PUBLIC_KEY=$(cat fullchain.pem | base64 -w 0)\n\n# Optional, only if you want to enable TURN with TLS\nCERT_TURN_PRIVATE_KEY=$(cat turn-privkey.pem | base64 -w 0)\nCERT_TURN_PUBLIC_KEY=$(cat turn-fullchain.pem | base64 -w 0)\n\nsh &lt;(curl -fsSL http://get.openvidu.io/pro/elastic/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    --openvidu-pro-license='xxxxx' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --private-ip='1.2.3.4' \\\n    --certificate-type='owncert' \\\n    --owncert-private-key=\"$CERT_PRIVATE_KEY\" \\\n    --owncert-public-key=\"$CERT_PUBLIC_KEY\" \\\n    --turn-owncert-private-key=\"$CERT_TURN_PRIVATE_KEY\" \\\n    --turn-owncert-public-key=\"$CERT_TURN_PUBLIC_KEY\"\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <ul> <li>Note that you just need to pass <code>--owncert-private-key</code> and <code>--owncert-public-key</code> with the content of the private and public key files in base64 format. The installation script will decode them and save them in the proper files.</li> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> <li><code>--private-ip</code> is very important. It should not change and Media Nodes should be able to reach the Master Node using this IP.</li> <li><code>--turn-owncert-private-key</code> and <code>--turn-owncert-public-key</code> are optional. You only need to pass them if you want to enable TURN with TLS.</li> </ul> <p>To install a Media Node, you can use the following command:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/elastic/latest/install_ov_media_node.sh) \\\n    --node-role='media-node' \\\n    --openvidu-pro-license='xxxxx' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --rtc-engine='pion' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --master-node-private-ip='1.2.3.4' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <ul> <li>Depending on the RTC engine, the argument <code>--rtc-engine</code> can be <code>pion</code> or <code>mediasoup</code>.</li> <li>The <code>--master-node-private-ip</code> is the private IP of the Master Node. Media Nodes should be able to reach the Master Node using this IP.</li> <li>If no media appears in your conference, reinstall specifying the <code>--public-ip</code> parameter with your machine's public IP. OpenVidu usually auto-detects the public IP, but it can fail. This IP is used by clients to send and receive media.</li> </ul> <p>You can run these commands in a CI/CD pipeline or in a script to automate the installation process.</p> <p>Some notes about all commands:</p> <ul> <li>The argument <code>--turn-domain-name</code> is optional. You define it only if you want to enable TURN with TLS in case users are behind restrictive firewalls.</li> <li>At the argument <code>--enabled-modules</code>, you can enable the modules you want to deploy. You can enable <code>observability</code> (Grafana stack), <code>app</code> (Default App - OpenVidu Call), and <code>v2compatibility</code> (OpenVidu v2 compatibility API).</li> </ul> <p>To start each node, remember to execute the following command in each node:</p> <pre><code>systemctl start openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/elastic/on-premises/install/#configuration-and-administration","title":"Configuration and administration","text":"<p>Once you have OpenVidu deployed, you can check the Configuration and Administration section to learn how to manage your OpenVidu Elastic deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/","title":"OpenVidu High Availability installation","text":"<p>OpenVidu High Availability is part of the PRO edition of OpenVidu. You have the following deployment options:</p> <ul> <li>On-premises Installation (DNS Load Balancing): Set up OpenVidu High Availability on your own servers with a DNS Load Balancing mechanism.</li> <li>On-premises Installation (Network Load Balancer): Set up OpenVidu High Availability on your own servers with a Network Load Balancer.</li> <li>AWS Installation: Deploy OpenVidu Elastic on Amazon Web Services.</li> </ul> <p>Once your deployment is complete, refer to the following sections for configuration and management:</p> <ul> <li>On-premises: Configuration and Administration</li> <li>AWS: Configuration and Administration</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/","title":"OpenVidu High Availability Configuration and Administration: AWS","text":"<p>The deployment of OpenVidu High Availability on AWS is automated using AWS CloudFormation, with Master and Media Nodes managed within an Auto Scaling Group. The Auto Scaling Group of Master Nodes is fixed to 4 instances while the Auto Scaling Group of Media Nodes is configured to scale based on the target average CPU utilization.</p> <p>Internally, the AWS deployment mirrors the on-premises setup, allowing you to follow the same administration and configuration guidelines provided in the On Premises High Availability documentation. However, there are specific considerations unique to the AWS environment that are worth taking into account.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/#cluster-shutdown-and-startup","title":"Cluster Shutdown and Startup","text":"<p>You can start and stop the OpenVidu High Availability cluster at any time. The following sections detail the procedures.</p> Shutdown the ClusterStartup the Cluster <p>To shut down the cluster, you need to stop the Media Nodes first and then stop the Master Nodes; this way, any ongoing session will not be interrupted.</p> <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>In the \"Resources\" tab, locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code>, and click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>Set the \"Desired capacity\", \"Min desired capacity\", and \"Max desired capacity\" to 0, and click on \"Update\".      </li> <li> <p>Wait until the \"Instance Management\" tab shows that there are no instances in the Auto Scaling Group.      </p> <p>Warning</p> <p>It may happen that some instances are still in the \"Terminating:Wait\" lifecycle state after setting the desired capacity to 0. This is because the Auto Scaling Group waits for the instances to finish processing any ongoing room, ingress, or egress operations before terminating them. This can take a few minutes. If you want to force the termination of the instances, you can manually terminate them from the EC2 Dashboard.</p> </li> <li> <p>After confirming that all Media Node instances are terminated, go back to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMasterNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Master Nodes selected.      </p> </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>Set the \"Desired capacity\", \"Min desired capacity\", and \"Max desired capacity\" to 0, and click on \"Update\".      </li> <li>Wait until the \"Instance Management\" tab shows that there are no instances in the Auto Scaling Group.      </li> </ol> <p>To start the cluster, we recommend starting the Master Node first and then the Media Nodes.</p> <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>Locate the resource with the logical ID: <code>OpenViduMasterNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Master Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>Set the \"Desired capacity\", \"Min desired capacity\", and \"Max desired capacity\" to the desired number of Media Nodes, and click on \"Update\". For the Master Nodes auto scaling group, the number of instances must be 4.      </li> <li>Wait until the \"Instance Management\" tab shows that there are the desired number of instances in the Auto Scaling Group.      </li> <li>Go back to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>Set the \"Desired capacity\", \"Min desired capacity\", and \"Max desired capacity\" to the desired number of Media Nodes, and click on \"Update\". In this example, we set the desired capacity to 2.      </li> <li>Wait until the \"Instance Management\" tab shows that there are the desired number of instances in the Auto Scaling Group.      </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/#change-the-instance-type","title":"Change the instance type","text":"<p>It is possible to change the instance type of both the Master Node and the Media Nodes. The following section details the procedures.</p> Master NodesMedia Nodes <p>Warning</p> <p>This procedure requires downtime, as it involves stopping all the Master Nodes and starting them again with the new instance type.</p> <ol> <li>Go to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>Locate the resource with the logical ID: <code>OpenViduMasterLaunchTemplate</code>. Click on it to go to the Launch Template Dashboard with the Launch Template of the Master Nodes selected.      </li> <li>Click on \"Actions &gt; Modify template (Create new version)\".      </li> <li>In the \"Instance type\" section, select the new instance type and click on \"Create template version\".      </li> <li>Go to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMasterNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Master Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li> <p>In the Launch Template section, select the new version of the launch template we just created at step 5 which is the highest version number.</p> <p>Then, click on \"Update\".</p> <p>Info</p> <p>By configuring \"Latest\" as the launch template version,  you no longer need to update the Auto Scaling Group every time you modify the launch template. The Auto Scaling Group will automatically use the latest version of the launch template.</p> <p></p> </li> <li> <p>Terminate the old instances manually from the EC2 Dashboard if you want to force the termination of the instances. New instances will be launched with the new instance type.</p> <p>Info</p> <p>The information at <code>/opt/openvidu</code> is persisted as AWS Elastic Block Store (EBS) volumes. When you terminate an instance, the EBS volume is detached and preserved. When the Auto Scaling Group launches a new instance, the EC2 instance is attached to the EBS volume, and the data is retained. This means that the data stored in the <code>/opt/openvidu</code> directory is not lost when you terminate an instance.</p> </li> </ol> <ol> <li>Go to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>Locate the resource with the logical ID: <code>OpenViduMediaNodeLaunchTemplate</code>. Click on it to go to the Launch Template Dashboard with the Launch Template of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Modify template (Create new version)\".      </li> <li>In the \"Instance type\" section, select the new instance type and click on \"Create template version\".      </li> <li>Go to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li> <p>In the Launch Template section, select the new version of the launch template we just created at step 5 which is the highest version number.</p> <p>Then, click on \"Update\".</p> <p>Info</p> <p>By configuring \"Latest\" as the launch template version,  you no longer need to update the Auto Scaling Group every time you modify the launch template. The Auto Scaling Group will automatically use the latest version of the launch template.</p> <p></p> </li> <li> <p>Terminate the old instances manually from the EC2 Dashboard if you want to force the termination of the instances. New instances will be launched with the new instance type.</p> <p>Info</p> <p>If you want to avoid downtime, you can wait until the Auto Scaling Group replaces the old instances with the new ones. But you will need to increase the desired capacity to force the replacement of the instances and then decrease it to the desired number of instances.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/#media-nodes-autoscaling-configuration","title":"Media Nodes Autoscaling Configuration","text":"<p>To configure the Auto Scaling settings for the Media Nodes, follow the steps outlined below. This configuration allows you to set the parameters that control how the Auto Scaling Group will scale based on the target average CPU utilization.</p> Media Nodes Autoscaling Configuration <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>In the \"Resources\" tab, locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code> and click on it to go to the Auto Scaling Group Dashboard.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>To configure scaling policies, navigate to the \"Automatic scaling\" tab within the Auto Scaling Group Dashboard, select the unique \"Target tracking scaling\" autoscaling policy, and click on \"Actions &gt; Edit\".      </li> <li> <p>It will open a panel where you can configure multiple parameters. In this example, we set the target average CPU utilization to 30%. Then, click on \"Update\".      </p> <p>Info</p> <p>OpenVidu High Availability is by default configured with a \"Target tracking scaling\" policy that scales based on the target average CPU utilization, however, you can configure different autoscaling policies according to your needs. For more information on the various types of autoscaling policies and how to implement them, refer to the AWS Auto Scaling documentation.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/#fixed-number-of-media-nodes","title":"Fixed Number of Media Nodes","text":"<p>If you need to maintain a fixed number of Media Nodes instead of allowing the Auto Scaling Group to dynamically adjust based on CPU utilization, you can configure the desired capacity settings accordingly. Follow the steps below to set a fixed number of Media Nodes:</p> Set Fixed Number of Media Nodes <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>In the \"Resources\" tab, locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code> and click on it to go to the Auto Scaling Group Dashboard.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li>Set the \"Desired capacity\", \"Min desired capacity\", and \"Max desired capacity\" to the fixed number of Media Nodes you require, and click on \"Update\". In this example, we set the desired capacity to 2.      </li> <li>Wait until the \"Instance Management\" tab shows that the Auto Scaling Group has the fixed number of instances running.      </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/#configuration-management","title":"Configuration Management","text":"<p>This section explains how to manage and update the configuration settings for your OpenVidu High Availability deployment. It is divided into three parts:</p> <ol> <li>Configuring CloudFormation YAML for Node Services Configuration: Details how to pre-configure settings in the CloudFormation template to avoid manual interventions post-deployment.</li> <li>Global Configuration: Covers parameters that affect the entire cluster when the CloudFormation stack is already deployed.</li> <li>Node Services Configuration: Focuses on settings specific to Master and Media Nodes services when the CloudFormation stack is already deployed.</li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/#configuring-cloudformation-yaml-for-node-services-configuration","title":"Configuring CloudFormation YAML for Node Services Configuration","text":"<p>To avoid manual intervention after deployment, you can pre-configure the node services configuration directly in the CloudFormation YAML template. This ensures that the necessary configurations are applied automatically upon deployment.</p> Master NodeMedia Nodes <ol> <li>Get the CloudFormation YAML template used to deploy OpenVidu High Availability on AWS.</li> <li> <p>Locate the section defining the Launch Template for the Master Node and update the <code>UserData</code> property with the required configuration parameters. The section looks like this:</p> <pre><code>OpenViduMasterLaunchTemplate:\n    Type: AWS::EC2::LaunchTemplate\n    Properties:\n        LaunchTemplateData:\n            UserData:\n                Fn::Base64: !Sub |\n                    #!/bin/bash\n                    ...\n                    ...\n                    # Install OpenVidu\n                    /usr/local/bin/install.sh || { /usr/local/bin/set-as-unhealthy.sh; exit 1; }\n\n                    ######### APPLY CUSTOM CONFIGURATIONS #########\n                    # If you want to apply any modification to the configuration files\n                    # of the OpenVidu services at /opt/openvidu, you can do it here.\n                    # Examples:\n                    #\n                    # - Change minio public port\n                    # yq eval '.apps.http.servers.minio.listen[0] = \":9001\"' -i /opt/openvidu/caddy.yaml\n                    #\n                    # - Disable dashboard access\n                    # yq eval 'del(.apps.http.servers.public.routes[] | \\\n                    #  select(.handle[]?.handler == \"subroute\" and \\\n                    #  .handle[].routes[].handle[].strip_path_prefix == \"/dashboard\"))' \\\n                    #  -i /opt/openvidu/caddy.yaml\n\n\n\n                    ######### END CUSTOM CONFIGURATIONS #########\n\n                    # Start OpenVidu\n                    systemctl start openvidu || { /usr/local/bin/set-as-unhealthy.sh; exit 1; }\n                    ...\n                    ...\n</code></pre> <p>The area between <code>APPLY CUSTOM CONFIGURATIONS</code> and <code>END CUSTOM CONFIGURATIONS</code> is where you can add your custom configuration commands. You can use <code>yq</code> to modify the configuration files of the OpenVidu services. The example shows how to change the <code>minio</code> public port and how to disable dashboard access in the <code>caddy.yaml</code> configuration file.</p> </li> <li> <p>Save the YAML file and use it to deploy your CloudFormation stack. This will apply the Master Node configuration automatically during the deployment process.</p> </li> </ol> <ol> <li>Get the CloudFormation YAML template used to deploy OpenVidu High Availability on AWS.</li> <li> <p>Locate the section defining the Launch Template for the Media Nodes and update the <code>UserData</code> property with the required configuration parameters. The section looks like this:</p> <pre><code>OpenViduMediaNodeLaunchTemplate:\n    Type: \"AWS::EC2::LaunchTemplate\"\n    Properties:\n        LaunchTemplateData:\n            UserData:\n                Fn::Base64: !Sub |\n                    #!/bin/bash\n                    ...\n                    ...\n                    # Install OpenVidu\n                    /usr/local/bin/install.sh || { echo \"[OpenVidu] error installing OpenVidu\"; /usr/local/bin/set_as_unhealthy.sh; exit 1; }\n\n                    ######### APPLY CUSTOM CONFIGURATIONS #########\n                    # If you want to apply any modification to the configuration files\n                    # of the OpenVidu services at /opt/openvidu, you can do it in this section.\n                    # Examples:\n                    #\n                    # - Announce specific IP address for the media node\n                    # yq eval '.rtc.node_ip = 1.2.3.4' -i /opt/openvidu/livekit.yaml\n                    #\n                    # - Add webhooks to livekit\n                    # yq eval '.webhook.urls += [\"http://new-endpoint.example.com/webhook\"]' -i /opt/openvidu/livekit.yaml\n\n\n\n                    ######### END CUSTOM CONFIGURATIONS #########\n\n                    # Start OpenVidu\n                    systemctl start openvidu || { echo \"[OpenVidu] error starting OpenVidu\"; /usr/local/bin/set_as_unhealthy.sh; exit 1; }\n</code></pre> <p>The area between <code>APPLY CUSTOM CONFIGURATIONS</code> and <code>END CUSTOM CONFIGURATIONS</code> is where you can add your custom configuration commands. You can use <code>yq</code> to modify the configuration files of the OpenVidu services. The example shows how to change the <code>rtc.node_ip</code> parameter and how to add a webhook to the <code>livekit.yaml</code> configuration file.</p> </li> <li> <p>Save the YAML file and use it to deploy your CloudFormation stack. This will apply the node services configuration automatically during the deployment process.</p> </li> </ol> <p>By pre-configuring the CloudFormation template, you streamline the deployment process and reduce the need for post-deployment manual configuration.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/#global-configuration","title":"Global Configuration","text":"<p>The global configuration parameters for the OpenVidu High Availability deployment are stored in a secret resource deployed by the CloudFormation stack. These parameters can affect the configuration of all the nodes in the cluster. To update any of these parameters, follow the steps below:</p> Update Global Configuration Parameters <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>In the \"Resources\" tab, locate the resource with the logical ID: <code>OpenViduSharedInfo</code> and click on it to view the secret in AWS Secrets Manager.      </li> <li>Click on \"Retrieve secret value\" to view the parameters.      </li> <li>Edit the desired parameters within the secret. For example, you can change the <code>RTC_ENGINE</code> parameter to <code>pion</code> or <code>mediasoup</code> depending on the WebRTC engine you want to use. Just click on \"Edit\", modify the value, and click on \"Save\".      </li> <li>To apply the changes, stop the cluster and then start it again following the procedures outlined in the Cluster Shutdown and Startup section.</li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/admin/#node-services-configuration","title":"Node Services Configuration","text":"<p>The node services configuration parameters for the OpenVidu High Availability deployment are stored in the configuration files of the services running on the Master and Media Nodes. These parameters can affect the configuration of the individual nodes in the cluster. To update any of these configuration files, follow the steps below:</p> Master NodeMedia Node <p>Master Node configurations require changes to be made in the Launch Template \"User Data\" section. To update the configuration:</p> <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>Locate the resource with the logical ID: <code>OpenViduMasterLaunchTemplate</code>. Click on it to go to the Launch Template Dashboard with the Launch Template of the Master Node selected.      </li> <li>Click on \"Actions &gt; Modify template (Create new version)\".      </li> <li>Go to the \"Advanced details\" section and modify the \"User data\" field with the new configuration. You can modify the configuration parameters of the services running on the Master Node following the same script structure as the one used in the Automatic installation and configuration of nodes, for the Master Node. When you finish, click on \"Create template version\".      </li> <li>Go to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMasterNodeASG</code>. Click on it to go to the EC2 Dashboard with the Master Node instance selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li> <p>In the Launch Template section, select the new version of the launch template we just created at step 5 which is the highest version number. Then, click on \"Update\".</p> <p>Info</p> <p>By configuring \"Latest\" as the launch template version,  you no longer need to update the Auto Scaling Group every time you modify the launch template. The Auto Scaling Group will automatically use the latest version of the launch template.</p> <p></p> </li> <li> <p>Terminate the old instances manually from the EC2 Dashboard. New instances will be launched with the new configuration.</p> <p>Warning</p> <p>This process requires downtime, as it involves terminating the old instances and launching new ones with the updated configuration.</p> </li> </ol> <p>Media Node configurations require changes to be made in the Launch Template \"User Data\" section. To update the configuration:</p> <ol> <li>Navigate to the CloudFormation Dashboard on AWS.</li> <li>Select the CloudFormation Stack that you used to deploy OpenVidu High Availability.</li> <li>Locate the resource with the logical ID: <code>OpenViduMediaNodeLaunchTemplate</code>. Click on it to go to the Launch Template Dashboard with the Launch Template of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Modify template (Create new version)\".      </li> <li>Go to the \"Advanced details\" section and modify the \"User data\" field with the new configuration. You can modify the configuration parameters of the services running on the Media Nodes following the same script structure as the one used in the Automatic installation and configuration of nodes, for the Media Nodes. When you finish, click on \"Create template version\".      </li> <li>Go to the CloudFormation Stack and locate the resource with the logical ID: <code>OpenViduMediaNodeASG</code>. Click on it to go to the Auto Scaling Group Dashboard with the Auto Scaling Group of the Media Nodes selected.      </li> <li>Click on \"Actions &gt; Edit\".      </li> <li> <p>In the Launch Template section, select the new version of the launch template we just created at step 5 which is the highest version number. Then, click on \"Update\".</p> <p>Info</p> <p>By configuring \"Latest\" as the launch template version,  you no longer need to update the Auto Scaling Group every time you modify the launch template. The Auto Scaling Group will automatically use the latest version of the launch template.</p> <p></p> </li> <li> <p>Terminate the old instances manually from the EC2 Dashboard if you want to force the termination of the instances. New instances will be launched with the new configuration.</p> <p>Warning</p> <p>This process requires downtime, as it involves terminating the old instances and launching new ones with the updated configuration.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/","title":"OpenVidu High Availability Installation: AWS","text":"<p>Info</p> <p>OpenVidu High Availability is part of OpenVidu PRO. Before deploying, you need to create an OpenVidu account to get your license key. There's a 15-day free trial waiting for you!</p> <p>This section contains the instructions to deploy a production-ready OpenVidu High Availability deployment in AWS. Deployed services are the same as the On Premises High Availability Installation but automate the process with AWS CloudFormation.</p> <p>First of all, import the template in the AWS CloudFormation console. You can click the following button...</p> <p>Deploy OpenVidu High Availability in </p> <p>...or access your AWS CloudFormation console and manually set this S3 URL in the <code>Specify template</code> section:</p> <pre><code>https://s3.eu-west-1.amazonaws.com/get.openvidu.io/pro/ha/latest/aws/cf-openvidu-ha.yaml\n</code></pre> <p>This is how the architecture of the deployment looks like.</p> Architecture overviewArchitecture overview with TURN over TLS <p> OpenVidu High Availability AWS Architecture </p> <ul> <li>The Load Balancer distributes HTTPS traffic to the Master Nodes.</li> <li>If RTMP media is ingested, the Load Balancer also routes this traffic to the Media Nodes.</li> <li>WebRTC traffic (SRTP/SCTP/STUN/TURN) is routed directly to the Media Nodes.</li> <li>An autoscaling group of Master Nodes is created with a fixed number of 4 Master Nodes. It must always have 4 Master Nodes to ensure high availability.</li> <li>An autoscaling group of Media Nodes is created to scale the number of Media Nodes based on the system load.</li> </ul> <p> OpenVidu High Availability AWS Architecture with TURN over TLS </p> <ul> <li>The Load Balancer distributes HTTPS traffic to the Master Nodes.</li> <li>If RTMP media is ingested, the Load Balancer also routes this traffic to the Media Nodes.</li> <li>WebRTC traffic (SRTP/SCTP/STUN/TURN) is routed directly to the Media Nodes.</li> <li>An additional Load Balancer is created to route TURN over TLS traffic to the TURN server running on the Media Nodes. It is used to allow users behind restrictive firewalls to connect to the Media Nodes.</li> <li>An autoscaling group of Master Nodes is created with a fixed number of 4 Master Nodes. It must always have 4 Master Nodes to ensure high availability.</li> <li>An autoscaling group of Media Nodes is created to scale the number of Media Nodes based on the system load.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#cloudformation-parameters","title":"CloudFormation Parameters","text":"<p>Depending on your needs, you need to fill the following CloudFormation parameters:</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#domain-and-load-balancer-configuration","title":"Domain and Load Balancer configuration","text":"<p>In this section, you need to specify the domain name and the SSL certificate to use from AWS Certificate Manager.</p> Domain and Load Balancer configuration <p>The parameters in this section might look like this:</p> <p></p> <p>Set the DomainName parameter to the domain name you intend to use for your OpenVidu deployment. Ensure this domain is not currently pointing to any other service; you can temporarily point it elsewhere.</p> <p>For the OpenViduCertificateARN parameter, specify the ARN of the SSL certificate you wish to use. This certificate should be created in the AWS Certificate Manager and configured for the domain specified in DomainName.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#openvidu-ha-configuration","title":"OpenVidu HA Configuration","text":"<p>In this section, you need to specify some properties needed for the OpenVidu HA deployment.</p> OpenVidu Elastic Configuration <p>The parameters in this section might appear as follows:</p> <p></p> <p>Make sure to provide the OpenViduLicense parameter with the license key. If you don't have one, you can request one here.</p> <p>For the RTCEngine parameter, you can choose between Pion (the engine used by LiveKit) and Mediasoup (experimental).</p> <p>Warning</p> <p>mediasoup integration in OpenVidu is experimental, and should not be used in production environments. There are some limitations that are currently being worked on, expected to be ironed out in the near future.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#ec2-instance-configuration","title":"EC2 Instance Configuration","text":"<p>You need to specify some properties for the EC2 instances that will be created.</p> EC2 Instance configuration <p>The parameters in this section may look like this:</p> <p></p> <p>Simply select the type of instance you want to deploy at MasterNodeInstanceType and MediaNodeInstanceType, the SSH key you want to use to access the machine at KeyName, and the Amazon Image ID (AMI) to use at AmiId.</p> <p>By default, the parameter AmiId is configured to use the latest Amazon Linux AMI, so ideally you don\u2019t need to modify this.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#media-nodes-autoscaling-group-configuration","title":"Media Nodes Autoscaling Group Configuration","text":"<p>The number of Media Nodes can scale up or down based on the system load. You can configure the minimum and maximum number of Media Nodes and a target CPU utilization to trigger the scaling up or down.</p> Media Nodes Autoscaling Group Configuration <p>The parameters in this section may look like this:</p> <p></p> <p>The InitialNumberOfMediaNodes parameter specifies the initial number of Media Nodes to deploy. The MinNumberOfMediaNodes and MaxNumberOfMediaNodes parameters specify the minimum and maximum number of Media Nodes that you want to be deployed.</p> <p>The ScaleTargetCPU parameter specifies the target CPU utilization to trigger the scaling up or down. The goal is to keep the CPU utilization of the Media Nodes close to this value. The autoscaling policy is based on Target Tracking Scaling Policy.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#vpc-configuration","title":"VPC Configuration","text":"<p>In this section, you need to specify the VPC and Subnet configuration for the deployment.</p> VPC Configuration <p>The parameters in this section may look like this:</p> <p></p> <p>The OpenViduVPC parameter specifies the VPC where the deployment will be created.</p> <p>The OpenViduMasterNodeSubnets specifies the subnets where the Master Nodes will be deployed. You can specify a maximum of 4 subnets.</p> <p>The OpenViduMediaNodeSubnets specifies the subnets where the Media Nodes will be deployed. There is no limit on the number of subnets you can specify.</p> <p>Warning</p> <ul> <li>It is recommended to deploy in a region with at least 4 availability zones and deploy the Master Nodes in 4 subnets, one in each availability zone. This is to ensure high availability.</li> <li>You must use public subnets for the Master Nodes and Media Nodes and have enabled the auto-assign public IP option.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#optional-turn-server-configuration-with-tls","title":"(Optional) TURN server configuration with TLS","text":"<p>This section is optional. It is useful when your users are behind a restrictive firewall that blocks UDP traffic.</p> TURN server configuration with TLS <p>The parameters in this section may look like this:</p> <p></p> <p>Set the TurnDomainName parameter to the domain name you intend to use for your TURN server. Ensure this domain is not currently pointing to any other service; you can temporarily point it elsewhere.</p> <p>For the TurnCertificateARN parameter, specify the ARN of the SSL certificate you wish to use. This certificate should be created in the AWS Certificate Manager and configured for the domain specified in TurnDomainName.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#volumes-configuration","title":"Volumes Configuration","text":"<p>In this section, you need to specify the configuration for the EBS volumes that will be created for the Master Nodes. Master Nodes will host all the recordings and metrics data replicated across all of them. The disk size of the EBS volumes is the same for all Master Nodes.</p> Volumes Configuration <p>The parameters in this section may look like this:</p> <p></p> <p>The RetainVolumes parameter specifies whether the EBS volumes should be retained when the stack is deleted. If you set this parameter to <code>true</code>, the EBS volumes will not be deleted when the stack is deleted. This is useful if you want to keep the recordings and metrics data after deleting the stack. If you set this parameter to <code>false</code>, the EBS volumes will be deleted when the stack is deleted. In any case, it is recommended to create a snapshot backup policy.</p> <p>The DiskSize parameter specifies the size of the EBS volumes in GB.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#deploying-the-stack","title":"Deploying the Stack","text":"<p>When you are ready with your CloudFormation parameters, just click on \"Next\", specify in \"Stack failure options\" the option \"Preserve successfully provisioned resources\" to be able to troubleshoot the deployment in case of error, click on \"Next\" again, and finally \"Submit\".</p> <p>When everything is ready, you will see the following links in the \"Outputs\" section of CloudFormation:</p> CloudFormation Outputs <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#deployment-credentials","title":"Deployment Credentials","text":"<p>The Output Key ServicesAndCredentials of the previous section points to an AWS Secret Manager secret that contains all URLs and credentials to access the services deployed. You can access the secret by clicking on the link in the Output Value column.</p> <p>Then, click on Retrieve secret value to get the JSON with all the information.</p> <p></p> <p></p> <p>To point your applications to your OpenVidu deployment, check the values of the JSON secret. All access credentials of all services are defined in this object.</p> <p>Your authentication credentials and URL to point your applications would be:</p> <ul> <li> <p>Applications developed with LiveKit SDK:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_NAME</code> as a URL. It could be <code>wss://openvidu.example.io/</code> or <code>https://openvidu.example.io/</code> depending on the SDK you are using.</li> <li>API Key: The value in <code>.env</code> of <code>LIVEKIT_API_KEY</code></li> <li>API Secret: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> <li> <p>Applications developed with OpenVidu v2:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_NAME</code> as a URL. For example, <code>https://openvidu.example.io/</code></li> <li>Username: <code>OPENVIDUAPP</code></li> <li>Password: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#troubleshooting-initial-cloudformation-stack-creation","title":"Troubleshooting Initial CloudFormation Stack Creation","text":"<p>If something goes wrong during the initial CloudFormation stack creation, your stack may reach the <code>CREATE_FAILED</code> status for multiple reasons. It could be due to a misconfiguration in the parameters, a lack of permissions, or a problem with the AWS services. When this happens, the following steps can help you troubleshoot the issue and identify what went wrong:</p> <ol> <li> <p>While deploying the stack, make sure at \"Stack failure options\" you have selected the option \"Preserve successfully provisioned resources\" to be able to troubleshoot the deployment in case of an error.</p> Disable Rollback on failure <p> </p> </li> <li> <p>Check if the EC2 instance or instances are running. If they are not, check the CloudFormation events for any error messages.</p> </li> <li> <p>If the EC2 instance or instances are running, SSH into the instance and check the logs of the following files:</p> <ul> <li><code>/var/log/cloud-init-output.log</code></li> <li><code>/var/log/cloud-init.log</code></li> </ul> <p>These logs will give you more information about the CloudFormation stack creation process.</p> </li> <li> <p>If everything seems fine, check the status and the logs of the installed OpenVidu services in all the Master Nodes and Media Nodes.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/aws/install/#configuration-and-administration","title":"Configuration and administration","text":"<p>When your CloudFormation stack reaches the <code>CREATE_COMPLETE</code> status, your OpenVidu High Availability deployment is ready to use. You can check the Configuration and Administration section to learn how to manage your deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/","title":"OpenVidu High Availability Configuration and Administration: On-premises","text":"<p>The OpenVidu installer offers an easy way to deploy OpenVidu High Availability on-premises. However, once the deployment is complete, you may need to perform administrative tasks based on your specific requirements, such as changing passwords, specifying custom configurations, and starting or stopping services.</p> <p>This section provides details on configuration parameters and common administrative tasks for on-premises OpenVidu High Availability deployments.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#openvidu-configuration","title":"OpenVidu configuration","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#directory-structure","title":"Directory structure","text":"<p>OpenVidu High Availability is composed of two types of nodes, Master Nodes and Media Nodes. The directory structure is as follows for each type of node:</p> Master NodesMedia Node <p>In each Master Node, the services are installed at <code>/opt/openvidu/</code> and have a systemd service located at <code>/etc/systemd/system/openvidu.service</code>.</p> <p>The directory structure of each Master Node is as follows:</p> <pre><code>|-- /opt/openvidu\n    |-- config/\n    |-- data/\n    |-- deployment-info.yaml\n    |-- docker-compose.override.yml\n    |-- docker-compose.yml\n    |-- .env\n    `-- owncert/\n</code></pre> <ul> <li><code>config/</code>: Contains the configuration files for the services deployed in the Master Node.</li> <li><code>data/</code>: Contains the data generated by the services deployed with the Master Node.</li> <li><code>deployment-info.yaml</code>: Contains the deployment information of the Master Node.</li> <li><code>docker-compose.override.yml</code>: Contains the service with the Default App (OpenVidu Call) deployed with OpenVidu.</li> <li><code>docker-compose.yml</code>: Contains the main services deployed for the Master Node.</li> <li><code>.env</code>: Contains parameters managed by multiple services.</li> <li><code>owncert/</code>: Contains the custom certificates for the Caddy server if you are using your own certificates.</li> </ul> <p>In each Media Node, the services are installed at <code>/opt/openvidu/</code> and have a systemd service located at <code>/etc/systemd/system/openvidu.service</code>.</p> <p>The directory structure of the Media Node is as follows:</p> <pre><code>|-- /opt/openvidu\n    |-- config/\n    |-- data/\n    |-- deployment-info.yaml\n    |-- docker-compose.yml\n    `-- .env\n</code></pre> <ul> <li><code>config/</code>: Contains the configuration files for the services deployed with the Media Node.</li> <li><code>data/</code>: Contains the data generated by the services deployed with the Media Node.</li> <li><code>deployment-info.yaml</code>: Contains the deployment information of the Media Node.</li> <li><code>docker-compose.yml</code>: Contains the main services deployed for the Media Node.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#services-configuration","title":"Services Configuration","text":"<p>Some services deployed with OpenVidu have their own configuration files located in the <code>/opt/openvidu/config/</code> directory, while others are configured in the <code>.env</code> file. Below are the services and their respective configuration files and parameters:</p> <p>Info</p> <p>The installer provides default configurations that work out of the box. However, you can modify these configurations to suit your specific requirements.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#configuration-files","title":"Configuration Files","text":"Master NodeMedia Node Service Description Configuration File Location Reference documentation Caddy Server Serves OpenVidu services and handles HTTPS. <code>/opt/openvidu/config/caddy.yaml</code> Caddy JSON Structure Loki Service Used for log aggregation. <code>/opt/openvidu/config/loki.yaml</code> Loki Config Promtail Service Collects logs and sends them to Loki. <code>/opt/openvidu/config/promtail.yaml</code> Promtail Config Mimir Service Service for long-term prometheus storage <code>/opt/openvidu/config/mimir.yaml</code> Mimir Config Grafana Service Used for visualizing monitoring data. <code>/opt/openvidu/config/grafana_config/</code> Grafana Config Service Description Configuration File Location Reference documentation OpenVidu Server Manages video rooms. It is compatible with LiveKit configuration and includes its own OpenVidu configuration parameters <code>/opt/openvidu/config/livekit.yaml</code> LiveKit Config Ingress Service Imports video from other sources into OpenVidu rooms. <code>/opt/openvidu/config/ingress.yaml</code> LiveKit Ingress Config Egress Service Exports video from OpenVidu rooms for recording or streaming. <code>/opt/openvidu/config/egress.yaml</code> LiveKit Egress Config Prometheus Service Used for monitoring. <code>/opt/openvidu/config/prometheus.yaml</code> Prometheus Config Promtail Service Collects logs and sends them to Loki. <code>/opt/openvidu/config/promtail.yaml</code> Promtail Config Caddy Service Allows Media Nodes to reach Master Node services in a balanced and high-available way. <code>/opt/openvidu/config/caddy.yaml</code> Caddy JSON Structure"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#environment-variables","title":"Environment variables","text":"Master NodeMedia Node <p>Warning</p> <ul> <li>All services use internally the values of <code>MASTER_NODE_X_PRIVATE_IP</code> where <code>X</code> is the Master Node number (1, 2, 3, and 4) defined in the <code>.env</code> file. These values are the private IP addresses of the Master Nodes. Ensure that these values are static IP addresses and are the same in all the Master Nodes and Media Nodes.</li> </ul> Service Description Environment Variables Grafana Service Used for visualizing monitoring data. <ul><li> <code>GRAFANA_ADMIN_USERNAME</code>: The username to access the Grafana dashboard.</li><li><code>GRAFANA_ADMIN_PASSWORD</code>: The password to access the Grafana dashboard.</li></ul> OpenVidu Dashboard Used to visualize OpenVidu Server Rooms, Ingress, and Egress services. <ul><li><code>DASHBOARD_ADMIN_USERNAME</code>: The username to access the OpenVidu Dashboard.</li><li><code>DASHBOARD_ADMIN_PASSWORD</code>: The password to access the OpenVidu Dashboard.</li></ul> Default App (OpenVidu Call) Default ready-to-use video conferencing app. <ul><li><code>CALL_PRIVATE_ACCESS</code>: If set to <code>true</code>, the app will be private and require authentication. If set to <code>false</code>, the app will be public and accessible without authentication. The user is configured with <code>CALL_USER</code> and <code>CALL_SECRET</code> parameters.</li><li><code>CALL_USER</code>: The username to access the app. This parameter is only used if <code>CALL_PRIVATE_ACCESS</code> is set to <code>true</code>.</li><li><code>CALL_SECRET</code>: The password to access the app. This parameter is only used if <code>CALL_PRIVATE_ACCESS</code> is set to <code>true</code>.</li><li><code>CALL_ADMIN_USERNAME</code>: The username to access the OpenVidu Call Admin Panel.</li><li><code>CALL_ADMIN_SECRET</code>: The password to access the OpenVidu Call Admin Panel.</li><li><code>LIVEKIT_API_KEY</code>: The API key to access the LiveKit service.</li><li><code>LIVEKIT_API_SECRET</code>: The API secret to access the LiveKit service.</li></ul> Redis Service Used as a shared memory database for OpenVidu and Ingress/Egress services. <ul><li><code>REDIS_PASSWORD</code>: The password for the Redis service.</li></ul> If you need to change the Redis password after the installation, check the advanced configuration section. MinIO Service Used for storing recordings. <ul><li><code>MINIO_ACCESS_KEY</code>: The access key for the MinIO service.</li><li><code>MINIO_SECRET_KEY</code>: The secret key for the MinIO service.</li></ul> If you need to change the MinIO access key and secret key after the installation, check the advanced configuration section. MongoDB Service Used for storing analytics and monitoring data. <ul><li><code>MONGO_ADMIN_USERNAME</code>: The username to access the MongoDB database.</li><li><code>MONGO_ADMIN_PASSWORD</code>: The password to access the MongoDB database.</li><li><code>MONGO_REPLICA_SET_KEY</code>: The replica set key for the MongoDB database.</li></ul> If you need to change the MongoDB username and password after the installation, check the advanced configuration section. OpenVidu v2 compatibility Service Used to enable compatibility with OpenVidu v2. Check the OpenVidu v2 Compatibility Configuration Parameters to see all the available parameters. <p>Warning</p> <ul> <li>All services use internally the values of <code>MASTER_NODE_X_PRIVATE_IP</code> where <code>X</code> is the Master Node number (1, 2, 3, and 4) defined in the <code>.env</code> file. These values are the private IP addresses of the Master Nodes. Ensure that these values are static IP addresses and are the same in all the Master Nodes and Media Nodes.</li> <li>All services use internally the <code>MEDIA_NODE_PRIVATE_IP</code> value defined in the <code>.env</code> file. This value is the private IP address of the Media Node. Ensure that this value is a static IP address. It should be different from Media Node to Media Node.</li> </ul> Service Description Environment Variables OpenVidu Server Manages video rooms. <ul><li><code>MASTER_NODE_X_PRIVATE_IP</code>: The private IP addresses of all Master Nodes. Used to connect to Master Node services.</li><li><code>MEDIA_NODE_PRIVATE_IP</code>: The private IP address of the Media Node. On startup, the OpenVidu Server registers itself with this IP address so that the Caddy server from Master Nodes can route requests to the Media Node.</li></ul> Ingress Service Imports video from other sources into OpenVidu rooms. <ul><li><code>MASTER_NODE_X_PRIVATE_IP</code>: The private IP addresses of all Master Nodes. Used to connect to the Master Node services.</li></ul> Egress Service Exports video from OpenVidu rooms for recording or streaming. <ul><li><code>MASTER_NODE_X_PRIVATE_IP</code>: The private IP addresses of all Master Nodes. Used to connect to the Master Node services.</li></ul> Prometheus Service Used for monitoring. <ul><li><code>MASTER_NODE_X_PRIVATE_IP</code>: The private IP addresses of all Master Nodes. Used to connect to the Master Node services.</li></ul> Promtail Service Collects logs and sends them to Loki. <ul><li><code>MASTER_NODE_X_PRIVATE_IP</code>: The private IP addresses of all Master Nodes. Used to connect to the Master Node services.</li></ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#openvidu-configuration-parameters","title":"OpenVidu Configuration Parameters","text":"<p>OpenVidu Server is built on top of LiveKit and offers extra configuration options. You can find the configuration file at <code>/opt/openvidu/config/livekit.yaml</code>. Additional parameters for configuring OpenVidu Server are:</p> <pre><code>openvidu:\n    license: &lt;YOUR_OPENVIDU_PRO_LICENSE&gt; # (1)\n    cluster_id: &lt;YOUR_DOMAIN_NAME&gt; # (2)\n    analytics: # (3)\n        enabled: true # (4)\n        interval: 10s # (5)\n        expiration: 768h # (6)\n        mongo_url: &lt;MONGO_URL&gt; # (7)\n    rtc:\n        engine: pion # (8)\n    mediasoup:\n        debug: \"\" # (9)\n        log_level: error # (10)\n        log_tags: [info, ice, rtp, rtcp, message] # (11)\n</code></pre> <ol> <li>Specify your OpenVidu Pro license key. If you don't have one, you can request one here.</li> <li>The cluster ID for the OpenVidu deployment. It is configured by default by OpenVidu Installer with the domain name of the deployment.</li> <li>The <code>analytics</code> configuration should be defined at the <code>openvidu</code> level in the <code>livekit.yaml</code> file.</li> <li>This must be set to <code>true</code> to send analytics data to MongoDB. If set to <code>false</code>, no analytics data will be sent.</li> <li>Time interval to send analytics data to MongoDB.</li> <li>Time to keep the analytics data in MongoDB. In this example, it is set to 32 days.</li> <li>MongoDB URL. This is the connection string to the MongoDB database where the analytics data will be stored.</li> <li>The <code>rtc.engine</code> parameter is set to <code>pion</code> by default. This is the WebRTC engine used by OpenVidu. Depending on your requirements, you can use:<ul> <li><code>pion</code></li> <li><code>mediasoup</code></li> </ul> </li> <li>Global toggle to enable debugging logs from MediaSoup. In most debugging cases, using just an asterisk (\"*\") here is enough, but this can be fine-tuned for specific log levels. More info.<ul> <li>Default is an empty string.</li> </ul> </li> <li>Logging level for logs generated by MediaSoup. More info.<ul> <li>Valid values are: <code>debug</code>, <code>warn</code>, <code>error</code>, <code>none</code>.</li> <li>Default is <code>error</code>.</li> </ul> </li> <li>Comma-separated list of log tag names, for debugging. More info.<ul> <li>Valid values are: <code>info</code>, <code>ice</code>, <code>dtls</code>, <code>rtp</code>, <code>srtp</code>, <code>rtcp</code>, <code>rtx</code>, <code>bwe</code>, <code>score</code>, <code>simulcast</code>, <code>svc</code>, <code>sctp</code>, <code>message</code>.</li> <li>Default is <code>[info, ice, rtp, rtcp, message]</code>.</li> </ul> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#openvidu-v2-compatibility-configuration-parameters","title":"OpenVidu v2 Compatibility Configuration Parameters","text":"<p>If you are using in <code>COMPOSE_PROFILES</code> at the <code>.env</code> file the <code>v2compatibility</code> profile, you will need to set the following parameters in the <code>.env</code> file for the OpenVidu V2 Compatibility service:</p> Parameter Description Default Value <code>V2COMPAT_OPENVIDU_SECRET</code> OpenVidu secret used to authenticate the OpenVidu V2 Compatibility service. In the <code>.env</code> file, this value is defined with <code>LIVEKIT_API_SECRET</code>. The value of <code>LIVEKIT_API_SECRET</code> in the <code>.env</code> file. <code>V2COMPAT_OPENVIDU_WEBHOOK</code> <code>true</code> to enable OpenVidu Webhook service. <code>false</code> otherwise. Valid values are <code>true</code> or <code>false</code>. <code>false</code> <code>V2COMPAT_OPENVIDU_WEBHOOK_ENDPOINT</code> HTTP(S) endpoint to send OpenVidu V2 Webhook events. Must be a valid URL. Example:  <code>V2COMPAT_OPENVIDU_WEBHOOK_ENDPOINT=http://myserver.com/webhook</code> - <code>V2COMPAT_OPENVIDU_WEBHOOK_HEADERS</code> JSON Array list of headers to send in the OpenVidu V2 Webhook events. Example:  <code>V2COMPAT_OPENVIDU_WEBHOOK_HEADERS=[\"Content-Type: application/json\"]</code> <code>[]</code> <code>V2COMPAT_OPENVIDU_WEBHOOK_EVENTS</code> Comma-separated list of OpenVidu V2 Webhook events to send. Example:  <code>V2COMPAT_OPENVIDU_WEBHOOK_EVENTS=sessionCreated,sessionDestroyed</code> <code>sessionCreated</code>, <code>sessionDestroyed,</code> <code>participantJoined,</code> <code>participantLeft,</code> <code>webrtcConnectionCreated,</code> <code>webrtcConnectionDestroyed,</code> <code>recordingStatusChanged,</code> <code>signalSent</code> (All available events) <code>V2COMPAT_OPENVIDU_PRO_AWS_S3_BUCKET</code> S3 Bucket where to store recording files. <code>openvidu</code> <code>V2COMPAT_OPENVIDU_PRO_AWS_S3_SERVICE_ENDPOINT</code> S3 Endpoint where to store recording files. <code>http://localhost:9100</code> <code>V2COMPAT_OPENVIDU_PRO_AWS_ACCESS_KEY</code> S3 Access Key of the S3 Bucket where to store recording files. - <code>V2COMPAT_OPENVIDU_PRO_AWS_SECRET_KEY</code> S3 Secret Key of the S3 Bucket where to store recording files. - <code>V2COMPAT_OPENVIDU_PRO_AWS_REGION</code> S3 Region of the S3 Bucket where to store recording files. <code>us-east-1</code>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#starting-stopping-and-restarting-openvidu","title":"Starting, stopping, and restarting OpenVidu","text":"<p>For every OpenVidu node, a systemd service is created during the installation process. This service allows you to start, stop, and restart the OpenVidu services easily.</p> <p>Start OpenVidu</p> <pre><code>sudo systemctl start openvidu\n</code></pre> <p>Stop OpenVidu</p> <pre><code>sudo systemctl stop openvidu\n</code></pre> <p>Restart OpenVidu</p> <pre><code>sudo systemctl restart openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#checking-the-status-of-services","title":"Checking the status of services","text":"<p>You can check the status of the OpenVidu services using the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose ps\n</code></pre> <p>Depending on the node type, you will see different services running.</p> Master NodeMedia Node <p>The services are operating correctly if you see an output similar to the following and there are no restarts from any of the services:</p> <pre><code>NAME                       IMAGE                                              COMMAND                  SERVICE                    CREATED          STATUS\napp                        docker.io/openvidu/openvidu-call                   \"docker-entrypoint.s\u2026\"   app                        12 seconds ago   Up 10 seconds\ncaddy                      docker.io/openvidu/openvidu-pro-caddy              \"/bin/caddy run --co\u2026\"   caddy                      12 seconds ago   Up 10 seconds\ndashboard                  docker.io/openvidu/openvidu-pro-dashboard          \"./openvidu-dashboard\"   dashboard                  12 seconds ago   Up 10 seconds\ngrafana                    docker.io/grafana/grafana                          \"/run.sh\"                grafana                    11 seconds ago   Up 8 seconds\nloki                       docker.io/grafana/loki                             \"/usr/bin/loki -conf\u2026\"   loki                       11 seconds ago   Up 9 seconds\nmimir                      docker.io/grafana/mimir                            \"/bin/mimir -config.\u2026\"   mimir                      11 seconds ago   Up 9 seconds\nminio                      docker.io/bitnami/minio                            \"/opt/bitnami/script\u2026\"   minio                      11 seconds ago   Up 9 seconds\nmongo                      docker.io/mongo                                    \"docker-entrypoint.s\u2026\"   mongo                      11 seconds ago   Up 9 seconds\nopenvidu-v2compatibility   docker.io/openvidu/openvidu-v2compatibility        \"/bin/server\"            openvidu-v2compatibility   12 seconds ago   Up 10 seconds\noperator                   docker.io/openvidu/openvidu-operator               \"/bin/operator\"          operator                   12 seconds ago   Up 10 seconds\npromtail                   docker.io/grafana/promtail                         \"/usr/bin/promtail -\u2026\"   promtail                   11 seconds ago   Up 9 seconds\nredis-sentinel             docker.io/redis                                    \"docker-entrypoint.s\u2026\"   redis-sentinel             10 seconds ago   Up 10 seconds\nredis-server               docker.io/redis                                    \"docker-entrypoint.s\u2026\"   redis-server               10 seconds ago   Up 10 seconds\n</code></pre> <p>The services are operating correctly if you see an output similar to the following and there are no restarts from any of the services:</p> <pre><code>NAME         IMAGE                                          COMMAND                  SERVICE      CREATED          STATUS\ncaddy        docker.io/openvidu/openvidu-caddy:main         \"/bin/caddy run --co\u2026\"   caddy        53 seconds ago   Up 53 seconds\negress       docker.io/livekit/egress                       \"/entrypoint.sh\"         egress       53 seconds ago   Up 51 seconds\ningress      docker.io/livekit/ingress                      \"ingress\"                ingress      53 seconds ago   Up 52 seconds\nopenvidu     docker.io/openvidu/openvidu-server-pro         \"/livekit-server --c\u2026\"   openvidu     53 seconds ago   Up 52 seconds\nprometheus   docker.io/prom/prometheus                      \"/bin/prometheus --c\u2026\"   prometheus   53 seconds ago   Up 51 seconds\npromtail     docker.io/grafana/promtail                     \"/usr/bin/promtail -\u2026\"   promtail     53 seconds ago   Up 52 seconds\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#checking-logs","title":"Checking logs","text":"<p>If any of the services are not working as expected, you can check the logs of the services using the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs &lt;service-name&gt;\n</code></pre> <p>Replace <code>&lt;service-name&gt;</code> with the name of the service you want to check. For example, to check the logs of the OpenVidu Server, use the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs openvidu\n</code></pre> <p>To check the logs of all services, use the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs\n</code></pre> <p>You can also review your logs using the Grafana dashboard provided with OpenVidu. To access it, go to https://&lt;your-domain.com&gt;/grafana and use the credentials located in <code>/opt/openvidu/.env</code> to log in. Once inside, navigate to the \"Home\" section, select \"Dashboard\", and then click on:</p> <ul> <li>\"OpenVidu &gt; OpenVidu Cluster Nodes Logs\": To check the logs of the OpenVidu services organized per node.</li> <li>\"OpenVidu &gt; OpenVidu Cluster Services Logs\": To check the logs of the OpenVidu services organized per service.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#adding-and-removing-media-nodes","title":"Adding and Removing Media Nodes","text":"<p>Adding and removing Media Nodes is straightforward. You can add new Media Nodes to the cluster to increase the capacity of your OpenVidu deployment. Similarly, you can remove Media Nodes to reduce the capacity of your deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#adding-media-nodes","title":"Adding Media Nodes","text":"<p>To add a new Media Node, simply spin up a new VM and run the OpenVidu installer script to integrate it into the existing cluster. Run the installation command on the new Media Node.</p> <p>Warning</p> <p>This installation command should be the same as the one you used to install the first Media Node. Make sure to use the same parameters and values as the first Media Node. In case you've changed the <code>.env</code> file in the Master Nodes, you will need to update the <code>.env</code> file or update the installation command with the new values.</p> <p>To automate the configuration of new nodes, check this section.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#removing-media-nodes-gracefully","title":"Removing Media Nodes Gracefully","text":"<p>To stop a Media Node gracefully, you need to stop the containers <code>openvidu</code>, <code>ingress</code>, and <code>egress</code> with a <code>SIGINT</code> signal. Here is a simple script that you can use to stop all these containers gracefully:</p> <pre><code>#!/bin/bash\n# Stop OpenVidu, Ingress, and Egress containers gracefully (1)\ndocker container kill --signal=SIGINT openvidu || true\ndocker container kill --signal=SIGINT ingress || true\ndocker container kill --signal=SIGINT egress || true\n\n# Wait for the containers to stop (2)\nwhile [ $(docker inspect -f '{{.State.Running}}' openvidu 2&gt;/dev/null) == \"true\" ] || \\\n    [ $(docker inspect -f '{{.State.Running}}' ingress 2&gt;/dev/null) == \"true\" ] || \\\n    [ $(docker inspect -f '{{.State.Running}}' egress 2&gt;/dev/null) == \"true\" ]; do\n    echo \"Waiting for containers to stop...\"\n    sleep 5\ndone\n</code></pre> <ol> <li>This script stops the OpenVidu, Ingress, and Egress containers gracefully. The <code>true</code> at the end of each command is to avoid the script from stopping if the container is not running.</li> <li>This script waits for the containers to stop before exiting.</li> </ol> <p>When all the containers are stopped, you can then stop the systemd service and remove the VM:</p> <pre><code>sudo systemctl stop openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#removing-media-nodes-forcefully","title":"Removing Media Nodes Forcefully","text":"<p>To remove a Media Node forcefully, without considering the rooms, ingress, and egress processes running in the node, you can simply stop the OpenVidu service in the Media Node and delete the VM.</p> <pre><code>sudo systemctl stop openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#advanced-configuration","title":"Advanced Configuration","text":"<p>This section addresses advanced configuration scenarios for customizing your OpenVidu High Availability deployment. It includes automating the installation with personalized settings, enabling or disabling OpenVidu modules, and modifying global parameters such as the domain name, passwords, and API keys.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#automatic-installation-and-configuration-of-nodes","title":"Automatic installation and configuration of nodes","text":"<p>For environments like the cloud, where instances are frequently spun up and down, automating the application of custom configurations to Master Nodes and Media Nodes may be useful for you.</p> Master NodeMedia Node <p>If you need to apply custom configurations to your Master Nodes, you can use the following script template:</p> <pre><code># 1. First install the Master Node (1)\nsh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    ... # Add the rest of the arguments (2)\n\n# 2. Add custom configurations (3)\n######### APPLY CUSTOM CONFIGURATIONS #########\n# If you want to apply any modification to the configuration files\n# of the OpenVidu services at /opt/openvidu, you can do it here.\n\n# Example 1: Change Minio public port\nyq eval '.apps.http.servers.minio.listen[0] = \":9001\"' -i /opt/openvidu/config/caddy.yaml\n\n# Example 2: Disable the /dashboard route in Caddy\nyq eval 'del(.apps.http.servers.public.routes[] | \\\n  select(.handle[]?.handler == \"subroute\" and \\\n  .handle[].routes[].handle[].strip_path_prefix == \"/dashboard\"))' \\\n  -i /opt/openvidu/config/caddy.yaml\n\n######### END CUSTOM CONFIGURATIONS #########\n\n# 3. Start OpenVidu (4)\nsystemctl start openvidu\n</code></pre> <ol> <li>First, install the Master Node using the OpenVidu installer. Check the installation guide for more information.</li> <li>Add the parameters you need to install the Master Node. You can find all the available parameters in the installation guide.</li> <li>Add the custom configurations you need to apply to the Master Node services. You can use <code>yq</code> or other tools to modify the configuration files. You can find more information about <code>yq</code> here.</li> <li>Start the Master Node.</li> </ol> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Just install the Master Node first with the installer and then run some extra commands to apply the custom configurations. This way, you can automate the process of installing the Master Node and applying custom configurations.</p> <p>If you need to apply custom configurations to the Media Node, you can use the following script template:</p> <pre><code># 1. First install the Media Node (1)\nsh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_media_node.sh) \\\n    --node-role='media-node' \\\n    ... # Add the rest of the arguments (2)\n\n# 2. Add custom configurations (3)\n######### APPLY CUSTOM CONFIGURATIONS #########\n# If you want to apply any modification to the configuration files\n# of the OpenVidu services at /opt/openvidu, you can do it in this section.\n\n# Example 1: Change public IP address announced by OpenVidu for WebRTC connections\nyq eval '.rtc.node_ip = 1.2.3.4' \\\n    -i /opt/openvidu/config/livekit.yaml\n\n# Example 2: Add a webhook to LiveKit\nyq eval '.webhook.urls += [\"http://new-endpoint.example.com/webhook\"]' \\\n    -i /opt/openvidu/config/livekit.yaml\n\n######### END CUSTOM CONFIGURATIONS #########\n\n# 3. Start OpenVidu (4)\nsystemctl start openvidu\n</code></pre> <ol> <li>First, install the Media Node using the OpenVidu installer. Check the installation guide for more information.</li> <li>Add the parameters you need to install the Media Node. You can find all the available parameters in the installation guide.</li> <li>Add the custom configurations you need to apply to the Media Node services. You can use <code>yq</code> or other tools to modify the configuration files. You can find more information about <code>yq</code> here.</li> <li>Start the Media Node.</li> </ol> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Just install the Media Node first with the installer and then run some extra commands to apply the custom configurations. This way, you can automate the process of installing the Media Node and applying custom configurations.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#enabling-and-disabling-openvidu-modules","title":"Enabling and Disabling OpenVidu Modules","text":"<p>The <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file in Master and Media Nodes allows you to enable or disable specific modules in OpenVidu. The following modules can be enabled or disabled:</p> Observability moduleV2 Compatibility moduleApp module (Default App) <p>In case you have installed OpenVidu with the <code>observability</code> module, you just need to enable the <code>observability</code> module in the <code>.env</code> file in all nodes.</p> <p>Otherwise, you can follow these steps to enable the <code>observability</code> module:</p> <ol> <li> <p>Stop all Master Nodes and all Media Nodes, and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>In the Master Nodes, update the <code>.env</code> with the following changes:</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>observability</code> module. Also, make sure to set up the <code>GRAFANA_ADMIN_USERNAME</code> and <code>GRAFANA_ADMIN_PASSWORD</code> parameters.</p> <p>If you have only the observability module enabled, your <code>.env</code> file should have the following environment variables:</p> <pre><code>GRAFANA_ADMIN_USERNAME=\"&lt;GRAFANA_ADMIN_USERNAME&gt;\"\nGRAFANA_ADMIN_PASSWORD=\"&lt;GRAFANA_ADMIN_PASSWORD&gt;\"\n\nCOMPOSE_PROFILES=\"observability\"\n</code></pre> </li> <li> <p>In the Media Nodes, enable the <code>observability</code> module:</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>observability</code> module in the <code>.env</code> file. If you have only the <code>observability</code> module enabled, your <code>.env</code> file should have the following environment variable:</p> <pre><code>COMPOSE_PROFILES=\"observability\"\n</code></pre> <p>Then, add the following parameter in the <code>config/livekit.yaml</code> file:</p> <pre><code>prometheus_port: 6789\n</code></pre> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Disabling the <code>observability</code> module</p> <p>If you have the <code>observability</code> module enabled, and you want to disable it, just remove the <code>observability</code> module from the <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file of all nodes.</p> <p>In case you have installed OpenVidu with the <code>v2compatibility</code> module, you just need to enable the <code>v2compatibility</code> module in the <code>.env</code> file in all nodes.</p> <p>Otherwise, you can follow these steps to enable the <code>v2compatibility</code> module:</p> <ol> <li> <p>Stop all Master Nodes, all Media Nodes, and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>In the Master Nodes, update the <code>.env</code> with the following changes:</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>v2compatibility</code> module.</p> <p>If you have only the <code>v2compatibility</code> module enabled, your <code>.env</code> file should have the following environment variable:</p> <pre><code>COMPOSE_PROFILES=\"v2compatibility\"\n</code></pre> </li> <li> <p>In the Media Nodes, update the LiveKit configuration to send webhooks to the V2 Compatibility service</p> <p>Just add the following parameter in the <code>config/livekit.yaml</code> file:</p> <pre><code>webhook:\n    api_key: \"&lt;LIVEKIT_API_KEY&gt;\"\n    urls:\n        - http://localhost:4443/livekit/webhook\n</code></pre> <p>Where <code>&lt;LIVEKIT_API_KEY&gt;</code> is the <code>LIVEKIT_API_KEY</code> parameter in the <code>.env</code> file.</p> <p>Note that the URL is <code>http://localhost:4443</code> because an internal caddy proxy will balance the requests to all the V2 Compatibility services running in the Master Nodes.</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Disabling the <code>v2compatibility</code> module</p> <p>If you have the <code>v2compatibility</code> module enabled, and you want to disable it, just remove the <code>v2compatibility</code> module from the <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file of all nodes.</p> <p>In case you have installed OpenVidu without the <code>app</code> module, you just need to enable the <code>app</code> module in the <code>.env</code> file in all nodes.</p> <p>Otherwise, you can follow these steps to enable the <code>app</code> module:</p> <ol> <li> <p>Stop all Master Nodes, all Media Nodes, and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>In all Master Nodes, update the <code>.env</code> with the following changes:</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>app</code> module.</p> <p>If you have only the <code>app</code> module enabled, your <code>.env</code> file should have the following environment variable:</p> <pre><code>COMPOSE_PROFILES=\"app\"\n</code></pre> </li> <li> <p>In the Media Nodes, update the LiveKit configuration to send webhooks to the Default App</p> <p>Just add the following parameter in the <code>config/livekit.yaml</code> file:</p> <pre><code>webhook:\n    api_key: \"&lt;LIVEKIT_API_KEY&gt;\"\n    urls:\n        - http://localhost:6080/api/webhook\n</code></pre> <p>Where <code>&lt;LIVEKIT_API_KEY&gt;</code> is the <code>LIVEKIT_API_KEY</code> parameter in the <code>.env</code> file.</p> <p>Note that the URL is <code>http://localhost:6080</code> because an internal caddy proxy will balance the requests to all the Default App services running in the Master Nodes.</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Disabling the <code>app</code> module</p> <p>If you have the <code>app</code> module enabled, and you want to disable it, just remove the <code>app</code> module from the <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file of all nodes.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#global-configuration-changes","title":"Global configuration changes","text":"<p>Some configuration parameters may require modifying multiple configuration files. Below are some examples of advanced configurations and how to apply them:</p> <p>Info</p> <p>Usually, this is not needed because the installer takes care of generating all of this parameters. However, it is necessary if any password, credential, or domain change is needed.</p> <p>Danger</p> <p>Advanced configurations should be performed with caution. Incorrect configurations can lead to service failures or unexpected behavior.</p> <p>Before making any changes, make sure to back up your installation by creating a snapshot of your server or by copying the <code>/opt/openvidu/</code> directory to a safe location. For example:</p> <pre><code>sudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> Changing <code>DOMAIN_OR_PUBLIC_IP</code>Changing <code>REDIS_PASSWORD</code>Changing <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>Changing <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code>Changing <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> <p>To change all occurrences of the domain or public IP address in the configuration files, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in all Master Nodes and all Media Nodes and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Find the current locations of <code>DOMAIN_OR_PUBLIC_IP</code> in your Master Nodes</p> <p>With the following commands, you can find all occurrences of the current domain or public IP address in the configuration files:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_DOMAIN_OR_PUBLIC_IP=\"$(grep '^DOMAIN_OR_PUBLIC_IP' /opt/openvidu/.env | cut -d '=' -f 2)\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> <p>Warning</p> <p>Keep the value of <code>CURRENT_DOMAIN_OR_PUBLIC_IP</code> as you will need it to update the configuration files in the Media Nodes.</p> Example output <p>The output should look similar to the following:</p> <pre><code>./.env:DOMAIN_OR_PUBLIC_IP=&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:        - certificate: /owncert/&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;.cert\n./config/caddy.yaml:          key: /owncert/&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;.key\n./config/caddy.yaml:            - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                    - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                        - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                    - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                        - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                  - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/promtail.yaml:          cluster_id: &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n</code></pre> <p>Note</p> <p>Don't worry if some values are different in your output. It varies depending on the parameters you've used to install OpenVidu.</p> </li> <li> <p>Update the Following Files in all your Master Nodes</p> <p>Based on the output from the previous step, update the following files with the new domain or public IP address:</p> <ul> <li><code>.env</code></li> <li><code>config/caddy.yaml</code></li> <li><code>config/promtail.yaml</code></li> </ul> </li> <li> <p>Verify the changes in all your Master Nodes</p> <p>These commands will list all occurrences of the new <code>DOMAIN_OR_PUBLIC_IP</code> in the configuration files. The output should match the locations found in the initial search but with the new domain or public IP address.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_DOMAIN_OR_PUBLIC_IP=\"&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 2 to 4 for all your Master Nodes</p> </li> <li> <p>Find the current locations of <code>CURRENT_DOMAIN_OR_PUBLIC_IP</code> in your Media Nodes</p> <p>With the <code>CURRENT_DOMAIN_OR_PUBLIC_IP</code> value obtained in step 2, you can find all occurrences of the current domain or public IP address in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_DOMAIN_OR_PUBLIC_IP=\"&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> Example output <p>The output should look similar to the following:</p> <pre><code>./config/promtail.yaml:          cluster_id: &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/livekit.yaml:    cluster_id: &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/livekit.yaml:    rtmp_base_url: rtmps://&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;:1935/rtmp\n./config/livekit.yaml:    whip_base_url: https://&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;/whip\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new domain or public IP address:</p> <ul> <li><code>config/promtail.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>DOMAIN_OR_PUBLIC_IP</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new domain or public IP address.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_DOMAIN_OR_PUBLIC_IP=\"&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 5 to 7 for all your Media Nodes</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Some notes on changing the <code>DOMAIN_OR_PUBLIC_IP</code> parameter:</p> <ul> <li>If you are using your own certificates, you need to place the new ones at <code>/opt/openvidu/owncert/&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;.cert</code> and <code>/opt/openvidu/owncert/&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;.key</code>.</li> <li>Make sure your new domain is pointing correctly to the machine where OpenVidu is installed.</li> </ul> <p>To change the <code>REDIS_PASSWORD</code> parameter, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in all the Master Nodes and all Media Nodes and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Replace in all Master Nodes the <code>REDIS_PASSWORD</code> in the <code>.env</code> file with your new value</p> <p>Warning</p> <p>Keep the previous value of <code>REDIS_PASSWORD</code> as you will need it to update the configuration files in the Media Nodes. We will refer to this value as <code>&lt;CURRENT_REDIS_PASSWORD&gt;</code>.</p> </li> <li> <p>Ensure to replace the <code>REDIS_PASSWORD</code> in the <code>.env</code> file of all your Master Nodes</p> </li> <li> <p>Find the current locations of <code>REDIS_PASSWORD</code> in your Media Nodes</p> <p>With the <code>CURRENT_REDIS_PASSWORD</code> value obtained in step 2, you can find all occurrences of the current Redis password in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_REDIS_PASSWORD=\"&lt;CURRENT_REDIS_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_REDIS_PASSWORD\" .\n</code></pre> Example output <p>The output should look similar to the following:</p> <pre><code>./config/egress.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n./config/ingress.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n./config/livekit.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new Redis password:</p> <ul> <li><code>config/egress.yaml</code></li> <li><code>config/ingress.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>REDIS_PASSWORD</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new Redis password.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_REDIS_PASSWORD=\"&lt;NEW_REDIS_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_REDIS_PASSWORD\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 3 to 5 for all your Media Nodes</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in all Master Nodes and all Media Nodes and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Replace at the Master Nodes the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in the <code>.env</code> file with your new values</p> <p>Warning</p> <p>Keep the previous values of <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> as you will need them to update the configuration files in the Media Nodes. We will refer to these values as <code>&lt;CURRENT_LIVEKIT_API_KEY&gt;</code> and <code>&lt;CURRENT_LIVEKIT_API_SECRET&gt;</code>.</p> </li> <li> <p>Ensure to replace the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in the <code>.env</code> file of all your Master Nodes</p> </li> <li> <p>Find the current locations of <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in your Media Nodes</p> <p>With the <code>CURRENT_LIVEKIT_API_KEY</code> and <code>CURRENT_LIVEKIT_API_SECRET</code> values obtained in step 2, you can find all occurrences of the current LiveKit API key and secret in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_LIVEKIT_API_KEY=\"&lt;CURRENT_LIVEKIT_API_KEY&gt;\"\nCURRENT_LIVEKIT_API_SECRET=\"&lt;CURRENT_LIVEKIT_API_SECRET&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_LIVEKIT_API_KEY\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_LIVEKIT_API_SECRET\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>LIVEKIT_API_KEY</code>:</p> <pre><code>./config/egress.yaml:api_key: &lt;CURRENT_LIVEKIT_API_KEY&gt;\n./config/ingress.yaml:api_key: &lt;CURRENT_LIVEKIT_API_KEY&gt;\n./config/livekit.yaml:    &lt;CURRENT_LIVEKIT_API_KEY&gt;: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/livekit.yaml:    api_key: &lt;CURRENT_LIVEKIT_API_KEY&gt;\n</code></pre> <p>And for <code>LIVEKIT_API_SECRET</code>:</p> <pre><code>./config/egress.yaml:api_secret: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/ingress.yaml:api_secret: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/livekit.yaml:    &lt;CURRENT_LIVEKIT_API_KEY&gt;: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>config/egress.yaml</code></li> <li><code>config/ingress.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_LIVEKIT_API_KEY=\"&lt;NEW_LIVEKIT_API_KEY&gt;\"\nNEW_LIVEKIT_API_SECRET=\"&lt;NEW_LIVEKIT_API_SECRET&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_LIVEKIT_API_KEY\" .\ngrep --exclude-dir=data -IHnr \"$NEW_LIVEKIT_API_SECRET\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 3 to 5 for all your Media Nodes</p> </li> <li> <p>Start all Master Nodes and Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in all the Master Nodes and all Media Nodes and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Replace in all the Master Nodes the <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> in the <code>.env</code> file with your new values</p> <p>Take into account that if you are using the <code>v2compatibility</code> module in <code>COMPOSE_PROFILES</code>, you will need to change the <code>V2COMPAT_OPENVIDU_PRO_AWS_ACCESS_KEY</code> and <code>V2COMPAT_OPENVIDU_PRO_AWS_SECRET_KEY</code> parameters in the <code>.env</code> file.</p> <p>Warning</p> <p>Keep the previous values of <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> as you will need them to update the configuration files in the Media Nodes. We will refer to these values as <code>&lt;CURRENT_MINIO_ACCESS_KEY&gt;</code> and <code>&lt;CURRENT_MINIO_SECRET_KEY&gt;</code>.</p> </li> <li> <p>Ensure to apply the changes in the <code>.env</code> file of all your Master Nodes</p> </li> <li> <p>Find the current locations of <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> in your Media Nodes</p> <p>With the <code>CURRENT_MINIO_ACCESS_KEY</code> and <code>CURRENT_MINIO_SECRET_KEY</code> values obtained in step 2, you can find all occurrences of the current MinIO access key and secret in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_MINIO_ACCESS_KEY=\"&lt;CURRENT_MINIO_ACCESS_KEY&gt;\"\nCURRENT_MINIO_SECRET_KEY=\"&lt;CURRENT_MINIO_SECRET_KEY&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_MINIO_ACCESS_KEY\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_MINIO_SECRET_KEY\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>MINIO_ACCESS_KEY</code>:</p> <pre><code>./config/egress.yaml:access_key: &lt;CURRENT_MINIO_ACCESS_KEY&gt;\n</code></pre> <p>And for <code>MINIO_SECRET_KEY</code>:</p> <pre><code>./config/egress.yaml:secret: &lt;CURRENT_MINIO_SECRET_KEY&gt;\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>config/egress.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_MINIO_ACCESS_KEY=\"&lt;NEW_MINIO_ACCESS_KEY&gt;\"\nNEW_MINIO_SECRET_KEY=\"&lt;NEW_MINIO_SECRET_KEY&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_MINIO_ACCESS_KEY\" .\ngrep --exclude-dir=data -IHnr \"$NEW_MINIO_SECRET_KEY\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 3 to 5 for all your Media Nodes</p> </li> <li> <p>Start all the Master Nodes and all the Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu in all the Master Nodes and all the Media Nodes and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Replace in all the Master Nodes the <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in the <code>.env</code> file with your new values</p> <p>Warning</p> <p>Keep the previous values of <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> as you will need them to update the configuration files in the Media Nodes. We will refer to these values as <code>&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;</code> and <code>&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;</code>.</p> </li> <li> <p>Ensure to replace the <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in the <code>.env</code> file of all your Master Nodes</p> </li> <li> <p>Find the current locations of <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in your Media Nodes</p> <p>With the <code>CURRENT_MONGO_ADMIN_USERNAME</code> and <code>CURRENT_MONGO_ADMIN_PASSWORD</code> values obtained in step 2, you can find all occurrences of the current MongoDB admin username and password in the configuration files of the Media Nodes. To do this, connect to each Media Node and run the following command:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_MONGO_ADMIN_USERNAME=\"&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;\"\nCURRENT_MONGO_ADMIN_PASSWORD=\"&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_MONGO_ADMIN_USERNAME\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_MONGO_ADMIN_PASSWORD\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>MONGO_ADMIN_USERNAME</code>:</p> <pre><code>./config/livekit.yaml:mongo_url: &lt;MONGO_URL&gt;\n</code></pre> <p>And for <code>MONGO_ADMIN_PASSWORD</code>:</p> <pre><code>./config/livekit.yaml:mongo_url: &lt;MONGO_URL&gt;\n</code></pre> </li> <li> <p>Update the Following Files in your Media Nodes</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes in your Media Nodes</p> <p>These commands will list all occurrences of the new <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in the configuration files of the Media Nodes. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_MONGO_ADMIN_USERNAME=\"&lt;NEW_MONGO_ADMIN_USERNAME&gt;\"\nNEW_MONGO_ADMIN_PASSWORD=\"&lt;NEW_MONGO_ADMIN_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_MONGO_ADMIN_USERNAME\" .\ngrep --exclude-dir=data -IHnr \"$NEW_MONGO_ADMIN_PASSWORD\" .\n</code></pre> </li> <li> <p>Ensure to follow from step 3 to 5 for all your Media Nodes</p> </li> <li> <p>Start all the Master Nodes and all the Media Nodes</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/admin/#uninstalling-openvidu","title":"Uninstalling OpenVidu","text":"<p>To uninstall any OpenVidu Node, just execute the following commands:</p> <pre><code>sudo su\nsystemctl stop openvidu\nrm -rf /opt/openvidu/\nrm /etc/systemd/system/openvidu.service\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-dlb/","title":"OpenVidu High Availability Installation: On-premises with DNS Load Balancing","text":"<p>Info</p> <p>OpenVidu High Availability is part of OpenVidu PRO. Before deploying, you need to create an OpenVidu account to get your license key. There's a 15-day free trial waiting for you!</p> <p>This section provides instructions for deploying a production-ready OpenVidu High Availability setup on-premises, utilizing DNS for load balancing traffic. DNS allows multiple records, even of the same kind, to be registered, enabling the listing of multiple hosts under the same domain name. Such a mechanism allows for the distribution of traffic among the Master Nodes, offering an alternative to Network Load Balancers.</p> <p>Advantages of DNS Load Balancing:</p> <ul> <li>Simplicity: Easier to configure compared to Network Load Balancing.</li> <li>Cost: More cost-effective than Network Load Balancing.</li> </ul> <p>Disadvantages of DNS Load Balancing:</p> <ul> <li>Health Checks: Less reliable for health checks compared to Network Load Balancing.</li> <li>Caching Issues: IP addresses of the Master Nodes can be cached, causing issues if the server's IP changes.</li> <li>DNS Round Robin: Some clients may not adhere to DNS Round Robin, potentially leading to uneven traffic distribution.</li> </ul> Architecture overview <p>This is how the architecture of the deployment looks like:</p> <p> OpenVidu High Availability Architecture with DNS Load Balancing </p> <ul> <li>The Master Nodes act as Load Balancers, managing the traffic and distributing it among the other Master Nodes and Media Nodes.</li> <li>Each Master Node has its own Caddy server acting as a Layer 4 (for TURN with TLS and RTMPS) and Layer 7 (For OpenVidu Dashboard, OpenVidu Call, etc., APIs) reverse proxy.</li> <li>WebRTC traffic (SRTP/SCTP/STUN/TURN) is routed directly to the Media Nodes.</li> </ul> <p>For the Master Node, the following services are configured:</p> <ul> <li>OpenVidu Dashboard, a web application interface to visualize your Rooms, Ingress, and Egress services.</li> <li>MinIO as an S3 storage service for recordings.</li> <li>Redis as a shared database for OpenVidu Server PRO and Ingress/Egress services.</li> <li>MongoDB as a database for storing analytics and monitoring data.</li> <li>Caddy as an internal reverse proxy for all services.</li> <li>OpenVidu V2 Compatibility (v2compatibility module) is an optional service that provides an API designed to maintain compatibility for applications developed with OpenVidu version 2.</li> <li>OpenVidu Call (Default Application module), an optional ready-to-use videoconferencing application.</li> <li>Grafana, Mimir, Promtail, and Loki (Observability module) form an optional observability stack for monitoring, allowing you to keep track of logs and deployment statistics for OpenVidu.</li> </ul> <p>For the Media Nodes, the following services are configured:</p> <ul> <li>OpenVidu Server PRO (LiveKit compatible).</li> <li>Ingress and Egress services.</li> <li>Prometheus, Promtail, and Loki (Observability module). Used to send metrics and logs to the observability stack.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-dlb/#prerequisites","title":"Prerequisites","text":"<ul> <li>At least 6 machines:<ul> <li>4 machines for the Master Nodes.</li> <li>2 machines for the Media Nodes.</li> </ul> </li> <li>Each machine must have:<ul> <li>A minimum of 4GB RAM and 4 CPU cores.</li> <li>Linux installed (Ubuntu is recommended).</li> </ul> </li> <li>All machines must have their own public IP.</li> <li>Significant disk space in all the Master Nodes, with 100GB recommended, especially if you plan to record your sessions (Egress). Media Nodes require less space; however, account for the space needed for ongoing recordings on these nodes.</li> <li>A Fully Qualified Domain Name (FQDN) pointing to all the public IPs of the Master Nodes. Simply create 4 A records in your DNS provider pointing to the public IPs of the Master Nodes using the same domain name.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-dlb/#port-rules-master-nodes","title":"Port rules (Master Nodes)","text":"<p>Ensure all these rules are configured in your firewall, security group, or any kind of network configuration that you have in your Master Nodes:</p> <p>Inbound port rules:</p> Protocol Ports Source Description TCP 80 0.0.0.0/0, ::/0 Redirect HTTP to HTTPS and Let's Encrypt validation. TCP 443 0.0.0.0/0, ::/0 Allows access to the following: <ul><li>Livekit API.</li><li>OpenVidu v2 Compatibility API</li><li>OpenVidu Dashboard.</li><li>OpenVidu Call (Default Application).</li><li>WHIP API.</li><li>TURN with TLS.</li><li>Custom layouts</li></ul> TCP 1935 0.0.0.0/0, ::/0 (Optional) For ingesting RTMP streams using Ingress service. TCP 9000 0.0.0.0/0, ::/0 (Optional) To expose MinIO publicly. TCP 3000 Master Nodes (Optional) For load balancing requests to Grafana (Observability module). TCP 8080 Master Nodes For load balancing requests to OpenVidu Dashboard. TCP 9101 Master Nodes For load balancing requests to MinIO Console. TCP 7946-7947 Master Nodes (Optional) For Mimir and Loki cluster communication (Observability module). TCP 9095-9096 Master Nodes (Optional) For Mimir and Loki cluster communication (Observability module). TCP 3100 Media Nodes (Optional) For Loki (Observability module). TCP 9009 Media Nodes (Optional) For Mimir (Observability module). TCP 4443 Master Nodes, Media Nodes (Optional) For OpenVidu V2 compatibility service. TCP 6080 Master Nodes, Media Nodes (Optional) For OpenVidu Call (Default Application). TCP 7000-7001 Master Nodes, Media Nodes For internal Redis communication TCP 9100 Master Nodes, Media Nodes For internal MinIO communication TCP 20000 Master Nodes, Media Nodes For internal Mongo communication <p>Outbound port rules:</p> <p>Typically, all outbound traffic is allowed.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-dlb/#port-rules-media-nodes","title":"Port rules (Media Nodes)","text":"<p>Ensure all these rules are configured in your firewall, security group, or any kind of network configuration that you have in your Media Nodes:</p> <p>Inbound port rules:</p> Protocol Ports Source Description UDP 443 0.0.0.0/0, ::/0 STUN/TURN over UDP. TCP 7881 0.0.0.0/0, ::/0 (Optional), only needed if you want to allow WebRTC over TCP. UDP 7885 0.0.0.0/0, ::/0 (Optional). Only needed if you want to ingest WebRTC using WHIP. UDP 50000-60000 0.0.0.0/0, ::/0 WebRTC Media traffic. TCP 1935 Master Nodes (Optional). Only needed if you want to ingest RTMP streams using Ingress service. Master Nodes need access to this port to reach Ingress RTMP service and expose it using TLS (RTMPS). TCP 5349 Master Nodes (Optional). Only needed if you want to expose TURN service with TLS. Master Nodes need access to this port to reach TURN service and expose it using TLS (TURNS). TCP 7880 Master Nodes LiveKit API. Master Nodes need access to load balance LiveKit API and expose it through HTTPS. TCP 8080 Master Nodes (Optional). Only needed if you want to ingest WebRTC streams using WHIP. Master Nodes need access to this port to reach WHIP HTTP service."},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-dlb/#guided-installation","title":"Guided Installation","text":"<p>Before the installation, ensure that all your machines meet the prerequisites and the port rules for the Master Nodes and Media Nodes are correctly configured.</p> <p>To install OpenVidu High Availability, begin by generating the commands required for setting up all nodes in the cluster. This is a simple and straightforward process; simply run the following command on any machine that has Docker installed:</p> <pre><code>docker run -it openvidu/openvidu-installer:latest \\\n    --deployment-type=ha\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>A wizard will guide you through the installation process. You will be asked for the following information:</p> <ul> <li>Write all 'Master Node' Private IPs separated by commas: Write the private IP of each Master Node separated by commas.</li> <li>Write your OpenVidu PRO License: Write your OpenVidu PRO License.</li> </ul> <p>Info</p> <p>If you don't have a license key for OpenVidu PRO, you can get a 15-day free trial license key by creating an OpenVidu account.</p> <ul> <li>Do you want to use an external load balancer?: Select No. It means that you are going to use DNS Load Balancing.</li> <li>Select which certificate type to use:<ul> <li>Self Signed Certificate: It will generate a self-signed certificate. It is not recommended for production environments, but it is useful for testing or development purposes.</li> <li>Let's Encrypt: It will automatically generate a certificate for your domain. The Let's Encrypt email is required and will be asked for later in the wizard.</li> <li>ZeroSSL: It will automatically generate a certificate for your domain using ZeroSSL. An API Key is required and will be asked for later in the wizard.</li> <li>Own Certificate: It will ask you for the certificate and key files. Just copy and paste the content of the files when the wizard asks for them.</li> </ul> </li> <li>Domain name: The domain name for your deployment. It must be an FQDN pointing to the machine where you are deploying OpenVidu.</li> <li>(Optional) Turn domain name: The domain name for your TURN server with TLS. It must be an FQDN pointing to the machine where you are deploying OpenVidu and must be different from the OpenVidu domain name. Recommended if users who are going to connect to your OpenVidu deployment are behind restrictive firewalls.</li> <li> <p>Select which RTC engine to use: Select the WebRTC engine you want to use. You can choose between Pion (The engine used by Livekit) or Mediasoup (Experimental).</p> <p>Warning</p> <p>mediasoup integration in OpenVidu is experimental, and should not be used in production environments. There are some limitations that are currently being worked on, expected to be ironed out in the near future.</p> </li> <li> <p>Modules to enable: Select the modules you want to enable. You can enable the following modules:</p> <ul> <li>Observability: Grafana stack, which includes logs and monitoring stats.</li> <li>Default App: OpenVidu Call, a ready-to-use videoconferencing application.</li> <li>OpenVidu V2 Compatibility: Compatibility API for applications developed with OpenVidu v2.</li> </ul> </li> </ul> <p>The rest of the parameters are secrets, usernames, and passwords. If empty, the wizard will generate random values for them.</p> <p>This command will output the following instructions, which you should follow:</p> <ol> <li>Firewall Configuration for 'Master Nodes': These rules are the same as the ones specified in the instructions. Depending on the modules you have selected, some rules defined at Port rules (Master Nodes) may not appear (Optional ports). Double-check them and modify them if you see something that can be enabled/disabled in your current port rules.</li> <li> <p>Installation Commands for 'Master Nodes': This is the command needed to install your Master Node. It should look like this:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_master_node.sh) \\\n    --no-tty --install \\\n    --deployment-type='ha' \\\n    --node-role='master-node' \\\n...\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Execute that command on all your Master Nodes to install them. When the installation process finishes, you will see the following output:</p> <pre><code>&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n&gt;                                                                             &lt;\n&gt;  \ud83c\udf89\ud83c\udf89 OpenVidu HA 'Master Node' Installation Finished Successfully! \ud83c\udf89\ud83c\udf89    &lt;\n&gt;                                                                             &lt;\n&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n</code></pre> <p>The Master Node will be installed in <code>/opt/openvidu</code> and configured as a systemd service. To start the service, use the following command:</p> <pre><code>systemctl start openvidu\n</code></pre> <p>Your Master Nodes will be ready once all of them have been started.</p> </li> <li> <p>Firewall Configuration for 'Media Nodes': These rules are the same as the ones defined previously as with Master Nodes. Double-check the Port rules (Media Nodes) and modify them if you see something that can be enabled/disabled in your current port rules.</p> </li> <li> <p>Installation Commands for 'Media Nodes': This is the command needed to install your Media Nodes. It should look like this:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_media_node.sh) \\\n    --no-tty --install \\\n    --deployment-type='ha' \\\n    --node-role='media-node' \\\n...\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Execute that command on your Media Nodes to install them. When the installation process finishes, you will see the following output:</p> <pre><code>&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n&gt;                                                                             &lt;\n&gt;  \ud83c\udf89 OpenVidu HA 'Media Node' Installation Finished Successfully! \ud83c\udf89         &lt;\n&gt;                                                                             &lt;\n&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n</code></pre> <p>The Media Node on each machine will be installed at <code>/opt/openvidu</code> and configured as a systemd service. You can start the service with the following command:</p> <pre><code>systemctl start openvidu\n</code></pre> </li> </ol> <p>If everything goes well, all containers will be up and running without restarts, and you will be able to access any of the following services:</p> <ul> <li>OpenVidu Call (Default Application): https://openvidu.example.io/</li> <li>OpenVidu Dashboard: https://openvidu.example.io/dashboard</li> <li>MinIO: https://openvidu.example.io/minio-console</li> <li>Grafana: https://openvidu.example.io/grafana</li> </ul> <p>OpenVidu Server PRO URL (LiveKit compatible) will be available also in:</p> <ul> <li>OpenVidu Server PRO: https://openvidu.example.io/</li> <li>LiveKit API: https://openvidu.example.io/ and wss://openvidu.example.io/</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-dlb/#deployment-credentials","title":"Deployment Credentials","text":"<p>To point your applications to your OpenVidu deployment, check the file at <code>/opt/openvidu/.env</code> of any Master Node. All access credentials of all services are defined in this file.</p> <p>Your authentication credentials and URL to point your applications would be:</p> <ul> <li> <p>Applications developed with LiveKit SDK:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_OR_PUBLIC_IP</code> as a URL. It could be <code>wss://openvidu.example.io/</code> or <code>https://openvidu.example.io/</code> depending on the SDK you are using.</li> <li>API Key: The value in <code>.env</code> of <code>LIVEKIT_API_KEY</code></li> <li>API Secret: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> <li> <p>Applications developed with OpenVidu v2:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_OR_PUBLIC_IP</code> as a URL. For example, <code>https://openvidu.example.io/</code></li> <li>Username: <code>OPENVIDUAPP</code></li> <li>Password: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-dlb/#non-interactive-installation","title":"Non-interactive installation","text":"<p>To automate the installation process, you just need to execute the specified command in the Guided Installation section and execute the generated commands.</p> <p>Each installation command for each type of node looks like this:</p> Master NodeMedia Node <p>The Master Node can be configured with multiple kinds of certificates. Here are the examples for each type of certificate:</p> Let's Encrypt certificatesSelf-signed certificatesCustom certificates <p>Example using Let's Encrypt certificates:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    --master-node-private-ip-list='10.5.0.1,10.5.0.2,10.5.0.3,10.5.0.4' \\\n    --openvidu-pro-license='xxxxx' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --mongo-replica-set-key='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --certificate-type='letsencrypt' \\\n    --letsencrypt-email='example@example.io'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Notes:</p> <ul> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> <li><code>--master-node-private-ip-list</code> is the list of private IPs of all Master Nodes separated by commas. It should not change and Media Nodes should be able to reach all Master Nodes using these IPs.</li> </ul> <p>Example using self-signed certificates:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    --master-node-private-ip-list='10.5.0.1,10.5.0.2,10.5.0.3,10.5.0.4' \\\n    --openvidu-pro-license='xxxxx' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --mongo-replica-set-key='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --certificate-type='selfsigned'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <ul> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> <li><code>--master-node-private-ip-list</code> is the list of private IPs of all Master Nodes separated by commas. It should not change and Media Nodes should be able to reach all Master Nodes using these IPs.</li> </ul> <p>Example using custom certificates:</p> <pre><code>CERT_PRIVATE_KEY=$(cat privkey.pem | base64 -w 0)\nCERT_PUBLIC_KEY=$(cat fullchain.pem | base64 -w 0)\n\n# Optional, only if you want to enable TURN with TLS\nCERT_TURN_PRIVATE_KEY=$(cat turn-privkey.pem | base64 -w 0)\nCERT_TURN_PUBLIC_KEY=$(cat turn-fullchain.pem | base64 -w 0)\n\nsh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    --master-node-private-ip-list='10.5.0.1,10.5.0.2,10.5.0.3,10.5.0.4' \\\n    --openvidu-pro-license='xxxxx' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --mongo-replica-set-key='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --certificate-type='owncert' \\\n    --owncert-private-key=\"$CERT_PRIVATE_KEY\" \\\n    --owncert-public-key=\"$CERT_PUBLIC_KEY\" \\\n    --turn-owncert-private-key=\"$CERT_TURN_PRIVATE_KEY\" \\\n    --turn-owncert-public-key=\"$CERT_TURN_PUBLIC_KEY\"\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <ul> <li>Note that you just need to pass <code>--owncert-private-key</code> and <code>--owncert-public-key</code> with the content of the private and public key files in base64 format. The installation script will decode them and save them in the proper files.</li> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> <li><code>--master-node-private-ip-list</code> is the list of private IPs of all Master Nodes separated by commas. It should not change and Media Nodes should be able to reach all Master Nodes using these IPs.</li> <li><code>--turn-owncert-private-key</code> and <code>--turn-owncert-public-key</code> are optional. You only need to pass them if you want to enable TURN with TLS.</li> </ul> <p>To install a Media Node, you can use the following command:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_media_node.sh) \\\n    --node-role='media-node' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --master-node-private-ip-list='10.5.0.1,10.5.0.2,10.5.0.3,10.5.0.4' \\\n    --openvidu-pro-license='xxxxx' \\\n    --rtc-engine='pion' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='openvidu.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <ul> <li>Depending on the RTC engine, the argument <code>--rtc-engine</code> can be <code>pion</code> or <code>mediasoup</code>.</li> <li><code>--master-node-private-ip</code> must be the same list of private IPs of all Master Nodes separated by commas. It should not change and Media Nodes should be able to reach all Master Nodes using these IPs.</li> <li>If no media appears in your conference, reinstall specifying the <code>--public-ip</code> parameter with your machine's public IP. OpenVidu usually auto-detects the public IP, but it can fail. This IP is used by clients to send and receive media.</li> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> </ul> <p>You can run these commands in a CI/CD pipeline or in a script to automate the installation process.</p> <p>Some general notes about all commands:</p> <ul> <li>The argument <code>--turn-domain-name</code> is optional. Define it only if you want to enable TURN with TLS in case users are behind restrictive firewalls.</li> <li>In the argument <code>--enabled-modules</code>, you can enable the modules you want to deploy. You can enable <code>observability</code> (Grafana stack), <code>app</code> (Default App - OpenVidu Call), and <code>v2compatibility</code> (OpenVidu v2 compatibility API).</li> </ul> <p>To start each node, remember to execute the following command in each node:</p> <pre><code>systemctl start openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-dlb/#configuration-and-administration","title":"Configuration and administration","text":"<p>Once you have OpenVidu deployed, you can check the Configuration and Administration section to learn how to manage your OpenVidu High Availability deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/","title":"OpenVidu High Availability Installation: On-premises with Network Load Balancer","text":"<p>Info</p> <p>OpenVidu High Availability is part of OpenVidu PRO. Before deploying, you need to create an OpenVidu account to get your license key. There's a 15-day free trial waiting for you!</p> <p>This section provides instructions for deploying a production-ready OpenVidu High Availability setup on-premises, utilizing a Network Load Balancer in front of the cluster. Network Load Balancing is a method of distributing incoming network traffic across multiple servers. It is a highly available, scalable, and fault-tolerant solution that ensures your OpenVidu deployment is always up and running. Compared to DNS Load Balancing, Network Load Balancing is more reliable for health checks and ensures that traffic is evenly distributed across all nodes.</p> <p>Advantages of Network Load Balancing:</p> <ul> <li>More control over the load balancing process.</li> <li>Possibility to use custom health checks to determine the status of the nodes.</li> </ul> <p>Disadvantages of Network Load Balancing:</p> <ul> <li>More complex to set up than DNS Load Balancing.</li> <li>Requires a Load Balancer to be deployed in front of the cluster.</li> <li>More expensive than DNS Load Balancing.</li> </ul> Architecture overview <p>This is how the architecture of the deployment looks:</p> <p> OpenVidu High Availability Architecture with Network Load Balancer </p> <ul> <li>The Load Balancer must be a Network Load Balancer that supports TCP and UDP traffic.</li> <li>The Load Balancer distributes traffic across all Master Nodes.</li> <li>If RTMP or TURN with TLS is enabled, the Load Balancer must also distribute traffic across all Media Nodes. (You can use a different Load Balancer for this purpose)</li> <li>WebRTC traffic (SRTP/SCTP/STUN/TURN) is routed directly to the Media Nodes.</li> </ul> <p>For the Master Node, the following services are configured:</p> <ul> <li>OpenVidu Dashboard, a web application interface to visualize your Rooms, Ingress, and Egress services.</li> <li>MinIO as an S3 storage service for recordings.</li> <li>Redis as a shared database for OpenVidu Server PRO and Ingress/Egress services.</li> <li>MongoDB as a database for storing analytics and monitoring data.</li> <li>Caddy as an internal reverse proxy for all services.</li> <li>OpenVidu V2 Compatibility (v2compatibility module) is an optional service that provides an API designed to maintain compatibility for applications developed with OpenVidu version 2.</li> <li>OpenVidu Call (Default Application module), an optional ready-to-use videoconferencing application.</li> <li>Grafana, Mimir, Promtail, and Loki (Observability module) form an optional observability stack for monitoring, allowing you to keep track of logs and deployment statistics for OpenVidu.</li> </ul> <p>For the Media Nodes, the following services are configured:</p> <ul> <li>OpenVidu Server PRO (LiveKit compatible).</li> <li>Ingress and Egress services.</li> <li>Prometheus, Promtail, and Loki (Observability module). Used to send metrics and logs to the observability stack.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/#prerequisites","title":"Prerequisites","text":"<ul> <li>At least 6 machines:<ul> <li>4 machines for the Master Nodes.</li> <li>2 machines for the Media Nodes.</li> </ul> </li> <li>Each machine must have:<ul> <li>A minimum of 4GB RAM and 4 CPU cores.</li> <li>Linux installed (Ubuntu is recommended).</li> </ul> </li> <li>Significant disk space in all the Master Nodes, with 100GB recommended, especially if you plan to record your sessions (Egress). Media Nodes require less space; however, account for the space needed for ongoing recordings on these nodes.</li> <li>Media Nodes must have a public IP. This is required because Media traffic is sent directly to these nodes. Master Nodes can have private IPs and will be accessed through the Load Balancer.</li> <li>A Load Balancer that supports TCP and UDP traffic. You can use a hardware load balancer or a software load balancer like HAProxy, Nginx, or AWS Network Load Balancer.</li> <li>A Fully Qualified Domain Name (FQDN) pointing to the Load Balancer. This domain name will be used to access the OpenVidu services.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/#port-rules-master-nodes","title":"Port rules (Master Nodes)","text":"<p>Ensure all these rules are configured in your firewall, security group, or any kind of network configuration that you have in your Master Nodes:</p> <p>Inbound port rules:</p> Protocol Ports Source Description TCP 7880 Load Balancer Allows access to the following to the Load Balancer: <ul><li>Livekit API.</li><li>OpenVidu v2 Compatibility API</li><li>OpenVidu Dashboard.</li><li>OpenVidu Call (Default Application).</li><li>WHIP API.</li><li>TURN with TLS.</li><li>Custom layouts</li></ul> TCP 7946-7947 Master Nodes (Optional) For Mimir and Loki cluster communication (Observability module). TCP 9095-9096 Master Nodes (Optional) For Mimir and Loki cluster communication (Observability module). TCP 3100 Media Nodes (Optional) For Loki (Observability module). TCP 9009 Media Nodes (Optional) For Mimir (Observability module). TCP 4443 Media Nodes (Optional) For OpenVidu V2 compatibility service. TCP 6080 Media Nodes (Optional) For OpenVidu Call (Default Application). TCP 7000-7001 Master Nodes, Media Nodes For internal Redis communication TCP 9100 Master Nodes, Media Nodes For internal Minio communication TCP 20000 Master Nodes, Media Nodes For internal Mongo communication <p>Outbound port rules:</p> <p>Typically, all outbound traffic is allowed.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/#port-rules-media-nodes","title":"Port rules (Media Nodes)","text":"<p>Ensure all these rules are configured in your firewall, security group, or any kind of network configuration that you have in your Media Nodes:</p> <p>Inbound port rules:</p> Protocol Ports Source Description UDP 443 0.0.0.0/0, ::/0 STUN/TURN over UDP. TCP 7881 0.0.0.0/0, ::/0 (Optional), only needed if you want to allow WebRTC over TCP. UDP 7885 0.0.0.0/0, ::/0 (Optional). Only needed if you want to ingest WebRTC using WHIP. UDP 50000-60000 0.0.0.0/0, ::/0 WebRTC Media traffic. TCP 1935 Load Balancer (Optional). Only needed if you want to ingest RTMP streams using Ingress service. Master Nodes need access to this port to reach Ingress RTMP service and expose it using TLS (RTMPS). TCP 5349 Load Balancer (Optional). Only needed if you want to expose TURN service with TLS. Master Nodes need access to this port to reach TURN service and expose it using TLS (TURNS). TCP 7880 Master Nodes LiveKit API. Master Nodes need access to load balance LiveKit API and expose it through HTTPS. TCP 8080 Master Nodes (Optional). Only needed if you want to ingest WebRTC streams using WHIP. Master Nodes need access to this port to reach WHIP HTTP service."},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/#guided-installation","title":"Guided Installation","text":"<p>Before the installation, ensure that all your machines meet the prerequisites and the port rules for the Master Nodes and Media Nodes are correctly configured.</p> <p>To install OpenVidu High Availability, begin by generating the commands required for setting up all nodes in the cluster. This is a simple and straightforward process; simply run the following command on any machine that has Docker installed:</p> <pre><code>docker run -it openvidu/openvidu-installer:latest \\\n    --deployment-type=ha\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>A wizard will guide you through the installation process. You will be asked for the following information:</p> <ul> <li>Write all 'Master Node' Private IPs separated by commas: Write the private IP of each Master Node separated by commas.</li> <li>Write your OpenVidu PRO License: Write your OpenVidu PRO License.</li> </ul> <p>Info</p> <p>If you don't have a license key for OpenVidu PRO, you can get a 15-day free trial license key by creating an OpenVidu account.</p> <ul> <li>Do you want to use an external load balancer?: Select Yes. We will use a Network Load Balancer in front of the cluster.</li> <li>Domain name: The domain name for your deployment. It must be an FQDN pointing to the machine where you are deploying OpenVidu.</li> <li>(Optional) TURN domain name: The domain name for your TURN server with TLS. It must be an FQDN pointing to the Load Balancer you will use and must be different from the OpenVidu domain name. Recommended if users who are going to connect to your OpenVidu deployment are behind restrictive firewalls.</li> <li> <p>Select which RTC engine to use: Select the WebRTC engine you want to use. You can choose between Pion (The engine used by Livekit) or Mediasoup (Experimental).</p> <p>Warning</p> <p>mediasoup integration in OpenVidu is experimental, and should not be used in production environments. There are some limitations that are currently being worked on, expected to be ironed out in the near future.</p> </li> <li> <p>Modules to enable: Select the modules you want to enable. You can enable the following modules:</p> <ul> <li>Observability: Grafana stack, which includes logs and monitoring stats.</li> <li>Default App: OpenVidu Call, a ready-to-use videoconferencing application.</li> <li>OpenVidu V2 Compatibility: Compatibility API for applications developed with OpenVidu v2.</li> </ul> </li> </ul> <p>The rest of the parameters are secrets, usernames, and passwords. If empty, the wizard will generate random values for them.</p> <p>This command will output the following instructions, which you should follow:</p> <ol> <li>Firewall Configuration for 'Master Nodes': These rules are the same as the ones specified in the instructions. Depending on the modules you have selected, some rules defined at Port rules (Master Nodes) may not appear (Optional ports). Double-check and modify them if you see something that can be enabled/disabled in your current port rules.</li> <li> <p>Installation Commands for 'Master Nodes': This is the command needed to install your Master Node. It should look like this:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_master_node.sh) \\\n    --no-tty --install \\\n    --deployment-type='ha' \\\n    --node-role='master-node' \\\n...\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Execute that command on all your Master Nodes to install them. When the installation process finishes, you will see the following output:</p> <pre><code>&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n&gt;                                                                             &lt;\n&gt;  \ud83c\udf89\ud83c\udf89 OpenVidu HA 'Master Node' Installation Finished Successfully! \ud83c\udf89\ud83c\udf89    &lt;\n&gt;                                                                             &lt;\n&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n</code></pre> <p>The Master Node will be installed in <code>/opt/openvidu</code> and configured as a systemd service. To start the service, use the following command:</p> <pre><code>systemctl start openvidu\n</code></pre> <p>Your Master Nodes will be ready once all of them have been started.</p> </li> <li> <p>Firewall Configuration for 'Media Nodes': These rules are the same as the ones defined previously as with Master Nodes. Double-check the Port rules (Media Nodes) and modify them if you see something that can be enabled/disabled in your current port rules.</p> </li> <li> <p>Installation Commands for 'Media Nodes': This is the command needed to install your Media Nodes. It should look like this:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_media_node.sh) \\\n    --no-tty --install \\\n    --deployment-type='ha' \\\n    --node-role='media-node' \\\n...\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Execute that command on your Media Nodes to install them. When the installation process finishes, you will see the following output:</p> <pre><code>&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n&gt;                                                                             &lt;\n&gt;  \ud83c\udf89 OpenVidu HA 'Media Node' Installation Finished Successfully! \ud83c\udf89         &lt;\n&gt;                                                                             &lt;\n&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n</code></pre> <p>The Media Node in each machine will be installed at <code>/opt/openvidu</code> and configured as a systemd service. You can start the service with the following command:</p> <pre><code>systemctl start openvidu\n</code></pre> </li> </ol> <p>If everything goes well, all containers will be up and running without restarts, and you will be able to access any of the following services:</p> <ul> <li>OpenVidu Call (Default Application): https://openvidu.example.io/</li> <li>OpenVidu Dashboard: https://openvidu.example.io/dashboard</li> <li>MinIO: https://openvidu.example.io/minio-console</li> <li>Grafana: https://openvidu.example.io/grafana</li> </ul> <p>OpenVidu Server PRO URL (LiveKit compatible) will be available also in:</p> <ul> <li>OpenVidu Server PRO: https://openvidu.example.io/</li> <li>LiveKit API: https://openvidu.example.io/ and wss://openvidu.example.io/</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/#load-balancer-configuration","title":"Load Balancer Configuration","text":"<p>To configure the Load Balancer, you must create a new TCP listener for each port that the Master Nodes use. The Load Balancer should be set up to distribute traffic evenly across all Master Nodes, targeting their private IP addresses. Additionally, optional features like RTMP and TURN with TLS should be directed to use the private IP addresses of the Media Nodes. This ensures that traffic for these services is properly routed to the Media Nodes.</p> <p>Below is an example using NGINX as a Load Balancer:</p> NGINX Load Balancer ConfigurationNGINX Load Balancer Configuration (With TLS for TURN) <p>Example configuration for NGINX Load Balancer:</p> <pre><code>events {\n    worker_connections 10240;\n}\n\nstream {\n\n    upstream openvidu_master_nodes {\n        server &lt;MASTER_NODE_IP_1&gt;:7880;\n        server &lt;MASTER_NODE_IP_2&gt;:7880;\n        server &lt;MASTER_NODE_IP_3&gt;:7880;\n        server &lt;MASTER_NODE_IP_4&gt;:7880;\n    }\n\n    # Optional: Only if you want to ingest RTMP\n    upstream openvidu_media_nodes_rtmp {\n        server &lt;MEDIA_NODE_IP_1&gt;:1935;\n        server &lt;MEDIA_NODE_IP_2&gt;:1935;\n        # Add more media nodes if needed\n    }\n\n    server {\n        listen 443 ssl;\n        server_name openvidu.example.com;\n        ssl_protocols       TLSv1.2 TLSv1.3;\n        ssl_certificate     /etc/nginx/ssl/openvidu-cert.pem;\n        ssl_certificate_key /etc/nginx/ssl/openvidu-key.pem;\n\n        proxy_connect_timeout 10s;\n        proxy_timeout 30s;\n\n        proxy_pass openvidu_master_nodes;\n    }\n\n    # Optional: Only if you want to ingest RTMP\n    server {\n        listen 1935 ssl;\n        server_name openvidu.example.com;\n        ssl_protocols       TLSv1.2 TLSv1.3;\n        ssl_certificate     /etc/nginx/ssl/openvidu-cert.pem;\n        ssl_certificate_key /etc/nginx/ssl/openvidu-key.pem;\n\n        proxy_connect_timeout 10s;\n        proxy_timeout 30s;\n\n        proxy_pass openvidu_media_nodes_rtmp;\n    }\n\n}\n</code></pre> <ul> <li>Notice that <code>openvidu.example.com</code> is the domain name you have chosen for your OpenVidu deployment and you should configure it in your DNS to point to the Load Balancer. Also, the <code>openvidu-cert.pem</code> and <code>openvidu-key.pem</code> must be valid SSL certificates for your domain.</li> <li>Replace <code>&lt;MASTER_NODE_IP_X&gt;</code> with the private IP addresses of your Master Nodes and <code>&lt;MEDIA_NODE_IP_X&gt;</code> with the private IP addresses of your Media Nodes.</li> </ul> <p>Example configuration for NGINX Load Balancer:</p> <pre><code>events {\n    worker_connections 10240;\n}\n\nstream {\n\n    upstream openvidu_master_nodes {\n        server &lt;MASTER_NODE_IP_1&gt;:7880;\n        server &lt;MASTER_NODE_IP_2&gt;:7880;\n        server &lt;MASTER_NODE_IP_3&gt;:7880;\n        server &lt;MASTER_NODE_IP_4&gt;:7880;\n    }\n\n    # Optional: Only if you want to ingest RTMP\n    upstream openvidu_media_nodes_rtmp {\n        server &lt;MEDIA_NODE_IP_1&gt;:1935;\n        server &lt;MEDIA_NODE_IP_2&gt;:1935;\n        # Add more media nodes if needed\n    }\n\n    upstream turn_tls {\n        server &lt;MEDIA_NODE_IP_1&gt;:5349;\n        server &lt;MEDIA_NODE_IP_2&gt;:5349;\n        # Add more media nodes if needed\n    }\n\n    map $ssl_server_name $targetBackend {\n        openvidu.example.com openvidu_master_nodes;\n        turn.example.com turn_tls;\n    }\n\n    map $ssl_server_name $targetCert {\n        openvidu.example.com /etc/nginx/ssl/openvidu-cert.pem;\n        turn.example.com /etc/nginx/ssl/turn-cert.pem;\n    }\n\n    map $ssl_server_name $targetCertKey {\n        openvidu.example.com /etc/nginx/ssl/openvidu-key.pem;\n        turn.example.com /etc/nginx/ssl/turn-key.pem;\n    }\n\n    server {\n        listen 443 ssl;\n        ssl_protocols       TLSv1.2 TLSv1.3;\n        ssl_certificate     $targetCert;\n        ssl_certificate_key $targetCertKey;\n\n        proxy_connect_timeout 10s;\n        proxy_timeout 30s;\n\n        proxy_pass $targetBackend;\n    }\n\n    # Optional: Only if you want to ingest RTMP\n    server {\n        listen 1935 ssl;\n        ssl_protocols       TLSv1.2 TLSv1.3;\n        ssl_certificate     $targetCert;\n        ssl_certificate_key $targetCertKey;\n\n        proxy_connect_timeout 10s;\n        proxy_timeout 30s;\n\n        proxy_pass openvidu_media_nodes_rtmp;\n    }\n\n}\n</code></pre> <ul> <li>Notice that <code>openvidu.example.com</code> is the domain name you have chosen for your OpenVidu deployment and <code>turn.example.com</code> is the domain name you have chosen for your TURN with TLS. Both domains should be configured in your DNS to point to the Load Balancer. Also, the <code>openvidu-cert.pem</code>, <code>openvidu-key.pem</code>, <code>turn-cert.pem</code>, and <code>turn-key.pem</code> must be valid SSL certificates for your domains.</li> <li>Replace <code>&lt;MASTER_NODE_IP_X&gt;</code> with the private IP addresses of your Master Nodes and <code>&lt;MEDIA_NODE_IP_X&gt;</code> with the private IP addresses of your Media Nodes.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/#deployment-credentials","title":"Deployment Credentials","text":"<p>To point your applications to your OpenVidu deployment, check the file at <code>/opt/openvidu/.env</code> of any Master Node. All access credentials of all services are defined in this file.</p> <p>Your authentication credentials and URL to point your applications would be:</p> <ul> <li> <p>Applications developed with LiveKit SDK:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_OR_PUBLIC_IP</code> as a URL. It could be <code>wss://openvidu.example.io/</code> or <code>https://openvidu.example.io/</code> depending on the SDK you are using.</li> <li>API Key: The value in <code>.env</code> of <code>LIVEKIT_API_KEY</code></li> <li>API Secret: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> <li> <p>Applications developed with OpenVidu v2:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_OR_PUBLIC_IP</code> as a URL. For example, <code>https://openvidu.example.io/</code></li> <li>Username: <code>OPENVIDUAPP</code></li> <li>Password: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul> </li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/#non-interactive-installation","title":"Non-interactive installation","text":"<p>To automate the installation process, you just need to execute the specified command in the Guided Installation section and execute the generated commands.</p> <p>Each installation command for each type of node looks like this:</p> Master NodeMedia Node <p>To install a Master Node, you can use the following command:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_master_node.sh) \\\n    --node-role='master-node' \\\n    --master-node-private-ip-list='10.5.0.1,10.5.0.2,10.5.0.3,10.5.0.4' \\\n    --openvidu-pro-license='xxxxx' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --mongo-replica-set-key='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --external-load-balancer\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Notes:</p> <ul> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> <li><code>--master-node-private-ip-list</code> is the list of private IPs of all Master Nodes separated by commas. It should not change, and Media Nodes should be able to reach all Master Nodes using these IPs.</li> </ul> <p>To install a Media Node, you can use the following command:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/pro/ha/latest/install_ov_media_node.sh) \\\n    --node-role='media-node' \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --master-node-private-ip-list='10.5.0.1,10.5.0.2,10.5.0.3,10.5.0.4' \\\n    --openvidu-pro-license='xxxxx' \\\n    --rtc-engine='pion' \\\n    --enabled-modules='observability,v2compatibility,app' \\\n    --turn-domain-name='openvidu.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <ul> <li>Depending on the RTC engine, the argument <code>--rtc-engine</code> can be <code>pion</code> or <code>mediasoup</code>.</li> <li><code>--master-node-private-ip</code> must be the same list of private IPs of all Master Nodes separated by commas. It should not change, and Media Nodes should be able to reach all Master Nodes using these IPs.</li> <li>If no media appears in your conference, reinstall specifying the <code>--public-ip</code> parameter with your machine's public IP. OpenVidu usually auto-detects the public IP, but it can fail. This IP is used by clients to send and receive media.</li> <li><code>--openvidu-pro-license</code> is mandatory. You can get a 15-day free trial license key by creating an OpenVidu account.</li> </ul> <p>You can run these commands in a CI/CD pipeline or in a script to automate the installation process.</p> <p>Some general notes about all commands:</p> <ul> <li>The argument <code>--turn-domain-name</code> is optional. You define it only if you want to enable TURN with TLS in case users are behind restrictive firewalls.</li> <li>In the argument <code>--enabled-modules</code>, you can enable the modules you want to deploy. You can enable <code>observability</code> (Grafana stack), <code>app</code> (Default App - OpenVidu Call), and <code>v2compatibility</code> (OpenVidu v2 compatibility API).</li> </ul> <p>To start each node, remember to execute the following command in each node:</p> <pre><code>systemctl start openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/ha/on-premises/install-nlb/#configuration-and-administration","title":"Configuration and administration","text":"<p>Once you have OpenVidu deployed, you can check the Configuration and Administration section to learn how to manage your OpenVidu High Availability deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/","title":"Production ready","text":"<p>OpenVidu is designed to be self-hosted, whether it is on premises or in a cloud provider. It brings to your own managed service advanced capabilities usually reserved only for SaaS solutions. There are two main reasons why you may need to self-host the real-time solution yourself:</p> <ul> <li>Privacy: you can't afford to let your client's data get out of your reach. OpenVidu allows you to meet all your privacy and regulatory requirements: no data at all is sent to any third-party server. Everything is self-contained on your own servers.</li> <li>Leverage your resources: your organization has access to its own infrastructure that can be used to host these services. SaaS solutions generally offer complete freedom from infrastructure management, but this comes with generally high prices that cover both the provider's infrastructure and their service surcharge. OpenVidu allows taking full advantage of your own infrastructure, reducing costs and increasing performance.</li> </ul> <p>It is important to mention that when we talk about self-hosting OpenVidu, we don't just mean installing it in bare-metal servers or private VPCs. OpenVidu also supports deployments in the most popular cloud providers, using their native services when possible. AWS is now supported, and others are coming soon. You can learn more about the different options to deploy OpenVidu in the deployment types section.</p> <p>One of OpenVidu's main goals is offering a self-hosted, production-ready live-video platform with all the advanced capabilities typically reserved for SaaS solutions. This includes outstanding performance, scalability, fault tolerance and observability:</p> <ul> <li> <p> Performance</p> <p>OpenVidu is built to be incredibly powerful. It is based on the best open source WebRTC stacks: LiveKit and mediasoup. By combining the best of both worlds, OpenVidu provides outstanding performance.</p> <p> Learn more about performance</p> </li> <li> <p> Scalability</p> <p>OpenVidu has been designed from the outset with scalability in mind. Host videoconference rooms and large live streams with hundreds of participants. Autoscale your cluster to adapt to the demand and optimize your resources.</p> <p> Learn more about scalability</p> </li> <li> <p> Fault Tolerance</p> <p>OpenVidu offers fault tolerance in all its components. Deploy a reliable high-availability cluster knowing that if one of your node goes down, others will be able to continue working with no downtime.</p> <p> Learn more about fault tolerance</p> </li> <li> <p> Observability</p> <p>OpenVidu brings everything necessary to monitor the status, health, load and history of your deployment. It automatically collects events, metrics and logs, and provides OpenVidu Dashboard and a Grafana stack to navigate them.</p> <p> Learn more about observability</p> </li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/","title":"Fault Tolerance","text":"<p>Real-time media is particularly sensitive to downtime events, as they directly affect the user experience in a very disruptive way. OpenVidu is designed from the ground up to be fault tolerant in all its services in case of node downtime, especially in its High Availability deployment.</p> <p>The extent of fault tolerance depends on the OpenVidu deployment type:</p> <ul> <li>OpenVidu Single Node: it is not fault tolerant. Fault tolerance requires a multi-node deployment.</li> <li>OpenVidu Elastic: fault tolerant only for Media Nodes.</li> <li>OpenVidu High Availability: fault tolerant for both Media Nodes and Master Nodes.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#fault-tolerance-in-openvidu-elastic","title":"Fault tolerance in OpenVidu Elastic","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#master-node","title":"Master Node","text":"<p>An OpenVidu Elastic deployment has a single Master Node, so a failure on this node is fatal and any ongoing video Rooms will be interrupted. The service won't be restored until the Master Node is recovered.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#media-nodes","title":"Media Nodes","text":"<p>You can have any number of Media Nodes in an OpenVidu Elastic deployment. Media Nodes are stateless, meaning that they do not store critical information about the Rooms, Egress or Ingress processes they are handling. This means that they can be easily replicated in any other Media Node in case of a failure.</p> <p>In the event of a Media Node failure, there are 3 services affected with the following behaviors:</p> <ul> <li>Active Rooms hosted by the failed Media Node will suffer a temporary interruption of about 5 seconds (this is the time the clients take to realize the Media Node has crashed). After that time has elapsed, the Room will be automatically reconstructed in a healthy Media Node. Every participant and track will be recreated and the Room will be fully operational again.</li> <li>Active Egress hosted by the failed Media Node will be interrupted. If the node's disk is still accessible, egress output files can still be recovered. See Recovering Egress from node failures.</li> <li>Active Ingress hosted by the failed Media Node will be interrupted. The participants of the Room will receive the proper events indicating the Ingress participant has left the Room: <code>TrackUnpublished</code> and <code>ParticipantDisconnected</code>. Some famous tools for streaming such as OBS Studio will automatically try to reconnect the stream when they detect a connection loss, so in this case interruption will be minimal and the Ingress tracks will be restored on their own on a healthy Media Node.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#fault-tolerance-in-openvidu-high-availability","title":"Fault tolerance in OpenVidu High Availability","text":"<p>OpenVidu High Availability delivers the highest possible degree of fault tolerance. This is achieved by running all of the services in the Master Nodes and the Media Nodes in their High Availability flavour.</p> <p>An OpenVidu High Availability deployment runs Master Nodes and Media Nodes in separated groups. Let's see the extent of fault tolerance for each node group:</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#master-nodes","title":"Master Nodes","text":"<p>The number of Master Nodes in an OpenVidu High Availability deployment is 4. This minimum number of nodes ensures that every service running in the Master Nodes is fault tolerant.</p> <p>If one Master Node fails, the service won't be affected. Some users may trigger event <code>Reconnecting</code> closely followed by <code>Reconnected</code>, but the service will remain fully operational.</p> <p>When two or more Master Nodes fail simultaneously, there can be some degradation of the service:</p> <ul> <li>If two Master Nodes fail, the service will still be operational for the most part. Only active Egress might be affected, as they won't be stored in the Minio storage. See Recovering Egress from node failures.</li> <li>If three or four Master Nodes fail, the service will be interrupted.</li> </ul> <p>In the event of Master Node failures, the service will be automatically restored as soon as the failed node(s) are recovered.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#media-nodes_1","title":"Media Nodes","text":"<p>Fault tolerance of Media Nodes in OpenVidu Elastic behaves the same as in OpenVidu High Availability.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#recovering-egress-from-node-failures","title":"Recovering Egress from node failures","text":"<p>Egress processes can be affected by the crash of a Master Node or a Media Node. To recover Egress from...</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#from-master-node-failures","title":"From Master Node failures","text":"<p>This only applies to OpenVidu High Availability</p> <p>If 2 Master Nodes crash, the Egress process won't be able to use the Minio storage. This has different consequences depending on the configured outputs for your Egress process:</p> <ul> <li>For MP4, OGG or WEBM files, if the Egress is stopped when 2 Master Nodes are down, the output files will not be uploaded to Minio.</li> <li>For HLS, the segments will stop being uploaded to Minio. If you are consuming these segments from another process, note that new segments will stop appearing.</li> </ul> <p>In both cases, files are not lost and can be recovered. They will be available in the Egress backup path of the Media Node hosting the Egress process (by default <code>/opt/openvidu/egress_data/home/egress/backup_storage</code>).</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/fault-tolerance/#from-a-media-node-failure","title":"From a Media Node failure","text":"<p>This applies to both OpenVidu High Availability and OpenVidu Elastic</p> <p>If the Media Node hosting an ongoing Egress process crashes, then the Egress process will be immediately interrupted. But as long as the disk of the crashed Media Node is still accessible, you may recover the output files. They will be available in the Media Node at path <code>/opt/openvidu/egress_data/home/egress/tmp</code>.</p> <p>It is possible that if the crashed Egress had MP4 as configured output (which is an option available for Room Composite and Track Composite) the recovered file may not be directly playable and it may require a repair process.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/","title":"Performance","text":"<p>Warning</p> <p>mediasoup integration in OpenVidu is experimental, and should not be used in production environments. There are some limitations that are currently being worked on, expected to be ironed out in the near future.</p> <p>OpenVidu is able to handle up to 2x the load in a single server, doubling the amount of media Tracks that can be transmitted compared to base LiveKit. By not only building upon the giant Open-Source shoulders of LiveKit, but also pushing the bar further, OpenVidu uses the best-in-class technologies to bring considerable performance improvements to the table.</p> <p>The key element of any WebRTC server solution is the ability to exchange media between participants of a room, in the so-called WebRTC SFU. LiveKit implements its own SFU, and that's where OpenVidu makes a different choice by using mediasoup.</p> <p>The key points of how this works are:</p> <ul> <li>On the surface, OpenVidu is the same than LiveKit, and for the most part features work equally, such as connection establishment, participant management, and SDK support.</li> <li>Internally however, mediasoup is used to replace the original WebRTC engine implementation of LiveKit. mediasoup is built with the most efficient technologies and has outstanding low-level optimizations, which translates in a 2x improvement with respect to the original LiveKit Open Source performance.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#about-mediasoup-integration","title":"About mediasoup integration","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#architecture","title":"Architecture","text":"<p>LiveKit created its own WebRTC SFU, based on the Pion library to route media between participants:</p> <p></p> <p>OpenVidu is built by a team of expert WebRTC developers who know all the ins and outs of low-level WebRTC development, so it was possible to replace LiveKit's own implementation with an alternative, and mediasoup was the clear best choice given its fantastic performance characteristics:</p> <p></p> <p>This means that applications built on top of LiveKit will continue to work exactly the same, while the internal WebRTC engine inside the server can be swapped at will and applications can benefit from that change, without having to be rebuilt.</p> <p>In terms of the signaling protocol, API and SDKs, OpenVidu maintains the original LiveKit implementation. LiveKit's API is very well designed, with a simple but powerful set of concepts, and the amount of SDKs available is very large.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#choice-of-technology","title":"Choice of technology","text":"<p>Both LiveKit and Pion are written in the Go programming language, and this has some implications for speed and efficiency. While Go is popular for its simplicity, readability, and approach to concurrency, when it comes to performance other alternatives rank higher in common benchmarks.</p> <p>First and foremost, the two most defining limitations of Go is that it requires a quite heavy runtime that is able to handle all of the low-level features of the language, such as goroutines and memory allocations. Also, speaking of memory management, Go requires a Garbage Collector, which knowledgeable readers will recognize as a hindrance for performance-critical applications.</p> <p>mediasoup, on the other hand, focuses all of its efforts on maximum efficiency. It is written in C++, and it is ultra-optimized for the specific task of routing media packets. C++ is a language that provides fully manual management of all resources, and direct access to the hardware, with the benefit of software that is as fast as it can be on any machine.</p> <p>We believe that by combining the best of the LiveKit stack with a top-notch WebRTC engine like mediasoup, OpenVidu is the best option for those who need a self-hosted and high-performance real-time solution.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#limitations","title":"Limitations","text":"<p>OpenVidu developers are hard at work with integrating mediasoup as a WebRTC engine within LiveKit, aiming to provide feature parity with the original Pion engine.</p> <p>There are, for now, some limitations that are expected to be ironed out over time:</p> <ul> <li>Data messages are not supported (LiveKit reference).</li> <li>No Ingress (LiveKit reference).</li> <li>No support for Speaker Detection events (LiveKit reference).</li> <li>No <code>ConnectionQualityChanged</code> event (LiveKit reference).</li> <li>No support for Dynacast (LiveKit reference).</li> <li>No support for Adaptive Streaming (LiveKit reference).</li> <li>Compatibility with OpenVidu v2 applications is limited with mediasoup. If your OpenVidu deployment is using module <code>v2compatibility</code>, do not use mediasoup.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#benchmarking","title":"Benchmarking","text":"<p>Numerous load tests have been performed to determine the true capabilities of OpenVidu on different hardware. To do so we have developed the tool Openvidu LoadTest: an in development project that aims to improve the precision of load and performance tests in WebRTC systems.</p> <p>We have compared OpenVidu using the original Pion WebRTC engine (this is the default LiveKit Open Source implementation) and using mediasoup as WebRTC engine. We tested the performance for both cases in the scenario below.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#results-conference-rooms","title":"Results: Conference rooms","text":"<p>This tests increasingly adds Rooms of 8 Participants each, every one sending 1 video Track and 1 audio Track, and subscribing to all remote Tracks.</p> <p>The following plot shows the number of Participants that can be added to a Room in OpenVidu using Pion and using mediasoup as WebRTC engines:</p> <p></p> <p>The conclusion is that for multiple Rooms, mediasoup performs much better than Pion, almost doubling the total number of Participants (and Tracks) that fit in the server.</p> <p>Below there is the deatiled connection progression for each Participant in each test.</p> <p>The X axis reflects the point of time in seconds. For each Participant there is a bar indicating its connection status:</p> <ul> <li>An orange bar indicates that the browser is up, but the connection to the media server is still in progress.</li> <li>A green bar indicates that the connection is up and running.</li> <li>A red bar indicates that the connection has failed, indicating the time that it's down.</li> </ul> <p>CPU load of the server is also shown with a black marked plot (from 0 to 1, representing 0% to 100% CPU load).</p> <p></p> Progression of the connection of each Participant through the test execution. Benchmark test for Rooms with 8 Participants using OpenVidu with Pion <p></p> Progression of the connection of each Participant through the test execution. Benchmark test for Rooms with 8 Participants using OpenVidu with mediasoup"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#benchmarking-technical-details","title":"Benchmarking technical details","text":"<ul> <li>Each participant sending video and audio to the media server uses the following video in loop: Video. The video is in <code>YUV4MPEG2</code> format and with a <code>640x480</code> resolution. The audio is in WAV format: Audio.</li> <li>All tests were done using AWS EC2 instances. The media server runs with a <code>m6in.xlarge</code> instance type, an instance type with 4 vCPUs and better network capabilities compared to other instance types.</li> <li>The workers running the browsers that act as participants ran in <code>c5.xlarge</code> instances, an instance type with 4 vCPUs with better computing capabilities.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#benchmarking-methodology","title":"Benchmarking methodology","text":"<p>Each test begins with no participants on the media server. First, the test controller creates EC2 instances to host the browsers. The controller then sends a request to create a number of participants (this number is known as the batch size). After each browser sends confirmation to the controller that it is connected, the controller sends another request to add more participants (as many participants as the batch size specifies). A participant is considered connected to the room if:</p> <ul> <li>If the participants sends video and audio, the participant is connected after confirming that both local tracks are being sent correctly.</li> <li>If the participant acts as viewer (is only receiving video and audio from a different participant), the participant is connected when it confirms that it is receiving at least both tracks from a user in the room.</li> </ul> <p>The test stops when it determines that no more users can be added to a room. This happens when a user has 5 failed connections. A connection is considered to have failed when it terminates with a fatal error (in LiveKit this is captured when a <code>Disconnected</code> event occurs) or when the connection times out. A failure in connection can occur when trying to join a room (ending usually in timeout) or during the connection (a <code>Disconnected</code> event is thrown). Each time a failure is communicated to the controller, it will kill that browser and restart it again, effectively restarting the connection (up to 5 times, as mentioned before).</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/performance/#about-openvidu-loadtest","title":"About OpenVidu LoadTest","text":"<p>Tools like livekit-cli simulate participants directly using WebRTC SDKs, but we found out that browsers add significant more load that these kind of systems. This makes Openvidu LoadTest give results that are closer to real-world scenarios, as it uses real browsers. Using real browsers also allows for the collection of useful data related to connections, events and WebRTC statistics. On the other hand, tests performed with Openvidu LoadTest are more expensive, as they require real instances to host the browsers.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/scalability/","title":"Scalability","text":"<p>Scalability is a very broad term with implications on many levels. In the case of real-time applications, it usually refers to the number of simultaneous Rooms you can host and the maximum number of participants in each Room, or more accurately, the number of media tracks sent and received in each Room.</p> <p>OpenVidu offers scalability out-of-the-box for typical videoconferencing use cases, but also for large low-latency live streams with hundreds of viewers. With OpenVidu Elastic and OpenVidu High Availability you can easily scale your deployment to host many simultaneous videoconferences and live streams. And it is also possible to scale automatically with our autoscaling feature, so you can truly adapt your resources to the demand.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/scalability/#scalability-depending-on-the-use-case","title":"Scalability depending on the use case","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/scalability/#small-and-medium-videoconferences","title":"Small and medium videoconferences","text":"<p>OpenVidu allows you to host multiple small and medium videoconferences (up to 10 participants). The number of simultaneous rooms depends on the deployment used and the power of machines.</p> <ul> <li> <p>Single Node deployment (OpenVidu Community): In this deployment, OpenVidu can manage up to XXX simultaneous videoconferences of 10 participants in a 4 CPU server. If you need more videoconferences at the same time, you can use more powerful server. This is known as vertical scalability. The limit here is usually the maximum computational power available for a single server and the maximum network bandwidth for it.</p> </li> <li> <p>Elastic and High Availability deployments (OpenVidu Pro): In these deployments, OpenVidu is able to distribute the videoconferences in multiple media servers. This is known as horizontal scalability. In this case, the maximum number of simultaneous videoconferences depends on the number of media server used and the computational power of each of them. Also, the service used to coordinate the media servers (Redis) can be the bottleneck and limit the number of videoconferences. In High Availability deployments, Redis is distributed in 4 master nodes, so it is able to handle more load than in the Elastic deployment (with only one master node).</p> </li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/scalability/#big-live-streams","title":"Big live streams","text":"<p>Live streaming is different from a video conference. In a videoconference, usually all participants can publish audio and video. Instead, in a live stream, only one participant can publish audio and video (known as the publisher) and others can view it (known as viewers).</p> <p>OpenVidu is able to manage live streams with up to XXX viewers (1 publisher and XXX subscribers) in a single Room hosted in a server with 4 CPUs. To manage more than one live stream simultaneously, an Elastic or High Availability deployment is needed with several media servers.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/scalability/#big-videoconferences-and-massive-live-streams-working-on-it","title":"Big videoconferences and massive live streams (Working on it! )","text":"<p>For big videoconferences with many participants (in the order of 100- or even 1000-) and massive live streams with few publishers and thousands of viewers, OpenVidu will offer in the near future two distinct strategies:</p> <ul> <li>Distributing participants of one Room in multiple servers: By connecting multiple media servers between them, OpenVidu will be able to manage Rooms with unlimited number of participants and live streams with unlimited number of viewers.</li> <li>Only show last speakers: A browser or mobile app is able to show a limited number of participants. A powerful computer can visualize up to 10 simultaneous videoconference participants at the same time with high video quality. To allow big videoconferences, OpenVidu will provide features on its frontend SDKs to show only last speakers in the videoconference.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/scalability/#autoscaling","title":"Autoscaling","text":"<p>OpenVidu Elastic and OpenVidu High Availability have multiple Media Nodes to handle the load.</p> <ul> <li>Rooms are distributed among the available nodes prioritizing the less-loaded nodes.</li> <li>It is possible to dynamically add new Media Nodes to the cluster when the load increases.</li> <li>It is possible to remove Media Nodes from the cluster when the load decreases. If the Media Node is hosting ongoing Rooms, it won't accept new Rooms and will wait until the ongoing Rooms finish before terminating.</li> </ul> <p>When deploying on AWS, OpenVidu will automatically add and remove Media Nodes according to load, thanks to Auto Scaling Groups. When deploying On Premises you are responsible of monitoring the load of your Media Nodes and triggering the addition of new Media Nodes or removal of existing Media Nodes.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/","title":"Observability","text":"<p>Any production software needs to be observable. But in real-time applications this becomes an absolute priority. You must be able to:</p> <ul> <li> Detect and solve networking issues that may prevent your users from connecting to your Rooms.</li> <li> Monitor the quality of the video and audio streams, that will reflect in your users' experience.</li> <li> Analyze the load in your hardware to detect bottlenecks and scale your deployment accordingly.</li> <li> Store historical data to analyze past issues and trends to make future decisions based on them.</li> </ul> <p>OpenVidu brings everything you need to fulfill these requirements. We collect events, metrics and logs from your deployment and provide OpenVidu Dashboard and a Grafana stack to navigate them.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/","title":"Grafana Stack","text":"<p>OpenVidu also provides different Grafana dashboards to monitor metrics from OpenVidu Server and logs from your cluster.</p> <p>Grafana is available at https://your.domain/grafana/ and can be accessed using your Grafana admin credentials.</p> <p></p> <p>Dashboards can be found in the OpenVidu folder at https://your.domain/grafana/dashboards/f/openvidu-dashboards/openvidu.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/#services","title":"Services","text":"<p>The Grafana stack that comes with OpenVidu is composed of the following services:</p> <ul> <li>Grafana : Tool for querying, visualizing, alerting on and exploring metrics, logs and traces. It queries different data sources to show data in beautiful dashboards. In OpenVidu, contains all dashboards built from Mimir/Prometheus and Loki data sources to monitor OpenVidu Server and logs from your cluster.</li> <li>Prometheus : System monitoring and alerting toolkit. It collects and stores metrics from different targets as time series data. In OpenVidu, it collects metrics from OpenVidu Server of each Media Node and sends them to Mimir.</li> <li>Mimir: Grafana software project that provides multi-tenant, long-term storage for Prometheus metrics. In OpenVidu, it is used to store metrics collected by Prometheus.</li> <li>Promtail: Agent that ships the contents of local logs to a Loki instance. In OpenVidu, it is used to collect logs from all services in your cluster and send them to Loki.</li> <li>Loki: Horizontally-scalable, highly-available, multi-tenant log aggregation system inspired by Prometheus. In OpenVidu, it is used to store logs collected by Promtail.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/#dashboards","title":"Dashboards","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/#openvidu-server-metrics","title":"OpenVidu Server Metrics","text":"<p>This dashboard provides metrics about OpenVidu Server. It includes charts about active rooms, active participants, published tracks, subscribed tracks, send/receive bytes, packet loss percentage and quality score.</p> <p>In case you are using OpenVidu PRO and you have more than one Media Node deployed, you will see all metrics from all nodes combined in the same chart.</p> <p></p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/#openvidu-media-nodes-server-metrics","title":"OpenVidu Media Nodes Server Metrics","text":"<p>This dashboard is part of OpenVidu PRO edition.</p> <p>This dashboard provides the same metrics as the OpenVidu Server Metrics dashboard, but grouped by Media Node.</p> <p>You can select the Media Node you want to see metrics from in the media_node dropdown. You will see different charts in the same panel according to the selected Media Nodes.</p> <p></p> <p>Info</p> <p>If you add new Media Nodes to your OpenVidu deployment, you will have to refresh the page in order to see the new Media Nodes in the dropdown.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/#openvidu-logs","title":"OpenVidu Logs","text":"<p>In case you are using OpenVidu COMMUNITY, this dashboard provides different visualizations for logs from your OpenVidu Single Node deployment.</p> <p>There is a panel showing all containers logs,</p> <p></p> <p>another panel to filter logs by room_id and participant_id,</p> <p></p> <p></p> <p>and one row for each selected service, containing all logs, warnings and errors from that service.</p> <p></p> <p></p> <p>You can also filter logs containing a specific text by using the filter search box.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/#openvidu-cluster-nodes-logs","title":"OpenVidu Cluster Nodes Logs","text":"<p>This dashboard is part of OpenVidu PRO edition.</p> <p>In case you are using OpenVidu PRO, this dashboard provides different visualizations for logs from your OpenVidu Elastic or OpenVidu High Availability cluster, grouped by node.</p> <p>First of all, there is a panel showing all containers logs from all nodes.</p> <p></p> <p>Then, there is a row for each selected node, containing all logs, warnings and errors from that node. Besides, each row contains a panel for each selected container, showing all its logs.</p> <p></p> <p></p> <p></p> <p></p> <p>Info</p> <p>Note that some panels have no data. This is because some containers are running in Master Nodes and others in Media Nodes.</p> <p></p> <p></p> <p>You can also filter logs containing a specific text by using the filter search box.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/#openvidu-cluster-services-logs","title":"OpenVidu Cluster Services Logs","text":"<p>This dashboard is part of OpenVidu PRO edition.</p> <p>In case you are using OpenVidu PRO, this dashboard provides different visualizations for logs from your OpenVidu Elastic or OpenVidu High Availability cluster, grouped by service.</p> <p>First of all, there is a panel to filter logs by room_id and participant_id.</p> <p></p> <p></p> <p>Then, there is a row for each selected service, containing all logs, warnings and errors from that service.</p> <p></p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/grafana-stack/#limitations","title":"Limitations","text":"<p>For now, in OpenVidu High Availability deployments, we have decided to not implement Grafana in High Availability (HA) mode. This decision is based on the fact that Grafana needs a configured HA MySQL or PostgreSQL database to work in HA mode, and we want to keep the deployment as simple as possible.</p> <p>There are 4 instances of Grafana in an OpenVidu High Availability deployment, one for each Master Node, but they are not synchronized between them. Therefore, if you make any change (change your admin password, create a new dashboard...) in one Grafana instance and the Master Node suddenly goes down, you will be redirected to another Grafana instance where the changes will not be reflected. That is the reason why we disable user signups and saving dashboard or datasource modifications in Grafana.</p> <p>However, all metrics and logs from all nodes are available in all Grafana instances, so you can monitor your OpenVidu cluster without any problem.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/","title":"OpenVidu Dashboard","text":"<p>It is a web application designed to provide OpenVidu administrators with a comprehensive view of usage statistics and real-time monitoring of video Rooms. OpenVidu Dashboard is included by default in any OpenVidu deployment.</p> <p>To access OpenVidu Dashboard, go to https://your.domain/dashboard/ and log in using your admin credentials.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/#views","title":"Views","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/#analytics","title":"Analytics","text":"<p>Display graphical analytics for client SDKs, connection types, bandwidth usage, unique participants, rooms and egresses created over different time periods (last 24 hours, last 7 days, last 28 days or current month).</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/#rooms","title":"Rooms","text":"<p>Review the total count of active rooms and active participants, along with a roster of currently active rooms and a history of closed rooms within the last 28 days. Detailed information on each room is accessible by clicking on the respective row.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/#room-details","title":"Room Details","text":"<p>This view is part of OpenVidu PRO edition.</p> <p>Retrieve in-depth information about a specific room, including its duration, bandwidth consumption, participants and related events. A chart illustrating the active participants count over time is also provided.</p> <p></p> <p></p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/#participant-details","title":"Participant Details","text":"<p>This view is part of OpenVidu PRO edition.</p> <p>Obtain detailed insights into each participant, covering their duration, bandwidth usage, average audio and video quality score, information about the client they are connecting with, connection stats, published tracks and related events.</p> <p></p> <p></p> <p>A participant may connect and disconnect from a room multiple times while it remains open. Each instance of connection using the same participant identity is referred to as a <code>participant session</code>. If multiple sessions occur, we will aggregate all participant sessions together and organize them into a timeline at the top of the participant details view. You can easily switch between participant sessions by clicking on each corresponding row:</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/#egress-ingress","title":"Egress-Ingress","text":"<p>Review an overview of all egresses and ingresses, including their duration and status. Detailed information for each egress or ingress can be accessed by clicking on the respective row.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/#egress-details","title":"Egress Details","text":"<p>This view is part of OpenVidu PRO edition.</p> <p>Access comprehensive details about a specific egress, including its duration, current status, type, associated room, destinations, status timeline and request information.</p> <p></p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/production-ready/observability/openvidu-dashboard/#ingress-details","title":"Ingress Details","text":"<p>This view is part of OpenVidu PRO edition.</p> <p>Explore detailed information about a specific ingress, including its total duration, status and a list of all associated rooms.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/","title":"OpenVidu Single Node installation","text":"<p>OpenVidu Single Node is part of the COMMUNITY edition of OpenVidu. You have the following deployment options:</p> <ul> <li>On-premises Installation: Set up OpenVidu Single Node on your own servers.</li> <li>AWS Installation: Deploy OpenVidu Single Node on Amazon Web Services.</li> </ul> <p>Once your deployment is complete, refer to the following sections for configuration and management:</p> <ul> <li>On-premises: Configuration and Administration</li> <li>AWS: Configuration and Administration</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/admin/","title":"OpenVidu Single Node Configuration and Administration: AWS","text":"<p>AWS deployment of OpenVidu Single Node is internally identical to the on-premises deployment, so you can follow the same instructions from the On Premises Single Node for administration and configuration. The only difference is that the deployment is automated with AWS CloudFormation.</p> <p>However, there are certain things worth mentioning:</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/admin/#start-and-stop-openvidu-through-aws-console","title":"Start and stop OpenVidu through AWS Console","text":"<p>You can start and stop all services as explained in the On Premises Single Node section. But you can also start and stop the EC2 instance directly from the AWS Console. This will stop all services running in the instance and reduce AWS costs.</p> Stop OpenVidu Single NodeStart OpenVidu Single Node <ol> <li>Go to the EC2 Dashboard of AWS.</li> <li>Right-click on the instance you want to start and select \"Stop instance\".</li> </ol> <p> </p> <ol> <li>Go to the EC2 Dashboard of AWS.</li> <li>Right-click on the instance you want to start and select \"Start instance\".</li> </ol> <p> </p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/admin/#change-the-instance-type","title":"Change the instance type","text":"<p>You can change the instance type of the OpenVidu Single Node instance to adapt it to your needs. To do this, follow these steps:</p> <ol> <li>Stop the instance.</li> <li> <p>Right-click on the instance and select \"Instance Settings &gt; Change Instance Type\".</p> Change instance type <p> </p> </li> <li> <p>Select the new instance type and click on \"Apply\".</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/","title":"OpenVidu Single Node Installation: AWS","text":"<p>Regarding OpenVidu v2 compatibility</p> <p>OpenVidu Single Node is not compatible with OpenVidu v2 API. For having compatibility with OpenVidu v2 applications, you must use OpenVidu Elastic or OpenVidu High Availability.</p> <p>This section contains the instructions to deploy a production-ready OpenVidu Single Node deployment in AWS. Deployed services are the same as the On Premises Single Node Installation but automate the process with AWS CloudFormation.</p> <p>First of all, import the template in the AWS CloudFormation console. You can click the following button...</p> <p>Deploy OpenVidu Single Node in </p> <p>...or access your AWS CloudFormation console and manually set this S3 URL in the <code>Specify template</code> section:</p> <pre><code>https://s3.eu-west-1.amazonaws.com/get.openvidu.io/community/singlenode/latest/aws/cf-openvidu-singlenode.yaml\n</code></pre> Architecture overview <p>This is how the architecture of the deployment looks like:</p> <p> OpenVidu Single Node AWS Architecture </p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/#cloudformation-parameters","title":"CloudFormation Parameters","text":"<p>Depending on your needs, you need to fill the following CloudFormation parameters:</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/#domain-and-ssl-certificate-configuration","title":"Domain and SSL Certificate Configuration","text":"<p>These are the three possible scenarios you may have to configure in this section:</p> Let's Encrypt Certificate (recommended)Self-Signed CertificateCustom Certificates <p>For a production-ready setup, this scenario is ideal when you have an FQDN (Fully Qualified Domain Name) and an Elastic IP at your disposal. It leverages the services of Let's Encrypt to automatically generate valid certificates.</p> <p>First, you need to have the FQDN pointing to the Elastic IP you are going to use.</p> <p>Then, you need to fill in the following parameters:</p> <p></p> <p>As you can see, you need to specify the DomainName with your FQDN, the PublicElasticIP with the Elastic IP that the domain points to, and the LetsEncryptEmail with your email address for Let\u2019s Encrypt notifications. These parameters are mandatory.</p> <p>This is the most straightforward option for deploying OpenVidu on AWS when you do not have a Fully Qualified Domain Name (FQDN). This method allows for the immediate use of OpenVidu in AWS using CloudFormation.</p> <p>However, this convenience comes with the caveat that users will need to manually accept the certificate in their web browsers. Please be aware that this configuration is solely for developmental and testing purposes and is not suitable for a production environment.</p> <p>These are the parameters needed in this section to use self-signed certificates:</p> <p></p> <p>You don\u2019t need to specify any parameters; just select the CertificateType as self-signed. The domain name used will be an AWS-generated one.</p> <p>Opt for this method if you possess your own certificate for an existing FQDN. It enables you to deploy OpenVidu on AWS using your certificates.</p> <p>You need to have a Fully Qualified Domain Name (FQDN) pointing to a previously created Elastic IP.</p> <p>Also, you need a temporary HTTP server hosting your private and public certificate under a specific URL. These URLs are needed for the instance to be able to download and install your certificates.</p> <p>The configured parameters would look like this:</p> <p></p> <p>You need to specify at OwnPublicCertificate and OwnPrivateCertificate the URLs where the public and private certificates are hosted, respectively. The DomainName and PublicElasticIP are mandatory parameters.</p> <p>Certificates need to be in PEM format and the URLs must be accessible from the instance.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/#ec2-instance-configuration","title":"EC2 Instance Configuration","text":"<p>You need to specify some properties for the EC2 instance that will be created.</p> EC2 Instance configuration <p>The parameters in this section may look like this:</p> <p></p> <p>Simply select the type of instance you want to deploy at InstanceType, the SSH key you want to use to access the machine at KeyName, and the Amazon Image ID (AMI) to use at AmiId.</p> <p>By default, the parameter AmiId is configured to use the latest LTS Ubuntu AMI, so ideally you don\u2019t need to modify this.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/#optional-turn-server-configuration-with-tls","title":"(Optional) TURN server configuration with TLS","text":"<p>This section is optional. It is useful when your users are behind a restrictive firewall that blocks UDP traffic. This parameter will only works if you are using <code>letsencrypt</code> or <code>owncert</code> as the CertificateType parameter.</p> TURN server configuration with TLS <p>The parameters in this section may look like this:</p> <p></p> <p>Set the TurnDomainName parameter to the domain name you intend to use for your TURN server. It should be pointing to the <code>PublicElasticIP</code> specified in the previous section.</p> <p>If you are using <code>letsencrypt</code> as the CertificateType parameter, you can leave the TurnOwnPublicCertificate and TurnOwnPrivateCertificate parameters empty. If you are using <code>owncert</code>, you need to specify the URLs where the public and private certificates are hosted.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/#deploying-the-stack","title":"Deploying the Stack","text":"<p>When you are ready with your CloudFormation parameters, just click on \"Next\", specify in \"Stack failure options\" the option \"Preserve successfully provisioned resources\" to be able to troubleshoot the deployment in case of error, click on \"Next\" again, and finally \"Submit\".</p> <p>When everything is ready, you will see the following links in the \"Outputs\" section of CloudFormation with all deployed services.</p> CloudFormation Outputs <p></p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/#deployment-credentials","title":"Deployment Credentials","text":"<p>To point your applications to your OpenVidu deployment, check the file of the EC2 instance <code>/opt/openvidu/.env</code>. All access credentials of all services are defined in this file.</p> <p>Just point your app to the OpenViduServerURL parameter of the CloudFormation outputs and get the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> from the <code>.env</code> file to connect your app to the OpenVidu Single Node deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/#troubleshooting-initial-cloudformation-stack-creation","title":"Troubleshooting Initial CloudFormation Stack Creation","text":"<p>If something goes wrong during the initial CloudFormation stack creation, your stack may reach the <code>CREATE_FAILED</code> status for multiple reasons. It could be due to a misconfiguration in the parameters, a lack of permissions, or a problem with the AWS services. When this happens, the following steps can help you troubleshoot the issue and identify what went wrong:</p> <ol> <li> <p>While deploying the stack, make sure at \"Stack failure options\" you have selected the option \"Preserve successfully provisioned resources\" to be able to troubleshoot the deployment in case of an error.</p> Disable Rollback on failure <p> </p> </li> <li> <p>Check if the EC2 instance or instances are running. If they are not, check the CloudFormation events for any error messages.</p> </li> <li> <p>If the EC2 instance or instances are running, SSH into the instance and check the logs of the following files:</p> <ul> <li><code>/var/log/cloud-init-output.log</code></li> <li><code>/var/log/cloud-init.log</code></li> </ul> <p>These logs will give you more information about the CloudFormation stack creation process.</p> </li> <li> <p>If everything seems fine, check the status and the logs of the installed OpenVidu services.</p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/aws/install/#configuration-and-administration","title":"Configuration and administration","text":"<p>When your CloudFormation stack reaches the <code>CREATE_COMPLETE</code> status, your OpenVidu Single Node deployment is ready to use. You can check the Configuration and Administration section to learn how to manage your deployment.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/","title":"OpenVidu Single Node Configuration and Administration: On-premises","text":"<p>The OpenVidu installer offers an easy way to deploy OpenVidu Single Node on-premises. However, once the deployment is complete, you may need to perform administrative tasks based on your specific requirements, such as changing passwords, specifying custom configurations, and starting or stopping services.</p> <p>This section provides details on configuration parameters and common administrative tasks for on-premises OpenVidu Single Node deployments.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#openvidu-configuration","title":"OpenVidu configuration","text":""},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#directory-structure","title":"Directory structure","text":"<p>OpenVidu is installed at <code>/opt/openvidu/</code> and has a systemd service located at <code>/etc/systemd/system/openvidu.service</code>.</p> <p>The directory structure of OpenVidu is as follows:</p> <pre><code>|-- /opt/openvidu\n    |-- config/\n    |-- custom-layout/\n    |-- data/\n    |-- deployment-info.yaml\n    |-- docker-compose.override.yml\n    |-- docker-compose.yml\n    |-- .env\n    `-- owncert/\n</code></pre> <ul> <li><code>config/</code>: Contains the configuration files for the services deployed with OpenVidu.</li> <li><code>custom-layout/</code>: An empty directory where you can place Custom Recording Templates for the Egress service.</li> <li><code>data/</code>: Contains the data generated by the services deployed with OpenVidu.</li> <li><code>deployment-info.yaml</code>: Contains the deployment information of OpenVidu.</li> <li><code>docker-compose.override.yml</code>: Contains the service with the Default App (OpenVidu Call).</li> <li><code>docker-compose.yml</code>: Contains the main services deployed with OpenVidu.</li> <li><code>.env</code>: Contains parameters managed by multiple services.</li> <li><code>owncert/</code>: Contains the custom certificates for the Caddy server if you are using your own certificates.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#services-configuration","title":"Services Configuration","text":"<p>Some services deployed with OpenVidu have their own configuration files located in the <code>/opt/openvidu/config/</code> directory, while others are configured in the <code>.env</code> file. Below are the services and their respective configuration files and parameters:</p> <p>Info</p> <p>The installer provides default configurations that work out of the box. However, you can modify these configurations to suit your specific requirements.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#configuration-files","title":"Configuration Files","text":"Service Description Configuration File Location Reference documentation OpenVidu Server Manages video rooms. It is compatible with LiveKit configuration and includes its own OpenVidu configuration parameters <code>/opt/openvidu/config/livekit.yaml</code> LiveKit Config Ingress Service Imports video from other sources into OpenVidu rooms. <code>/opt/openvidu/config/ingress.yaml</code> LiveKit Ingress Config Egress Service Exports video from OpenVidu rooms for recording or streaming. <code>/opt/openvidu/config/egress.yaml</code> LiveKit Egress Config Caddy Server Serves OpenVidu services and handles HTTPS. <code>/opt/openvidu/config/caddy.yaml</code> Caddy JSON Structure Prometheus Service Used for monitoring. <code>/opt/openvidu/config/prometheus.yaml</code> Prometheus Config Loki Service Used for log aggregation. <code>/opt/openvidu/config/loki.yaml</code> Loki Config Promtail Service Collects logs and sends them to Loki. <code>/opt/openvidu/config/promtail.yaml</code> Promtail Config Grafana Service Used for visualizing monitoring data. <code>/opt/openvidu/config/grafana_config/</code> Grafana Config"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#environment-variables","title":"Environment Variables","text":"Service Description Environment Variables OpenVidu Server Manages video rooms. <ul><li><code>LIVEKIT_API_KEY</code>: The API key to access the LiveKit service.</li><li><code>LIVEKIT_API_SECRET</code>: The API secret to access the LiveKit service.</li></ul> If you need to change the LiveKit API key and secret after the installation, check the advanced configuration section. Grafana Service Used for visualizing monitoring data. <ul><li> <code>GRAFANA_ADMIN_USERNAME</code>: The username to access the Grafana dashboard.</li><li><code>GRAFANA_ADMIN_PASSWORD</code>: The password to access the Grafana dashboard.</li></ul> OpenVidu Dashboard Used to visualize OpenVidu Server Rooms, Ingress, and Egress services. <ul><li><code>DASHBOARD_ADMIN_USERNAME</code>: The username to access the OpenVidu Dashboard.</li><li><code>DASHBOARD_ADMIN_PASSWORD</code>: The password to access the OpenVidu Dashboard.</li></ul> Default App (OpenVidu Call) Default ready-to-use video conferencing app. <ul><li><code>CALL_PRIVATE_ACCESS</code>: If set to <code>true</code>, the app will be private and require authentication. If set to <code>false</code>, the app will be public and accessible without authentication. The user is configured with <code>CALL_USER</code> and <code>CALL_SECRET</code> parameters.</li><li><code>CALL_USER</code>: The username to access the app. This parameter is only used if <code>CALL_PRIVATE_ACCESS</code> is set to <code>true</code>.</li><li><code>CALL_SECRET</code>: The password to access the app. This parameter is only used if <code>CALL_PRIVATE_ACCESS</code> is set to <code>true</code>.</li><li><code>CALL_ADMIN_USERNAME</code>: The username to access the OpenVidu Call Admin Panel.</li><li><code>CALL_ADMIN_SECRET</code>: The password to access the OpenVidu Call Admin Panel.</li><li><code>LIVEKIT_API_KEY</code>: The API key to access the LiveKit service.</li><li><code>LIVEKIT_API_SECRET</code>: The API secret to access the LiveKit service.</li></ul> Redis Service Used as a shared memory database for OpenVidu and Ingress/Egress services. <ul><li><code>REDIS_PASSWORD</code>: The password for the Redis service.</li></ul> If you need to change the Redis password after the installation, check the advanced configuration section. MinIO Service Used for storing recordings. <ul><li><code>MINIO_ACCESS_KEY</code>: The access key for the MinIO service.</li><li><code>MINIO_SECRET_KEY</code>: The secret key for the MinIO service.</li></ul> If you need to change the MinIO access key and secret key after the installation, check the advanced configuration section. MongoDB Service Used for storing analytics and monitoring data. <ul><li><code>MONGO_ADMIN_USERNAME</code>: The username to access the MongoDB database.</li><li><code>MONGO_ADMIN_PASSWORD</code>: The password to access the MongoDB database.</li></ul> If you need to change the MongoDB username and password after the installation, check the advanced configuration section."},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#openvidu-configuration-parameters","title":"OpenVidu Configuration Parameters","text":"<p>OpenVidu Server is built on top of LiveKit and offers extra configuration options. You can find the configuration file at <code>/opt/openvidu/config/livekit.yaml</code>. The additional parameters for configuring the OpenVidu Server are:</p> <pre><code>openvidu:\n    analytics: # (1)\n        enabled: true # (2)\n        mongo_url: mongodb://&lt;MONGO_ADMIN_USERNAME&gt;:&lt;MONGO_ADMIN_PASSWORD&gt;@localhost:20000/ # (3)\n        interval: 10s # (4)\n        expiration: 768h # (5)\n</code></pre> <ol> <li>The <code>analytics</code> configuration should be defined at the <code>openvidu</code> level in the <code>livekit.yaml</code> file.</li> <li>This must be set to <code>true</code> to send analytics data to MongoDB. If set to <code>false</code>, no analytics data will be sent.</li> <li>MongoDB connection string. In OpenVidu Single Node, the MongoDB service is running on the same machine, so you can use <code>localhost</code> as the hostname. The default port in OpenVidu for MongoDB is <code>20000</code>. <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> are the credentials to access the MongoDB database.</li> <li>Time interval to send analytics data to MongoDB.</li> <li>Time to keep the analytics data in MongoDB. In this example, it is set to 32 days.</li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#starting-stopping-and-restarting-openvidu","title":"Starting, stopping, and restarting OpenVidu","text":"<p>You can start, stop, and restart the OpenVidu services using the following commands:</p> <p>Start OpenVidu</p> <pre><code>sudo systemctl start openvidu\n</code></pre> <p>Stop OpenVidu</p> <pre><code>sudo systemctl stop openvidu\n</code></pre> <p>Restart OpenVidu</p> <pre><code>sudo systemctl restart openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#checking-the-status-of-services","title":"Checking the status of services","text":"<p>You can check the status of the OpenVidu services using the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose ps\n</code></pre> <p>The services are operating correctly if you see an output similar to the following and there are no restarts from any of the services:</p> <pre><code>NAME         IMAGE                                        COMMAND                  SERVICE      CREATED          STATUS\napp          docker.io/openvidu/openvidu-call             \"docker-entrypoint.s\u2026\"   app          19 seconds ago   Up 16 seconds\ncaddy        docker.io/openvidu/openvidu-caddy            \"/bin/caddy run --co\u2026\"   caddy        19 seconds ago   Up 16 seconds\ndashboard    docker.io/openvidu/openvidu-dashboard        \"./openvidu-dashboard\"   dashboard    19 seconds ago   Up 16 seconds\negress       docker.io/livekit/egress                     \"/entrypoint.sh\"         egress       18 seconds ago   Up 14 seconds\ngrafana      docker.io/grafana/grafana                    \"/run.sh\"                grafana      18 seconds ago   Up 13 seconds\ningress      docker.io/livekit/ingress                    \"ingress\"                ingress      19 seconds ago   Up 14 seconds\nloki         docker.io/grafana/loki                       \"/usr/bin/loki -conf\u2026\"   loki         18 seconds ago   Up 14 seconds\nminio        docker.io/bitnami/minio                      \"/opt/bitnami/script\u2026\"   minio        18 seconds ago   Up 14 seconds\nmongo        docker.io/mongo                              \"docker-entrypoint.s\u2026\"   mongo        18 seconds ago   Up 15 seconds\nopenvidu     docker.io/openvidu/openvidu-server           \"/livekit-server --c\u2026\"   openvidu     19 seconds ago   Up 14 seconds\nprometheus   docker.io/prom/prometheus                    \"/bin/prometheus --c\u2026\"   prometheus   18 seconds ago   Up 14 seconds\npromtail     docker.io/grafana/promtail                   \"/usr/bin/promtail -\u2026\"   promtail     18 seconds ago   Up 14 seconds\nredis        docker.io/redis                              \"docker-entrypoint.s\u2026\"   redis        19 seconds ago   Up 15 seconds\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#checking-logs","title":"Checking logs","text":"<p>If any of the services are not working as expected, you can check the logs of the services using the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs &lt;service-name&gt;\n</code></pre> <p>Replace <code>&lt;service-name&gt;</code> with the name of the service you want to check. For example, to check the logs of the OpenVidu Server, use the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs openvidu\n</code></pre> <p>To check the logs of all services, use the following command:</p> <pre><code>cd /opt/openvidu/\ndocker compose logs\n</code></pre> <p>You can also review your logs using the Grafana dashboard provided with OpenVidu. To access it, go to https://&lt;your-domain.com&gt;/grafana and use the credentials located in <code>/opt/openvidu/.env</code> to log in. Once inside, navigate to the \"Home\" section, select \"Dashboard\", and then click on \"OpenVidu &gt; OpenVidu Logs\". All the logs will be displayed there.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#advanced-configuration","title":"Advanced Configuration","text":"<p>This section addresses advanced configuration scenarios for customizing your OpenVidu Single Node deployment. It includes automating the installation with personalized settings, enabling or disabling OpenVidu modules, and modifying global parameters such as the domain name, passwords, and API keys.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#automatic-installation-and-configuration","title":"Automatic installation and configuration","text":"<p>For environments like the cloud, where instances are frequently spun up and down, automating the application of custom configurations to OpenVidu may be useful for you.</p> <p>If you need to automate these configuration changes, you can use the following script template as an example:</p> <pre><code># 1. First install OpenVidu (1)\nsh &lt;(curl -fsSL http://get.openvidu.io/community/singlenode/latest/install.sh) \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    ... # Add the rest of the arguments\n\n# 2. Add custom configurations (2)\n######### APPLY CUSTOM CONFIGURATIONS #########\n# If you want to apply any modification to the configuration files\n# of the OpenVidu services at /opt/openvidu, you can do it in this section.\n\n# Example 1: Change public IP address announced by OpenVidu for WebRTC connections\nyq eval '.rtc.node_ip = 1.2.3.4' \\\n    -i /opt/openvidu/config/livekit.yaml\n\n# Example 2: Add a webhook to LiveKit\nyq eval '.webhook.urls += [\"http://new-endpoint.example.com/webhook\"]' \\\n    -i /opt/openvidu/config/livekit.yaml\n\n######### END CUSTOM CONFIGURATIONS #########\n\n# 3. Start OpenVidu # (3)\nsystemctl start openvidu\n</code></pre> <ol> <li>First, install OpenVidu using the OpenVidu installer. Check the installation guide for more information.</li> <li>Add the custom configurations you need to apply to the OpenVidu services. You can use <code>yq</code> or other tools to modify the configuration files. You can find more information about <code>yq</code> here.</li> <li>Start OpenVidu to apply the changes.</li> </ol> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Just install OpenVidu first with the installer and then run some extra commands to apply the custom configurations. This way, you can automate the process of installing OpenVidu and applying custom configurations.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#enabling-and-disabling-openvidu-modules","title":"Enabling and disabling OpenVidu modules","text":"<p>The <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file allows you to enable or disable specific modules in OpenVidu. The following modules can be enabled or disabled:</p> Observability moduleApp module (Default App) <p>Enabling the <code>observability</code> module</p> <p>In case you have installed OpenVidu with the <code>observability</code> module, you just need to enable the <code>observability</code> module in the <code>.env</code> file.</p> <p>Otherwise, you can follow these steps to enable the <code>observability</code> module:</p> <ol> <li> <p>Stop OpenVidu and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Update the <code>.env</code> file</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>observability</code> module. Also make sure to set up the <code>GRAFANA_ADMIN_USERNAME</code> and <code>GRAFANA_ADMIN_PASSWORD</code> parameters.</p> <p>If you have only the observability module enabled, your <code>.env</code> file should have the following environment variables:</p> <pre><code>GRAFANA_ADMIN_USERNAME=\"&lt;GRAFANA_ADMIN_USERNAME&gt;\"\nGRAFANA_ADMIN_PASSWORD=\"&lt;GRAFANA_ADMIN_PASSWORD&gt;\"\n\nCOMPOSE_PROFILES=\"observability\"\n</code></pre> </li> <li> <p>Enable Prometheus port in LiveKit</p> <p>Just add the following parameter in the <code>config/livekit.yaml</code> file:</p> <pre><code>prometheus_port: 6789\n</code></pre> </li> </ol> <p>Disabling the <code>observability</code> module</p> <p>If you have the <code>observability</code> module enabled, and you want to disable it, just remove the <code>observability</code> module from the <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file.</p> <p>Enabling the <code>app</code> module</p> <p>In case you have installed OpenVidu with the <code>app</code> module, you just need to enable the <code>app</code> module in the <code>.env</code> file.</p> <p>Otherwise, you can follow these steps to enable the <code>app</code> module:</p> <ol> <li> <p>Stop OpenVidu and backup the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Update the <code>.env</code> file</p> <p>Add to the <code>COMPOSE_PROFILES</code> the <code>app</code> module.</p> <p>If you have only the <code>app</code> module enabled, your <code>.env</code> file should have the following environment variable:</p> <pre><code>COMPOSE_PROFILES=\"app\"\n</code></pre> </li> <li> <p>Enable LiveKit webhooks for the Default App</p> <p>Just add the following parameter in the <code>config/livekit.yaml</code> file:</p> <pre><code>webhook:\n    api_key: \"&lt;LIVEKIT_API_KEY&gt;\"\n    urls:\n        - http://localhost:6080/api/webhook\n</code></pre> <p>Where <code>&lt;LIVEKIT_API_KEY&gt;</code> is the <code>LIVEKIT_API_KEY</code> parameter in the <code>.env</code> file.</p> </li> </ol> <p>Disabling the <code>app</code> module</p> <p>If you have the <code>app</code> module enabled, and you want to disable it, just remove the <code>app</code> module from the <code>COMPOSE_PROFILES</code> parameter in the <code>.env</code> file.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#global-configuration-changes","title":"Global configuration changes","text":"<p>Some configuration parameters may require modifying multiple configuration files. Below are some examples of advanced configurations and how to apply them:</p> <p>Info</p> <p>Usually, this is not needed because the installer takes care of generating all of this parameters. However, it is necessary if any password, credential, or domain change is needed.</p> <p>Danger</p> <p>Advanced configurations should be performed with caution. Incorrect configurations can lead to service failures or unexpected behavior.</p> <p>Before making any changes, make sure to back up your installation by creating a snapshot of your server or by copying the <code>/opt/openvidu/</code> directory to a safe location. For example:</p> <pre><code>sudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> Changing <code>DOMAIN_OR_PUBLIC_IP</code>Changing <code>REDIS_PASSWORD</code>Changing <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>Changing <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code>Changing <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> <p>To change all occurrences of the domain or public IP address in the configuration files, follow these steps:</p> <ol> <li> <p>Stop OpenVidu and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Find the current locations of <code>DOMAIN_OR_PUBLIC_IP</code></p> <p>With the following commands, you can find all occurrences of the current domain or public IP address in the configuration files:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_DOMAIN_OR_PUBLIC_IP=\"$(grep '^DOMAIN_OR_PUBLIC_IP' /opt/openvidu/.env | cut -d '=' -f 2)\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> Example output <p>The output should look similar to the following:</p> <pre><code>./.env:DOMAIN_OR_PUBLIC_IP=&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:        - certificate: /owncert/&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;.cert\n./config/caddy.yaml:          key: /owncert/&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;.key\n./config/caddy.yaml:            - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                    - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                        - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                    - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                        - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/caddy.yaml:                  - &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/promtail.yaml:          cluster_id: &lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;\n./config/livekit.yaml:    rtmp_base_url: rtmps://&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;:1935/rtmp\n./config/livekit.yaml:    whip_base_url: https://&lt;CURRENT_DOMAIN_OR_PUBLIC_IP&gt;/whip\n</code></pre> <p>Note</p> <p>Don't worry if some values are different in your output. It may vary depending on the parameters you've used to install OpenVidu.</p> </li> <li> <p>Update the Following Files:</p> <p>Based on the output from the previous step, update the following files with the new domain or public IP address:</p> <ul> <li><code>.env</code></li> <li><code>config/caddy.yaml</code></li> <li><code>config/promtail.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes</p> <p>These commands will list all occurrences of the new <code>DOMAIN_OR_PUBLIC_IP</code> in the configuration files. The output should match the locations found in the initial search but with the new domain or public IP address.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_DOMAIN_OR_PUBLIC_IP=\"&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_DOMAIN_OR_PUBLIC_IP\" .\n</code></pre> </li> <li> <p>Start OpenVidu</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>Some notes on changing the <code>DOMAIN_OR_PUBLIC_IP</code> parameter:</p> <ul> <li>If you are using your own certificates, you need to place the new ones at <code>/opt/openvidu/owncert/&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;.cert</code> and <code>/opt/openvidu/owncert/&lt;NEW_DOMAIN_OR_PUBLIC_IP&gt;.key</code>.</li> <li>Make sure your new domain is pointing correctly to the machine where OpenVidu is installed.</li> </ul> <p>To change the <code>REDIS_PASSWORD</code> parameter, follow these steps:</p> <ol> <li> <p>Stop OpenVidu and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Find the current locations of <code>REDIS_PASSWORD</code></p> <p>With the following command, you can find all occurrences of the current <code>REDIS_PASSWORD</code> in the configuration files:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_REDIS_PASSWORD=\"$(grep REDIS_PASSWORD /opt/openvidu/.env | cut -d '=' -f 2)\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_REDIS_PASSWORD\" .\n</code></pre> Example output <p>The output should look similar to the following:</p> <pre><code>./.env:REDIS_PASSWORD=&lt;CURRENT_REDIS_PASSWORD&gt;\n./config/egress.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n./config/ingress.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n./config/livekit.yaml:    password: &lt;CURRENT_REDIS_PASSWORD&gt;\n</code></pre> </li> <li> <p>Update the Following Files:</p> <p>Based on the output from the previous step, update the following files with the new value:</p> <ul> <li><code>.env</code></li> <li><code>config/egress.yaml</code></li> <li><code>config/ingress.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes</p> <p>These commands will list all occurrences of the new <code>REDIS_PASSWORD</code> in the configuration files. The output should match the locations found in the initial search but with the new value.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_REDIS_PASSWORD=\"&lt;NEW_REDIS_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_REDIS_PASSWORD\" .\n</code></pre> </li> <li> <p>Start OpenVidu</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Find the current locations of <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code></p> <p>With the following commands, you can find all occurrences of the current <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in the configuration files:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_LIVEKIT_API_KEY=\"$(grep LIVEKIT_API_KEY /opt/openvidu/.env | cut -d '=' -f 2)\"\nCURRENT_LIVEKIT_API_SECRET=\"$(grep LIVEKIT_API_SECRET /opt/openvidu/.env | cut -d '=' -f 2)\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_LIVEKIT_API_KEY\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_LIVEKIT_API_SECRET\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>LIVEKIT_API_KEY</code>:</p> <pre><code>./.env:LIVEKIT_API_KEY=&lt;CURRENT_LIVEKIT_API_KEY&gt;\n./config/egress.yaml:api_key: &lt;CURRENT_LIVEKIT_API_KEY&gt;\n./config/ingress.yaml:api_key:&lt;CURRENT_LIVEKIT_API_KEY&gt;\n./config/livekit.yaml:    &lt;CURRENT_LIVEKIT_API_KEY&gt;: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/livekit.yaml:    api_key: &lt;CURRENT_LIVEKIT_API_KEY&gt;\n</code></pre> <p>And for <code>LIVEKIT_API_SECRET</code>:</p> <pre><code>./.env:LIVEKIT_API_SECRET=&lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/egress.yaml:api_secret: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/ingress.yaml:api_secret: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n./config/livekit.yaml:    &lt;CURRENT_LIVEKIT_API_KEY&gt;: &lt;CURRENT_LIVEKIT_API_SECRET&gt;\n</code></pre> </li> <li> <p>Update the Following Files:</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>.env</code></li> <li><code>config/egress.yaml</code></li> <li><code>config/ingress.yaml</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes</p> <p>These commands will list all occurrences of the new <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> in the configuration files. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_LIVEKIT_API_KEY=\"&lt;NEW_LIVEKIT_API_KEY&gt;\"\nNEW_LIVEKIT_API_SECRET=\"&lt;NEW_LIVEKIT_API_SECRET&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_LIVEKIT_API_KEY\" .\ngrep --exclude-dir=data -IHnr \"$NEW_LIVEKIT_API_SECRET\" .\n</code></pre> </li> <li> <p>Start OpenVidu</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Find the current locations of <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code></p> <p>With the following commands, you can find all occurrences of the current <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> in the configuration files:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_MINIO_ACCESS_KEY=\"$(grep MINIO_ACCESS_KEY /opt/openvidu/.env | cut -d '=' -f 2)\"\nCURRENT_MINIO_SECRET_KEY=\"$(grep MINIO_SECRET_KEY /opt/openvidu/.env | cut -d '=' -f 2)\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_MINIO_ACCESS_KEY\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_MINIO_SECRET_KEY\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>MINIO_ACCESS_KEY</code>:</p> <pre><code>./.env:MINIO_ACCESS_KEY=&lt;CURRENT_MINIO_ACCESS_KEY&gt;\n./config/egress.yaml:    access_key: &lt;CURRENT_MINIO_ACCESS_KEY&gt;\n</code></pre> <p>And for <code>MINIO_SECRET_KEY</code>:</p> <pre><code>./.env:MINIO_SECRET_KEY=&lt;CURRENT_MINIO_SECRET_KEY&gt;\n./config/egress.yaml:    secret: &lt;CURRENT_MINIO_SECRET_KEY&gt;\n</code></pre> </li> <li> <p>Update the Following Files:</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>.env</code></li> <li><code>config/egress.yaml</code></li> </ul> </li> <li> <p>Verify the changes</p> <p>These commands will list all occurrences of the new <code>MINIO_ACCESS_KEY</code> and <code>MINIO_SECRET_KEY</code> in the configuration files. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_MINIO_ACCESS_KEY=\"&lt;NEW_MINIO_ACCESS_KEY&gt;\"\nNEW_MINIO_SECRET_KEY=\"&lt;NEW_MINIO_SECRET_KEY&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_MINIO_ACCESS_KEY\" .\ngrep --exclude-dir=data -IHnr \"$NEW_MINIO_SECRET_KEY\" .\n</code></pre> </li> <li> <p>Start OpenVidu</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol> <p>To change the <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> parameters, follow these steps:</p> <ol> <li> <p>Stop OpenVidu and back up the deployment</p> <pre><code>sudo systemctl stop openvidu\nsudo cp -r /opt/openvidu/ /opt/openvidu_backup/\n</code></pre> </li> <li> <p>Change the password through the MongoDB shell</p> <p>With OpenVidu running, change the password with the following commands:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_MONGO_ADMIN_USERNAME=\"$(grep MONGO_ADMIN_USERNAME /opt/openvidu/.env | cut -d '=' -f 2)\"\nCURRENT_MONGO_ADMIN_PASSWORD=\"$(grep MONGO_ADMIN_PASSWORD /opt/openvidu/.env | cut -d '=' -f 2)\"\nNEW_MONGO_ADMIN_USERNAME=\"&lt;NEW_MONGO_ADMIN_USERNAME&gt;\"\nNEW_MONGO_ADMIN_PASSWORD=\"&lt;NEW_MONGO_ADMIN_PASSWORD&gt;\"\n\n# Change username\ndocker exec -it mongo \\\n    mongosh admin \\\n    --port 20000 \\\n    --username \"$CURRENT_MONGO_ADMIN_USERNAME\" \\\n    --password \"$CURRENT_MONGO_ADMIN_PASSWORD\" \\\n    --eval \"db.system.users.updateOne({user: '$CURRENT_MONGO_ADMIN_USERNAME'}, {\\$set: {user: '$NEW_MONGO_ADMIN_USERNAME'}})\"\n\n# Change password\ndocker exec -it mongo \\\n    mongosh admin \\\n    --port 20000 \\\n    --username \"$NEW_MONGO_ADMIN_USERNAME\" \\\n    --password \"$CURRENT_MONGO_ADMIN_PASSWORD\" \\\n    --eval \"db.changeUserPassword('$NEW_MONGO_ADMIN_USERNAME', '$NEW_MONGO_ADMIN_PASSWORD')\"\n</code></pre> <p>After running these commands, the new username and password will be updated in the MongoDB database, but you still need to change the configuration files.</p> </li> <li> <p>Stop OpenVidu</p> <pre><code>sudo systemctl stop openvidu\n</code></pre> </li> <li> <p>Find the current locations of <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code></p> <p>With the following commands, you can find all occurrences of the current <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in the configuration files:</p> <pre><code>sudo su\ncd /opt/openvidu/\nCURRENT_MONGO_ADMIN_USERNAME=\"$(grep MONGO_ADMIN_USERNAME /opt/openvidu/.env | cut -d '=' -f 2)\"\nCURRENT_MONGO_ADMIN_PASSWORD=\"$(grep MONGO_ADMIN_PASSWORD /opt/openvidu/.env | cut -d '=' -f 2)\"\ngrep --exclude-dir=data -IHnr \"$CURRENT_MONGO_ADMIN_USERNAME\" .\ngrep --exclude-dir=data -IHnr \"$CURRENT_MONGO_ADMIN_PASSWORD\" .\n</code></pre> Example output <p>The output should look similar to the following for <code>MONGO_ADMIN_USERNAME</code>:</p> <pre><code>./.env:MONGO_ADMIN_USERNAME=&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;\n./config/livekit.yaml:        mongo_url: mongodb://&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;:&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;@127.0.0.1:20000\n</code></pre> <p>And for <code>MONGO_ADMIN_PASSWORD</code>:</p> <pre><code>./.env:MONGO_ADMIN_PASSWORD=&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;\n./config/livekit.yaml:        mongo_url: mongodb://&lt;CURRENT_MONGO_ADMIN_USERNAME&gt;:&lt;CURRENT_MONGO_ADMIN_PASSWORD&gt;@127.0.0.1:20000\n</code></pre> </li> <li> <p>Update the Following Files:</p> <p>Based on the output from the previous step, update the following files with the new values:</p> <ul> <li><code>.env</code></li> <li><code>config/livekit.yaml</code></li> </ul> </li> <li> <p>Verify the changes</p> <p>These commands will list all occurrences of the new <code>MONGO_ADMIN_USERNAME</code> and <code>MONGO_ADMIN_PASSWORD</code> in the configuration files. The output should match the locations found in the initial search but with the new values.</p> <pre><code>sudo su\ncd /opt/openvidu/\nNEW_MONGO_ADMIN_USERNAME=\"&lt;NEW_MONGO_ADMIN_USERNAME&gt;\"\nNEW_MONGO_ADMIN_PASSWORD=\"&lt;NEW_MONGO_ADMIN_PASSWORD&gt;\"\ngrep --exclude-dir=data -IHnr \"$NEW_MONGO_ADMIN_USERNAME\" .\ngrep --exclude-dir=data -IHnr \"$NEW_MONGO_ADMIN_PASSWORD\" .\n</code></pre> </li> <li> <p>Start OpenVidu</p> <pre><code>sudo systemctl start openvidu\n</code></pre> </li> </ol>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/admin/#uninstalling-openvidu","title":"Uninstalling OpenVidu","text":"<p>To uninstall OpenVidu, just execute the following commands:</p> <pre><code>sudo su\nsystemctl stop openvidu\nrm -rf /opt/openvidu/\nrm /etc/systemd/system/openvidu.service\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/install/","title":"OpenVidu Single Node Installation: On-premises","text":"<p>Regarding OpenVidu v2 compatibility</p> <p>OpenVidu Single Node is not compatible with OpenVidu v2 API. For having compatibility with OpenVidu v2 applications, you must use OpenVidu Elastic or OpenVidu High Availability.</p> <p>This section contains the instructions to deploy a production-ready OpenVidu Single Node deployment on-premises. It is a deployment based on Docker and Docker Compose, which will automatically configure all the necessary services for OpenVidu to work properly.</p> Architecture overview <p>This is how the architecture of the deployment looks like:</p> <p> OpenVidu Single Node On Premises Architecture </p> <p>All services are deployed on a single machine, which includes:</p> <ul> <li>OpenVidu Server (LiveKit compatible).</li> <li>Ingress and Egress services.</li> <li>OpenVidu Dashboard, a web application interface to visualize your Rooms, Ingress, and Egress services.</li> <li>MinIO as an S3 storage service for recordings.</li> <li>Redis as a shared database for OpenVidu Server and Ingress/Egress services.</li> <li>MongoDB as a database for storing analytics and monitoring data.</li> <li>Caddy as a reverse proxy. It can be deployed with self-signed certificates, Let's Encrypt certificates, or custom certificates.</li> <li>OpenVidu Call (Default Application module), an optional ready-to-use videoconferencing application.</li> <li>Grafana, Mimir, Promtail, and Loki (Observability module) form an optional observability stack for monitoring, allowing you to keep track of logs and deployment statistics for OpenVidu.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/install/#prerequisites","title":"Prerequisites","text":"<p>Before starting the installation process, make sure you have the following prerequisites:</p> <ul> <li>A machine with at least 4GB RAM and 4 CPU cores and Linux installed (Ubuntu recommended).</li> <li>Generous disk space (100GB recommended) if you are going to record your sessions.</li> <li>The machine must have a Public IP and an FQDN (Fully Qualified Domain Name) pointing to it.</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/install/#port-rules","title":"Port rules","text":"<p>Ensure all these rules are configured in your firewall, security group, or any kind of network configuration that you have in your machine.</p> <p>Inbound port rules:</p> Protocol Ports Source Description TCP 80 0.0.0.0/0, ::/0 Redirect HTTP traffic to HTTPS and Let's Encrypt validation. TCP 443 0.0.0.0/0, ::/0 Allows access to the following: <ul><li>LiveKit API.</li><li>OpenVidu Dashboard.</li><li>OpenVidu Call (Default Application).</li><li>WHIP API.</li><li>TURN with TLS.</li><li>Custom layouts</li></ul> UDP 443 0.0.0.0/0, ::/0 STUN/TURN server over UDP. TCP 1935 0.0.0.0/0, ::/0 (Optional), only needed if you want to ingest RTMP streams using Ingress service. TCP 7881 0.0.0.0/0, ::/0 (Optional), only needed if you want to allow WebRTC over TCP. UDP 7885 0.0.0.0/0, ::/0 (Optional), only needed if you want to ingest WebRTC using WHIP protocol. TCP 9000 0.0.0.0/0, ::/0 (Optional), only needed if you want to expose MinIO publicly. UDP 50000 - 60000 0.0.0.0/0, ::/0 WebRTC Media traffic. <p>Outbound port rules:</p> <p>Typically, all outbound traffic is allowed.</p>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/install/#guided-installation","title":"Guided Installation","text":"<p>Before the installation, ensure that your machine meets the prerequisites and the port rules. Then, execute the following command on the machine where you want to deploy OpenVidu:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/community/singlenode/latest/install.sh)\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>A wizard will guide you through the installation process. You will be asked for the following information:</p> <ul> <li>Select which certificate type to use:<ul> <li>Self Signed Certificate: It will generate a self-signed certificate. It is not recommended for production environments, but it is useful for testing or development purposes.</li> <li>Let's Encrypt: It will automatically generate a certificate for your domain. The Let's Encrypt email is required and will be asked later in the wizard.</li> <li>ZeroSSL: It will automatically generate a certificate for your domain using ZeroSSL. An API Key is required and will be asked later in the wizard.</li> <li>Own Certificate: It will ask you for the certificate and key files. Just copy and paste the content of the files when the wizard asks for them.</li> </ul> </li> <li>Domain name: The domain name for your deployment. It must be an FQDN pointing to the machine where you are deploying OpenVidu.</li> <li>(Optional) Turn domain name: The domain name for your TURN server with TLS. It must be an FQDN pointing to the machine where you are deploying OpenVidu and must be different from the OpenVidu domain name. Recommended if users who are going to connect to your OpenVidu deployment are behind restrictive firewalls.</li> <li>Modules to enable: Select the modules you want to enable. You can enable the following modules:<ul> <li>Default App: OpenVidu Call, a ready-to-use videoconferencing application.</li> <li>Observability: Grafana stack, which includes logs and monitoring stats.</li> </ul> </li> </ul> <p>The rest of the parameters are secrets, usernames, and passwords. If empty, the wizard will generate random values for them.</p> <p>When the installation process finishes, you will see the following message:</p> <pre><code>&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n&gt;                                                                             &lt;\n&gt;  \ud83c\udf89 OpenVidu Community Installation Finished Successfully! \ud83c\udf89               &lt;\n&gt;                                                                             &lt;\n&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;\n</code></pre> <p>OpenVidu will be installed at <code>/opt/openvidu</code> and configured as a systemd service. You can start the service with the following command:</p> <pre><code>systemctl start openvidu\n</code></pre> <p>If everything goes well, all containers will be up and running without restarts, and you will be able to access any of the following services:</p> <ul> <li>OpenVidu Call (Default Application): https://openvidu.example.io/</li> <li>OpenVidu Dashboard: https://openvidu.example.io/dashboard</li> <li>MinIO: https://openvidu.example.io/minio-console</li> <li>Grafana: https://openvidu.example.io/grafana</li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/install/#deployment-credentials","title":"Deployment Credentials","text":"<p>To point your applications to your OpenVidu deployment, check the file at <code>/opt/openvidu/.env</code>. All access credentials of all services are defined in this file.</p> <p>Your authentication credentials and URLs to point your applications to are:</p> <ul> <li>URL: The value in <code>.env</code> of <code>DOMAIN_OR_PUBLIC_IP</code> as a URL. It could be <code>wss://openvidu.example.io/</code> or <code>https://openvidu.example.io/</code> depending on the SDK you are using.</li> <li>API Key: The value in <code>.env</code> of <code>LIVEKIT_API_KEY</code></li> <li>API Secret: The value in <code>.env</code> of <code>LIVEKIT_API_SECRET</code></li> </ul>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/install/#non-interactive-installation","title":"Non-interactive installation","text":"<p>If you want to automate the installation process, you can generate a command with all the parameters needed to install OpenVidu by answering the wizard questions. You can do this by running the following command:</p> <pre><code>docker run -it openvidu/openvidu-installer:latest \\\n    --deployment-type=single_node\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>This is going to generate a command like this, but it may vary depending on the answers you provide. Here are three examples of the command you can run depending on the certificate type you choose:</p> Let's Encrypt certificatesSelf-signed certificatesCustom certificates <p>Example using Let's Encrypt certificates:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/community/singlenode/latest/install.sh) \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --certificate-type='letsencrypt' \\\n    --letsencrypt-email='example@example.io'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Example using self-signed certificates:</p> <pre><code>sh &lt;(curl -fsSL http://get.openvidu.io/community/singlenode/latest/install.sh) \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --certificate-type='selfsigned' \\\n    --letsencrypt-email='example@example.io'\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <p>Example using custom certificates:</p> <pre><code>CERT_PRIVATE_KEY=$(cat privkey.pem | base64 -w 0)\nCERT_PUBLIC_KEY=$(cat fullchain.pem | base64 -w 0)\n\n# Optional, only if you want to enable TURN with TLS\nCERT_TURN_PRIVATE_KEY=$(cat turn-privkey.pem | base64 -w 0)\nCERT_TURN_PUBLIC_KEY=$(cat turn-fullchain.pem | base64 -w 0)\n\nsh &lt;(curl -fsSL http://get.openvidu.io/community/singlenode/latest/install.sh) \\\n    --domain-name-or-ip='openvidu.example.io' \\\n    --enabled-modules='observability,app' \\\n    --turn-domain-name='turn.example.io' \\\n    --livekit-api-key='xxxxx' \\\n    --livekit-api-secret='xxxxx' \\\n    --dashboard-admin-user='xxxxx' \\\n    --dashboard-admin-password='xxxxx' \\\n    --redis-password='xxxxx' \\\n    --minio-access-key='xxxxx' \\\n    --minio-secret-key='xxxxx' \\\n    --mongo-admin-user='xxxxx' \\\n    --mongo-admin-password='xxxxx' \\\n    --grafana-admin-user='xxxxx' \\\n    --grafana-admin-password='xxxxx' \\\n    --default-app-user='xxxxx' \\\n    --default-app-password='xxxxx' \\\n    --default-app-admin-user='xxxxx' \\\n    --default-app-admin-password='xxxxx' \\\n    --certificate-type='owncert' \\\n    --owncert-private-key=\"$CERT_PRIVATE_KEY\" \\\n    --owncert-public-key=\"$CERT_PUBLIC_KEY\" \\\n    --turn-owncert-private-key=\"$CERT_TURN_PRIVATE_KEY\" \\\n    --turn-owncert-public-key=\"$CERT_TURN_PUBLIC_KEY\"\n</code></pre> <p>Note</p> <p>In case you want to deploy a specific version, just replace <code>latest</code> with the desired version. For example: <code>3.0.0</code>.</p> <ul> <li>Note that you just need to pass <code>--owncert-private-key</code> and <code>--owncert-public-key</code> with the content of the private and public key files in base64 format. The installation script will decode them and save them in the proper files.</li> <li><code>--turn-owncert-private-key</code> and <code>--turn-owncert-public-key</code> are optional. You only need to pass them if you want to enable TURN with TLS.</li> </ul> <p>You can run that command in a CI/CD pipeline or in a script to automate the installation process.</p> <p>Some notes about the command:</p> <ul> <li>The argument <code>--turn-domain-name</code> is optional. You define it only if you want to enable TURN with TLS in case users are behind restrictive firewalls.</li> <li>In the argument <code>--enabled-modules</code>, you can enable the modules you want to deploy. You can enable <code>observability</code> (Grafana stack) and <code>app</code> (Default App - OpenVidu Call).</li> <li>If no media appears in your conference, reinstall specifying the <code>--public-ip</code> parameter with your machine's public IP. OpenVidu usually auto-detects the public IP, but it can fail. This IP is used by clients to send and receive media.</li> </ul> <p>To start OpenVidu, remember to run:</p> <pre><code>systemctl start openvidu\n</code></pre>"},{"location":"/3.0.0-beta1/docs/self-hosting/single-node/on-premises/install/#configuration-and-administration","title":"Configuration and administration","text":"<p>Once you have OpenVidu deployed, you can check the Configuration and Administration section to learn how to manage your OpenVidu Single Node deployment.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/","title":"Angular Components Tutorials","text":"Angular Components <p>In the following tutorials you can learn how to use each one of the available Angular Components to build your application UI tailored to your needs:</p> <ul> <li>Custom UI: learn how to customize the UI, changing colors, shapes and add your branding logo.</li> <li>Custom toolbar: learn how to replace the default toolbar with your own.</li> <li>Toolbar buttons: learn how to add custom buttons to the toolbar.</li> <li>Toolbar panel buttons: learn how to add custom panel buttons to the toolbar.</li> <li>Custom layout: learn how to replace the default layout with your own.</li> <li>Custom stream: learn how to replace the default stream with your own.</li> <li>Custom panels: learn how to replace the default panels with your own.</li> <li>Additional panel: learn how to add a new extra panel besides the default ones.</li> <li>Custom chat panel: learn how to replace the default chat panel with your own.</li> <li>Custom activities panel: learn how to replace the default activities panel with your own.</li> <li>Custom participants panel: learn how to replace the default participants panel with your own.</li> <li>Custom participant panel item: learn how to replace the default participants panel item with your own.</li> <li>Custom participant panel item element: learn how to replace the default participants panel item element with your own.</li> <li>Toggle hand: learn how to add extra features to the videoconference.</li> <li>Admin dashboard: learn how to add an admin dashboard to the videoconference.</li> </ul>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-additional-panels/","title":"Additional panels using Angular Components","text":"<p>Source code </p> <p>The openvidu-additional-panels tutorial demonstrates how to add new panels to the videoconference, providing a more tailored user experience.</p> <p>Adding new videoconference panels is made simple with the AdditionalPanelsDirective, which offers a straightforward way to replace and adapt the PanelComponent to your needs.</p> <p> </p> OpenVidu Components - Additional Panel <p>This tutorial combines the use of the ToolbarAdditionalPanelButtonsDirective and the AdditionalPanelsDirective to add new buttons to the toolbar and new panels to the videoconference. If you want to learn how to add new buttons to the toolbar, you can check the openvidu-toolbar-panel-buttons tutorial.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-additional-panels/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-additional-panels/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-additional-panels/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-additional-panels/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-additional-panels/#4-run-the-openvidu-additional-panels-tutorial","title":"4. Run the openvidu-additional-panels tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-additional-panels\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-additional-panels/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { OpenViduComponentsModule } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;!-- OpenVidu Video Conference Component --&gt;\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n      &lt;!-- Additional Toolbar Buttons --&gt;\n      &lt;div *ovToolbarAdditionalPanelButtons style=\"text-align: center;\"&gt;\n        &lt;button mat-icon-button (click)=\"toggleMyPanel('my-panel1')\"&gt;\n          &lt;mat-icon&gt;360&lt;/mat-icon&gt;\n        &lt;/button&gt;\n        &lt;button mat-icon-button (click)=\"toggleMyPanel('my-panel2')\"&gt;\n          &lt;mat-icon&gt;star&lt;/mat-icon&gt;\n        &lt;/button&gt;\n      &lt;/div&gt;\n\n      &lt;!-- Additional Panels --&gt;\n      &lt;div *ovAdditionalPanels id=\"my-panels\"&gt;\n        @if (showExternalPanel) {\n        &lt;div id=\"my-panel1\"&gt;\n          &lt;h2&gt;NEW PANEL 1&lt;/h2&gt;\n          &lt;p&gt;This is my new additional panel&lt;/p&gt;\n        &lt;/div&gt;\n        } @if (showExternalPanel2) {\n        &lt;div id=\"my-panel2\"&gt;\n          &lt;h2&gt;NEW PANEL 2&lt;/h2&gt;\n          &lt;p&gt;This is another new panel&lt;/p&gt;\n        &lt;/div&gt;\n        }\n      &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule, MatIconButton, MatIcon],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-additional-panels';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  // Flags to control the visibility of external panels\n  showExternalPanel: boolean = false; // (5)!\n  showExternalPanel2: boolean = false; // (6)!\n\n  constructor(private httpClient: HttpClient) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  ngOnInit() {\n    this.subscribeToPanelToggling(); // (7)!\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (8)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Subscribe to panel toggling events\n  subscribeToPanelToggling() {\n    this.panelService.panelStatusObs.subscribe((ev: PanelStatusInfo) =&gt; { // (9)!\n      this.showExternalPanel = ev.isOpened &amp;&amp; ev.panelType === 'my-panel1';\n      this.showExternalPanel2 = ev.isOpened &amp;&amp; ev.panelType === 'my-panel2';\n    });\n  }\n\n  // Toggle the visibility of external panels\n  toggleMyPanel(type: string) { // (10)!\n    this.panelService.togglePanel(type);\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (11)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>showExternalPanel</code>: Flag to control the visibility of the first external panel.</li> <li><code>showExternalPanel2</code>: Flag to control the visibility of the second external panel.</li> <li><code>subscribeToPanelToggling</code> method that subscribes to panel toggling events.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>panelService.panelStatusObs</code> observable that listens to panel toggling events.</li> <li><code>toggleMyPanel</code> method that toggles the visibility of external panels.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>showExternalPanel</code>: Flag to control the visibility of the first external panel.</li> <li><code>showExternalPanel2</code>: Flag to control the visibility of the second external panel.</li> <li><code>subscribeToPanelToggling</code> method that subscribes to panel toggling events.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>panelService.panelStatusObs</code> observable that listens to panel toggling events.</li> <li><code>toggleMyPanel</code> method that toggles the visibility of external panels.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-additional-panels/#adding-new-panels","title":"Adding new panels","text":"<p>The <code>*ovPanel</code> directive is used to replace the default videoconference panels with a custom ones. In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            [toolbarDisplayRoomName]=\"false\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n        &gt;\n            &lt;!-- Additional Toolbar Buttons --&gt;\n            &lt;div *ovToolbarAdditionalPanelButtons style=\"text-align: center;\"&gt;\n                &lt;button mat-icon-button (click)=\"toggleMyPanel('my-panel1')\"&gt;\n                    &lt;mat-icon&gt;360&lt;/mat-icon&gt;\n                &lt;/button&gt;\n                &lt;button mat-icon-button (click)=\"toggleMyPanel('my-panel2')\"&gt;\n                    &lt;mat-icon&gt;star&lt;/mat-icon&gt;\n                &lt;/button&gt;\n            &lt;/div&gt;\n\n            &lt;!-- Additional Panels --&gt;\n            &lt;div *ovAdditionalPanels id=\"my-panels\"&gt;\n                @if (showExternalPanel) {\n                &lt;div id=\"my-panel1\"&gt;\n                    &lt;h2&gt;NEW PANEL 1&lt;/h2&gt;\n                    &lt;p&gt;This is my new additional panel&lt;/p&gt;\n                &lt;/div&gt;\n                } @if (showExternalPanel2) {\n                &lt;div id=\"my-panel2\"&gt;\n                    &lt;h2&gt;NEW PANEL 2&lt;/h2&gt;\n                    &lt;p&gt;This is another new panel&lt;/p&gt;\n                &lt;/div&gt;\n                }\n            &lt;/div&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule, MatIconButton, MatIcon],\n})\nexport class AppComponent {\n    // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ovToolbarAdditionalPanelButtons</code> directive is used to add new buttons to the toolbar and the <code>*ovAdditionalPanels</code> directive is used to add new panels to the videoconference.</p> <p>When the user clicks on the buttons, the <code>toggleMyPanel</code> method is called to toggle the visibility of the new panels. These new panels are handled by the <code>showExternalPanel</code> and <code>showExternalPanel2</code> flags.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-admin-dashboard/","title":"Create admin dashboard using Angular Components","text":"<p>Source code </p> <p>The openvidu-admin-dashboard tutorial demonstrates how to create an admin dashboard to manage the recordings of a videoconference using the OpenVidu Components Angular library.</p> <p> </p> OpenVidu Components - Admin Login <p> </p> OpenVidu Components - Admin Dashboard"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-admin-dashboard/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-admin-dashboard/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-admin-dashboard/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-admin-dashboard/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-admin-dashboard/#4-run-the-openvidu-admin-dashboard-tutorial","title":"4. Run the openvidu-admin-dashboard tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-admin-dashboard\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-admin-dashboard/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-admin-login</code> component to create a login form and the <code>ov-admin-dashboard</code> component to create the admin dashboard.</p> <pre><code>import { OpenViduComponentsModule } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    @if (logged) {\n    &lt;ov-admin-dashboard\n      [recordingsList]=\"recordings()\"\n      (onLogoutRequested)=\"onLogoutRequested()\"\n      (onRefreshRecordingsRequested)=\"onRefreshRecordingsRequested()\"\n      (onLoadMoreRecordingsRequested)=\"onLoadMoreRecordingsRequested()\"\n      (onRecordingDeleteRequested)=\"onRecordingDeleteRequested($event)\"\n    &gt;&lt;/ov-admin-dashboard&gt;\n    } @else {\n    &lt;ov-admin-login (onLoginRequested)=\"onLoginRequested($event)\"&gt;\n    &lt;/ov-admin-login&gt;\n    }\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n\n  roomName = 'openvidu-admin-dashboard'; // (1)!\n\n  logged: boolean = false; // (2)!\n\n  // Recordings list to show in the dashboard\n  // This is a dummy list, you should replace it with your own list from the server\n  recordings: WritableSignal&lt;RecordingInfo[]&gt; = signal([ // (3)!\n    {\n      id: 'recording1',\n      roomName: this.roomName,\n      roomId: 'roomId1',\n      outputMode: RecordingOutputMode.COMPOSED,\n      status: RecordingStatus.READY,\n      filename: 'sampleRecording.mp4',\n      startedAt: new Date().getTime(),\n      endedAt: new Date().getTime(),\n      duration: 0,\n      size: 100,\n      location: 'http://localhost:8080/recordings/recording1',\n    }\n  ]);\n\n  constructor() {}\n\n  onLoginRequested(credentials: { username: string; password: string }) { // (4)!\n    console.log(`Login button clicked ${credentials}`);\n    /**\n     * WARNING! This code is developed for didactic purposes only.\n     * The authentication process should be done in the server side.\n     **/\n    this.logged = true;\n  }\n\n  onLogoutRequested() { // (5)!\n    console.log('Logout button clicked');\n    /**\n     * WARNING! This code is developed for didactic purposes only.\n     * The authentication process should be done in the server side.\n     **/\n    this.logged = false;\n  }\n\n  onRefreshRecordingsRequested() { // (6)!\n    console.log('Refresh recording clicked');\n    /**\n     * WARNING! This code is developed for didactic purposes only.\n     * The authentication process should be done in the server side.\n     **/\n    // Getting the recordings from the server\n    this.recordings.update(() =&gt; [\n      {\n        id: 'recording1',\n        roomName: this.title,\n        roomId: 'roomId1',\n        outputMode: RecordingOutputMode.COMPOSED,\n        status: RecordingStatus.READY,\n        filename: 'sampleRecording1.mp4',\n        startedAt: new Date().getTime(),\n        endedAt: new Date().getTime(),\n        duration: 0,\n        size: 100,\n        location: 'http://localhost:8080/recordings/recording1',\n      },\n    ]);\n  }\n\n  onLoadMoreRecordingsRequested() { // (7)!\n    console.log('Load more recordings clicked');\n  }\n\n  onRecordingDeleteRequested(recording: RecordingDeleteRequestedEvent) { // (8)!\n    console.log(`Delete recording clicked ${recording.recordingId}`);\n    /**\n     * WARNING! This code is developed for didactic purposes only.\n     * The authentication process should be done in the server side.\n     **/\n    // Deleting the recording from the server\n    this.recordings.update((recordings) =&gt;\n      recordings.filter((rec) =&gt; rec.id !== recording.recordingId)\n    );\n\n    console.log(this.recordings());\n  }\n}\n</code></pre> <ol> <li><code>roomName</code>: OpenVidu Room name.</li> <li><code>logged</code>: Boolean that indicates if the user is logged in.</li> <li><code>recordings</code>: Dummy list of recordings to show in the dashboard. You should replace it with your own list from the server from the server.</li> <li><code>onLoginRequested</code> method that fires when the login button is clicked.</li> <li><code>onLogoutRequested</code> method that fires when the logout button is clicked.</li> <li><code>onRefreshRecordingsRequested</code> method that fires when the refresh recordings button is clicked.</li> <li><code>onLoadMoreRecordingsRequested</code> method that fires when the load more recordings button is clicked.</li> <li><code>onRecordingDeleteRequested</code> method that fires when the delete recording button is clicked.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>roomName</code>: OpenVidu Room name.</li> <li><code>logged</code>: Boolean that indicates if the user is logged in.</li> <li><code>recordings</code>: Dummy list of recordings to show in the dashboard. You should replace it with your own list from the server from the server.</li> <li><code>onLoginRequested</code> method that fires when the login button is clicked.</li> <li><code>onLogoutRequested</code> method that fires when the logout button is clicked.</li> <li><code>onRefreshRecordingsRequested</code> method that fires when the refresh recordings button is clicked.</li> <li><code>onLoadMoreRecordingsRequested</code> method that fires when the load more recordings button is clicked.</li> <li><code>onRecordingDeleteRequested</code> method that fires when the delete recording button is clicked.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-activities-panel/","title":"Custom activities panel using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-activities-panel tutorial demonstrates how to customize the activities panel, providing a more tailored user experience.</p> <p>Replacing the default activities panel is made simple with the ActivitiesPanelDirective, which offers a straightforward way to replace and adapt the ActivitiesPanelComponent to your needs.</p> <p> </p> OpenVidu Components - Custom Activities Panel"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-activities-panel/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-activities-panel/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-activities-panel/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-activities-panel/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-activities-panel/#4-run-the-openvidu-custom-activities-panel-tutorial","title":"4. Run the openvidu-custom-activities-panel tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-activities-panel\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-activities-panel/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { OpenViduComponentsModule } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;!-- OpenVidu Video Conference Component --&gt;\n    &lt;ov-videoconference\n        [token]=\"token\"\n        [livekitUrl]=\"LIVEKIT_URL\"\n        (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n        &lt;!-- Custom activities panel --&gt;\n        &lt;div *ovActivitiesPanel id=\"my-panel\"&gt;\n            &lt;h3&gt;ACTIVITIES&lt;/h3&gt;\n            &lt;div&gt;CUSTOM ACTIVITIES&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-activities-panel';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (6)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-activities-panel/#customizing-chat-panel","title":"Customizing chat panel","text":"<p>This tutorial uses the <code>*ovActivitiesPanel</code> directive with the aim of replacing the default activities panel with a custom one.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n        &gt;\n            &lt;!-- Custom activities panel --&gt;\n            &lt;div *ovActivitiesPanel id=\"my-panel\"&gt;\n                &lt;h3&gt;ACTIVITIES&lt;/h3&gt;\n                &lt;div&gt;CUSTOM ACTIVITIES&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n    // ...\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-chat-panel/","title":"Custom chat panel using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-chat-panel tutorial demonstrates how to customize the chat panel, providing a more tailored user experience.</p> <p>Replacing the default chat panel is made simple with the ChatPanelDirective, which offers a straightforward way to replace and adapt the ChatPanelComponent to your needs.</p> <p> </p> OpenVidu Components - Custom Chat Panel"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-chat-panel/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-chat-panel/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-chat-panel/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-chat-panel/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-chat-panel/#4-run-the-openvidu-custom-chat-panel-tutorial","title":"4. Run the openvidu-custom-chat-panel tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-chat-panel\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-chat-panel/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import {\n  DataPacket_Kind,\n  DataPublishOptions,\n  DataTopic,\n  ParticipantService,\n  RemoteParticipant,\n  Room,\n  RoomEvent,\n  OpenViduComponentsModule,\n} from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;!-- OpenVidu Video Conference Component --&gt;\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      [toolbarDisplayRoomName]=\"false\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n      (onRoomCreated)=\"onRoomCreated($event)\"\n    &gt;\n      &lt;!-- Chat Panel --&gt;\n      &lt;div *ovChatPanel id=\"my-panel\"&gt;\n        &lt;h3&gt;Chat&lt;/h3&gt;\n        &lt;div&gt;\n          &lt;ul&gt;\n            @for (msg of messages; track msg) {\n            &lt;li&gt;{{ msg }}&lt;/li&gt;\n            }\n          &lt;/ul&gt;\n        &lt;/div&gt;\n        &lt;input value=\"Hello\" #input /&gt;\n        &lt;button (click)=\"send(input.value)\"&gt;Send&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-chat-panel';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  messages: string[] = []; // (5)!\n\n  constructor(private httpClient: HttpClient, private participantService: ParticipantService) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (6)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  /**\n   * Handles the creation of a new room and sets up an event listener for receiving data.\n   *\n   * @param room - The Room object that was created.\n   */\n  onRoomCreated(room: Room) { // (7)!\n    // Set up an event listener for the RoomEvent.DataReceived event.\n    room.on(RoomEvent.DataReceived, ( // (8)!\n      payload: Uint8Array,\n      participant?: RemoteParticipant,\n      _?: DataPacket_Kind,\n      topic?: string\n    ) =&gt; {\n      // Check if the received data topic is related to chat messages.\n      if (topic === DataTopic.CHAT) {\n        // Decode the payload from Uint8Array to a string and parse it as JSON.\n        const { message } = JSON.parse(new TextDecoder().decode(payload));\n\n        // Get the participant's name or default to 'Unknown' if not available.\n        const participantName = participant?.name || 'Unknown';\n\n        // Add the received message to the messages array.\n        this.messages.push(message);\n\n        // Log the received message and the participant's name to the console.\n        console.log(`Message received from ${participantName}:`, message);\n      }\n    });\n  }\n\n  // Function to send a chat message\n  async send(message: string): Promise&lt;void&gt; { // (9)!\n    const strData = JSON.stringify({ message });\n    const data: Uint8Array = new TextEncoder().encode(strData);\n    const options: DataPublishOptions = { topic: DataTopic.CHAT };\n    await this.participantService.publishData(data, options);\n    this.messages.push(message);\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (10)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>messages</code> array that stores the chat messages.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>onRoomCreated</code> method that handles the creation of a new room and sets up an event listener for receiving data.</li> <li>Event listener for the RoomEvent.DataReceived event that listens to chat messages.</li> <li><code>send</code> method that sends a chat message.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>messages</code> array that stores the chat messages.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>onRoomCreated</code> method that handles the creation of a new room and sets up an event listener for receiving data.</li> <li>Event listener for the RoomEvent.DataReceived event that listens to chat messages.</li> <li><code>send</code> method that sends a chat message.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-chat-panel/#customizing-chat-panel","title":"Customizing chat panel","text":"<p>This tutorial uses the <code>*ovChatPanel</code> directive with the aim of replacing the default chat panel with a custom one.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n            (onRoomCreated)=\"onRoomCreated($event)\"\n        &gt;\n            &lt;!-- Chat Panel --&gt;\n            &lt;div *ovChatPanel id=\"my-panel\"&gt;\n                &lt;h3&gt;Chat&lt;/h3&gt;\n                &lt;div&gt;\n                    &lt;ul&gt;\n                        @for (msg of messages; track msg) {\n                        &lt;li&gt;{{ msg }}&lt;/li&gt;\n                        }\n                    &lt;/ul&gt;\n                &lt;/div&gt;\n                &lt;input value=\"Hello\" #input /&gt;\n                &lt;button (click)=\"send(input.value)\"&gt;Send&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n    // ...\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-layout/","title":"Custom layout using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-layout tutorial demonstrates how to replace the default layout of the OpenVidu Components Angular library with a custom layout.</p> <p>Replacing the default layout is made simple with the LayoutDirective, which offers a straightforward way to customize the LayoutComponent.</p> <p> </p> OpenVidu Components - Custom Layout"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-layout/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-layout/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-layout/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-layout/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-layout/#4-run-the-openvidu-custom-layout-tutorial","title":"4. Run the openvidu-custom-layout tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-layout\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-layout/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { OpenViduComponentsModule, ParticipantModel, ParticipantService } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n      &lt;!-- OpenVidu Video Conference Component --&gt;\n      &lt;ov-videoconference\n        [token]=\"token\"\n        [livekitUrl]=\"LIVEKIT_URL\"\n        (onTokenRequested)=\"onTokenRequested($event)\"\n      &gt;\n        &lt;!-- Custom Layout for Video Streams --&gt;\n        &lt;div *ovLayout&gt;\n          &lt;div class=\"container\"&gt;\n            &lt;!-- Local Participant's Tracks --&gt;\n            @for (track of localParticipant.tracks; track track) {\n            &lt;div\n              class=\"item\"\n              [ngClass]=\"{\n                hidden:\n                  track.isAudioTrack &amp;&amp; !track.participant.onlyHasAudioTracks\n              }\"\n            &gt;\n              &lt;ov-stream [track]=\"track\"&gt;&lt;/ov-stream&gt;\n            &lt;/div&gt;\n            }\n\n            &lt;!-- Remote Participants' Tracks --&gt;\n            @for (track of remoteParticipants | tracks; track track) {\n            &lt;div\n              class=\"item\"\n              [ngClass]=\"{\n                hidden:\n                  track.isAudioTrack &amp;&amp; !track.participant.onlyHasAudioTracks\n              }\"\n            &gt;\n              &lt;ov-stream [track]=\"track\"&gt;&lt;/ov-stream&gt;\n            &lt;/div&gt;\n            }\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/ov-videoconference&gt;\n  `,\n  styles: `\n    /* css styles */\n  `,\n  standalone: true,\n    imports: [OpenViduComponentsModule, NgClass],\n})\nexport class AppComponent implements OnInit, OnDestroy {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-layout';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  // Participant-related properties\n  localParticipant!: ParticipantModel; // (5)!\n  remoteParticipants!: ParticipantModel[]; // (6)!\n  localParticipantSubs!: Subscription; // (7)!\n  remoteParticipantsSubs!: Subscription; // (8)!\n\n  constructor(private httpClient: HttpClient,   private participantService: ParticipantService) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  ngOnInit() {\n    // Subscribe to participants' updates\n    this.subscribeToParticipants();\n  }\n\n  ngOnDestroy() {\n    // Unsubscribe from participant updates to prevent memory leaks\n    this.localParticipantSubs?.unsubscribe();\n    this.remoteParticipantsSubs?.unsubscribe();\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (9)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Subscribe to updates for local and remote participants\n  private subscribeToParticipants() { // (10)!\n    this.localParticipantSubs = this.participantService.localParticipant$.subscribe((p) =&gt; {\n      if (p) this.localParticipant = p;\n    });\n\n    this.remoteParticipantsSubs = this.participantService.remoteParticipants$.subscribe((participants) =&gt; {\n      this.remoteParticipants = participants;\n    });\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (11)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>localParticipant</code>: Local participant model.</li> <li><code>remoteParticipants</code>: Remote participants model.</li> <li><code>localParticipantSubs</code>: Subscription to the local participant updates.</li> <li><code>remoteParticipantsSubs</code>: Subscription to the remote participants updates.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>subscribeToParticipants</code> method that subscribes to updates for local and remote participants.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>localParticipant</code>: Local participant model.</li> <li><code>remoteParticipants</code>: Remote participants model.</li> <li><code>localParticipantSubs</code>: Subscription to the local participant updates.</li> <li><code>remoteParticipantsSubs</code>: Subscription to the remote participants updates.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>subscribeToParticipants</code> method that subscribes to updates for local and remote participants.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-layout/#adding-custom-buttons-to-the-toolbar","title":"Adding custom buttons to the toolbar","text":"<p>OpenVidu Components Angular provides a directive called <code>*ovLayout</code> that allows you to customize the default layout of the videoconference. In this tutorial, we are creating a very basic layout just for demonstration purposes.</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n        &gt;\n            &lt;!-- Custom Layout for Video Streams --&gt;\n            &lt;div *ovLayout&gt;\n                &lt;div class=\"container\"&gt;\n                    &lt;!-- Local Participant's Tracks --&gt;\n                    @for (track of localParticipant.tracks; track track) {\n                    &lt;div\n                        class=\"item\"\n                        [ngClass]=\"{\n                            hidden:\n                                track.isAudioTrack &amp;&amp; !track.participant.onlyHasAudioTracks\n                        }\"\n                    &gt;\n                        &lt;ov-stream [track]=\"track\"&gt;&lt;/ov-stream&gt;\n                    &lt;/div&gt;\n                    }\n\n                    &lt;!-- Remote Participants' Tracks --&gt;\n                    @for (track of remoteParticipants | tracks; track track) {\n                    &lt;div\n                        class=\"item\"\n                        [ngClass]=\"{\n                            hidden:\n                                track.isAudioTrack &amp;&amp; !track.participant.onlyHasAudioTracks\n                        }\"\n                    &gt;\n                        &lt;ov-stream [track]=\"track\"&gt;&lt;/ov-stream&gt;\n                    &lt;/div&gt;\n                    }\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule, MatIconButton, MatIcon],\n})\nexport class AppComponent implements OnInit, OnDestroy {\n    // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ovLayout</code> directive is used to customize the layout of the videoconference. The layout is divided into two sections: one for the local participant's tracks and another for the remote participants' tracks.</p> <p>The repeater directive <code>@for</code> is used to iterate over the tracks of the local participant and the remote participants and display them in the layout using the <code>ov-stream</code> component.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-panels/","title":"Custom panels using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-panels tutorial demonstrates how to replace the default panels with a custom ones, providing a more tailored user experience.</p> <p>Customizing the videoconference panels is made simple with the PanelDirective, which offers a straightforward way to replace and adapt the PanelComponent to your needs.</p> <p> </p> OpenVidu Components - Custom Panels"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-panels/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-panels/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-panels/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-panels/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-panels/#4-run-the-openvidu-custom-panels-tutorial","title":"4. Run the openvidu-custom-panels tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-panels\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-panels/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { OpenViduComponentsModule } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n      &lt;!-- OpenVidu Video Conference Component --&gt;\n      &lt;ov-videoconference\n        [token]=\"token\"\n        [livekitUrl]=\"LIVEKIT_URL\"\n        (onTokenRequested)=\"onTokenRequested($event)\"\n      &gt;\n        &lt;!-- Custom Panels --&gt;\n        &lt;ov-panel *ovPanel&gt;\n          &lt;!-- Custom Chat Panel --&gt;\n          &lt;div *ovChatPanel id=\"my-chat-panel\"&gt;This is my custom chat panel&lt;/div&gt;\n\n          &lt;!-- Custom Participants Panel --&gt;\n          &lt;div *ovParticipantsPanel id=\"my-participants-panel\"&gt;\n            This is my custom participants panel\n          &lt;/div&gt;\n\n          &lt;!-- Custom Activities Panel --&gt;\n          &lt;div *ovActivitiesPanel id=\"my-activities-panel\"&gt;\n            This is my custom activities panel\n          &lt;/div&gt;\n        &lt;/ov-panel&gt;\n      &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-panels';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (6)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-panels/#customizing-the-panels","title":"Customizing the panels","text":"<p>The <code>*ovPanel</code> directive is used to replace the default videoconference panels with a custom ones. In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n        &gt;\n            &lt;!-- Custom Panels --&gt;\n            &lt;ov-panel *ovPanel&gt;\n                &lt;!-- Custom Chat Panel --&gt;\n                &lt;div *ovChatPanel id=\"my-chat-panel\"&gt;This is my custom chat panel&lt;/div&gt;\n\n                &lt;!-- Custom Participants Panel --&gt;\n                &lt;div *ovParticipantsPanel id=\"my-participants-panel\"&gt;\n                    This is my custom participants panel\n                &lt;/div&gt;\n\n                &lt;!-- Custom Activities Panel --&gt;\n                &lt;div *ovActivitiesPanel id=\"my-activities-panel\"&gt;\n                    This is my custom activities panel\n                &lt;/div&gt;\n            &lt;/ov-panel&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n    // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ovPanel</code> directive is used to replace the default videoconference panels with custom ones. The <code>*ovChatPanel</code>, <code>*ovParticipantsPanel</code>, and <code>*ovActivitiesPanel</code> directives are used to replace the default chat, participants, and activities panels with custom ones.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item-element/","title":"Custom participants panel item element using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-participant-panel-item-element tutorial demonstrates how to replace the default participant item element inside of the participants panel with a custom one, providing a more tailored user experience.</p> <p>Replacing the default participant item element is made simple with the ParticipantsPanelItemElementsDirective, which offers a straightforward way to replace and adapt the ParticipantsPanelItemComponent to your needs.</p> <p> </p> OpenVidu Components - Custom Participants Panel Item Element"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item-element/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item-element/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item-element/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item-element/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item-element/#4-run-the-openvidu-custom-participant-panel-item-element-tutorial","title":"4. Run the openvidu-custom-participant-panel-item-element tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-participant-panel-item-element\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item-element/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import {\n  ParticipantModel,\n    ParticipantService,\n  OpenViduComponentsModule\n} from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;!-- OpenVidu Video Conference Component --&gt;\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n      &lt;!-- Participant Panel Item Elements --&gt;\n      &lt;div *ovParticipantPanelItemElements=\"let participant\"&gt;\n        &lt;!-- Leave Button for Local Participant --&gt;\n        @if (participant.isLocal) {\n        &lt;button (click)=\"leaveSession()\"&gt;Leave&lt;/button&gt;\n        }\n      &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-participant-panel-item-element';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Function to leave the session\n  async leaveSession() { // (6)!\n    await this.openviduService.disconnectRoom();\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (7)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>leaveSession</code> method that disconnects the client from the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>leaveSession</code> method that disconnects the client from the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item-element/#customizing-participant-item-element","title":"Customizing participant item element","text":"<p>This tutorial uses the <code>*ovParticipantPanelItem</code> directive with the aim of replacing the default participant item, inside of the participants panel, with a custom one.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n        &gt;\n            &lt;!-- Participant Panel Item Elements --&gt;\n            &lt;div *ovParticipantPanelItemElements=\"let participant\"&gt;\n                &lt;!-- Leave Button for Local Participant --&gt;\n                @if (participant.isLocal) {\n                &lt;button (click)=\"leaveSession()\"&gt;Leave&lt;/button&gt;\n                }\n            &lt;/div&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n    // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ovParticipantPanelItemElements</code> directive is used to replace the default participant item element, inside of the participants panel, with a custom one.</p> <p>The <code>*ovParticipantPanelItemElements</code> directive provides a way to access the participant object and customize the participant item component to your needs.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item/","title":"Custom participants panel item using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-participant-panel-item tutorial demonstrates how to replace the default participant item inside of the participants panel with a custom one, providing a more tailored user experience.</p> <p>Replacing the default participant item is made simple with the ParticipantsPanelItemDirective, which offers a straightforward way to replace and adapt the ParticipantsPanelItemComponent to your needs.</p> <p> </p> OpenVidu Components - Custom Participants Panel Item"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item/#4-run-the-openvidu-custom-participant-panel-item-tutorial","title":"4. Run the openvidu-custom-participant-panel-item tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-participant-panel-item\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import {\n  ParticipantModel,\n    ParticipantService,\n  OpenViduComponentsModule\n} from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;!-- OpenVidu Video Conference Component --&gt;\n    &lt;ov-videoconference\n        [token]=\"token\"\n        [livekitUrl]=\"LIVEKIT_URL\"\n        (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n        &lt;!-- Participant Panel Items --&gt;\n        &lt;div *ovParticipantPanelItem=\"let participant\" style=\"display: flex\"&gt;\n            &lt;p&gt;{{ participant.name }}&lt;/p&gt;\n\n            &lt;!-- More Options Menu --&gt;\n            &lt;button mat-icon-button [matMenuTriggerFor]=\"menu\"&gt;\n                &lt;mat-icon&gt;more_vert&lt;/mat-icon&gt;\n            &lt;/button&gt;\n\n            &lt;!-- Menu Content --&gt;\n            &lt;mat-menu #menu=\"matMenu\"&gt;\n                &lt;button mat-menu-item&gt;Button 1&lt;/button&gt;\n                &lt;button mat-menu-item&gt;Button 2&lt;/button&gt;\n            &lt;/mat-menu&gt;\n        &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n    imports: [\n    OpenViduComponentsModule,\n    MatIconButton,\n    MatMenuTrigger,\n    MatIcon,\n    MatMenu,\n    MatMenuItem,\n  ],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-participant-panel-item';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (6)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participant-panel-item/#customizing-participant-item","title":"Customizing participant item","text":"<p>This tutorial uses the <code>*ovParticipantPanelItem</code> directive with the aim of replacing the default participant item, inside of the participants panel, with a custom one.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n        &gt;\n            &lt;!-- Participant Panel Items --&gt;\n            &lt;div *ovParticipantPanelItem=\"let participant\" style=\"display: flex\"&gt;\n                &lt;p&gt;{{ participant.name }}&lt;/p&gt;\n\n                &lt;!-- More Options Menu --&gt;\n                &lt;button mat-icon-button [matMenuTriggerFor]=\"menu\"&gt;\n                    &lt;mat-icon&gt;more_vert&lt;/mat-icon&gt;\n                &lt;/button&gt;\n\n                &lt;!-- Menu Content --&gt;\n                &lt;mat-menu #menu=\"matMenu\"&gt;\n                    &lt;button mat-menu-item&gt;Button 1&lt;/button&gt;\n                    &lt;button mat-menu-item&gt;Button 2&lt;/button&gt;\n                &lt;/mat-menu&gt;\n            &lt;/div&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [\n        OpenViduComponentsModule,\n        MatIconButton,\n        MatMenuTrigger,\n        MatIcon,\n        MatMenu,\n        MatMenuItem,\n    ],\n})\nexport class AppComponent {\n    // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ovParticipantPanelItem</code> directive is used to replace the default participant item inside of the participants panel with a custom one. The <code>*ovParticipantPanelItem</code> directive provides a way to access the participant object and customize the participant item component to your needs.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participants-panel/","title":"Custom participants panel using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-participants-panel tutorial demonstrates how to customize the participants panel, providing a more tailored user experience.</p> <p>Replacing the default participants panel is made simple with the ParticipantsPanelDirective, which offers a straightforward way to replace and adapt the ParticipantsPanelComponent to your needs.</p> <p> </p> OpenVidu Components - Custom Participants Panel"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participants-panel/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participants-panel/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participants-panel/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participants-panel/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participants-panel/#4-run-the-openvidu-custom-participants-panel-tutorial","title":"4. Run the openvidu-custom-participants-panel tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-participants-panel\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participants-panel/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import {\n  ParticipantModel,\n    ParticipantService,\n  OpenViduComponentsModule\n} from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;!-- OpenVidu Video Conference Component --&gt;\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n      &lt;!-- Custom Participants Panel --&gt;\n      &lt;div *ovParticipantsPanel id=\"my-panel\"&gt;\n        &lt;ul id=\"local\"&gt;\n          &lt;li&gt;{{ localParticipant.name }}&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;ul id=\"remote\"&gt;\n          @for (p of remoteParticipants; track p) {\n          &lt;li&gt;{{ p.name }}&lt;/li&gt;\n          }\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent implements OnInit, OnDestroy {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-participants-panel';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  // Participant-related properties\n  localParticipant!: ParticipantModel; // (5)!\n  remoteParticipants!: ParticipantModel[]; // (6)!\n  localParticipantSubs!: Subscription; // (7)!\n  remoteParticipantsSubs!: Subscription; // (8)!\n\n  constructor(private httpClient: HttpClient, private participantService: ParticipantService) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  ngOnInit() {\n    // Subscribe to participants' updates\n    this.subscribeToParticipants();\n  }\n\n  ngOnDestroy() {\n    // Unsubscribe from participant updates to prevent memory leaks\n    this.localParticipantSubs?.unsubscribe();\n    this.remoteParticipantsSubs?.unsubscribe();\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (9)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Subscribe to updates for local and remote participants\n  private subscribeToParticipants() { // (10)!\n    this.localParticipantSubs = this.participantService.localParticipant$.subscribe((p) =&gt; {\n      if (p) this.localParticipant = p;\n    });\n\n    this.remoteParticipantsSubs = this.participantService.remoteParticipants$.subscribe((participants) =&gt; {\n      this.remoteParticipants = participants;\n    });\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (11)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>localParticipant</code>: Local participant model.</li> <li><code>remoteParticipants</code>: Remote participants model.</li> <li><code>localParticipantSubs</code>: Subscription to the local participant updates.</li> <li><code>remoteParticipantsSubs</code>: Subscription to the remote participants updates.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>subscribeToParticipants</code> method that subscribes to updates for local and remote participants.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>localParticipant</code>: Local participant model.</li> <li><code>remoteParticipants</code>: Remote participants model.</li> <li><code>localParticipantSubs</code>: Subscription to the local participant updates.</li> <li><code>remoteParticipantsSubs</code>: Subscription to the remote participants updates.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>subscribeToParticipants</code> method that subscribes to updates for local and remote participants.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-participants-panel/#customizing-participants-panel","title":"Customizing participants panel","text":"<p>This tutorial uses the <code>*ovParticipantsPanel</code> directive with the aim of replacing the default participant panel with a custom one.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n      &lt;!-- Custom Participants Panel --&gt;\n      &lt;div *ovParticipantsPanel id=\"my-panel\"&gt;\n        &lt;ul id=\"local\"&gt;\n          &lt;li&gt;{{ localParticipant.name }}&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;ul id=\"remote\"&gt;\n          @for (p of remoteParticipants; track p) {\n          &lt;li&gt;{{ p.name }}&lt;/li&gt;\n          }\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule],\n})\nexport class AppComponent implements OnInit, OnDestroy{\n    // ...\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-stream/","title":"Custom stream using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-stream tutorial demonstrates how to replace the default video stream with a custom one, providing a more tailored user experience.</p> <p>Customizing the video stream component is made simple with the StreamDirective, which offers a straightforward way to replace and adapt the StreamComponent to your needs.</p> <p> </p> OpenVidu Components - Custom Stream"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-stream/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-stream/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-stream/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-stream/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-stream/#4-run-the-openvidu-custom-stream-tutorial","title":"4. Run the openvidu-custom-stream tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-stream\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-stream/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { OpenViduComponentsModule } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n      &lt;ov-videoconference\n        [token]=\"token\"\n        [livekitUrl]=\"LIVEKIT_URL\"\n        (onTokenRequested)=\"onTokenRequested($event)\"\n      &gt;\n        &lt;!-- Display Video Streams --&gt;\n        &lt;div *ovStream=\"let track\"&gt;\n          &lt;!-- Video Stream Component --&gt;\n          &lt;ov-stream [track]=\"track\" [displayParticipantName]=\"false\"&gt;&lt;/ov-stream&gt;\n\n          &lt;!-- Display Participant's Name --&gt;\n          &lt;p&gt;{{ track.participant.name }}&lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-stream';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (6)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-stream/#customizing-the-video-stream","title":"Customizing the video stream","text":"<p>The <code>*ovStream</code> directive is used to replace the default video stream with a custom one and allows you to customize the video stream component to your needs. It provides a way to access the video stream track and the participant name.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;!-- OpenVidu Video Conference Component --&gt;\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n        &gt;\n            &lt;!-- Display Video Streams --&gt;\n            &lt;div *ovStream=\"let track\"&gt;\n                &lt;!-- Video Stream Component --&gt;\n                &lt;ov-stream [track]=\"track\" [displayParticipantName]=\"false\"&gt;&lt;/ov-stream&gt;\n\n                &lt;!-- Display Participant's Name --&gt;\n                &lt;p&gt;{{ track.participant.name }}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n    // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ovStream</code> directive provides access to the ParticipantTrackPublication object, which contains the video stream track and the participant name.</p> <p>The <code>track</code> object is passed to the <code>ov-stream</code> component to display the video stream. The <code>track.participant.name</code> object is used to display the participant's name.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-toolbar/","title":"Custom toolbar using Angular Components","text":"<p>Source code </p> <p>The openvidu-custom-toolbar tutorial demonstrates how to replace the default toolbar with a custom one, providing a more tailored user experience.</p> <p>Customizing the toolbar is made simple with the ToolbarDirective, which offers a straightforward way to replace and adapt the ToolbarComponent to your needs.</p> <p> </p> OpenVidu Components - Custom Toolbar"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-toolbar/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-toolbar/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-toolbar/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-toolbar/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-toolbar/#4-run-the-openvidu-custom-toolbar-tutorial","title":"4. Run the openvidu-custom-toolbar tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-toolbar\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-toolbar/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { OpenViduComponentsModule, ParticipantService } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n      &lt;div *ovToolbar style=\"text-align: center;\"&gt;\n        &lt;button (click)=\"toggleVideo()\"&gt;Toggle Video&lt;/button&gt;\n        &lt;button (click)=\"toggleAudio()\"&gt;Toggle Audio&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-toolbar';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient, private participantService: ParticipantService) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Toggles the camera on and off.\n  async toggleVideo() { // (6)!\n    const isCameraEnabled = this.participantService.isMyCameraEnabled();\n    await this.participantService.setCameraEnabled(!isCameraEnabled);\n  }\n\n  // Toggles the microphone on and off.\n  async toggleAudio() { // (7)!\n    const isMicrophoneEnabled = this.participantService.isMyMicrophoneEnabled();\n    await this.participantService.setMicrophoneEnabled(!isMicrophoneEnabled);\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (8)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>toggleVideo</code> method that toggles the camera on and off.</li> <li><code>toggleAudio</code> method that toggles the microphone on and off.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>toggleVideo</code> method that toggles the camera on and off.</li> <li><code>toggleAudio</code> method that toggles the microphone on and off.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-toolbar/#customizing-the-toolbar","title":"Customizing the toolbar","text":"<p>The <code>*ov-toolbar</code> directive allows you to replace the default toolbar with a custom one. This directive is applied to a <code>div</code> element that contains the custom toolbar elements.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n  selector: 'app-root',\n  template:`\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n      &lt;div *ovToolbar style=\"text-align: center;\"&gt;\n        &lt;button (click)=\"toggleVideo()\"&gt;Toggle Video&lt;/button&gt;\n        &lt;button (click)=\"toggleAudio()\"&gt;Toggle Audio&lt;/button&gt;\n      &lt;/div&gt;\n\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n  // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ov-toolbar</code> directive is applied to a <code>div</code> element that contains two buttons. These buttons are used to toggle the camera and microphone on and off.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/","title":"Custom UI using Angular Components","text":"<p>Source code </p> <p>Creating a unique and intuitive user interface (UI) is essential for ensuring a great user experience. OpenVidu Components Angular allows for flexibility in UI customization to fit your application's design requirements.</p> <p> </p> OpenVidu Components - Custom UI"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/#4-run-the-openvidu-custom-ui-tutorial","title":"4. Run the openvidu-custom-ui tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-custom-ui\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { OpenViduComponentsModule } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-custom-ui';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (6)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/#customizing-the-ui","title":"Customizing the UI","text":"<p>To customize the appearance of OpenVidu Components, simply redefine the necessary CSS variables in your <code>styles.scss</code> file. For instance, to change the primary color used throughout your application, you would update the <code>--ov-primary-color</code> variable as shown below:</p> <p><pre><code>:root {\n  --ov-primary-color: #yourNewColor; /* Replace #yourNewColor with your chosen hex color code */\n\n  /* Others variables ... */\n}\n</code></pre> Once you redefine a variable, the new style will automatically apply to all components in the OpenVidu UI that use that variable.</p> <p>The library also allows you to customize shape of buttons, panels and videos customization, the background color personalization of panels, buttons and videoconference and also you can change the text color.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-custom-ui/#replacing-the-branding-logo","title":"Replacing the branding logo","text":"<p>You can replace the branding logo with your own. Just modify the <code>src/assets/images/logo.png</code> file with your own logo.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toggle-hand/","title":"Add toggle hand feature using Angular Components","text":"<p>Source code </p> <p>The openvidu-toggle-hand tutorial demonstrates how to add a toggle hand feature to the OpenVidu Components Angular library.</p> <p>The toggle hand feature allows participants to raise and lower their hand during a videoconference. This feature is useful for participants to signal that they want to speak or ask a question.</p> <p>This tutorial combines the use of the ToolbarAdditionalButtonsDirective, the StreamDirective and the ParticipantsPanelItemElementsDirective to create a custom toolbar button, a custom stream component element and a custom participant panel item element. Check the openvidu-toolbar-buttons and the openvidu-custom-stream tutorials documentation for learning more about these directives.</p> <p> </p> OpenVidu Components - Toggle Hand"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toggle-hand/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toggle-hand/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toggle-hand/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toggle-hand/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toggle-hand/#4-run-the-openvidu-toggle-hand-tutorial","title":"4. Run the openvidu-toggle-hand tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-toggle-hand\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toggle-hand/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li> <p><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</p> </li> <li> <p><code>app/models/participant-app.model.ts</code>: Contains the <code>ParticipantAppModel</code> class that extends the <code>ParticipantModel</code> class to add the ability to raise and lower the hand.</p> </li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsmodels/participant-app.model.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import {\n  ParticipantModel,\n  ParticipantService,\n  OpenViduComponentsModule\n} from 'openvidu-components-angular';\n\nenum DataTopicApp {\n  HAND_TOGGLE = 'handToggle'\n}\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;!-- OpenVidu Video Conference Component --&gt;\n    &lt;ov-videoconference\n      [prejoin]=\"true\"\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n      (onRoomCreated)=\"handleRemoteHand($event)\"\n    &gt;\n      &lt;div *ovToolbarAdditionalButtons&gt;\n        &lt;button toolbar-btn mat-icon-button (click)=\"handleLocalHand()\" [class.active-btn]=\"hasHandRaised\"&gt;\n          &lt;mat-icon matTooltip=\"Toggle hand\"&gt;front_hand&lt;/mat-icon&gt;\n        &lt;/button&gt;\n      &lt;/div&gt;\n\n      &lt;div *ovStream=\"let track\" style=\"height: 100%\"&gt;\n        &lt;ov-stream [track]=\"track\"&gt;&lt;/ov-stream&gt;\n        @if (track.participant.hasHandRaised) {\n        &lt;mat-icon @inOutHandAnimation id=\"hand-notification\"&gt;front_hand&lt;/mat-icon&gt;\n        }\n      &lt;/div&gt;\n\n      &lt;div *ovParticipantPanelItemElements=\"let participant\"&gt;\n        @if (participant.hasHandRaised) {\n        &lt;mat-icon&gt;front_hand&lt;/mat-icon&gt;\n        }\n      &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule, MatIconButton, MatIcon]\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-toggle-hand';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  // Whether the local participant has raised their hand.\n  hasHandRaised: boolean = false; // (5)!\n\n  constructor(private httpClient: HttpClient, private participantService: ParticipantService) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (6)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Handles the reception of a remote hand-raising event.\n  handleRemoteHand(room: Room) { // (7)!\n    // Subscribe to hand toggling events from other participants\n    room.on(RoomEvent.DataReceived, (payload: Uint8Array, participant?: RemoteParticipant, _?: DataPacket_Kind, topic?: string) =&gt; { // (8)!\n      if (topic === DataTopicApp.HAND_TOGGLE) {\n        const p = this.participantService.getRemoteParticipantBySid(participant.sid); // (9)!\n        if (p) {\n          (&lt;ParticipantAppModel&gt;p).toggleHandRaised(); // (10)!\n        }\n        this.participantService.updateRemoteParticipants(); // (11)!\n      }\n    });\n  }\n\n  // Handles the local hand-raising event.\n  async handleLocalHand() {  // (12)!\n    // Get local participant with ParticipantService\n    const participant = &lt;ParticipantAppModel&gt;this.participantService.getLocalParticipant(); // (13)!\n\n    // Toggle the participant hand with the method we wil add in our ParticipantAppModel\n    participant.toggleHandRaised(); // (14)!\n\n    // Refresh the local participant object for others component and services\n    this.participantService.updateLocalParticipant(); // (15)!\n\n    // Send a signal with the new value to others participant using the openvidu-browser signal\n    const strData = JSON.stringify({});\n    const data: Uint8Array = new TextEncoder().encode(strData);\n    const options: DataPublishOptions = { topic: DataTopicApp.HAND_TOGGLE };\n\n    await this.participantService.publishData(data, options); // (16)!\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (17)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>hasHandRaised</code>: Boolean that indicates if the local participant has raised their hand.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>handleRemoteHand</code> method that handles the reception of a remote <code>HAND_TOGGLE</code>  event.</li> <li><code>on</code> method that subscribes to the <code>DataReceived</code> event to handle the reception of a remote <code>HAND_TOGGLE</code> event.</li> <li><code>getRemoteParticipantBySid</code> method that retrieves a remote participant by its unique ID.</li> <li><code>toggleHandRaised</code> method that toggles the hand raising status of a remote participant.</li> <li><code>updateRemoteParticipants</code> method that updates the list of remote participants.</li> <li><code>handleLocalHand</code> method that handles the local <code>HAND_TOGGLE</code> event.</li> <li><code>getLocalParticipant</code> method that retrieves the local participant.</li> <li><code>toggleHandRaised</code> method that toggles the hand raising status of the local participant.</li> <li><code>updateLocalParticipant</code> method that updates the local participant.</li> <li><code>publishData</code> method that sends a signal to other participants.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>hasHandRaised</code>: Boolean that indicates if the local participant has raised their hand.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>handleRemoteHand</code> method that handles the reception of a remote <code>HAND_TOGGLE</code>  event.</li> <li><code>on</code> method that subscribes to the <code>DataReceived</code> event to handle the reception of a remote <code>HAND_TOGGLE</code> event.</li> <li><code>getRemoteParticipantBySid</code> method that retrieves a remote participant by its unique ID.</li> <li><code>toggleHandRaised</code> method that toggles the hand raising status of a remote participant.</li> <li><code>updateRemoteParticipants</code> method that updates the list of remote participants.</li> <li><code>handleLocalHand</code> method that handles the local <code>HAND_TOGGLE</code> event.</li> <li><code>getLocalParticipant</code> method that retrieves the local participant.</li> <li><code>toggleHandRaised</code> method that toggles the hand raising status of the local participant.</li> <li><code>updateLocalParticipant</code> method that updates the local participant.</li> <li><code>publishData</code> method that sends a signal to other participants.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The <code>ParticipantAppModel</code> class extends the <code>ParticipantModel</code> class to add the ability to raise and lower the hand.</p> <pre><code>  import { ParticipantModel, ParticipantProperties } from 'openvidu-components-angular';\n\n  // Represents a participant in the application, with the ability to raise their hand.\n  export class ParticipantAppModel extends ParticipantModel {\n\n    // Indicates whether the participant has raised their hand.\n    hasHandRaised: boolean;\n\n    //  Creates a new instance of ParticipantAppModel.\n    constructor(props: ParticipantProperties) {\n      super(props);\n      this.hasHandRaised = false;\n    }\n\n    // Toggles the participant's hand raised status.\n    toggleHandRaised() {\n      this.hasHandRaised = !this.hasHandRaised;\n    }\n  }\n</code></pre> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-buttons/","title":"Add toolbar buttons using Angular Components","text":"<p>Source code </p> <p>The openvidu-toolbar-buttons tutorial demonstrates how to add custom buttons to the central part of the default toolbar in the OpenVidu Components Angular library.</p> <p>Adding toolbar buttons is made simple with the ToolbarAdditionalButtonsDirective, which offers a straightforward way to add custom buttons to the ToolbarComponent.</p> <p> </p> OpenVidu Components - Toolbar Buttons"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-buttons/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-buttons/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-buttons/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-buttons/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-buttons/#4-run-the-openvidu-toolbar-buttons-tutorial","title":"4. Run the openvidu-toolbar-buttons tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-toolbar-buttons\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-buttons/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { MatIcon } from '@angular/material/icon';\nimport { MatIconButton } from '@angular/material/button';\nimport { OpenViduComponentsModule, ParticipantService } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n      &lt;div *ovToolbarAdditionalButtons style=\"text-align: center;\"&gt;\n        &lt;button mat-icon-button (click)=\"toggleVideo()\"&gt;\n          &lt;mat-icon&gt;videocam&lt;/mat-icon&gt;\n        &lt;/button&gt;\n        &lt;button mat-icon-button (click)=\"toggleAudio()\"&gt;\n          &lt;mat-icon&gt;mic&lt;/mat-icon&gt;\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n    imports: [OpenViduComponentsModule, MatIconButton, MatIcon],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-toolbar-buttons';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient, private participantService: ParticipantService) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Toggles the camera on and off.\n  async toggleVideo() { // (6)!\n    const isCameraEnabled = this.participantService.isMyCameraEnabled();\n    await this.participantService.setCameraEnabled(!isCameraEnabled);\n  }\n\n  // Toggles the microphone on and off.\n  async toggleAudio() { // (7)!\n    const isMicrophoneEnabled = this.participantService.isMyMicrophoneEnabled();\n    await this.participantService.setMicrophoneEnabled(!isMicrophoneEnabled);\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (8)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>toggleVideo</code> method that toggles the camera on and off.</li> <li><code>toggleAudio</code> method that toggles the microphone on and off.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>toggleVideo</code> method that toggles the camera on and off.</li> <li><code>toggleAudio</code> method that toggles the microphone on and off.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-buttons/#adding-additional-buttons-to-the-toolbar","title":"Adding additional buttons to the toolbar","text":"<p>OpenVidu Components Angular provides a directive called <code>*ovToolbarAdditionalButtons</code> that allows you to add custom buttons to the toolbar.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n  selector: 'app-root',\n  template:`\n    &lt;ov-videoconference\n      [token]=\"token\"\n      [livekitUrl]=\"LIVEKIT_URL\"\n      (onTokenRequested)=\"onTokenRequested($event)\"\n    &gt;\n      &lt;div *ovToolbarAdditionalButtons style=\"text-align: center;\"&gt;\n        &lt;button mat-icon-button (click)=\"toggleVideo()\"&gt;\n          &lt;mat-icon&gt;videocam&lt;/mat-icon&gt;\n        &lt;/button&gt;\n        &lt;button mat-icon-button (click)=\"toggleAudio()\"&gt;\n          &lt;mat-icon&gt;mic&lt;/mat-icon&gt;\n        &lt;/button&gt;\n      &lt;/div&gt;\n\n    &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n  imports: [OpenViduComponentsModule, MatIconButton, MatIcon],\n})\nexport class AppComponent {\n  // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ovToolbarAdditionalButtons</code> directive is used to add two buttons to the toolbar. The <code>mat-icon-button</code> component from Angular Material is used to create the buttons. The <code>toggleVideo</code> and <code>toggleAudio</code> methods are called when the buttons are clicked.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-panel-buttons/","title":"Add toolbar panel buttons using Angular Components","text":"<p>Source code </p> <p>The openvidu-toolbar-panel-buttons tutorial demonstrates how to add custom buttons to the right part of the default toolbar in the OpenVidu Components Angular library.</p> <p>Adding toolbar buttons is made simple with the ToolbarAdditionalPanelButtonsDirective, which offers a straightforward way to add custom buttons to the ToolbarComponent.</p> <p> </p> OpenVidu Components - Toolbar Panel Buttons"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-panel-buttons/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-panel-buttons/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-panel-buttons/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-panel-buttons/#3-run-the-server-application","title":"3. Run the server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-panel-buttons/#4-run-the-openvidu-toolbar-panel-buttons-tutorial","title":"4. Run the openvidu-toolbar-panel-buttons tutorial","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>  cd openvidu-tutorials/openvidu-components/openvidu-toolbar-panel-buttons\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>  npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>  npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>.</p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-panel-buttons/#understanding-the-code","title":"Understanding the code","text":"<p>This tutorial is an Angular project generated with Angular CLI tool. Therefore, you will see many configuration files and other components that are not the primary focus of this tutorial. We will concentrate on the following files in the <code>src</code> directory:</p> <ul> <li><code>main.ts</code>: This file defines the root application component. It imports the <code>OpenViduComponentsModule</code>, where we configure the OpenVidu Components Angular library.</li> <li><code>app/app.component.ts</code>: This file defines the AppComponent, the primary and sole component of the application. It is responsible for requesting the OpenVidu token and passing it to the videoconference component, facilitating the connection to the OpenVidu Room.</li> <li><code>styles.scss</code>: This file defines the global styles of the application. Here, you can customize the UI of the OpenVidu Components Angular library.</li> </ul> <p>To use OpenVidu Components Angular in your application, you need to install the library and import the <code>OpenViduComponentsModule</code> in your Angular module. Let's see how to do this:</p> <ol> <li> <p>Create an Angular Project (version 17 or higher)</p> <p>To begin, you will need to create a new Angular project if you haven't already. Ensure you have Node.js and the Angular CLI installed. Then, run the following command to create a new Angular project:</p> <pre><code>ng new your-project-name\n</code></pre> <p>Replace <code>your-project-name</code> with the desired name for your project.</p> </li> <li> <p>Add Angular Material to your project</p> <p>OpenVidu Components Angular needs Angular Material, which provides a range of UI components. To add Angular Material to your project, navigate to your project directory and run:</p> <pre><code>ng add @angular/material\n</code></pre> </li> <li> <p>Install OpenVidu Components Angular</p> <p>With your Angular project set up, it's time to add videoconferencing capabilities with OpenVidu Components Angular. Install the library using npm:</p> <pre><code>npm install openvidu-components-angular\n</code></pre> </li> <li> <p>Import and use OpenVidu Components Angular</p> <p>To use OpenVidu Components Angular in your application, you need to:</p> <ol> <li>Import the <code>OpenViduComponentsModule</code> in your Angular application.</li> <li>Configure the module with the <code>OpenViduComponentsConfig</code> object.</li> <li>Add the component to your template file.</li> <li>Assign the OpenVidu token and LiveKit URL to the component.</li> <li>Customize the appearance of the components using CSS variables.</li> </ol> </li> </ol> main.tsapp.component.tsstyles.scss <p>In your <code>main.ts</code> application file, import the it and configure it as follows:</p> <pre><code>// Other imports ...\n\nimport { OpenViduComponentsModule, OpenViduComponentsConfig } from 'openvidu-components-angular';\n\nconst config: OpenViduComponentsConfig = {\n    production: true,\n};\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        importProvidersFrom(\n            OpenViduComponentsModule.forRoot(config)\n            // Other imports ...\n        ),\n        provideAnimations(),\n    ],\n}).catch((err) =&gt; console.error(err));\n</code></pre> <p>Use the <code>ov-videoconference</code> component to create a videoconference. This component requires a token to connect to the OpenVidu Room. The <code>AppComponent</code> class is responsible for requesting the token and passing it to the <code>ov-videoconference</code> component.</p> <pre><code>import { MatIcon } from '@angular/material/icon';\nimport { MatIconButton } from '@angular/material/button';\nimport { OpenViduComponentsModule } from 'openvidu-components-angular';\n\n@Component({\n  selector: 'app-root',\n  template:`\n      &lt;ov-videoconference\n        [token]=\"token\"\n        [livekitUrl]=\"LIVEKIT_URL\"\n        [toolbarDisplayRoomName]=\"false\"\n        (onTokenRequested)=\"onTokenRequested($event)\"\n      &gt;\n        &lt;div *ovToolbarAdditionalPanelButtons style=\"text-align: center;\"&gt;\n          &lt;button mat-icon-button (click)=\"onButtonClicked()\"&gt;\n            &lt;mat-icon&gt;star&lt;/mat-icon&gt;\n          &lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/ov-videoconference&gt;\n  `,\n  styles: [''],\n  standalone: true,\n    imports: [OpenViduComponentsModule, MatIconButton, MatIcon],\n})\nexport class AppComponent {\n  // For local development, leave these variables empty\n  // For production, configure them with correct URLs depending on your deployment\n\n  APPLICATION_SERVER_URL = '';  // (1)!\n  LIVEKIT_URL = ''; // (2)!\n\n  // The name of the room to join.\n  roomName = 'openvidu-toolbar-panel-buttons';  // (3)!\n\n  // The token used to join the room.\n  token!: string; // (4)!\n\n  constructor(private httpClient: HttpClient) {\n    this.configureUrls();\n  }\n\n  private configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!this.APPLICATION_SERVER_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.APPLICATION_SERVER_URL = 'http://localhost:6080/';\n      } else {\n        this.APPLICATION_SERVER_URL =\n          'https://' + window.location.hostname + ':6443/';\n      }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!this.LIVEKIT_URL) {\n      if (window.location.hostname === 'localhost') {\n        this.LIVEKIT_URL = 'ws://localhost:7880/';\n      } else {\n        this.LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n      }\n    }\n  }\n\n  // Requests a token to join the room with the given participant name.\n  async onTokenRequested(participantName: string) { // (5)!\n    const { token } = await this.getToken(this.roomName, participantName);\n    this.token = token;\n  }\n\n  // Method to handle button click\n  onButtonClicked() { // (6)!\n    alert('button clicked');\n  }\n\n  // Retrieves a token to join the room with the given name and participant name.\n  getToken(roomName: string, participantName: string): Promise&lt;any&gt; { // (7)!\n    // Requesting token to the server application\n  }\n}\n</code></pre> <ol> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>onButtonClicked</code> method that fires when the custom button is clicked.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ol> <p>The <code>app.component.ts</code> file declares the following properties and methods:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: URL to communicate the client application with the server application to request OpenVidu tokens.</li> <li><code>LIVEKIT_URL</code>: URL to communicate the client application with the LiveKit server.</li> <li><code>roomName</code>: OpenVidu Room identifier. This is the room where the VideoconferenceComponent will connect.</li> <li><code>token</code>: OpenVidu Token used to connect to the OpenVidu Room.</li> <li><code>onTokenRequested</code> method that fires when the VideoconferenceComponent requests a token to connect to the OpenVidu Room.</li> <li><code>onButtonClicked</code> method that fires when the custom button is clicked.</li> <li><code>getToken</code> method that requests a token to the server application.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p> <p>The OpenVidu Components Angular library provides a set of CSS variables that you can use to customize the appearance of the components. You can define these variables in your application's global styles file (e.g. <code>styles.scss</code>).</p> <pre><code>:root {\n    --ov-primary-color: #303030; /* Primary interface color */\n    --ov-secondary-color: #3e3f3f; /* Secondary interface color */\n    --ov-tertiary-color: #598eff; /* Tertiary accent color for elements */\n    --ov-warn-color: #eb5144; /* Warning color for alerts and notifications */\n    --ov-light-color: #e6e6e6; /* Light color for elements */\n\n    --ov-accent-color: #ffae35; /* Accent color for standout UI elements */\n\n    --ov-logo-background-color: #3a3d3d; /* Background color for the logo area */\n    --ov-text-color: #ffffff; /* Default text color */\n\n    --ov-panel-text-color: #1d1d1d; /* Text color for panel elements */\n    --ov-panel-background: #ffffff; /* Background color for panels */\n\n    --ov-buttons-radius: 50%; /* Border-radius for circular buttons */\n    --ov-leave-button-radius: 10px; /* Border-radius for the leave button */\n    --ov-video-radius: 5px; /* Border-radius for video elements */\n    --ov-panel-radius: 5px; /* Border-radius for panel elements */\n}\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/angular-components/openvidu-toolbar-panel-buttons/#adding-custom-buttons-to-the-toolbar","title":"Adding custom buttons to the toolbar","text":"<p>OpenVidu Components Angular provides a directive called <code>*ovToolbarAdditionalPanelButtons</code> that allows you to add custom buttons to the toolbar. This directive can be used to add buttons to the right part of the toolbar.</p> <p>In the <code>app.component.ts</code> file, you can see the following code snippet:</p> <pre><code>@Component({\n    selector: 'app-root',\n    template: `\n        &lt;ov-videoconference\n            [token]=\"token\"\n            [livekitUrl]=\"LIVEKIT_URL\"\n            [toolbarDisplayRoomName]=\"false\"\n            (onTokenRequested)=\"onTokenRequested($event)\"\n        &gt;\n            &lt;div *ovToolbarAdditionalPanelButtons style=\"text-align: center;\"&gt;\n                &lt;button mat-icon-button (click)=\"onButtonClicked()\"&gt;\n                    &lt;mat-icon&gt;star&lt;/mat-icon&gt;\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/ov-videoconference&gt;\n    `,\n    styles: [''],\n    standalone: true,\n    imports: [OpenViduComponentsModule, MatIconButton, MatIcon],\n})\nexport class AppComponent {\n    // ...\n}\n</code></pre> <p>In this code snippet, the <code>*ovToolbarAdditionalPanelButtons</code> directive is used to add a custom button to the right part of the toolbar and is displayed as a star icon, and the <code>onButtonClicked</code> method is called when the button is clicked.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/","title":"Application Client Tutorials","text":"<p>Every application client below shares the same core functionality:</p> <ul> <li>Users request a LiveKit token to any application server to connect to a room.</li> <li>Users may publish their camera, microphone and screen-share.</li> <li>Users automatically subscribe to all media published by other users.</li> <li>Users may leave the room at any time.</li> </ul> <p>Every application client below is interchangeable with the others, because:</p> <ul> <li>All of them are compatible with each other, meaning that participants are able to join the same LiveKit room from any of the client applications.</li> <li>All of them are compatible with any application server, meaning that they can request a LiveKit token from any of the server applications.</li> </ul> <p> JavaScript</p> <p> React</p> <p> Angular</p> <p> Vue</p> <p> Electron</p> <p> Ionic</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/","title":"Angular Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with Angular that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#3-run-a-server-application","title":"3. Run a server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#understanding-the-code","title":"Understanding the code","text":"<p>This Angular project has been created using the Angular CLI tool. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>src/app/</code> directory:</p> <ul> <li><code>app.component.ts</code>: This file defines the <code>AppComponent</code>, which serves as the main component of the application. It is responsible for handling tasks such as joining a video call and managing the video calls themselves.</li> <li><code>app.component.html</code>: This HTML file is associated with the <code>AppComponent</code>, and it dictates the structure and layout of the main application component.</li> <li><code>app.component.css</code>: The CSS file linked to <code>AppComponent</code>, which controls the styling and appearance of the application's main component.</li> <li><code>VideoComponent</code>: Component responsible for displaying video tracks along with participant's data. It is defined in the <code>video.component.ts</code> file within the <code>video</code> directory, along with its associated HTML and CSS files.</li> <li><code>AudioComponent</code>: Component responsible for displaying audio tracks. It is defined in the <code>audio.component.ts</code> file within the <code>audio</code> directory, along with its associated HTML and CSS files.</li> </ul> <p>To use the LiveKit JS SDK in an Angular application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>app.component.ts</code> file:</p> app.component.ts<pre><code>type TrackInfo = { // (1)!\n    trackPublication: RemoteTrackPublication;\n    participantIdentity: string;\n};\n\n// For local development, leave these variables empty\n// For production, configure them with correct URLs depending on your deployment\nvar APPLICATION_SERVER_URL = ''; // (2)!\nvar LIVEKIT_URL = ''; // (3)!\n\n@Component({ // (4)!\n    selector: 'app-root',\n    standalone: true,\n    imports: [ReactiveFormsModule, AudioComponent, VideoComponent],\n    templateUrl: './app.component.html',\n    styleUrl: './app.component.css',\n})\nexport class AppComponent implements OnDestroy {\n    roomForm = new FormGroup({ // (5)!\n        roomName: new FormControl('Test Room', Validators.required),\n        participantName: new FormControl('Participant' + Math.floor(Math.random() * 100), Validators.required),\n    });\n\n    room = signal&lt;Room | undefined&gt;(undefined); // (6)!\n    localTrack = signal&lt;LocalVideoTrack | undefined&gt;(undefined); // (7)!\n    remoteTracksMap = signal&lt;Map&lt;string, TrackInfo&gt;&gt;(new Map()); // (8)!\n\n    constructor(private httpClient: HttpClient) {\n        this.configureUrls();\n    }\n\n    configureUrls() {\n        // If APPLICATION_SERVER_URL is not configured, use default value from local development\n        if (!APPLICATION_SERVER_URL) {\n            if (window.location.hostname === 'localhost') {\n                APPLICATION_SERVER_URL = 'http://localhost:6080/';\n            } else {\n                APPLICATION_SERVER_URL = 'https://' + window.location.hostname + ':6443/';\n            }\n        }\n\n        // If LIVEKIT_URL is not configured, use default value from local development\n        if (!LIVEKIT_URL) {\n            if (window.location.hostname === 'localhost') {\n                LIVEKIT_URL = 'ws://localhost:7880/';\n            } else {\n                LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n            }\n        }\n    }\n</code></pre> <ol> <li><code>TrackInfo</code> type, which groups a track publication with the participant's identity.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>Angular component decorator that defines the <code>AppComponent</code> class and associates the HTML and CSS files with it.</li> <li>The <code>roomForm</code> object, which is a form group that contains the <code>roomName</code> and <code>participantName</code> fields. These fields are used to join a video call room.</li> <li>The room object, which represents the video call room.</li> <li>The local video track, which represents the user's camera.</li> <li>Map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> </ol> <p>The <code>app.component.ts</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>roomForm</code>: A form group that contains the <code>roomName</code> and <code>participantName</code> fields. These fields are used to join a video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>localTrack</code>: The local video track, which represents the user's camera.</li> <li><code>remoteTracksMap</code>: A map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> method is called:</p> app.component.ts<pre><code>async joinRoom() {\n    // Initialize a new Room object\n    const room = new Room();\n    this.room.set(room); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    this.room.on(\n        RoomEvent.TrackSubscribed,\n        (_track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) =&gt; { // (2)!\n            this.remoteTracksMap.update((map) =&gt; {\n                map.set(publication.trackSid, {\n                    trackPublication: publication,\n                    participantIdentity: participant.identity,\n                });\n                return map;\n            });\n        }\n    );\n\n    // On every new Track destroyed...\n    room.on(RoomEvent.TrackUnsubscribed, (_track: RemoteTrack, publication: RemoteTrackPublication) =&gt; { // (3)!\n        this.remoteTracksMap.update((map) =&gt; {\n            map.delete(publication.trackSid);\n            return map;\n        });\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = this.roomForm.value.roomName!; // (4)!\n        const participantName = this.roomForm.value.participantName!;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await this.getToken(roomName, participantName); // (5)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (6)!\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (7)!\n        this.localTrack.set(room.localParticipant.videoTrackPublications.values().next().value.videoTrack);\n    } catch (error: any) {\n        console.log(\n            'There was an error connecting to the room:',\n            error?.error?.errorMessage || error?.message || error\n        );\n        await this.leaveRoom();\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get the room name and participant name from the form.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> method performs the following actions:</p> <ol> <li> <p>It creates a new <code>Room</code> object. This object represents the video call room.</p> <p>Info</p> <p>When the room object is defined, the HTML template is automatically updated hiding the \"Join room\" page and showing the \"Room\" layout.</p> </li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li> <p><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>remoteTracksMap</code>, which links track SIDs with <code>TrackInfo</code> objects containing the track publication and the participant's identity.</p> </li> <li> <p><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the track from the <code>remoteTracksMap</code>.</p> </li> </ul> <p>These event handlers are essential for managing the behavior of tracks within the video call. You can further extend the event handling as needed for your application.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It retrieves the room name and participant name from the form.</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> method:</p> app.component.ts<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync getToken(roomName: string, participantName: string): Promise&lt;string&gt; {\n    const response = await lastValueFrom(\n        this.httpClient.post&lt;{ token: string }&gt;(APPLICATION_SERVER_URL + 'token', { roomName, participantName })\n    );\n    return response.token;\n}\n</code></pre> <p>This function sends a POST request using HttpClient to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then stored in the <code>localTrack</code> variable.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#displaying-video-and-audio-tracks","title":"Displaying Video and Audio Tracks","text":"<p>In order to display participants' video and audio tracks, the <code>app.component.html</code> file integrates the <code>VideoComponent</code> and <code>AudioComponent</code>.</p> app.component.html<pre><code>&lt;div id=\"layout-container\"&gt;\n    @if (localTrack()) {\n    &lt;video-component\n        [track]=\"localTrack()!\"\n        [participantIdentity]=\"roomForm.value.participantName!\"\n        [local]=\"true\"\n    &gt;&lt;/video-component&gt;\n    }\n    @for (remoteTrack of remoteTracksMap().values(); track remoteTrack.trackPublication.trackSid) {\n        @if (remoteTrack.trackPublication.kind === 'video') {\n        &lt;video-component\n            [track]=\"remoteTrack.trackPublication.videoTrack!\"\n            [participantIdentity]=\"remoteTrack.participantIdentity\"\n        &gt;&lt;/video-component&gt;\n        } @else {\n        &lt;audio-component [track]=\"remoteTrack.trackPublication.audioTrack!\" hidden&gt;&lt;/audio-component&gt;\n        }\n    }\n&lt;/div&gt;\n</code></pre> <p>This code snippet does the following:</p> <ul> <li> <p>We use the Angular <code>@if</code> block to conditionally display the local video track using the <code>VideoComponent</code>. The <code>local</code> property is set to <code>true</code> to indicate that the video track belongs to the local participant.</p> <p>Info</p> <p>The audio track is not displayed for the local participant because there is no need to hear one's own audio.</p> </li> <li> <p>Then, we use the Angular <code>@for</code> block to iterate over the <code>remoteTracksMap</code>. For each remote track, we create a <code>VideoComponent</code> or an <code>AudioComponent</code> depending on the track's kind (video or audio). The <code>participantIdentity</code> property is set to the participant's identity, and the <code>track</code> property is set to the video or audio track. The <code>hidden</code> attribute is added to the <code>AudioComponent</code> to hide the audio tracks from the layout.</p> </li> </ul> <p>Let's see now the code of the <code>video.component.ts</code> file:</p> video.component.ts<pre><code>// (1)!\n@Component({\n    selector: 'video-component',\n    standalone: true,\n    imports: [],\n    templateUrl: './video.component.html',\n    styleUrl: './video.component.css',\n})\nexport class VideoComponent implements AfterViewInit, OnDestroy {\n    videoElement = viewChild&lt;ElementRef&lt;HTMLVideoElement&gt;&gt;('videoElement'); // (2)!\n\n    track = input.required&lt;LocalVideoTrack | RemoteVideoTrack&gt;(); // (3)!\n    participantIdentity = input.required&lt;string&gt;(); // (4)!\n    local = input(false); // (5)!\n\n    ngAfterViewInit() {\n        if (this.videoElement()) {\n            this.track().attach(this.videoElement()!.nativeElement); // (6)!\n        }\n    }\n\n    ngOnDestroy() {\n        this.track().detach(); // (7)!\n    }\n}\n</code></pre> <ol> <li>Angular component decorator that defines the <code>VideoComponent</code> class and associates the HTML and CSS files with it.</li> <li>The reference to the video element in the HTML template.</li> <li>The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li>The participant identity associated with the video track.</li> <li>A boolean flag that indicates whether the video track belongs to the local participant.</li> <li>Attach the video track to the video element when the track is set.</li> <li>Detach the video track when the component is destroyed.</li> </ol> <p>The <code>VideoComponent</code> does the following:</p> <ul> <li> <p>It defines the properties <code>track</code>, <code>participantIdentity</code>, and <code>local</code> as inputs of the component:</p> <ul> <li><code>track</code>: The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li><code>participantIdentity</code>: The participant identity associated with the video track.</li> <li><code>local</code>: A boolean flag that indicates whether the video track belongs to the local participant. This flag is set to <code>false</code> by default.</li> </ul> </li> <li> <p>It creates a reference to the video element in the HTML template.</p> </li> <li>It attaches the video track to the video element when the view is initialized.</li> <li>It detaches the video track when the component is destroyed.</li> </ul> <p>Finally, let's see the code of the <code>audio.component.ts</code> file:</p> audio.component.ts<pre><code>// (1)!\n@Component({\n    selector: 'audio-component',\n    standalone: true,\n    imports: [],\n    templateUrl: './audio.component.html',\n    styleUrl: './audio.component.css',\n})\nexport class AudioComponent implements AfterViewInit, OnDestroy {\n    audioElement = viewChild&lt;ElementRef&lt;HTMLAudioElement&gt;&gt;('audioElement'); // (2)!\n\n    track = input.required&lt;LocalAudioTrack | RemoteAudioTrack&gt;(); // (3)!\n\n    ngAfterViewInit() {\n        if (this.audioElement()) {\n            this.track().attach(this.audioElement()!.nativeElement); // (4)!\n        }\n    }\n\n    ngOnDestroy() {\n        this.track().detach(); // (5)!\n    }\n}\n</code></pre> <ol> <li>Angular component decorator that defines the <code>AudioComponent</code> class and associates the HTML and CSS files with it.</li> <li>The reference to the audio element in the HTML template.</li> <li>The audio track object, which can be a <code>RemoteAudioTrack</code> or a <code>LocalAudioTrack</code>, although in this case, it will always be a <code>RemoteAudioTrack</code>.</li> <li>Attach the audio track to the audio element when view is initialized.</li> <li>Detach the audio track when the component is destroyed.</li> </ol> <p>The <code>AudioComponent</code> class is similar to the <code>VideoComponent</code> class, but it is used to display audio tracks. It attaches the audio track to the audio element when view is initialized and detaches the audio track when the component is destroyed.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/angular/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> method:</p> app.component.ts<pre><code>async leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await this.room()?.disconnect(); // (1)!\n\n    // Reset all variables\n    this.room.set(undefined); // (2)!\n    this.localTrack.set(undefined);\n    this.remoteTracksMap.set(new Map());\n}\n\n@HostListener('window:beforeunload') // (3)!\nasync ngOnDestroy() {\n    // On window closed or component destroyed, leave the room\n    await this.leaveRoom();\n}\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Reset all variables.</li> <li>Call the <code>leaveRoom()</code> method when the user closes the browser window or navigates to another page.</li> </ol> <p>The <code>leaveRoom()</code> method performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It resets all variables.</li> </ul> <p>The <code>window.onbeforeunload</code> event and the <code>ngOnDestroy()</code> lifecycle hook are used to ensure that the user leaves the room when the browser window is closed or the component is destroyed.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/","title":"Electron Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with Electron that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/#3-run-a-server-application","title":"3. Run a server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/#understanding-the-code","title":"Understanding the code","text":"<p>This Electron project has been created using electron-forge. As an Electron application, the code is divided into two main parts, the main process and the renderer process. The most important files are located within the <code>src/</code> directory:</p> <ul> <li><code>index.js</code>: This file is the entry point (main process) for the Electron application. It creates the main window and loads the <code>index.html</code> file.</li> <li><code>app.js</code>: This file constitutes the renderer process code, responsible for the application UI and logic. It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</li> <li><code>index.html</code>: This HTML file is responsible for creating the user interface. It contains the form to connect to a video call and the video call layout.</li> <li><code>styles.css</code>: This file contains CSS classes that are used to style the <code>index.html</code> page.</li> </ul> <p>To use the LiveKit JS SDK in an Electron application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>app.js</code> file:</p> app.js<pre><code>const { Room, RoomEvent } = require(\"livekit-client\"); // (1)!\n\n// Configure this constants with correct URLs depending on your deployment\nconst APPLICATION_SERVER_URL = \"http://localhost:6080/\"; // (2)!\nconst LIVEKIT_URL = \"ws://localhost:7880/\"; // (3)!\n\nvar room; // (4)!\n</code></pre> <ol> <li>Import the <code>Room</code> and <code>RoomEvent</code> classes from the <code>livekit-client</code> package.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>The room object, which represents the video call room.</li> </ol> <p>The <code>app.js</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> </ul> <p>Configure the URLs</p> <p>You should configure <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> constants with the correct URLs depending on your deployment.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> function is called:</p> app.js<pre><code>async function joinRoom() {\n    // Disable 'Join' button\n    document.getElementById(\"join-button\").disabled = true;\n    document.getElementById(\"join-button\").innerText = \"Joining...\";\n\n    // Initialize a new Room object\n    room = new Room(); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.on(RoomEvent.TrackSubscribed, (track, _publication, participant) =&gt; {\n        // (2)!\n        addTrack(track, participant.identity);\n    });\n\n    // On every new Track destroyed...\n    room.on(RoomEvent.TrackUnsubscribed, (track, _publication, participant) =&gt; {\n        // (3)!\n        track.detach();\n        document.getElementById(track.sid)?.remove();\n\n        if (track.kind === \"video\") {\n            removeVideoContainer(participant.identity);\n        }\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = document.getElementById(\"room-name\").value; // (4)!\n        const userName = document.getElementById(\"participant-name\").value;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName, userName); // (5)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (6)!\n\n        // Hide the 'Join room' page and show the 'Room' page\n        document.getElementById(\"room-title\").innerText = roomName; // (7)!\n        document.getElementById(\"join\").hidden = true;\n        document.getElementById(\"room\").hidden = false;\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (8)!\n        const localVideoTrack = this.room.localParticipant.videoTrackPublications.values().next().value.track;\n        addTrack(localVideoTrack, userName, true);\n    } catch (error) {\n        console.log(\"There was an error connecting to the room:\", error.message);\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get the room name and participant name from the form.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Hide the \"Join room\" page and show the \"Room\" page.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> function performs the following actions:</p> <ol> <li>It creates a new <code>Room</code> object. This object represents the video call room.</li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It handles the attachment of the track to the HTML page, assigning an ID, and appending it to the <code>layout-container</code> element. If the track is of kind <code>video</code>, a <code>video-container</code> is created and participant data is appended as well.</li> </ul> app.js<pre><code>function addTrack(track, participantIdentity, local = false) {\n    const element = track.attach(); // (1)!\n    element.id = track.sid;\n\n    /* If the track is a video track, we create a container and append the video element to it\n    with the participant's identity */\n    if (track.kind === \"video\") {\n        const videoContainer = createVideoContainer(participantIdentity, local);\n        videoContainer.append(element);\n        appendParticipantData(videoContainer, participantIdentity + (local ? \" (You)\" : \"\"));\n    } else {\n        document.getElementById(\"layout-container\").append(element);\n    }\n}\n</code></pre> <ol> <li>Attach the track to an HTML element.</li> </ol> app.js<pre><code>function createVideoContainer(participantIdentity, local = false) {\n    const videoContainer = document.createElement(\"div\");\n    videoContainer.id = `camera-${participantIdentity}`;\n    videoContainer.className = \"video-container\";\n    const layoutContainer = document.getElementById(\"layout-container\");\n\n    if (local) {\n        layoutContainer.prepend(videoContainer);\n    } else {\n        layoutContainer.append(videoContainer);\n    }\n\n    return videoContainer;\n}\n\nfunction appendParticipantData(videoContainer, participantIdentity) {\n    const dataElement = document.createElement(\"div\");\n    dataElement.className = \"participant-data\";\n    dataElement.innerHTML = `&lt;p&gt;${participantIdentity}&lt;/p&gt;`;\n    videoContainer.prepend(dataElement);\n}\n</code></pre> <ul> <li><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of detaching the track from the HTML page and removing it from the DOM. If the track is a <code>video</code> track, <code>video-container</code> with the participant's identity is removed as well.</li> </ul> app.js<pre><code>function removeVideoContainer(participantIdentity) {\n    const videoContainer = document.getElementById(`camera-${participantIdentity}`);\n    videoContainer?.remove();\n}\n</code></pre> <p>These event handlers are essential for managing the behavior of tracks within the video call.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It retrieves the room name and participant name from the form.</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> function:</p> app.js<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync function getToken(roomName, participantName) {\n    const response = await fetch(APPLICATION_SERVER_URL + \"token\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            roomName,\n            participantName\n        })\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(`Failed to get token: ${error.errorMessage}`);\n    }\n\n    const token = await response.json();\n    return token.token;\n}\n</code></pre> <p>This function sends a POST request using <code>fetch()</code> to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It updates the UI to hide the \"Join room\" page and show the \"Room\" layout.</li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then added to the layout.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/electron/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> function:</p> app.js<pre><code>async function leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await room.disconnect(); // (1)!\n\n    // Remove all HTML elements inside the layout container\n    removeAllLayoutElements(); // (2)!\n\n    // Back to 'Join room' page\n    document.getElementById(\"join\").hidden = false; // (3)!\n    document.getElementById(\"room\").hidden = true;\n\n    // Enable 'Join' button\n    document.getElementById(\"join-button\").disabled = false;\n    document.getElementById(\"join-button\").innerText = \"Join!\";\n}\n\n// (4)!\nwindow.onbeforeunload = () =&gt; {\n    room?.disconnect();\n};\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Remove all HTML elements inside the layout container.</li> <li>Show the \"Join room\" page and hide the \"Room\" layout.</li> <li>Call the <code>disconnect()</code> method on the <code>room</code> object when the user closes the tab or navigates to another page.</li> </ol> <p>The <code>leaveRoom()</code> function performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It removes all HTML elements inside the layout container by calling the <code>removeAllLayoutElements()</code> function.</li> <li>It shows the \"Join room\" page and hides the \"Room\" layout.</li> </ul> <p>The <code>window.onbeforeunload</code> event is used to ensure that the user is disconnected from the room before the page is unloaded. This event is triggered when the user closes the tab or navigates to another page.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/","title":"Ionic Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with Ionic, using Angular and Capacitor, that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#3-run-a-server-application","title":"3. Run a server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB.</p>  Android iOS <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p><p></p></p> </li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#understanding-the-code","title":"Understanding the code","text":"<p>This Ionic project has been created using the Ionic CLI tool. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>src/app/</code> directory:</p> <ul> <li><code>app.component.ts</code>: This file defines the <code>AppComponent</code>, which serves as the main component of the application. It is responsible for handling tasks such as joining a video call and managing the video calls themselves.</li> <li><code>app.component.html</code>: This HTML file is associated with the <code>AppComponent</code>, and it dictates the structure and layout of the main application component.</li> <li><code>app.component.scss</code>: The CSS file linked to <code>AppComponent</code>, which controls the styling and appearance of the application's main component.</li> <li><code>VideoComponent</code>: Component responsible for displaying video tracks along with participant's data. It is defined in the <code>video.component.ts</code> file within the <code>video</code> directory, along with its associated HTML and CSS files.</li> <li><code>AudioComponent</code>: Component responsible for displaying audio tracks. It is defined in the <code>audio.component.ts</code> file within the <code>audio</code> directory, along with its associated HTML and CSS files.</li> </ul> <p>To use the LiveKit JS SDK in an Ionic application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>app.component.ts</code> file:</p> app.component.ts<pre><code>type TrackInfo = { // (1)!\n    trackPublication: RemoteTrackPublication;\n    participantIdentity: string;\n};\n\n// For local development launching app in web browser, leave these variables empty\n// For production or when launching app in device, configure them with correct URLs\nvar APPLICATION_SERVER_URL = ''; // (2)!\nvar LIVEKIT_URL = ''; // (3)!\n\n@Component({ // (4)!\n    selector: 'app-root',\n    templateUrl: 'app.component.html',\n    styleUrl: 'app.component.scss',\n    standalone: true,\n    imports: [\n        IonApp,\n        VideoComponent,\n        AudioComponent,\n        ReactiveFormsModule,\n        IonHeader,\n        IonToolbar,\n        IonTitle,\n        IonButtons,\n        IonButton,\n        IonFab,\n        IonFabButton,\n        IonIcon,\n        IonContent,\n        IonList,\n        IonItem,\n        IonInput,\n        IonFooter,\n    ],\n})\nexport class AppComponent implements OnDestroy {\n    roomForm = new FormGroup({ // (5)!\n        roomName: new FormControl('Test Room', Validators.required),\n        participantName: new FormControl('Participant' + Math.floor(Math.random() * 100), Validators.required),\n    });\n\n    room = signal&lt;Room | undefined&gt;(undefined); // (6)!\n    localTrack = signal&lt;LocalVideoTrack | undefined&gt;(undefined); // (7)!\n    remoteTracksMap = signal&lt;Map&lt;string, TrackInfo&gt;&gt;(new Map()); // (8)!\n\n    constructor(private httpClient: HttpClient) {\n        this.configureUrls();\n        addIcons({\n            logoGithub,\n            book,\n            settings,\n        });\n    }\n\n    configureUrls() {\n        const deviceMode = this.platform.is('hybrid');\n\n        // If APPLICATION_SERVER_URL is not configured and app is not launched in device mode,\n        // use default value from local development\n        if (!APPLICATION_SERVER_URL) {\n            if (deviceMode) {\n                APPLICATION_SERVER_URL = 'https://{YOUR-LAN-IP}.openvidu-local.dev:6443/';\n            } else {\n                if (window.location.hostname === 'localhost') {\n                    APPLICATION_SERVER_URL = 'http://localhost:6080/';\n                } else {\n                    APPLICATION_SERVER_URL = 'https://' + window.location.hostname + ':6443/';\n                }\n            }\n        }\n\n        // If LIVEKIT_URL is not configured and app is not launched in device mode,\n        // use default value from local development\n        if (!LIVEKIT_URL) {\n            if (deviceMode) {\n                LIVEKIT_URL = 'wss://{YOUR-LAN-IP}.openvidu-local.dev:7443/';\n            } else {\n                if (window.location.hostname === 'localhost') {\n                    LIVEKIT_URL = 'ws://localhost:7880/';\n                } else {\n                    LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n                }\n            }\n        }\n    }\n</code></pre> <ol> <li><code>TrackInfo</code> type, which groups a track publication with the participant's identity.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>Angular component decorator that defines the <code>AppComponent</code> class and associates the HTML and CSS files with it.</li> <li>The <code>roomForm</code> object, which is a form group that contains the <code>roomName</code> and <code>participantName</code> fields. These fields are used to join a video call room.</li> <li>The room object, which represents the video call room.</li> <li>The local video track, which represents the user's camera.</li> <li>Map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> </ol> <p>The <code>app.component.ts</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>roomForm</code>: A form group that contains the <code>roomName</code> and <code>participantName</code> fields. These fields are used to join a video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>localTrack</code>: The local video track, which represents the user's camera.</li> <li><code>remoteTracksMap</code>: A map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> </ul> <p>Configure the URLs</p> <p>For local development launching the app in a web browser, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production or when launching the app in a mobile device, you should configure these variables with the correct URLs depending on your deployment.</p> <p>You can also configure these variables once the application has been launched by clicking on the settings button in the bottom right corner of the screen.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> method is called:</p> app.component.ts<pre><code>async joinRoom() {\n    // Initialize a new Room object\n    const room = new Room();\n    this.room.set(room); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    this.room.on(\n        RoomEvent.TrackSubscribed,\n        (_track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) =&gt; { // (2)!\n            this.remoteTracksMap.update((map) =&gt; {\n                map.set(publication.trackSid, {\n                    trackPublication: publication,\n                    participantIdentity: participant.identity,\n                });\n                return map;\n            });\n        }\n    );\n\n    // On every new Track destroyed...\n    room.on(RoomEvent.TrackUnsubscribed, (_track: RemoteTrack, publication: RemoteTrackPublication) =&gt; { // (3)!\n        this.remoteTracksMap.update((map) =&gt; {\n            map.delete(publication.trackSid);\n            return map;\n        });\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = this.roomForm.value.roomName!; // (4)!\n        const participantName = this.roomForm.value.participantName!;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await this.getToken(roomName, participantName); // (5)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (6)!\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (7)!\n        this.localTrack.set(room.localParticipant.videoTrackPublications.values().next().value.videoTrack);\n    } catch (error: any) {\n        console.log(\n            'There was an error connecting to the room:',\n            error?.error?.errorMessage || error?.message || error\n        );\n        await this.leaveRoom();\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get the room name and participant name from the form.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> method performs the following actions:</p> <ol> <li> <p>It creates a new <code>Room</code> object. This object represents the video call room.</p> <p>Info</p> <p>When the room object is defined, the HTML template is automatically updated hiding the \"Join room\" page and showing the \"Room\" layout.</p> </li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li> <p><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>remoteTracksMap</code>, which links track SIDs with <code>TrackInfo</code> objects containing the track publication and the participant's identity.</p> </li> <li> <p><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the track from the <code>remoteTracksMap</code>.</p> </li> </ul> <p>These event handlers are essential for managing the behavior of tracks within the video call. You can further extend the event handling as needed for your application.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It retrieves the room name and participant name from the form.</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> method:</p> app.component.ts<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync getToken(roomName: string, participantName: string): Promise&lt;string&gt; {\n    const response = await lastValueFrom(\n        this.httpClient.post&lt;{ token: string }&gt;(APPLICATION_SERVER_URL + 'token', { roomName, participantName })\n    );\n    return response.token;\n}\n</code></pre> <p>This function sends a POST request using HttpClient to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then stored in the <code>localTrack</code> variable.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#displaying-video-and-audio-tracks","title":"Displaying Video and Audio Tracks","text":"<p>In order to display participants' video and audio tracks, the <code>app.component.html</code> file integrates the <code>VideoComponent</code> and <code>AudioComponent</code>.</p> app.component.html<pre><code>&lt;div id=\"layout-container\"&gt;\n    @if (localTrack()) {\n    &lt;video-component\n        [track]=\"localTrack()!\"\n        [participantIdentity]=\"roomForm.value.participantName!\"\n        [local]=\"true\"\n    &gt;&lt;/video-component&gt;\n    }\n    @for (remoteTrack of remoteTracksMap().values(); track remoteTrack.trackPublication.trackSid) {\n        @if (remoteTrack.trackPublication.kind === 'video') {\n        &lt;video-component\n            [track]=\"remoteTrack.trackPublication.videoTrack!\"\n            [participantIdentity]=\"remoteTrack.participantIdentity\"\n        &gt;&lt;/video-component&gt;\n        } @else {\n        &lt;audio-component [track]=\"remoteTrack.trackPublication.audioTrack!\" hidden&gt;&lt;/audio-component&gt;\n        }\n    }\n&lt;/div&gt;\n</code></pre> <p>This code snippet does the following:</p> <ul> <li> <p>We use the Angular <code>@if</code> block to conditionally display the local video track using the <code>VideoComponent</code>. The <code>local</code> property is set to <code>true</code> to indicate that the video track belongs to the local participant.</p> <p>Info</p> <p>The audio track is not displayed for the local participant because there is no need to hear one's own audio.</p> </li> <li> <p>Then, we use the Angular <code>@for</code> block to iterate over the <code>remoteTracksMap</code>. For each remote track, we create a <code>VideoComponent</code> or an <code>AudioComponent</code> depending on the track's kind (video or audio). The <code>participantIdentity</code> property is set to the participant's identity, and the <code>track</code> property is set to the video or audio track. The <code>hidden</code> attribute is added to the <code>AudioComponent</code> to hide the audio tracks from the layout.</p> </li> </ul> <p>Let's see now the code of the <code>video.component.ts</code> file:</p> video.component.ts<pre><code>// (1)!\n@Component({\n    selector: \"video-component\",\n    standalone: true,\n    imports: [],\n    templateUrl: \"./video.component.html\",\n    styleUrl: \"./video.component.css\"\n})\nexport class VideoComponent implements AfterViewInit, OnDestroy {\n    videoElement = viewChild&lt;ElementRef&lt;HTMLVideoElement&gt;&gt;(\"videoElement\"); // (2)!\n\n    track = input.required&lt;LocalVideoTrack | RemoteVideoTrack&gt;(); // (3)!\n    participantIdentity = input.required&lt;string&gt;(); // (4)!\n    local = input(false); // (5)!\n\n    ngAfterViewInit() {\n        if (this.videoElement()) {\n            this.track().attach(this.videoElement()!.nativeElement); // (6)!\n        }\n    }\n\n    ngOnDestroy() {\n        this.track().detach(); // (7)!\n    }\n}\n</code></pre> <ol> <li>Angular component decorator that defines the <code>VideoComponent</code> class and associates the HTML and CSS files with it.</li> <li>The reference to the video element in the HTML template.</li> <li>The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li>The participant identity associated with the video track.</li> <li>A boolean flag that indicates whether the video track belongs to the local participant.</li> <li>Attach the video track to the video element when the track is set.</li> <li>Detach the video track when the component is destroyed.</li> </ol> <p>The <code>VideoComponent</code> does the following:</p> <ul> <li> <p>It defines the properties <code>track</code>, <code>participantIdentity</code>, and <code>local</code> as inputs of the component:</p> <ul> <li><code>track</code>: The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li><code>participantIdentity</code>: The participant identity associated with the video track.</li> <li><code>local</code>: A boolean flag that indicates whether the video track belongs to the local participant. This flag is set to <code>false</code> by default.</li> </ul> </li> <li> <p>It creates a reference to the video element in the HTML template.</p> </li> <li>It attaches the video track to the video element when the view is initialized.</li> <li>It detaches the video track when the component is destroyed.</li> </ul> <p>Finally, let's see the code of the <code>audio.component.ts</code> file:</p> audio.component.ts<pre><code>// (1)!\n@Component({\n    selector: \"audio-component\",\n    standalone: true,\n    imports: [],\n    templateUrl: \"./audio.component.html\",\n    styleUrl: \"./audio.component.css\"\n})\nexport class AudioComponent implements AfterViewInit, OnDestroy {\n    audioElement = viewChild&lt;ElementRef&lt;HTMLAudioElement&gt;&gt;(\"audioElement\"); // (2)!\n\n    track = input.required&lt;LocalAudioTrack | RemoteAudioTrack&gt;(); // (3)!\n\n    ngAfterViewInit() {\n        if (this.audioElement()) {\n            this.track().attach(this.audioElement()!.nativeElement); // (4)!\n        }\n    }\n\n    ngOnDestroy() {\n        this.track().detach(); // (5)!\n    }\n}\n</code></pre> <ol> <li>Angular component decorator that defines the <code>AudioComponent</code> class and associates the HTML and CSS files with it.</li> <li>The reference to the audio element in the HTML template.</li> <li>The audio track object, which can be a <code>RemoteAudioTrack</code> or a <code>LocalAudioTrack</code>, although in this case, it will always be a <code>RemoteAudioTrack</code>.</li> <li>Attach the audio track to the audio element when view is initialized.</li> <li>Detach the audio track when the component is destroyed.</li> </ol> <p>The <code>AudioComponent</code> class is similar to the <code>VideoComponent</code> class, but it is used to display audio tracks. It attaches the audio track to the audio element when view is initialized and detaches the audio track when the component is destroyed.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#leaving-the-room","title":"Leaving the room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> method:</p> app.component.ts<pre><code>async leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await this.room()?.disconnect(); // (1)!\n\n    // Reset all variables\n    this.room.set(undefined); // (2)!\n    this.localTrack.set(undefined);\n    this.remoteTracksMap.set(new Map());\n}\n\nasync ngOnDestroy() { // (3)!\n    // On window closed or component destroyed, leave the room\n    await this.leaveRoom();\n}\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Reset all variables.</li> <li>Call the <code>leaveRoom()</code> method when the component is destroyed.</li> </ol> <p>The <code>leaveRoom()</code> method performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It resets all variables.</li> </ul> <p>The <code>ngOnDestroy()</code> lifecycle hook is used to ensure that the user leaves the room when the component is destroyed.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/ionic/#specific-mobile-requirements","title":"Specific mobile requirements","text":"<p>In order to be able to test the application on an Android or iOS device, the application must ask for the necessary permissions to access the device's camera and microphone. These permissions are requested when the user joins the video call room.</p>  Android iOS <p>The application must include the following permissions in the <code>AndroidManifest.xml</code> file located in the <code>android/app/src/main/AndroidManifest.xml</code> directory:</p> AndroidManifest.xml<pre><code>&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;\n&lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /&gt;\n</code></pre> <p>The application must include the following permissions in the <code>Info.plist</code> file located in the <code>ios/App/App/Info.plist</code> directory:</p> Info.plist<pre><code>&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;This Application uses your camera to make video calls.&lt;/string&gt;\n&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;\n&lt;string&gt;This Application uses your microphone to make calls.&lt;/string&gt;\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/","title":"JavaScript Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with plain JavaScript, HTML and CSS that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/#3-run-a-server-application","title":"3. Run a server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/#understanding-the-code","title":"Understanding the code","text":"<p>This application is designed to be beginner-friendly and consists of only three essential files that are located in the <code>src</code> directory:</p> <ul> <li><code>app.js</code>: This is the main JavaScript file for the sample application. It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</li> <li><code>index.html</code>: This HTML file is responsible for creating the user interface. It contains the form to connect to a video call and the video call layout.</li> <li><code>styles.css</code>: This file contains CSS classes that are used to style the <code>index.html</code> page.</li> </ul> <p>To use the LiveKit JS SDK in your application, you need to include the library in your HTML file. You can do this by adding the following script tag to the <code>&lt;head&gt;</code> section of your HTML file:</p> index.html<pre><code>&lt;script src=\"https://cdn.jsdelivr.net/npm/livekit-client@2.1.5/dist/livekit-client.umd.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Then, you can use the <code>LivekitClient</code> object in your JavaScript code by referencing it from the <code>window</code> object under <code>LivekitClient</code>. When accessing symbols from the class, you will need to prefix them with <code>LivekitClient.</code>. For example, <code>Room</code> becomes <code>LivekitClient.Room</code>.</p> <p>Now let's see the code of the <code>app.js</code> file:</p> app.js<pre><code>// For local development, leave these variables empty\n// For production, configure them with correct URLs depending on your deployment\nvar APPLICATION_SERVER_URL = \"\"; // (1)!\nvar LIVEKIT_URL = \"\"; // (2)!\nconfigureUrls();\n\nconst LivekitClient = window.LivekitClient; // (3)!\nvar room; // (4)!\n\nfunction configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!APPLICATION_SERVER_URL) {\n        if (window.location.hostname === \"localhost\") {\n            APPLICATION_SERVER_URL = \"http://localhost:6080/\";\n        } else {\n            APPLICATION_SERVER_URL = \"https://\" + window.location.hostname + \":6443/\";\n        }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!LIVEKIT_URL) {\n        if (window.location.hostname === \"localhost\") {\n            LIVEKIT_URL = \"ws://localhost:7880/\";\n        } else {\n            LIVEKIT_URL = \"wss://\" + window.location.hostname + \":7443/\";\n        }\n    }\n}\n</code></pre> <ol> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>The LivekitClient object, which is the entry point to the LiveKit JS SDK.</li> <li>The room object, which represents the video call room.</li> </ol> <p>The <code>app.js</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>LivekitClient</code>: The LiveKit JS SDK object, which is the entry point to the LiveKit JS SDK.</li> <li><code>room</code>: The room object, which represents the video call room.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> function is called:</p> app.js<pre><code>async function joinRoom() {\n    // Disable 'Join' button\n    document.getElementById(\"join-button\").disabled = true;\n    document.getElementById(\"join-button\").innerText = \"Joining...\";\n\n    // Initialize a new Room object\n    room = new LivekitClient.Room(); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, _publication, participant) =&gt; {\n        // (2)!\n        addTrack(track, participant.identity);\n    });\n\n    // On every new Track destroyed...\n    room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track, _publication, participant) =&gt; {\n        // (3)!\n        track.detach();\n        document.getElementById(track.sid)?.remove();\n\n        if (track.kind === \"video\") {\n            removeVideoContainer(participant.identity);\n        }\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = document.getElementById(\"room-name\").value; // (4)!\n        const userName = document.getElementById(\"participant-name\").value;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName, userName); // (5)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (6)!\n\n        // Hide the 'Join room' page and show the 'Room' page\n        document.getElementById(\"room-title\").innerText = roomName; // (7)!\n        document.getElementById(\"join\").hidden = true;\n        document.getElementById(\"room\").hidden = false;\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (8)!\n        const localVideoTrack = this.room.localParticipant.videoTrackPublications.values().next().value.track;\n        addTrack(localVideoTrack, userName, true);\n    } catch (error) {\n        console.log(\"There was an error connecting to the room:\", error.message);\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get the room name and participant name from the form.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Hide the \"Join room\" page and show the \"Room\" page.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> function performs the following actions:</p> <ol> <li>It creates a new <code>Room</code> object using <code>LivekitClient.Room()</code>. This object represents the video call room.</li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li><code>LivekitClient.RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It handles the attachment of the track to the HTML page, assigning an ID, and appending it to the <code>layout-container</code> element. If the track is of kind <code>video</code>, a <code>video-container</code> is created and participant data is appended as well.</li> </ul> app.js<pre><code>function addTrack(track, participantIdentity, local = false) {\n    const element = track.attach(); // (1)!\n    element.id = track.sid;\n\n    /* If the track is a video track, we create a container and append the video element to it\n    with the participant's identity */\n    if (track.kind === \"video\") {\n        const videoContainer = createVideoContainer(participantIdentity, local);\n        videoContainer.append(element);\n        appendParticipantData(videoContainer, participantIdentity + (local ? \" (You)\" : \"\"));\n    } else {\n        document.getElementById(\"layout-container\").append(element);\n    }\n}\n</code></pre> <ol> <li>Attach the track to an HTML element.</li> </ol> app.js<pre><code>function createVideoContainer(participantIdentity, local = false) {\n    const videoContainer = document.createElement(\"div\");\n    videoContainer.id = `camera-${participantIdentity}`;\n    videoContainer.className = \"video-container\";\n    const layoutContainer = document.getElementById(\"layout-container\");\n\n    if (local) {\n        layoutContainer.prepend(videoContainer);\n    } else {\n        layoutContainer.append(videoContainer);\n    }\n\n    return videoContainer;\n}\n\nfunction appendParticipantData(videoContainer, participantIdentity) {\n    const dataElement = document.createElement(\"div\");\n    dataElement.className = \"participant-data\";\n    dataElement.innerHTML = `&lt;p&gt;${participantIdentity}&lt;/p&gt;`;\n    videoContainer.prepend(dataElement);\n}\n</code></pre> <ul> <li><code>LivekitClient.RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of detaching the track from the HTML page and removing it from the DOM. If the track is a <code>video</code> track, <code>video-container</code> with the participant's identity is removed as well.</li> </ul> app.js<pre><code>function removeVideoContainer(participantIdentity) {\n    const videoContainer = document.getElementById(`camera-${participantIdentity}`);\n    videoContainer?.remove();\n}\n</code></pre> <p>These event handlers are essential for managing the behavior of tracks within the video call.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It retrieves the room name and participant name from the form.</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> function:</p> app.js<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync function getToken(roomName, participantName) {\n    const response = await fetch(APPLICATION_SERVER_URL + \"token\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            roomName,\n            participantName\n        })\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(`Failed to get token: ${error.errorMessage}`);\n    }\n\n    const token = await response.json();\n    return token.token;\n}\n</code></pre> <p>This function sends a POST request using <code>fetch()</code> to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It updates the UI to hide the \"Join room\" page and show the \"Room\" layout.</li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then added to the layout.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/javascript/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> function:</p> app.js<pre><code>async function leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await room.disconnect(); // (1)!\n\n    // Remove all HTML elements inside the layout container\n    removeAllLayoutElements(); // (2)!\n\n    // Back to 'Join room' page\n    document.getElementById(\"join\").hidden = false; // (3)!\n    document.getElementById(\"room\").hidden = true;\n\n    // Enable 'Join' button\n    document.getElementById(\"join-button\").disabled = false;\n    document.getElementById(\"join-button\").innerText = \"Join!\";\n}\n\n// (4)!\nwindow.onbeforeunload = () =&gt; {\n    room?.disconnect();\n};\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Remove all HTML elements inside the layout container.</li> <li>Show the \"Join room\" page and hide the \"Room\" layout.</li> <li>Call the <code>disconnect()</code> method on the <code>room</code> object when the user closes the tab or navigates to another page.</li> </ol> <p>The <code>leaveRoom()</code> function performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It removes all HTML elements inside the layout container by calling the <code>removeAllLayoutElements()</code> function.</li> <li>It shows the \"Join room\" page and hides the \"Room\" layout.</li> </ul> <p>The <code>window.onbeforeunload</code> event is used to ensure that the user is disconnected from the room before the page is unloaded. This event is triggered when the user closes the tab or navigates to another page.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/","title":"React Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with React that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#3-run-a-server-application","title":"3. Run a server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#understanding-the-code","title":"Understanding the code","text":"<p>This React project has been generated using the Vite. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>src/</code> directory:</p> <ul> <li><code>App.tsx</code>: This file defines the main application component. It is responsible for handling tasks such as joining a video call and managing the video calls themselves.</li> <li><code>App.css</code>: This file contains the styles for the main application component.</li> <li><code>VideoComponent.tsx</code>: This file defines the <code>VideoComponent</code>. This component is responsible for displaying video tracks along with participant's data. Its associated styles are in <code>VideoComponent.css</code>.</li> <li><code>AudioComponent.vue</code>: This file defines the <code>AudioComponent</code>. This component is responsible for displaying audio tracks.</li> </ul> <p>To use the LiveKit JS SDK in a Vue application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>App.tsx</code> file:</p> App.tsx<pre><code>type TrackInfo = { // (1)!\n    trackPublication: RemoteTrackPublication;\n    participantIdentity: string;\n};\n\n// For local development, leave these variables empty\n// For production, configure them with correct URLs depending on your deployment\nlet APPLICATION_SERVER_URL = \"\"; // (2)!\nlet LIVEKIT_URL = \"\"; // (3)!\nconfigureUrls();\n\nfunction configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!APPLICATION_SERVER_URL) {\n        if (window.location.hostname === \"localhost\") {\n            APPLICATION_SERVER_URL = \"http://localhost:6080/\";\n        } else {\n            APPLICATION_SERVER_URL = \"https://\" + window.location.hostname + \":6443/\";\n        }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!LIVEKIT_URL) {\n        if (window.location.hostname === \"localhost\") {\n            LIVEKIT_URL = \"ws://localhost:7880/\";\n        } else {\n            LIVEKIT_URL = \"wss://\" + window.location.hostname + \":7443/\";\n        }\n    }\n}\n\nfunction App() {\n    const [room, setRoom] = useState&lt;Room | undefined&gt;(undefined); // (4)!\n    const [localTrack, setLocalTrack] = useState&lt;LocalVideoTrack | undefined&gt;(undefined); // (5)!\n    const [remoteTracks, setRemoteTracks] = useState&lt;TrackInfo[]&gt;([]); // (6)!\n\n    const [participantName, setParticipantName] = useState(\"Participant\" + Math.floor(Math.random() * 100)); // (7)!\n    const [roomName, setRoomName] = useState(\"Test Room\"); // (8)!\n</code></pre> <ol> <li><code>TrackInfo</code> type, which groups a track publication with the participant's identity.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>The room object, which represents the video call room.</li> <li>The local video track, which represents the user's camera.</li> <li>The remote tracks array.</li> <li>The participant's name.</li> <li>The room name.</li> </ol> <p>The <code>App.tsx</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>localTrack</code>: The local video track, which represents the user's camera.</li> <li><code>remoteTracks</code>: An array of <code>TrackInfo</code> objects, which group a track publication with the participant's identity.</li> <li><code>participantName</code>: The participant's name.</li> <li><code>roomName</code>: The room name.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> function is called:</p> App.tsx<pre><code>async function joinRoom() {\n    // Initialize a new Room object\n    const room = new Room(); // (1)!\n    setRoom(room);\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.on(\n        RoomEvent.TrackSubscribed,\n        (_track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) =&gt; {\n            // (2)!\n            setRemoteTracks((prev) =&gt; [\n                ...prev,\n                { trackPublication: publication, participantIdentity: participant.identity }\n            ]);\n        }\n    );\n\n    // On every Track destroyed...\n    room.on(RoomEvent.TrackUnsubscribed, (_track: RemoteTrack, publication: RemoteTrackPublication) =&gt; {\n        // (3)!\n        setRemoteTracks((prev) =&gt; prev.filter((track) =&gt; track.trackPublication.trackSid !== publication.trackSid));\n    });\n\n    try {\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName, participantName); // (4)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (5)!\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (6)!\n        setLocalTrack(room.localParticipant.videoTrackPublications.values().next().value.videoTrack);\n    } catch (error) {\n        console.log(\"There was an error connecting to the room:\", (error as Error).message);\n        await leaveRoom();\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get a token from the application server with the room name and participant name from the form.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> function performs the following actions:</p> <ol> <li> <p>It creates a new <code>Room</code> object. This object represents the video call room.</p> <p>Info</p> <p>When the room object is defined, the HTML template is automatically updated hiding the \"Join room\" page and showing the \"Room\" layout.</p> </li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li> <p><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>remoteTracks</code> array as a <code>TrackInfo</code> object containing the track publication and the participant's identity.</p> </li> <li> <p><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the track from the <code>remoteTracks</code> array.</p> </li> </ul> <p>These event handlers are essential for managing the behavior of tracks within the video call. You can further extend the event handling as needed for your application.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> function:</p> App.tsx<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync function getToken(roomName: string, participantName: string) {\n    const response = await fetch(APPLICATION_SERVER_URL + \"token\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            roomName: roomName,\n            participantName: participantName\n        })\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(`Failed to get token: ${error.errorMessage}`);\n    }\n\n    const data = await response.json();\n    return data.token;\n}\n</code></pre> <p>This function sends a POST request using <code>fetch()</code> to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then stored in the <code>localTrack</code> variable.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#displaying-video-and-audio-tracks","title":"Displaying Video and Audio Tracks","text":"<p>In order to display participants' video and audio tracks, the main component integrates the <code>VideoComponent</code> and <code>AudioComponent</code>.</p> App.tsx<pre><code>&lt;div id=\"layout-container\"&gt;\n    {localTrack &amp;&amp; (\n        &lt;VideoComponent track={localTrack} participantIdentity={participantName} local={true} /&gt;\n    )}\n    {remoteTracks.map((remoteTrack) =&gt;\n        remoteTrack.trackPublication.kind === \"video\" ? (\n            &lt;VideoComponent\n                key={remoteTrack.trackPublication.trackSid}\n                track={remoteTrack.trackPublication.videoTrack!}\n                participantIdentity={remoteTrack.participantIdentity}\n            /&gt;\n        ) : (\n            &lt;AudioComponent\n                key={remoteTrack.trackPublication.trackSid}\n                track={remoteTrack.trackPublication.audioTrack!}\n            /&gt;\n        )\n    )}\n&lt;/div&gt;\n</code></pre> <p>This code snippet does the following:</p> <ul> <li> <p>If the property <code>localTrack</code> is defined, we display the local video track using the <code>VideoComponent</code>. The <code>local</code> property is set to <code>true</code> to indicate that the video track belongs to the local participant.</p> <p>Info</p> <p>The audio track is not displayed for the local participant because there is no need to hear one's own audio.</p> </li> <li> <p>Then, we iterate over the <code>remoteTracks</code> array and, for each remote track, we create a <code>VideoComponent</code> or an <code>AudioComponent</code> depending on the track's kind (video or audio). The <code>participantIdentity</code> property is set to the participant's identity, and the <code>track</code> property is set to the video or audio track.</p> </li> </ul> <p>Let's see now the code of the <code>VideoComponent.txs</code> file:</p> VideoComponent.tsx<pre><code>interface VideoComponentProps {\n    track: LocalVideoTrack | RemoteVideoTrack; // (1)!\n    participantIdentity: string; // (2)!\n    local?: boolean; // (3)!\n}\n\nfunction VideoComponent({ track, participantIdentity, local = false }: VideoComponentProps) {\n    const videoElement = useRef&lt;HTMLVideoElement | null&gt;(null); // (4)!\n\n    useEffect(() =&gt; {\n        if (videoElement.current) {\n            track.attach(videoElement.current); // (5)!\n        }\n\n        return () =&gt; {\n            track.detach(); // (6)!\n        };\n    }, [track]);\n\n    return (\n        &lt;div id={\"camera-\" + participantIdentity} className=\"video-container\"&gt;\n            &lt;div className=\"participant-data\"&gt;\n                &lt;p&gt;{participantIdentity + (local ? \" (You)\" : \"\")}&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;video ref={videoElement} id={track.sid}&gt;&lt;/video&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <ol> <li>The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li>The participant identity associated with the video track.</li> <li>A boolean flag that indicates whether the video track belongs to the local participant.</li> <li>The reference to the video element in the HTML template.</li> <li>Attach the video track to the video element when the component is mounted.</li> <li>Detach the video track when the component is unmounted.</li> </ol> <p>The <code>VideoComponent</code> does the following:</p> <ul> <li> <p>It defines the properties <code>track</code>, <code>participantIdentity</code>, and <code>local</code> as props of the component:</p> <ul> <li><code>track</code>: The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li><code>participantIdentity</code>: The participant identity associated with the video track.</li> <li><code>local</code>: A boolean flag that indicates whether the video track belongs to the local participant. This flag is set to <code>false</code> by default.</li> </ul> </li> <li> <p>It creates a reference to the video element in the HTML template.</p> </li> <li>It attaches the video track to the video element when the component is mounted.</li> <li>It detaches the video track when the component is unmounted.</li> </ul> <p>Finally, let's see the code of the <code>AudioComponent.tsx</code> file:</p> AudioComponent.tsx<pre><code>interface AudioComponentProps {\n    track: LocalAudioTrack | RemoteAudioTrack; // (1)!\n}\n\nfunction AudioComponent({ track }: AudioComponentProps) {\n    const audioElement = useRef&lt;HTMLAudioElement | null&gt;(null); // (2)!\n\n    useEffect(() =&gt; {\n        if (audioElement.current) {\n            track.attach(audioElement.current); // (3)!\n        }\n\n        return () =&gt; {\n            track.detach(); // (4)!\n        };\n    }, [track]);\n\n    return &lt;audio ref={audioElement} id={track.sid} /&gt;;\n}\n</code></pre> <ol> <li>The audio track object, which can be a <code>LocalAudioTrack</code> or a <code>RemoteAudioTrack</code>, although in this case, it will always be a <code>RemoteAudioTrack</code>.</li> <li>The reference to the audio element in the HTML template.</li> <li>Attach the audio track to the audio element when the component is mounted.</li> <li>Detach the audio track when the component is unmounted.</li> </ol> <p>The <code>AudioComponent</code> is similar to the <code>VideoComponent</code> but is used to display audio tracks. It defines the <code>track</code> property as a prop for the component and creates a reference to the audio element in the HTML template. The audio track is attached to the audio element when the component is mounted and detached when the component is unmounted.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/react/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> function:</p> App.tsx<pre><code>async function leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await room?.disconnect(); // (1)!\n\n    // Reset the state\n    setRoom(undefined); // (2)!\n    setLocalTrack(undefined);\n    setRemoteTracks([]);\n}\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Reset all variables to their initial state.</li> </ol> <p>The <code>leaveRoom()</code> function performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>Room</code> object.</li> <li>It resets all variables to their initial state.</li> </ul>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/","title":"Vue Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with Vue that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#1-run-openvidu-server","title":"1. Run OpenVidu Server","text":"Run OpenVidu locallyDeploy OpenVidu <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official deployment guide.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#3-run-a-server-application","title":"3. Run a server application","text":"Node Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#understanding-the-code","title":"Understanding the code","text":"<p>This Vue project has been generated using the Vue CLI tool. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>src/</code> directory:</p> <ul> <li> <p><code>App.vue</code>: This file defines the main application component along with its HTML template and styles. It is responsible for handling tasks such as joining a video call and managing the video calls themselves.</p> </li> <li> <p><code>VideoComponent.vue</code>: This file defines the <code>VideoComponent</code>. This component is responsible for displaying video tracks along with participant's data.</p> </li> <li><code>AudioComponent.vue</code>: This file defines the <code>AudioComponent</code>. This component is responsible for displaying audio tracks.</li> </ul> <p>To use the LiveKit JS SDK in a Vue application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>App.vue</code> file:</p> App.vue<pre><code>type TrackInfo = {\n    // (1)!\n    trackPublication: RemoteTrackPublication;\n    participantIdentity: string;\n};\n\n// For local development, leave these variables empty\n// For production, configure them with correct URLs depending on your deployment\nlet APPLICATION_SERVER_URL = \"\"; // (2)!\nlet LIVEKIT_URL = \"\"; // (3)!\nconfigureUrls();\n\nfunction configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from local development\n    if (!APPLICATION_SERVER_URL) {\n        if (window.location.hostname === \"localhost\") {\n            APPLICATION_SERVER_URL = \"http://localhost:6080/\";\n        } else {\n            APPLICATION_SERVER_URL = \"https://\" + window.location.hostname + \":6443/\";\n        }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from local development\n    if (!LIVEKIT_URL) {\n        if (window.location.hostname === \"localhost\") {\n            LIVEKIT_URL = \"ws://localhost:7880/\";\n        } else {\n            LIVEKIT_URL = \"wss://\" + window.location.hostname + \":7443/\";\n        }\n    }\n}\n\nconst room = ref&lt;Room&gt;(); // (4)!\nconst localTrack = ref&lt;LocalVideoTrack&gt;(); // (5)!\nconst remoteTracksMap: Ref&lt;Map&lt;string, TrackInfo&gt;&gt; = ref(new Map()); // (6)!\n\nlet participantName = ref(\"Participant\" + Math.floor(Math.random() * 100)); // (7)!\nlet roomName = ref(\"Test Room\"); // (8)!\n</code></pre> <ol> <li><code>TrackInfo</code> type, which groups a track publication with the participant's identity.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>The room object, which represents the video call room.</li> <li>The local video track, which represents the user's camera.</li> <li>Map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> <li>The participant's name.</li> <li>The room name.</li> </ol> <p>The <code>App.vue</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>localTrack</code>: The local video track, which represents the user's camera.</li> <li><code>remoteTracksMap</code>: A map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> <li><code>participantName</code>: The participant's name.</li> <li><code>roomName</code>: The room name.</li> </ul> <p>Configure the URLs</p> <p>For local development, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for production, you should configure these variables with the correct URLs depending on your deployment.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> function is called:</p> App.vue<pre><code>async function joinRoom() {\n    // Initialize a new Room object\n    room.value = new Room(); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.value.on(\n        RoomEvent.TrackSubscribed,\n        (_track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) =&gt; {\n            // (2)!\n            remoteTracksMap.value.set(publication.trackSid, {\n                trackPublication: publication,\n                participantIdentity: participant.identity\n            });\n        }\n    );\n\n    // On every Track destroyed...\n    room.value.on(RoomEvent.TrackUnsubscribed, (_track: RemoteTrack, publication: RemoteTrackPublication) =&gt; {\n        // (3)!\n        remoteTracksMap.value.delete(publication.trackSid);\n    });\n\n    try {\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName.value, participantName.value); // (4)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.value.connect(LIVEKIT_URL, token); // (5)!\n\n        // Publish your camera and microphone\n        await room.value.localParticipant.enableCameraAndMicrophone(); // (6)!\n        localTrack.value = room.value.localParticipant.videoTrackPublications.values().next().value.videoTrack;\n    } catch (error: any) {\n        console.log(\"There was an error connecting to the room:\", error.message);\n        await leaveRoom();\n    }\n\n    // Add listener for beforeunload event to leave the room when the user closes the tab\n    window.addEventListener(\"beforeunload\", leaveRoom); // (7)!\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get a token from the application server with the room name and participant name from the form.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> <li>Add a listener for the <code>beforeunload</code> event to leave the room when the user closes the tab.</li> </ol> <p>The <code>joinRoom()</code> function performs the following actions:</p> <ol> <li> <p>It creates a new <code>Room</code> object. This object represents the video call room.</p> <p>Info</p> <p>When the room object is defined, the HTML template is automatically updated hiding the \"Join room\" page and showing the \"Room\" layout.</p> </li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li> <p><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>remoteTracksMap</code>, which links track SIDs with <code>TrackInfo</code> objects containing the track publication and the participant's identity.</p> </li> <li> <p><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the track from the <code>remoteTracksMap</code>.</p> </li> </ul> <p>These event handlers are essential for managing the behavior of tracks within the video call. You can further extend the event handling as needed for your application.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> function:</p> App.vue<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync function getToken(roomName: string, participantName: string) {\n    const response = await fetch(APPLICATION_SERVER_URL + \"token\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            roomName,\n            participantName\n        })\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(`Failed to get token: ${error.errorMessage}`);\n    }\n\n    const data = await response.json();\n    return data.token;\n}\n</code></pre> <p>This function sends a POST request using <code>fetch()</code> to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then stored in the <code>localTrack</code> variable.</li> <li>It adds a listener for the <code>beforeunload</code> event to leave the room when the user closes the tab.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#displaying-video-and-audio-tracks","title":"Displaying Video and Audio Tracks","text":"<p>In order to display participants' video and audio tracks, the main component integrates the <code>VideoComponent</code> and <code>AudioComponent</code>.</p> App.vue<pre><code>&lt;div id=\"layout-container\"&gt;\n    &lt;VideoComponent v-if=\"localTrack\" :track=\"localTrack\" :participantIdentity=\"participantName\" :local=\"true\" /&gt;\n    &lt;template v-for=\"remoteTrack of remoteTracksMap.values()\" :key=\"remoteTrack.trackPublication.trackSid\"&gt;\n        &lt;VideoComponent\n            v-if=\"remoteTrack.trackPublication.kind === 'video'\"\n            :track=\"remoteTrack.trackPublication.videoTrack!\"\n            :participantIdentity=\"remoteTrack.participantIdentity\"\n        /&gt;\n        &lt;AudioComponent v-else :track=\"remoteTrack.trackPublication.audioTrack!\" hidden /&gt;\n    &lt;/template&gt;\n&lt;/div&gt;\n</code></pre> <p>This code snippet does the following:</p> <ul> <li> <p>We use the <code>v-if</code> directive to conditionally display the local video track using the <code>VideoComponent</code>. The <code>local</code> property is set to <code>true</code> to indicate that the video track belongs to the local participant.</p> <p>Info</p> <p>The audio track is not displayed for the local participant because there is no need to hear one's own audio.</p> </li> <li> <p>Then, we use the <code>v-for</code> directive to iterate over the <code>remoteTracksMap</code>. For each remote track, we create a <code>VideoComponent</code> or an <code>AudioComponent</code> depending on the track's kind (video or audio). The <code>participantIdentity</code> property is set to the participant's identity, and the <code>track</code> property is set to the video or audio track. The <code>hidden</code> attribute is added to the <code>AudioComponent</code> to hide the audio tracks from the layout.</p> </li> </ul> <p>Let's see now the code of the <code>VideoComponent.vue</code> file:</p> VideoComponent.vue<pre><code>const props = withDefaults(\n    defineProps&lt;{\n        track: LocalVideoTrack | RemoteVideoTrack; // (1)!\n        participantIdentity: string; // (2)!\n        local?: boolean; // (3)!\n    }&gt;(),\n    {\n        local: false\n    }\n);\n\nconst videoElement = ref&lt;HTMLMediaElement | null&gt;(null); // (4)!\n\nonMounted(() =&gt; {\n    if (videoElement.value) {\n        props.track.attach(videoElement.value); // (5)!\n    }\n});\n\nonUnmounted(() =&gt; {\n    props.track.detach(); // (6)!\n});\n</code></pre> <ol> <li>The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li>The participant identity associated with the video track.</li> <li>A boolean flag that indicates whether the video track belongs to the local participant.</li> <li>The reference to the video element in the HTML template.</li> <li>Attach the video track to the video element when the component is mounted.</li> <li>Detach the video track when the component is unmounted.</li> </ol> <p>The <code>VideoComponent</code> does the following:</p> <ul> <li> <p>It defines the properties <code>track</code>, <code>participantIdentity</code>, and <code>local</code> using the <code>defineProps()</code> function:</p> <ul> <li><code>track</code>: The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li><code>participantIdentity</code>: The participant identity associated with the video track.</li> <li><code>local</code>: A boolean flag that indicates whether the video track belongs to the local participant. This flag is set to <code>false</code> by default.</li> </ul> </li> <li> <p>It creates a reference to the video element in the HTML template.</p> </li> <li>It attaches the video track to the video element when the component is mounted.</li> <li>It detaches the video track when the component is unmounted.</li> </ul> <p>Finally, let's see the code of the <code>AudioComponent.vue</code> file:</p> AudioComponent.vue<pre><code>const props = defineProps&lt;{\n    track: LocalAudioTrack | RemoteAudioTrack; // (1)!\n}&gt;();\nconst audioElement = ref&lt;HTMLMediaElement | null&gt;(null); // (2)!\n\nonMounted(() =&gt; {\n    if (audioElement.value) {\n        props.track.attach(audioElement.value); // (3)!\n    }\n});\n\nonUnmounted(() =&gt; {\n    props.track.detach(); // (4)!\n});\n</code></pre> <ol> <li>The audio track object, which can be a <code>LocalAudioTrack</code> or a <code>RemoteAudioTrack</code>, although in this case, it will always be a <code>RemoteAudioTrack</code>.</li> <li>The reference to the audio element in the HTML template.</li> <li>Attach the audio track to the audio element when the component is mounted.</li> <li>Detach the audio track when the component is unmounted.</li> </ol> <p>The <code>AudioComponent</code> is similar to the <code>VideoComponent</code> but is used to display audio tracks. It defines the <code>track</code> property using the <code>defineProps()</code> function and creates a reference to the audio element in the HTML template. The audio track is attached to the audio element when the component is mounted and detached when the component is unmounted.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-client/vue/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> function:</p> App.vue<pre><code>async function leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await room.value?.disconnect(); // (1)!\n\n    // Empty all variables\n    room.value = undefined; // (2)!\n    localTrack.value = undefined;\n    remoteTracksMap.value.clear();\n\n    window.removeEventListener(\"beforeunload\", leaveRoom); // (3)!\n}\n\nonUnmounted(() =&gt; {\n    // (4)!\n    // On component unmount, leave the room\n    leaveRoom();\n});\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Reset all variables to their initial state.</li> <li>Remove the <code>beforeunload</code> event listener.</li> <li>Call the <code>leaveRoom()</code> function when the component is unmounted.</li> </ol> <p>The <code>leaveRoom()</code> function performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>Room</code> object.</li> <li>It resets all variables to their initial state.</li> <li>It removes the <code>beforeunload</code> event listener.</li> </ul> <p>The <code>leaveRoom()</code> function is also called when the component is unmounted using the <code>onUnmounted()</code> lifecycle hook. This ensures that the user leaves the room when the component is no longer needed.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/","title":"Application Server Tutorials","text":"<p>Every application server below has two specific purposes: </p> <ul> <li>Generate LiveKit tokens on demand for any application client.</li> <li>Receive LiveKit webhook events.</li> </ul> <p>To do so they all define two REST endpoints:</p> <ul> <li><code>/token</code>: takes a room and participant name and returns a token.</li> <li><code>/webhook</code>: for receiving webhook events from LiveKit Server.</li> </ul> <p>They use the proper LiveKit Server SDK for their language, if available.</p> <p> NodeJS</p> <p> Go</p> <p> Ruby</p> <p> Java</p> <p> Python</p> <p> Rust</p> <p> PHP</p> <p> .NET</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/dotnet/","title":".NET Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for .NET with ASP.NET Core Minimal APIs that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>Unfortunately there is no .NET SDK for LiveKit available, so the application has to manually build LiveKit compatible JWT tokens using the .NET library <code>System.IdentityModel.Tokens.Jwt</code>, and check the validity of webhook events on its own. It is a fairly easy process.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/dotnet/#running-this-application","title":"Running this application","text":"<p>Download the tutorial code:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your OpenVidu Server.</p> <p>Info</p> <p>You can run any Application Client to test against this server right away.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/dotnet/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple ASP.NET Core Minimal APIs app with a single file <code>Program.cs</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code <code>Program.cs</code> file:</p> Program.cs<pre><code>var builder = WebApplication.CreateBuilder(args); // (1)!\nvar MyAllowSpecificOrigins = \"_myAllowSpecificOrigins\"; // (2)!\n\nIConfiguration config = new ConfigurationBuilder() // (3)!\n                .SetBasePath(Directory.GetCurrentDirectory())\n                .AddJsonFile(\"appsettings.json\")\n                .AddEnvironmentVariables().Build();\n\n// Load env variables\nvar SERVER_PORT = config.GetValue&lt;int&gt;(\"SERVER_PORT\"); // (4)!\nvar LIVEKIT_API_KEY = config.GetValue&lt;string&gt;(\"LIVEKIT_API_KEY\"); // (5)!\nvar LIVEKIT_API_SECRET = config.GetValue&lt;string&gt;(\"LIVEKIT_API_SECRET\"); // (6)!\n\n// Enable CORS support\nbuilder.Services.AddCors(options =&gt; // (7)!\n{\n    options.AddPolicy(name: MyAllowSpecificOrigins,\n                      builder =&gt;\n                      {\n                          builder.WithOrigins(\"*\").AllowAnyHeader();\n                      });\n});\n\nbuilder.WebHost.UseKestrel(serverOptions =&gt; // (8)!\n{\n    serverOptions.ListenAnyIP(SERVER_PORT);\n});\n\nvar app = builder.Build(); // (9)!\napp.UseCors(MyAllowSpecificOrigins);\n</code></pre> <ol> <li>A <code>WebApplicationBuilder</code> instance to build the application.</li> <li>The name of the CORS policy to be used in the application.</li> <li>A <code>IConfiguration</code> instance to load the configuration from the <code>appsettings.json</code> file, including the required environment variables.</li> <li>The port where the application will be listening.</li> <li>The API key of LiveKit Server.</li> <li>The API secret of LiveKit Server.</li> <li>Configure CORS support.</li> <li>Configure the port.</li> <li>Build the application and enable CORS support.</li> </ol> <p>The <code>Program.cs</code> file imports the required dependencies and loads the necessary environment variables (defined in <code>appsettings.json</code> file):</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Finally the application enables CORS support and the port where the application will be listening.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/dotnet/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> Program.cs<pre><code>app.MapPost(\"/token\", async (HttpRequest request) =&gt;\n{\n    var body = new StreamReader(request.Body); // (1)!\n    string postData = await body.ReadToEndAsync();\n    Dictionary&lt;string, dynamic&gt; bodyParams = JsonSerializer.Deserialize&lt;Dictionary&lt;string, dynamic&gt;&gt;(postData) ?? new Dictionary&lt;string, dynamic&gt;();\n\n    if (bodyParams.TryGetValue(\"roomName\", out var roomName) &amp;&amp; bodyParams.TryGetValue(\"participantName\", out var participantName))\n    {\n        var token = CreateLiveKitJWT(roomName.ToString(), participantName.ToString()); // (2)!\n        return Results.Json(new { token }); // (3)!\n    }\n    else\n    {\n        return Results.BadRequest(new { errorMessage = \"roomName and participantName are required\" }); // (4)!\n    }\n});\n</code></pre> <ol> <li>The endpoint obtains a Dictionary from the body request, and check if fields <code>roomName</code> and <code>participantName</code> are available.</li> <li>Create a new JWT token with the room and participant name.</li> <li>Return the token to the client.</li> <li>Return a <code>400</code> error if required fields are not available.</li> </ol> <p>The endpoint obtains a Dictionary from the body request, and check if fields <code>roomName</code> and <code>participantName</code> are available. If not, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. Unfortunately there is no .NET SDK for LiveKit, so we need to create the JWT token manually. The <code>CreateLiveKitJWT</code> method is responsible for creating the LiveKit compatible JWT token:</p> Program.cs<pre><code>string CreateLiveKitJWT(string roomName, string participantName)\n{\n    JwtHeader headers = new(new SigningCredentials(new SymmetricSecurityKey(Encoding.UTF8.GetBytes(LIVEKIT_API_SECRET)), \"HS256\")); // (1)!\n\n    var videoGrants = new Dictionary&lt;string, object&gt;() // (2)!\n    {\n        { \"room\", roomName },\n        { \"roomJoin\", true }\n    };\n    JwtPayload payload = new()\n    {\n        { \"exp\", new DateTimeOffset(DateTime.UtcNow.AddHours(6)).ToUnixTimeSeconds() }, // (3)!\n        { \"iss\", LIVEKIT_API_KEY }, // (4)!\n        { \"nbf\", 0 }, // (5)!\n        { \"sub\", participantName }, // (6)!\n        { \"name\", participantName },\n        { \"video\", videoGrants }\n    };\n    JwtSecurityToken token = new(headers, payload);\n    return new JwtSecurityTokenHandler().WriteToken(token); // (7)!\n}\n</code></pre> <ol> <li>Create a new <code>JwtHeader</code> with <code>LIVEKIT_API_SECRET</code> as the secret key and HS256 as the encryption algorithm.</li> <li>Create a new Dictionary with the video grants for the participant. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Set the expiration time of the token. LiveKit default's is 6 hours.</li> <li>Set the API key of LiveKit Server as the issuer (<code>iss</code>) of the token.</li> <li>The <code>Not before</code> field (<code>nbf</code>) sets when the token becomes valid (0 for immediately valid).</li> <li>Set the participant's name in the claims <code>sub</code> and <code>name</code>.</li> <li>Finally, the returned token is sent back to the client.</li> </ol> <p>This method uses the native <code>System.IdentityModel.Tokens.Jwt</code> library to create a JWT token valid for LiveKit. The most important field in the JwtPayload is <code>video</code>, which will determine the VideoGrant permissions of the participant in the Room. You can also customize the expiration time of the token by changing the <code>exp</code> field, and add a <code>metadata</code> field for the participant. Check out all the available claims.</p> <p>Finally, the returned token is sent back to the client.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/dotnet/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> Program.cs<pre><code>app.MapPost(\"/webhook\", async (HttpRequest request) =&gt;\n{\n    var body = new StreamReader(request.Body);\n    string postData = await body.ReadToEndAsync(); // (1)!\n\n    var authHeader = request.Headers[\"Authorization\"]; // (2)!\n    if (authHeader.Count == 0)\n    {\n        return Results.BadRequest(\"Authorization header is required\");\n    }\n    try\n    {\n        VerifyWebhookEvent(authHeader.First(), postData); // (3)!\n    }\n    catch (Exception e)\n    {\n        Console.Error.WriteLine(\"Error validating webhook event: \" + e.Message);\n        return Results.Unauthorized();\n    }\n\n    Console.Out.WriteLine(postData); // (4)!\n    return Results.Ok(); // (5)!\n});\n</code></pre> <ol> <li>The raw string body of the request contains the webhook event.</li> <li>The <code>Authorization</code> header is required to validate the webhook event.</li> <li>Verify the webhook event.</li> <li>Consume the event as you whish.</li> <li>Return a response to LiveKit Server to let it know that the webhook was received correctly.</li> </ol> <p>The endpoint receives the incoming webhook event and validates it to ensure it is coming from our LiveKit Server. For that we need the raw string body and the <code>Authorization</code> header of the request. After validating it, we can consume the event (in this case, we just log it), and we must also return a <code>200</code> OK response to LiveKit Server to let it know that the webhook was received correctly.</p> <p>Unfortunately there is no .NET SDK for LiveKit, so we need to manually validate the webhook event. The <code>VerifyWebhookEvent</code> method does that:</p> Program.cs<pre><code>void VerifyWebhookEvent(string authHeader, string body)\n{\n    var utf8Encoding = new UTF8Encoding();\n    var tokenValidationParameters = new TokenValidationParameters()\n    {\n        ValidateIssuerSigningKey = true,\n        IssuerSigningKey = new SymmetricSecurityKey(utf8Encoding.GetBytes(LIVEKIT_API_SECRET)), // (1)!\n        ValidateIssuer = true,\n        ValidIssuer = LIVEKIT_API_KEY, // (2)!\n        ValidateAudience = false\n    };\n\n    var jwtValidator = new JwtSecurityTokenHandler();\n    var claimsPrincipal = jwtValidator.ValidateToken(authHeader, tokenValidationParameters, out SecurityToken validatedToken); // (3)!\n\n    var sha256 = SHA256.Create();\n    var hashBytes = sha256.ComputeHash(utf8Encoding.GetBytes(body));\n    var hash = Convert.ToBase64String(hashBytes); // (4)!\n\n    if (claimsPrincipal.HasClaim(c =&gt; c.Type == \"sha256\") &amp;&amp; claimsPrincipal.FindFirstValue(\"sha256\") != hash)\n    {\n        throw new ArgumentException(\"sha256 checksum of body does not match!\");\n    }\n}\n</code></pre> <ol> <li>Use the <code>LIVEKIT_API_SECRET</code> as the secret key to validate the token.</li> <li>Set the <code>LIVEKIT_API_KEY</code> as the issuer of the token.</li> <li>Validate the <code>Authorization</code> header with the recently created <code>TokenValidationParameters</code>. If the <code>LIVEKIT_API_SECRET</code> or <code>LIVEKIT_API_KEY</code> of the LiveKit Server that sent the event do not match the ones in the application, this will throw an exception.</li> <li>Calculate the SHA256 hash of the body and compare it with the <code>sha256</code> claim in the token. If they match, it means the webhook event was not tampered and we can trust it.</li> </ol> <p>We need a <code>TokenValidationParameters</code> object from the <code>Microsoft.IdentityModel.Tokens</code> namespace. We use the <code>LIVEKIT_API_SECRET</code> as the symmetric key, and the <code>LIVEKIT_API_KEY</code> as the issuer of the token.</p> <p>If method <code>JwtSecurityTokenHandler#ValidateToken</code> does rise an exception when validating the <code>Authorization</code> header, it means the webhook event was sent by a LiveKit Server with different credentials.</p> <p>Finally, we calculate the SHA256 hash of the body and compare it with the <code>sha256</code> claim in the token. If they match, it means the webhook event was not tampered and we can definitely trust it.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/go/","title":"Go Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Go with Gin  that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses the LiveKit Go SDK.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/go/#running-this-application","title":"Running this application","text":"<p>Download the tutorial code:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>Info</p> <p>You can run any Application Client to test against this server right away.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/go/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Go app with a single file <code>main.go</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>main.go</code> file:</p> main.go<pre><code>var (\n    SERVER_PORT        = getEnv(\"SERVER_PORT\", \"6080\") // (1)!\n    LIVEKIT_API_KEY    = getEnv(\"LIVEKIT_API_KEY\", \"devkey\") // (2)!\n    LIVEKIT_API_SECRET = getEnv(\"LIVEKIT_API_SECRET\", \"secret\") // (3)!\n)\n\nfunc getEnv(key, defaultValue string) string {\n    if value, ok := os.LookupEnv(key); ok {\n        return value\n    }\n    return defaultValue\n}\n</code></pre> <ol> <li>The port where the application will be listening</li> <li>The API key of LiveKit Server</li> <li>The API secret of LiveKit Server</li> </ol> <p>The <code>main.go</code> file first loads the necessary environment variables:</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Method <code>getEnv</code> simply load each environment variable, giving a default value if not found.</p> <p>The server launch takes place in the <code>main</code> function at the end of the file, where we set the REST endpoints and start the server on <code>SERVER_PORT</code>:</p> main.go<pre><code>func main() {\n    router := gin.Default() // (1)!\n    router.Use(cors.Default()) // (2)!\n    router.POST(\"/token\", createToken) // (3)!\n    router.POST(\"/webhook\", receiveWebhook) // (4)!\n    router.Run(\":\" + SERVER_PORT) // (5)!\n}\n</code></pre> <ol> <li>Create a new Gin router</li> <li>Enable CORS support</li> <li>Create the <code>/token</code> endpoint</li> <li>Create the <code>/webhook</code> endpoint</li> <li>Start the server on the <code>SERVER_PORT</code></li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/go/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> main.go<pre><code>func createToken(context *gin.Context) {\n    var body struct {\n        RoomName        string `json:\"roomName\"`\n        ParticipantName string `json:\"participantName\"`\n    }\n\n    if err := context.BindJSON(&amp;body); err != nil {\n        context.JSON(http.StatusBadRequest, err.Error())\n        return\n    }\n\n    if body.RoomName == \"\" || body.ParticipantName == \"\" {\n        context.JSON(http.StatusBadRequest, gin.H{\"errorMessage\": \"roomName and participantName are required\"})\n        return\n    }\n\n    at := auth.NewAccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET) // (1)!\n    grant := &amp;auth.VideoGrant{\n        RoomJoin: true,\n        Room:     body.RoomName,\n    }\n    at.AddGrant(grant).SetIdentity(body.ParticipantName) // (2)!\n\n    token, err := at.ToJWT() // (3)!\n    if err != nil {\n        context.JSON(http.StatusInternalServerError, err.Error())\n        return\n    }\n\n    context.JSON(http.StatusOK, gin.H{\"token\": token}) // (4)!\n}\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set the video grants and identity of the participant in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>Room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>We first load the request body into a struct with <code>roomName</code> and <code>participantName</code> string fields. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Go SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set the video grants and identity of the participant in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>Room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token and return it to the client.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/go/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> main.go<pre><code>func receiveWebhook(context *gin.Context) {\n    authProvider := auth.NewSimpleKeyProvider( // (1)!\n        LIVEKIT_API_KEY, LIVEKIT_API_SECRET,\n    )\n    event, err := webhook.ReceiveWebhookEvent(context.Request, authProvider) // (2)!\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"error validating webhook event: %v\", err)\n        return\n    }\n    fmt.Println(\"LiveKit Webhook\", event) // (3)!\n}\n</code></pre> <ol> <li>Create a <code>SimpleKeyProvider</code> with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API</code>.</li> <li>Receive the webhook event providing the <code>http.Request</code> in the Gin context and the <code>SimpleKeyProvider</code> we just created. This will validate and decode the incoming webhook event.</li> <li>Consume the event as you whish.</li> </ol> <p></p> <ol> <li>Create a <code>SimpleKeyProvider</code> with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API</code>.</li> <li>Receive the webhook event providing the <code>http.Request</code> in the Gin context and the <code>SimpleKeyProvider</code> we just created. This will validate and decode the incoming webhook event.</li> <li>Consume the event as you whish.</li> </ol> <p></p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/java/","title":"Java Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Java with Spring Boot that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit Kotlin SDK.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/java/#running-this-application","title":"Running this application","text":"<p>Download the tutorial code:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>Info</p> <p>You can run any Application Client to test against this server right away.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/java/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Spring Boot app with a single controller <code>Controller.java</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>Controller.java</code> file:</p> Controller.java<pre><code>@CrossOrigin(origins = \"*\") // (1)!\n@RestController // (2)!\npublic class Controller {\n\n    @Value(\"${livekit.api.key}\")\n    private String LIVEKIT_API_KEY; // (3)!\n\n    @Value(\"${livekit.api.secret}\")\n    private String LIVEKIT_API_SECRET; // (4)!\n\n    ...\n}\n</code></pre> <ol> <li>Allows the application to be accessed from any domain</li> <li>Marks the class as a controller where every method returns a domain object instead of a view</li> <li>The API key of LiveKit Server</li> <li>The API secret of LiveKit Server</li> </ol> <p>Starting by the top, the <code>Controller</code> class has the following annotations:</p> <ul> <li><code>@CrossOrigin(origins = \"*\")</code>: allows the application to be accessed from any domain.</li> <li><code>@RestController</code>: marks the class as a controller where every method returns a domain object instead of a view.</li> </ul> <p>Going deeper, the <code>Controller</code> class has the following fields:</p> <ul> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server. It is injected from the property <code>livekit.api.key</code> defined in <code>application.properties</code> using the <code>@Value(\"${livekit.api.key}\")</code> annotation.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server. It is injected from the the property <code>livekit.api.secret</code> defined in <code>application.properties</code> using the <code>@Value(\"${livekit.api.secret}\")</code> annotation.</li> </ul>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/java/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> Controller.java<pre><code>@PostMapping(value = \"/token\")\npublic ResponseEntity&lt;Map&lt;String, String&gt;&gt; createToken(@RequestBody Map&lt;String, String&gt; params) {\n    String roomName = params.get(\"roomName\");\n    String participantName = params.get(\"participantName\");\n\n    if (roomName == null || participantName == null) {\n        return ResponseEntity.badRequest().body(Map.of(\"errorMessage\", \"roomName and participantName are required\"));\n    }\n\n    AccessToken token = new AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET); // (1)!\n    token.setName(participantName); // (2)!\n    token.setIdentity(participantName);\n    token.addGrants(new RoomJoin(true), new RoomName(roomName)); // (3)!\n\n    return ResponseEntity.ok(Map.of(\"token\", token.toJwt())); // (4)!\n}\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>RoomName</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Kotlin SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>RoomName</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/java/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> Controller.java<pre><code>@PostMapping(value = \"/webhook\", consumes = \"application/webhook+json\")\npublic ResponseEntity&lt;String&gt; receiveWebhook(@RequestHeader(\"Authorization\") String authHeader, @RequestBody String body) { // (1)!\n    WebhookReceiver webhookReceiver = new WebhookReceiver(LIVEKIT_API_KEY, LIVEKIT_API_SECRET); // (2)!\n    try {\n        WebhookEvent event = webhookReceiver.receive(body, authHeader); // (3)!\n        System.out.println(\"LiveKit Webhook: \" + event.toString()); // (4)!\n    } catch (Exception e) {\n        System.err.println(\"Error validating webhook event: \" + e.getMessage());\n    }\n    return ResponseEntity.ok(\"ok\");\n}\n</code></pre> <ol> <li>We need the 'Authorization' header and the raw body of the HTTP request.</li> <li>Initialize the WebhookReceiver using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. It will help validating and decoding incoming webhook events.</li> <li>Obtain the <code>WebhookEvent</code> object using the <code>WebhookReceiver#receive</code> method. It takes the raw body as a String and the Authorization header of the request.</li> <li>Consume the event as you whish.</li> </ol> <p>We declare the 'Authorization' header and the raw body of the HTTP request as parameters of the our method. We need both of them to validate and decode the incoming webhook event.</p> <p>Then we initialize a <code>WebhookReceiver</code> object using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</p> <p>Finally we obtain a <code>WebhookEvent</code> object calling method <code>WebhookReceiver#receive</code>. It takes the raw body as a String and the <code>Authorization</code> header of the request. If everything is correct, you can do whatever you want with the event (in this case, we just log it).</p> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/node/","title":"Node.js Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Node with Express that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit JS SDK.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/node/#running-this-application","title":"Running this application","text":"<p>Download the tutorial code:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre> <p>To run this server application, you need Node installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>Info</p> <p>You can run any Application Client to test against this server right away.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/node/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Express app with a single file <code>index.js</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>index.js</code> file:</p> index.js<pre><code>import \"dotenv/config\";\nimport express from \"express\";\nimport cors from \"cors\";\nimport { AccessToken, WebhookReceiver } from \"livekit-server-sdk\"; // (1)!\n\nconst SERVER_PORT = process.env.SERVER_PORT || 6080; // (2)!\nconst LIVEKIT_API_KEY = process.env.LIVEKIT_API_KEY || \"devkey\"; // (3)!\nconst LIVEKIT_API_SECRET = process.env.LIVEKIT_API_SECRET || \"secret\"; // (4)!\n\nconst app = express(); // (5)!\n\napp.use(cors()); // (6)!\napp.use(express.json()); // (7)!\napp.use(express.raw({ type: \"application/webhook+json\" })); // (8)!\n</code></pre> <ol> <li>Import <code>AccessToken</code> from <code>livekit-server-sdk</code>.</li> <li>The port where the application will be listening.</li> <li>The API key of LiveKit Server.</li> <li>The API secret of LiveKit Server.</li> <li>Initialize the Express application.</li> <li>Enable CORS support.</li> <li>Enable JSON body parsing for the <code>/token</code> endpoint.</li> <li>Enable raw body parsing for the <code>/webhook</code> endpoint.</li> </ol> <p>The <code>index.js</code> file imports the required dependencies and loads the necessary environment variables:</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>It also initializes the <code>WebhookReceiver</code> object that will help validating and decoding incoming webhook events.</p> <p>Finally the <code>express</code> application is initialized. CORS is allowed, JSON body parsing is enabled for the <code>/token</code> endpoint and raw body parsing is enabled for the <code>/webhook</code> endpoint.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/node/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> index.js<pre><code>app.post(\"/token\", async (req, res) =&gt; {\n  const roomName = req.body.roomName;\n  const participantName = req.body.participantName;\n\n  if (!roomName || !participantName) {\n    res.status(400).json({ errorMessage: \"roomName and participantName are required\" });\n    return;\n  }\n\n  const at = new AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET, { // (1)!\n    identity: participantName,\n  });\n  at.addGrant({ roomJoin: true, room: roomName }); // (2)!\n  const token = await at.toJwt(); // (3)!\n  res.json({ token }); // (4)!\n});\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code>, <code>LIVEKIT_API_SECRET</code> and setting the participant's identity.</li> <li>We set the video grants in the AccessToken. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit JS SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code>, <code>LIVEKIT_API_SECRET</code> and setting the participant's identity.</li> <li>We set the video grants in the AccessToken. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/node/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> index.js<pre><code>const webhookReceiver = new WebhookReceiver( // (1)!\n  LIVEKIT_API_KEY,\n  LIVEKIT_API_SECRET\n);\n\napp.post(\"/webhook\", async (req, res) =&gt; {\n  try {\n    const event = await webhookReceiver.receive(\n      req.body, // (2)!\n      req.get(\"Authorization\") // (3)!\n    );\n    console.log(event); // (4)!\n  } catch (error) {\n    console.error(\"Error validating webhook event\", error);\n  }\n  res.status(200).send();\n});\n</code></pre> <ol> <li>Initialize the WebhookReceiver using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. It will help validating and decoding incoming webhook events.</li> <li>The body of the HTTP request.</li> <li>The <code>Authorization</code> header of the HTTP request.</li> <li>Consume the event as you whish.</li> </ol> <p>First of all we initialize the <code>WebhookReceiver</code> using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. This object will validate and decode the incoming webhook events.</p> <p>The endpoint receives the incoming webhook with the async method <code>WebhookReceiver#receive</code>. It takes the body and the <code>Authorization</code> header of the request. If everything is correct, you can do whatever you want with the event (in this case, we just log it).</p> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/php/","title":"PHP Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for PHP  that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit PHP SDK.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/php/#running-this-application","title":"Running this application","text":"<p>Download the tutorial code:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Info</p> <p>You can run any Application Client to test against this server right away.</p> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/php/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple PHP app with a single file <code>index.php</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>index.php</code> file:</p> index.php<pre><code>&lt;?php\nrequire __DIR__ . \"/vendor/autoload.php\";\n\nuse Agence104\\LiveKit\\AccessToken; // (1)!\nuse Agence104\\LiveKit\\AccessTokenOptions;\nuse Agence104\\LiveKit\\VideoGrant;\nuse Agence104\\LiveKit\\WebhookReceiver;\nuse Dotenv\\Dotenv;\n\nDotenv::createImmutable(__DIR__)-&gt;safeLoad();\n\nheader(\"Access-Control-Allow-Origin: *\"); // (2)!\nheader(\"Access-Control-Allow-Headers: Content-Type, Authorization\");\nheader(\"Content-type: application/json\");\n\n$LIVEKIT_API_KEY = $_ENV[\"LIVEKIT_API_KEY\"] ?? \"devkey\"; // (3)!\n$LIVEKIT_API_SECRET = $_ENV[\"LIVEKIT_API_SECRET\"] ?? \"secret\"; // (4)!\n</code></pre> <ol> <li>Import all necessary dependencies from the PHP LiveKit library.</li> <li>Configure HTTP headers for the web server: enable CORS support, allow the <code>Content-Type</code> and <code>Authorization</code> headers and set the response content type to <code>application/json</code>.</li> <li>The API key of LiveKit Server.</li> <li>The API secret of LiveKit Server.</li> </ol> <p>The <code>index.php</code> file imports the required dependencies, sets the HTTP headers for the web server and loads the necessary environment variables:</p> <ul> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/php/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> index.php<pre><code>&lt;?php\nif (isset($_SERVER[\"REQUEST_METHOD\"]) &amp;&amp; $_SERVER[\"REQUEST_METHOD\"] === \"POST\" &amp;&amp; $_SERVER[\"PATH_INFO\"] === \"/token\") {\n    $data = json_decode(file_get_contents(\"php://input\"), true);\n\n    $roomName = $data[\"roomName\"] ?? null;\n    $participantName = $data[\"participantName\"] ?? null;\n\n    if (!$roomName || !$participantName) {\n        http_response_code(400);\n        echo json_encode([\"errorMessage\" =&gt; \"roomName and participantName are required\"]);\n        exit();\n    }\n\n    $tokenOptions = (new AccessTokenOptions()) // (1)!\n        -&gt;setIdentity($participantName);\n    $videoGrant = (new VideoGrant()) // (2)!\n        -&gt;setRoomJoin()\n        -&gt;setRoomName($roomName);\n    $token = (new AccessToken($LIVEKIT_API_KEY, $LIVEKIT_API_SECRET)) // (3)!\n        -&gt;init($tokenOptions)\n        -&gt;setGrant($videoGrant)\n        -&gt;toJwt();\n\n    echo json_encode([\"token\" =&gt; $token]); // (4)!\n    exit();\n}\n</code></pre> <ol> <li>Create an <code>AccessTokenOptions</code> object with the participant's identity.</li> <li>Create a <code>VideoGrant</code> object setting the necessary video grants options. <code>setRoomJoin</code> allows the user to join a room and <code>setRoomName</code> determines the specific room. Check out all Video Grants.</li> <li>We create the <code>AccessToken</code> providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>, initialize it with the token options, set the video grants and generate the JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit PHP SDK:</p> <ol> <li>Create an <code>AccessTokenOptions</code> object with the participant's identity.</li> <li>Create a <code>VideoGrant</code> object setting the necessary video grants options. <code>setRoomJoin</code> allows the user to join a room and <code>setRoomName</code> determines the specific room. Check out all Video Grants.</li> <li>We create the <code>AccessToken</code> providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>, initialize it with the token options, set the video grants and generate the JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/php/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> index.php<pre><code>&lt;?php\n$webhookReceiver = (new WebhookReceiver($LIVEKIT_API_KEY, $LIVEKIT_API_SECRET)); // (1)!\n\nif (isset($_SERVER[\"REQUEST_METHOD\"]) &amp;&amp; $_SERVER[\"REQUEST_METHOD\"] === \"POST\" &amp;&amp; $_SERVER[\"PATH_INFO\"] === \"/webhook\") {\n    $headers = getallheaders();\n    $authHeader = $headers[\"Authorization\"]; // (2)!\n    $body = file_get_contents(\"php://input\"); // (3)!\n    try {\n        $event = $webhookReceiver-&gt;receive($body, $authHeader); // (4)!\n        error_log(\"LiveKit Webhook:\");\n        error_log(print_r($event-&gt;getEvent(), true)); // (5)!\n        exit();\n    } catch (Exception $e) {\n        http_response_code(401);\n        echo \"Error validating webhook event\";\n        echo json_encode($e-&gt;getMessage());\n        exit();\n    }\n}\n</code></pre> <ol> <li>Create a new <code>WebhookReceiver</code> object providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. It will help validating and decoding incoming webhook events.</li> <li>The <code>Authorization</code> header of the HTTP request.</li> <li>The raw body of the HTTP request as a string.</li> <li>Obtain the <code>WebhookEvent</code> object using the <code>WebhookReceiver#receive</code> method. It takes the raw body as a String and the Authorization header of the request.</li> <li>Consume the event as you wish.</li> </ol> <p>We first create a <code>WebhookReceiver</code> object using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. Then we must retrieve the <code>Authorization</code> header and the raw body of the HTTP request. We need both of them to validate and decode the incoming webhook event.</p> <p>Finally, we obtain the <code>WebhookEvent</code> object using the <code>WebhookReceiver#receive</code> method. It takes the raw body as a String and the Authorization header of the request. We can consume the event as we wish (in this case, we just log it using the error output).</p> <p></p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/python/","title":"Python Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Python with Flask that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit Python SDK.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/python/#running-this-application","title":"Running this application","text":"<p>Download the tutorial code:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>Info</p> <p>You can run any Application Client to test against this server right away.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/python/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Flask app with a single file <code>app.py</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>app.py</code> file:</p> app.py<pre><code>import os\nfrom flask import Flask, request\nfrom flask_cors import CORS\nfrom dotenv import load_dotenv\nfrom livekit.api import AccessToken, VideoGrants, TokenVerifier, WebhookReceiver # (1)!\n\nload_dotenv() # (2)!\n\nSERVER_PORT = os.environ.get(\"SERVER_PORT\", 6080) # (3)!\nLIVEKIT_API_KEY = os.environ.get(\"LIVEKIT_API_KEY\", \"devkey\") # (4)!\nLIVEKIT_API_SECRET = os.environ.get(\"LIVEKIT_API_SECRET\", \"secret\") # (5)!\n\napp = Flask(__name__) # (6)!\n\nCORS(app) # (7)!\n</code></pre> <ol> <li>Import all necessary dependencies from <code>livekit</code> library</li> <li>Load environment variables from <code>.env</code> file</li> <li>The port where the application will be listening</li> <li>The API key of LiveKit Server</li> <li>The API secret of LiveKit Server</li> <li>Initialize the Flask application</li> <li>Enable CORS support</li> </ol> <p>The <code>app.py</code> file imports the required dependencies and loads the necessary environment variables from <code>.env</code> file using <code>dotenv</code> library:</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Finally the <code>Flask</code> application is initialized and CORS support is enabled.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/python/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> app.py<pre><code>@app.post(\"/token\")\ndef create_token():\n    room_name = request.json.get(\"roomName\")\n    participant_name = request.json.get(\"participantName\")\n\n    if not room_name or not participant_name:\n        return {\"errorMessage\": \"roomName and participantName are required\"}, 400\n\n    token = (\n        AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET) # (1)!\n        .with_identity(participant_name) # (2)!\n        .with_grants(api.VideoGrants(room_join=True, room=room_name)) # (3)!\n    )\n    return {\"token\": token.to_jwt()} # (4)!\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>room_join</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, we convert the AccessToken to a JWT token and send it back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Python SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>room_join</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, we convert the AccessToken to a JWT token and send it back to the client.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/python/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> app.py<pre><code>token_verifier = TokenVerifier(LIVEKIT_API_KEY, LIVEKIT_API_SECRET) # (1)!\nwebhook_receiver = WebhookReceiver(token_verifier) # (2)!\n\n\n@app.post(\"/webhook\")\ndef receive_webhook():\n    auth_token = request.headers.get(\"Authorization\") # (3)!\n\n    if not auth_token:\n        return \"Authorization header is required\", 401\n\n    try:\n        event = webhook_receiver.receive(request.data.decode(\"utf-8\"), auth_token) # (4)!\n        print(\"LiveKit Webhook:\", event) # (5)!\n        return \"ok\"\n    except:\n        print(\"Authorization header is not valid\")\n        return \"Authorization header is not valid\", 401\n</code></pre> <ol> <li>Initialize a <code>TokenVerifier</code> using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>Initialize a <code>WebhookReceiver</code> using the <code>TokenVerifier</code>. It will help validating and decoding incoming webhook events.</li> <li>Get the 'Authorization' header from the HTTP request.</li> <li>Obtain the webhook event using the <code>WebhookReceiver#receive</code> method. It expects the raw body of the request and the 'Authorization' header.</li> <li>Consume the event as you whish.</li> </ol> <p>First of all, we need a <code>WebhookReceiver</code> for validating and decoding incoming webhook events. We initialize it with a <code>TokenVerifier</code> built with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</p> <p>Inside the <code>receive_webhook</code> handler we:</p> <ol> <li>Get the <code>Authorization</code> header from the HTTP request.</li> <li>Obtain the webhook event using the <code>WebhookReceiver#receive</code> method. It expects the raw body of the request and the <code>Authorization</code> header. In this way, we can validate the event to confirm it is actually coming from our LiveKit Server.</li> <li>If everything is ok, you can consume the event as you whish (in this case, we just log it).</li> </ol> <p></p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/ruby/","title":"Ruby Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Ruby with Sinatra that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit Ruby SDK.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/ruby/#running-this-application","title":"Running this application","text":"<p>Download the tutorial code:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>Info</p> <p>You can run any Application Client to test against this server right away.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/ruby/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Ruby app using the popular Sinatra web library. It has a single file <code>app.rb</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>app.rb</code> file:</p> app.rb<pre><code>require 'sinatra'\nrequire 'sinatra/cors'\nrequire 'sinatra/json'\nrequire 'livekit' # (1)!\nrequire './env.rb'\n\nSERVER_PORT = ENV['SERVER_PORT'] || 6080 # (2)!\nLIVEKIT_API_KEY = ENV['LIVEKIT_API_KEY'] || 'devkey' # (3)!\nLIVEKIT_API_SECRET = ENV['LIVEKIT_API_SECRET'] || 'secret' # (4)!\n\nset :port, SERVER_PORT # (5)!\n\nregister Sinatra::Cors # (6)!\nset :allow_origin, '*' # (7)!\nset :allow_methods, 'POST,OPTIONS'\nset :allow_headers, 'content-type'\nset :bind, '0.0.0.0' # (8)!\n</code></pre> <ol> <li>Import <code>livekit</code> library</li> <li>The port where the application will be listening</li> <li>The API key of LiveKit Server</li> <li>The API secret of LiveKit Server</li> <li>Configure the port</li> <li>Enable CORS support</li> <li>Set allowed origin (any), methods and headers</li> <li>Listen in any available network interface of the host</li> </ol> <p>The <code>app.rb</code> file imports the required dependencies and loads the necessary environment variables (defined in <code>env.rb</code> file):</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Finally the application configures the port, sets the CORS configuration for Sinatra and binds the application to all available network interfaces (0.0.0.0).</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/ruby/#create-token-endpoint","title":"Create token endpoint","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> app.rb<pre><code>post '/token' do\n  body = JSON.parse(request.body.read)\n  room_name = body['roomName']\n  participant_name = body['participantName']\n\n  if room_name.nil? || participant_name.nil?\n    status 400\n    return json({errorMessage: 'roomName and participantName are required'})\n  end\n\n  token = LiveKit::AccessToken.new(api_key: LIVEKIT_API_KEY, api_secret: LIVEKIT_API_SECRET) # (1)!\n  token.identity = participant_name # (2)!\n  token.add_grant(roomJoin: true, room: room_name) # (3)!\n\n  return json({token: token.to_jwt}) # (4)!\nend\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, we convert the AccessToken to a JWT token and send it back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Ruby SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, we convert the AccessToken to a JWT token and send it back to the client.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/ruby/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> app.rb<pre><code>post '/webhook' do\n  auth_header = request.env['HTTP_AUTHORIZATION'] # (1)!\n  token_verifier = LiveKit::TokenVerifier.new(api_key: LIVEKIT_API_KEY, api_secret: LIVEKIT_API_SECRET) # (2)!\n  begin\n    token_verifier.verify(auth_header) # (3)!\n    body = JSON.parse(request.body.read) # (4)!\n    puts \"LiveKit Webhook: #{body}\" # (5)!\n    return\n  rescue =&gt; e\n    puts \"Authorization header is not valid: #{e}\"\n  end\nend\n</code></pre> <ol> <li>Get the <code>Authorization</code> header from the HTTP request.</li> <li>Create a new <code>TokenVerifier</code> instance providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. This will validate the webhook event to confirm it is actually coming from our LiveKit Server.</li> <li>Verify the <code>Authorization</code> header with the <code>TokenVerifier</code>.</li> <li>Now that we are sure the event is valid, we can parse the request JSON body to get the actual webhook event.</li> <li>Consume the event as you whish.</li> </ol> <p></p> <p>We need to verify that the event is coming from our LiveKit Server. For that we need the <code>Authorization</code> header from the HTTP request and a <code>TokenVerifier</code> instance built with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</p> <p>If the verification is successful, we can parse the request JSON body and consume the event (in this case, we just log it).</p> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/rust/","title":"Rust Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Rust with Axum that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses the LiveKit Rust SDK.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/rust/#running-this-application","title":"Running this application","text":"<p>Download the tutorial code:</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>Info</p> <p>You can run any Application Client to test against this server right away.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/rust/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Rust app with a single file <code>main.rs</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>main.rs</code> file:</p> main.rs<pre><code>use axum::http::HeaderMap;\nuse axum::{\n    extract::Json, http::header::CONTENT_TYPE, http::Method, http::StatusCode, routing::post,\n    Router,\n};\nuse dotenv::dotenv;\nuse livekit_api::access_token::AccessToken; // (1)!\nuse livekit_api::access_token::TokenVerifier;\nuse livekit_api::access_token::VideoGrants;\nuse livekit_api::webhooks::WebhookReceiver;\nuse serde_json::{json, Value};\nuse std::env;\nuse tokio::net::TcpListener;\nuse tower_http::cors::{Any, CorsLayer};\n\n#[tokio::main]\nasync fn main() {\n    dotenv().ok(); // (2)!\n\n    let server_port = env::var(\"SERVER_PORT\").unwrap_or(\"6081\".to_string());\n\n    let cors = CorsLayer::new() // (3)!\n        .allow_methods([Method::POST])\n        .allow_origin(Any)\n        .allow_headers([CONTENT_TYPE]);\n\n    let app = Router::new() // (4)!\n        .route(\"/token\", post(create_token))\n        .route(\"/webhook\", post(receive_webhook))\n        .layer(cors);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:\".to_string() + &amp;server_port)\n        .await\n        .unwrap();\n    axum::serve(listener, app).await.unwrap(); // (5)!\n}\n</code></pre> <ol> <li>Import all necessary dependencies from the Rust LiveKit library.</li> <li>Load environment variables from <code>.env</code> file.</li> <li>Enable CORS support.</li> <li>Define <code>/token</code> and <code>/webhook</code> endpoints.</li> <li>Start the server listening on the specified port.</li> </ol> <p>The <code>main.rs</code> file imports the required dependencies and loads the necessary environment variables:</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Then CORS support is enabled and the endpoints are defined. Finally the <code>axum</code> application is initialized on the specified port.</p>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/rust/#create-token-endpoint","title":"Create token endpoint","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> main.rs<pre><code>async fn create_token(payload: Option&lt;Json&lt;Value&gt;&gt;) -&gt; (StatusCode, Json&lt;Value&gt;) {\n    if let Some(payload) = payload {\n        let livekit_api_key = env::var(\"LIVEKIT_API_KEY\").unwrap_or(\"devkey\".to_string());\n        let livekit_api_secret = env::var(\"LIVEKIT_API_SECRET\").unwrap_or(\"secret\".to_string());\n\n        let room_name = match payload.get(\"roomName\") {\n            Some(value) =&gt; value,\n            None =&gt; {\n                return (\n                    StatusCode::BAD_REQUEST,\n                    Json(json!({ \"errorMessage\": \"roomName is required\" })),\n                );\n            }\n        };\n        let participant_name = match payload.get(\"participantName\") {\n            Some(value) =&gt; value,\n            None =&gt; {\n                return (\n                    StatusCode::BAD_REQUEST,\n                    Json(json!({ \"errorMessage\": \"participantName is required\" })),\n                );\n            }\n        };\n\n        let token = match AccessToken::with_api_key(&amp;livekit_api_key, &amp;livekit_api_secret) // (1)!\n            .with_identity(&amp;participant_name.to_string()) // (2)!\n            .with_name(&amp;participant_name.to_string())\n            .with_grants(VideoGrants { // (3)!\n                room_join: true,\n                room: room_name.to_string(),\n                ..Default::default()\n            })\n            .to_jwt() // (4)!\n        {\n            Ok(token) =&gt; token,\n            Err(_) =&gt; {\n                return (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    Json(json!({ \"errorMessage\": \"Error creating token\" })),\n                );\n            }\n        };\n\n        return (StatusCode::OK, Json(json!({ \"token\": token }))); // (5)!\n    } else {\n        return (\n            StatusCode::BAD_REQUEST,\n            Json(json!({ \"errorMessage\": \"roomName and participantName are required\" })),\n        );\n    }\n}\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>room_join</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Rust SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>room_join</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"/3.0.0-beta1/docs/tutorials/application-server/rust/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> main.rs<pre><code>async fn receive_webhook(headers: HeaderMap, body: String) -&gt; (StatusCode, String) {\n    let livekit_api_key = env::var(\"LIVEKIT_API_KEY\").unwrap_or(\"devkey\".to_string());\n    let livekit_api_secret = env::var(\"LIVEKIT_API_SECRET\").unwrap_or(\"secret\".to_string());\n    let token_verifier = TokenVerifier::with_api_key(&amp;livekit_api_key, &amp;livekit_api_secret); // (1)!\n    let webhook_receiver = WebhookReceiver::new(token_verifier); // (2)!\n\n    let auth_header = match headers.get(\"Authorization\") { // (3)!\n        Some(header_value) =&gt; match header_value.to_str() {\n            Ok(header_str) =&gt; header_str,\n            Err(_) =&gt; {\n                return (\n                    StatusCode::BAD_REQUEST,\n                    \"Invalid Authorization header format\".to_string(),\n                );\n            }\n        },\n        None =&gt; {\n            return (\n                StatusCode::BAD_REQUEST,\n                \"Authorization header is required\".to_string(),\n            );\n        }\n    };\n\n    match webhook_receiver.receive(&amp;body, auth_header) { // (4)!\n        Ok(event) =&gt; {\n            println!(\"LiveKit WebHook: {:?}\", event); // (5)!\n            return (StatusCode::OK, \"ok\".to_string());\n        }\n        Err(_) =&gt; {\n            return (\n                StatusCode::UNAUTHORIZED,\n                \"Error validating webhook event\".to_string(),\n            );\n        }\n    }\n}\n</code></pre> <ol> <li>Create a <code>TokenVerifier</code> with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. This will validate the webhook event to confirm it is actually coming from our LiveKit Server.</li> <li>Create a <code>WebhookReceiver</code> with the <code>TokenVerifier</code>.</li> <li>Get the <code>Authorization</code> header from the HTTP request.</li> <li>Obtain the webhook event using the <code>WebhookReceiver#receive</code> method. It expects the raw string body of the request and the <code>Authorization</code> header.</li> <li>Consume the event as you wish.</li> </ol> <p>We declare as function parameters the map of headers (<code>headers: HeaderMap</code>) and the raw body (<code>body: String</code>) of the HTTP request. We will need both of them to validate and decode the incoming webhook event. We then:</p> <ol> <li>Create a <code>TokenVerifier</code> with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. This will validate the webhook event to confirm it is actually coming from our LiveKit Server.</li> <li>Create a <code>WebhookReceiver</code> with the <code>TokenVerifier</code>.</li> <li>Get the <code>Authorization</code> header from the HTTP request.</li> <li>Obtain the webhook event using the <code>WebhookReceiver#receive</code> method. It expects the raw string body of the request and the <code>Authorization</code> header.</li> <li>Consume the event as you wish (in this case, we just log it).</li> </ol> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p></p>"},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/","title":"Angular Components","text":""},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/#introduction","title":"Introduction","text":"<p>Angular Components are the simplest way to create real-time videoconferencing apps with Angular. There's no need to manage state or low-level events; Angular Components from OpenVidu handle all the complexity for you.</p> <p>This Angular library, offers developers a robust set of powerful and comprehensive videoconferencing components. These components are highly adaptable, extendable, and easily replaceable, allowing you to tailor them to your application's specific requirements.</p> <p> </p> Angular Components <p>The primary goal of the OpenVidu team is to minimize the developer's effort when creating videoconferencing applications. Angular Components significantly contribute to this objective for several reasons:</p> <ul> <li> <p> Rapid Development</p> <p>Abstracts the complexity of videoconferencing applications, allowing you to focus on customizations</p> </li> <li> <p> Flexible Customization</p> <p>Offers maximum customization flexibility, allowing you to adapt, extend, and replace any component</p> </li> <li> <p> Easy Maintenance</p> <p>Ensures your code remains up to date, making it easier to update your application with each new OpenVidu release</p> </li> </ul>"},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/#how-to-use","title":"How to use","text":"<p>Using Angular Components in your application is straightforward. The official Angular Components Tutorials cover everything Angular Components offers, from customizing colors and branding logos to injecting new custom features.</p>"},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/#featured-components","title":"Featured Components","text":"<ul> <li> <p>Videoconference</p> <p>The Videoconference component is the core of Angular Components. You can nest HTML and Angular components inside it or leave it empty to use the default setup.</p> <p> See Reference</p> </li> <li> <p>Panel</p> <p>The Panel components is the root of side panels in the videoconference. You can nest HTML and Angular components inside it or leave it empty to use the default setup.</p> <p> See Reference</p> </li> </ul>"},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/#prefabricated-components","title":"Prefabricated Components","text":"<p>Angular Components provides a wide range of prefabricated components that you can use to build your videoconferencing application in a matter of minutes. These components are designed for direct use without any extensions or modifications.</p> Toolbar Layout Stream ChatPanel ParticipantsPanel ParticipantPanelItem ActivitiesPanel RecordingActivity BroadcastingActivity AdminLogin AdminDashboard"},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/#directives","title":"Directives","text":"<p>Angular Components provides two types of directives: Structural Directives and Attribute Directives.</p> <ul> <li> <p>Structural Directives: These directives manipulate the DOM by adding or removing elements from the view.</p> <p>They are distinguished by the asterisk (*) prefix and must be placed inside an HTML element within any Featured Component.</p> <p>For example, the <code>*ovToolbar</code> directive allows you to add a custom toolbar to the videoconference, replacing the default one.</p> <p>You can check the list of available structural directives in the Angular Components API Reference.</p> </li> <li> <p>Attribute Directives: Commonly known as Components Inputs, allow you to manipulate the appearance or behavior of an element.</p> <p>You can check the list of available structural directives in the Angular Components API Reference.</p> </li> </ul>"},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/#events","title":"Events","text":"<p>Each component in Angular Components emits a set of events that you can listen to in your application to trigger specific actions.</p> <p>These events are designed to provide you with the flexibility to customize your videoconferencing application according to your requirements.</p> <p>You can check out all component events in the Angular Components API Reference.</p>"},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/#applications","title":"Applications","text":"<p>A practical example showcases the potential of Angular Components is our production-ready flagship application, OpenVidu Call. This application is built using Angular Components and demonstrates the power and flexibility of the library.</p>"},{"location":"/3.0.0-beta1/docs/ui-components/angular-components/#references","title":"References","text":"<ul> <li>Angular Components API Reference</li> </ul>"},{"location":"/3.0.0-beta1/docs/ui-components/react-components/","title":"React Components","text":""},{"location":"/3.0.0-beta1/docs/ui-components/react-components/#introduction","title":"Introduction","text":"<p>React Components are the simplest way to create real-time audio/video applications with React. There's no need to manage state or low level events, React Components from LiveKit handle all the complexity for you.</p>"},{"location":"/3.0.0-beta1/docs/ui-components/react-components/#featured-components","title":"Featured Components","text":"<p>A curated set of components that we believe are essential and serve as a solid foundation for most applications.</p> <ul> <li> <p>LiveKitRoom</p> <p>It provides the Room context to all its children, serving as the root component of your application, and also exposes the Room state through a React context.</p> <p> See Reference</p> </li> <li> <p>RoomAudioRenderer</p> <p>It manages remote participants' audio tracks and ensures that microphones and screen sharing are audible. It also provides a way to control the volume of each participant.</p> <p> See Reference</p> </li> <li> <p>TrackLoop</p> <p>Provides an easy way to loop through all participant camera and screen tracks. For each track, TrackLoop creates a TrackRefContext that you can use to render the track.</p> <p> See Reference</p> </li> </ul>"},{"location":"/3.0.0-beta1/docs/ui-components/react-components/#prefabricated-components","title":"Prefabricated Components","text":"<p>Prefabricated are constructed using components and enhanced with additional functionalities, unique styles, and practical defaults. They are designed for immediate use and are not meant to be extended.</p> AudioConference Chat ControlBar MediaDeviceMenu PreJoin VideoConference"},{"location":"/3.0.0-beta1/docs/ui-components/react-components/#contexts","title":"Contexts","text":"<p>Contexts are used to allow child components to access parent state without having to pass it down the component tree via props</p> Participant Room Chat Feature Layout Pin TrackRef"},{"location":"/3.0.0-beta1/docs/ui-components/react-components/#hooks","title":"Hooks","text":"<p>Hooks are functions that let you use state and other React features without writing a class. They are functions that let you \u201chook into\u201d React state and lifecycle features from function components.</p> <p>React Components provides a set of hooks that you can use to interact with the components and the underlying LiveKit client.</p> <p> See Reference</p>"},{"location":"/3.0.0-beta1/docs/ui-components/react-components/#applications","title":"Applications","text":"<p>A practical example showcases the potential of React Components is the production-ready flagship application, LiveKit Meet. This application is built using React Components and demonstrates the power and flexibility of the library.</p>"},{"location":"/3.0.0-beta1/docs/ui-components/react-components/#references","title":"References","text":"<ul> <li>React Components</li> </ul>"}]}