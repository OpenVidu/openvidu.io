{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"advanced-features/automatic-reconnection/","text":"Automatic reconnection Since release 2.12.0, clients are be able to automatically reconnect their media streams with OpenVidu after a network drop. To understand how this works, let's first differentiate between the two types of connections clients have with OpenVidu: Signaling plane : this is the connection used by clients to send requests to OpenVidu (join a Session, publish a Stream...) and used by OpenVidu to send back to clients answers to those requests and one-way events. Media plane : this is the connection used by clients and OpenVidu to actually send and receive audio/video data flows. Both connections live separately and use completely different communication protocols (WebSocket vs WebRTC). Once these concepts have been clarified, we can now explain which is the workflow once a client loses their network connection. The moment the client detects that its connection with OpenVidu is broken, they will actively try to re-establish a connection with OpenVidu's signaling plane, and won't stop trying until success. So, after a client loses its network connection 1 of 3 things may happen depending on the amount of time elapsed (the time indicated in parentheses is roughly a guide): 1) The client recovers its connection rather quickly (0~7 seconds) Both the signaling plane and the media plane are fine. Nothing else must be done: the user is reconnected to the Session. 2) The client recovers its connection too late (> 12 seconds) OpenVidu thinks the client has disconnected with no chance of recovery and proceeds to kick him out of the Session. Once the user recovers their connection, they will receive a rejection message from OpenVidu. They are by all means no longer part of the Session, and they need to join it again as a new user. Every other participant of the Session will already have received the proper events with reason property set to networkDisconnect streamDestroyed event (only if the disconnected participant was publishing to the Session) connectionDestroyed event 3) The client recovers its connection soon enough to hold on the signaling plane but not the media plane (7~12 seconds) This intermediate case is the only one that requires an actual active process of renegotiation between the client and OpenVidu. The client manages to recover its network connection soon enough that OpenVidu has not evicted it from the Session for lack of ping, but the media plane might be frozen depending on the amount of time elapsed. In this case, the only solution is to renegotiate the whole media connections with OpenVidu. Clients will automatically do so: they analyze each one of the media connections that where established before the network dropped and for each one of them that is frozen, silently asks OpenVidu to fully recreate a new media connection, keeping the previous configuration. What clients perceive is that videos leave the frozen state and play again without having to do anything. It should be stressed that this doesn't mean that the media plane will always be broken at this particular point: it is just one possibility that sometimes may happen depending on many factors: client's device, time elapsed, network topology... Reconnection events To help managing the 3 scenarios of the previous section, the Session object owned by the affected user will dispatch the following events during the reconnection process: Event reconnecting is triggered once the client realizes its connection to OpenVidu is broken Once the connection ir recovered: If OpenVidu has not evicted the user yet, reconnected event is dispatched. Media streams may be renegotiated under the hood if necessary If OpenVidu has evicted the user, sessionDisconnected event is fired with reason set to networkDisconnect session.on('reconnecting', () => console.warn('Oops! Trying to reconnect to the session')); session.on('reconnected', () => console.log('Hurray! You successfully reconnected to the session')); session.on('sessionDisconnected', (event) => { if (event.reason === 'networkDisconnect') { console.warn('Dang-it... You lost your connection to the session'); } else { // Disconnected from the session for other reason than a network drop } });","title":"Automatic reconnection"},{"location":"advanced-features/automatic-reconnection/#automatic-reconnection","text":"Since release 2.12.0, clients are be able to automatically reconnect their media streams with OpenVidu after a network drop. To understand how this works, let's first differentiate between the two types of connections clients have with OpenVidu: Signaling plane : this is the connection used by clients to send requests to OpenVidu (join a Session, publish a Stream...) and used by OpenVidu to send back to clients answers to those requests and one-way events. Media plane : this is the connection used by clients and OpenVidu to actually send and receive audio/video data flows. Both connections live separately and use completely different communication protocols (WebSocket vs WebRTC). Once these concepts have been clarified, we can now explain which is the workflow once a client loses their network connection. The moment the client detects that its connection with OpenVidu is broken, they will actively try to re-establish a connection with OpenVidu's signaling plane, and won't stop trying until success. So, after a client loses its network connection 1 of 3 things may happen depending on the amount of time elapsed (the time indicated in parentheses is roughly a guide):","title":"Automatic reconnection"},{"location":"advanced-features/automatic-reconnection/#1-the-client-recovers-its-connection-rather-quickly-07-seconds","text":"Both the signaling plane and the media plane are fine. Nothing else must be done: the user is reconnected to the Session.","title":"1) The client recovers its connection rather quickly (0~7 seconds)"},{"location":"advanced-features/automatic-reconnection/#2-the-client-recovers-its-connection-too-late-12-seconds","text":"OpenVidu thinks the client has disconnected with no chance of recovery and proceeds to kick him out of the Session. Once the user recovers their connection, they will receive a rejection message from OpenVidu. They are by all means no longer part of the Session, and they need to join it again as a new user. Every other participant of the Session will already have received the proper events with reason property set to networkDisconnect streamDestroyed event (only if the disconnected participant was publishing to the Session) connectionDestroyed event","title":"2) The client recovers its connection too late (&gt; 12 seconds)"},{"location":"advanced-features/automatic-reconnection/#3-the-client-recovers-its-connection-soon-enough-to-hold-on-the-signaling-plane-but-not-the-media-plane-712-seconds","text":"This intermediate case is the only one that requires an actual active process of renegotiation between the client and OpenVidu. The client manages to recover its network connection soon enough that OpenVidu has not evicted it from the Session for lack of ping, but the media plane might be frozen depending on the amount of time elapsed. In this case, the only solution is to renegotiate the whole media connections with OpenVidu. Clients will automatically do so: they analyze each one of the media connections that where established before the network dropped and for each one of them that is frozen, silently asks OpenVidu to fully recreate a new media connection, keeping the previous configuration. What clients perceive is that videos leave the frozen state and play again without having to do anything. It should be stressed that this doesn't mean that the media plane will always be broken at this particular point: it is just one possibility that sometimes may happen depending on many factors: client's device, time elapsed, network topology...","title":"3) The client recovers its connection soon enough to hold on the signaling plane but not the media plane (7~12 seconds)"},{"location":"advanced-features/automatic-reconnection/#reconnection-events","text":"To help managing the 3 scenarios of the previous section, the Session object owned by the affected user will dispatch the following events during the reconnection process: Event reconnecting is triggered once the client realizes its connection to OpenVidu is broken Once the connection ir recovered: If OpenVidu has not evicted the user yet, reconnected event is dispatched. Media streams may be renegotiated under the hood if necessary If OpenVidu has evicted the user, sessionDisconnected event is fired with reason set to networkDisconnect session.on('reconnecting', () => console.warn('Oops! Trying to reconnect to the session')); session.on('reconnected', () => console.log('Hurray! You successfully reconnected to the session')); session.on('sessionDisconnected', (event) => { if (event.reason === 'networkDisconnect') { console.warn('Dang-it... You lost your connection to the session'); } else { // Disconnected from the session for other reason than a network drop } });","title":"Reconnection events"},{"location":"advanced-features/filters/","text":"Voice and video filters OpenVidu API offers a simple way of applying filters to video and audio streams in the server side by making use of Kurento Media Server capabilities. This is the current status of filter support in OpenVidu: You can apply one filter at a time to a published Stream . Every user subscribed to it will receive the modified stream. You can remove an applied filter . You can call any remote method offered by an applied filter You can add and remove event listeners to any event dispatched by an applied filter. You must configure in the participant token the allowed filters the user can apply. WARNING : video filters that make use of OpenCV are not available for OpenVidu installations in Ubuntu 18.04 , only in Ubuntu 16.04. This affects the following Kurento filters : FaceOverlayFilter , ChromaFilter , PointerDetectorFilter , CrowdDetectorFilter , PlateDetectorFilter . All other filters work fine in Ubuntu 18.04 Step by step 1) Generate a token with the filters the user will be able to apply This is a simple way of securing the ability of applying filters from OpenVidu Browser, so that not every user is able to apply any filter at any time. REST API Java Node When generating a token with operation POST /api/tokens include in the JSON body a parameter kurentoOptions with a property allowedFilters : a string array containing the name of the filters the user will be able to apply { \"session\": \"6fpivlanw91qjy6n\", \"data\": \"user_data\", \"role\": \"PUBLISHER\", \"kurentoOptions\": { \"allowedFilters\": [\"GStreamerFilter\", \"FaceOverlayFilter\"] } } When generating a token, call TokenOptions.Builder#kurentoOptions(KurentoOptions) to set allowedFilters value with method KurentoOptions.Builder#allowedFilters(String[]) . This method receives a string array containing the name of the filters the user will be able to apply TokenOptions tokenOptions = new TokenOptions.Builder() .role(OpenViduRole.PUBLISHER) .data(\"user_data\") .kurentoOptions( new KurentoOptions.Builder() .allowedFilters(new String[]{\"GStreamerFilter\", \"FaceOverlayFilter\"}) .build()) .build(); String token = session.generateToken(tokenOptions); When generating a token, include in TokenOptions parameter a kurentoOptions object with allowedFiters property: a string array containing the name of the filters the user will be able to apply var tokenOptions = { role: \"PUBLISHER\", data: \"user_data\", kurentoOptions: { allowedFilters: [\"GStreamerFilter\", \"FaceOverlayFilter\"] } }; session.generateToken(tokenOptions).then(token => { ... }); 2.A) Initialize a Publisher object configured for using a filter from the beginning of the publishing ... Use PublisherProperties , specifically property filter : var OV = new OpenVidu(); var publisher = OV.initPublisher( targetElement, filter: { type: \"GStreamerFilter\", options: { command: \"videoflip method=vertical-flip\" } } ); // ... user already connected to \"session\" with the appropriate token session.publish(publisher); 2.B) ... or apply the filter dynamically after publishing the stream, whenever you want // ... user already connected to the session with the appropriate token // and successfully publishing the Publisher object publisher.stream.applyFilter(\"GStreamerFilter\", { command: \"videoflip method=vertical-flip\" }) .then(() => { console.log(\"Video rotated!\"); }) .catch(error => { console.error(error); }); 3) You can execute any method offered by the filter // ... user already connected to the session with the appropriate token, // successfully publishing the Publisher object and a filter being applied to its stream publisher.stream.filter.execMethod(\"setElementProperty\", {\"propertyName\":\"method\",\"propertyValue\":\"horizontal-flip\"}) .then(() => { console.log(\"Video rotation direction modified!\"); }) .catch(error => { console.error(error); }); 4) You can also subscribe to any filter event (if it dispatches any), and later unsubscribe from it // ... user already connected to the session with the appropriate token, // successfully publishing the Publisher object and a filter being applied to its stream publisher.stream.filter.addEventListener(\"FooFilterEvent\", filterEvent => { console.log('Filter event received!. Data: ' + filterEvent.data); }); ... publisher.stream.filter.removeEventListener(\"FooFilterEvent\"); 4) To remove the filter // ... user already connected to the session with the appropriate token, // successfully publishing the Publisher object and a filter being applied to its stream publisher.stream.removeFilter() .then(() => { console.log(\"Filter removed\"); }) .catch(error => { console.error(error); }); Moderators are not only able to call all of these methods over their Publisher.stream object, but also over any Subscriber.stream object. Also, they don't need any special token permission to apply filters and can bypass any token restriction set to other user tokens Filter samples GStreamer filters These filters are set with type GStreamerFilter and an options parameter like this: publisher.stream.applyFilter(\"GStreamerFilter\", {\"command\": \"GSTREAMER_COMMAND\"}) A list of interesting values for GSTREAMER_COMMAND parameter is stated below. Replace GSTREAMER_COMMAND in the upper code snippet for any of the examples provided in the following list items: Video overlay filters gdkpixbufoverlay : overlays an image on top of the video. This is very useful, for example, to add a logo Example: gdkpixbufoverlay location=/images/img.png offset-x=10 offset-y=10 overlay-height=200 overlay-width=200 Documentation: Link textoverlay : overlays an embedded text on top of the video Example: textoverlay text=\"Embedded text\" valignment=top halignment=right font-desc=\"Cantarell 25\" Documentation: Link timeoverlay : overlays the time the video stream has been playing Example: timeoverlay valignment=bottom halignment=right font-desc=\"Sans, 20\" Documentation: Link clockoverlay : overlays a clock with the local time (in OpenVidu Server host) Example: clockoverlay valignment=bottom halignment=right shaded-background=true font-desc=\"Sans, 20\" Documentation: Link Video effect filters videoflip : rotates the video stream Example: videoflip method=vertical-flip Documentation: Link videocrop : crops the video steam Example: videocrop top=100 left=35 right=0 bottom=0 Documentation: Link videobox : resizes a video stream by adding borders or cropping Example: videobox fill=black top=20 bottom=20 left=-10 right=-10 Documentation: Link chromahold : removes all colors from the video stream except the RGB indicated one Example: chromahold target-r=0 target-g=0 target-b=255 tolerance=90 Documentation: Link coloreffects : applies different color filters to the video stream Example: coloreffects preset=heat Documentation: Link videobalance : changes different properties of the video stream such as brightness, contrast, hue or saturation Example: videobalance saturation=0.0 Documentation: Link gamma : adjusts gamma level of the video stream Example: gamma gamma=5.0 Documentation: Link videomedian : adds a median filter to the video stream Example: videomedian filtersize=9 lum-only=false Documentation: Link Many effects of effectv project : funny filters for the video stream like agingtv , dicetv , optv , quarktv , radioactv , revtv , rippletv , shagadelictv , streaktv , vertigotv , warptv Example: radioactv Audio filters audioecho : adds reverb to the audio stream Example: audioecho delay=50000000 intensity=0.6 feedback=0.4 Documentation: Link audioamplify : amplifies an audio stream by a given factor Example: audioamplify amplification=1.5 clipping-method=wrap-positive Documentation: Link pitch : controls the pitch of an audio stream Example: pitch pitch=1.2 Documentation: Link Other audio filters: check them out in GStreamer site All available GStreamer plugins can be found in GStreamer site . Kurento filters FaceOverlayFilter (overlay an image over detected faces) publisher.stream.applyFilter(\"FaceOverlayFilter\") .then(filter => { filter.execMethod( \"setOverlayedImage\", { \"uri\":\"https://cdn.pixabay.com/photo/2013/07/12/14/14/derby-148046_960_720.png\", \"offsetXPercent\":\"-0.2F\", \"offsetYPercent\":\"-0.8F\", \"widthPercent\":\"1.3F\", \"heightPercent\":\"1.0F\" }); }); ChromaFilter (set a chroma background) publisher.stream.applyFilter( \"ChromaFilter\", { \"window\": { \"topRightCornerX\": 0, \"topRightCornerY\": 0, \"width\": 50, \"height\": 50 }, \"backgroundImage\": \"https://www.maxpixel.net/static/photo/1x/Cool-Blue-Liquid-Lake-Abstract-Background-Clear-316144.jpg\" }); You must install Kurento ChromaFilter library in the same host as Kurento Media Server: sudo apt-get install kms-chroma ZBarFilter (detect and read bar codes information) publisher.stream.applyFilter(\"ZBarFilter\") .then(filter => { filter.addEventListener(\"CodeFound\", filterEvent => { console.log('Bar code found!. Data: ' + filterEvent.data); } }); function changeLangTab(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.textContent || event.target.innerText; var txt = txt.replace(/\\s/g, \"-\").toLowerCase(); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of language buttons if (child.classList.contains(\"lang-tabs-header\")) { for (var j = 0; j < child.children.length; j++) { var btn = child.children[j]; if (btn.classList.contains(\"lang-tabs-btn\")) { btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9'; btn.style.fontWeight = btn === event.target ? 'bold' : 'normal'; } } } // Change visibility of language content if (child.classList.contains(\"lang-tabs-content\")) { if (child.id === txt) { child.style.display = \"block\"; } else { child.style.display = \"none\"; } } } }","title":"Voice and video filters"},{"location":"advanced-features/filters/#voice-and-video-filters","text":"OpenVidu API offers a simple way of applying filters to video and audio streams in the server side by making use of Kurento Media Server capabilities. This is the current status of filter support in OpenVidu: You can apply one filter at a time to a published Stream . Every user subscribed to it will receive the modified stream. You can remove an applied filter . You can call any remote method offered by an applied filter You can add and remove event listeners to any event dispatched by an applied filter. You must configure in the participant token the allowed filters the user can apply. WARNING : video filters that make use of OpenCV are not available for OpenVidu installations in Ubuntu 18.04 , only in Ubuntu 16.04. This affects the following Kurento filters : FaceOverlayFilter , ChromaFilter , PointerDetectorFilter , CrowdDetectorFilter , PlateDetectorFilter . All other filters work fine in Ubuntu 18.04","title":"Voice and video filters"},{"location":"advanced-features/filters/#step-by-step","text":"","title":"Step by step"},{"location":"advanced-features/filters/#1-generate-a-token-with-the-filters-the-user-will-be-able-to-apply","text":"This is a simple way of securing the ability of applying filters from OpenVidu Browser, so that not every user is able to apply any filter at any time. REST API Java Node When generating a token with operation POST /api/tokens include in the JSON body a parameter kurentoOptions with a property allowedFilters : a string array containing the name of the filters the user will be able to apply { \"session\": \"6fpivlanw91qjy6n\", \"data\": \"user_data\", \"role\": \"PUBLISHER\", \"kurentoOptions\": { \"allowedFilters\": [\"GStreamerFilter\", \"FaceOverlayFilter\"] } } When generating a token, call TokenOptions.Builder#kurentoOptions(KurentoOptions) to set allowedFilters value with method KurentoOptions.Builder#allowedFilters(String[]) . This method receives a string array containing the name of the filters the user will be able to apply TokenOptions tokenOptions = new TokenOptions.Builder() .role(OpenViduRole.PUBLISHER) .data(\"user_data\") .kurentoOptions( new KurentoOptions.Builder() .allowedFilters(new String[]{\"GStreamerFilter\", \"FaceOverlayFilter\"}) .build()) .build(); String token = session.generateToken(tokenOptions); When generating a token, include in TokenOptions parameter a kurentoOptions object with allowedFiters property: a string array containing the name of the filters the user will be able to apply var tokenOptions = { role: \"PUBLISHER\", data: \"user_data\", kurentoOptions: { allowedFilters: [\"GStreamerFilter\", \"FaceOverlayFilter\"] } }; session.generateToken(tokenOptions).then(token => { ... });","title":"1) Generate a token with the filters the user will be able to apply"},{"location":"advanced-features/filters/#2a-initialize-a-publisher-object-configured-for-using-a-filter-from-the-beginning-of-the-publishing","text":"Use PublisherProperties , specifically property filter : var OV = new OpenVidu(); var publisher = OV.initPublisher( targetElement, filter: { type: \"GStreamerFilter\", options: { command: \"videoflip method=vertical-flip\" } } ); // ... user already connected to \"session\" with the appropriate token session.publish(publisher);","title":"2.A) Initialize a Publisher object configured for using a filter from the beginning of the publishing ..."},{"location":"advanced-features/filters/#2b-or-apply-the-filter-dynamically-after-publishing-the-stream-whenever-you-want","text":"// ... user already connected to the session with the appropriate token // and successfully publishing the Publisher object publisher.stream.applyFilter(\"GStreamerFilter\", { command: \"videoflip method=vertical-flip\" }) .then(() => { console.log(\"Video rotated!\"); }) .catch(error => { console.error(error); });","title":"2.B) ... or apply the filter dynamically after publishing the stream, whenever you want"},{"location":"advanced-features/filters/#3-you-can-execute-any-method-offered-by-the-filter","text":"// ... user already connected to the session with the appropriate token, // successfully publishing the Publisher object and a filter being applied to its stream publisher.stream.filter.execMethod(\"setElementProperty\", {\"propertyName\":\"method\",\"propertyValue\":\"horizontal-flip\"}) .then(() => { console.log(\"Video rotation direction modified!\"); }) .catch(error => { console.error(error); });","title":"3) You can execute any method offered by the filter"},{"location":"advanced-features/filters/#4-you-can-also-subscribe-to-any-filter-event-if-it-dispatches-any-and-later-unsubscribe-from-it","text":"// ... user already connected to the session with the appropriate token, // successfully publishing the Publisher object and a filter being applied to its stream publisher.stream.filter.addEventListener(\"FooFilterEvent\", filterEvent => { console.log('Filter event received!. Data: ' + filterEvent.data); }); ... publisher.stream.filter.removeEventListener(\"FooFilterEvent\");","title":"4) You can also subscribe to any filter event (if it dispatches any), and later unsubscribe from it"},{"location":"advanced-features/filters/#4-to-remove-the-filter","text":"// ... user already connected to the session with the appropriate token, // successfully publishing the Publisher object and a filter being applied to its stream publisher.stream.removeFilter() .then(() => { console.log(\"Filter removed\"); }) .catch(error => { console.error(error); }); Moderators are not only able to call all of these methods over their Publisher.stream object, but also over any Subscriber.stream object. Also, they don't need any special token permission to apply filters and can bypass any token restriction set to other user tokens","title":"4) To remove the filter"},{"location":"advanced-features/filters/#filter-samples","text":"","title":"Filter samples"},{"location":"advanced-features/filters/#gstreamer-filters","text":"These filters are set with type GStreamerFilter and an options parameter like this: publisher.stream.applyFilter(\"GStreamerFilter\", {\"command\": \"GSTREAMER_COMMAND\"}) A list of interesting values for GSTREAMER_COMMAND parameter is stated below. Replace GSTREAMER_COMMAND in the upper code snippet for any of the examples provided in the following list items:","title":"GStreamer filters"},{"location":"advanced-features/filters/#video-overlay-filters","text":"gdkpixbufoverlay : overlays an image on top of the video. This is very useful, for example, to add a logo Example: gdkpixbufoverlay location=/images/img.png offset-x=10 offset-y=10 overlay-height=200 overlay-width=200 Documentation: Link textoverlay : overlays an embedded text on top of the video Example: textoverlay text=\"Embedded text\" valignment=top halignment=right font-desc=\"Cantarell 25\" Documentation: Link timeoverlay : overlays the time the video stream has been playing Example: timeoverlay valignment=bottom halignment=right font-desc=\"Sans, 20\" Documentation: Link clockoverlay : overlays a clock with the local time (in OpenVidu Server host) Example: clockoverlay valignment=bottom halignment=right shaded-background=true font-desc=\"Sans, 20\" Documentation: Link","title":"Video overlay filters"},{"location":"advanced-features/filters/#video-effect-filters","text":"videoflip : rotates the video stream Example: videoflip method=vertical-flip Documentation: Link videocrop : crops the video steam Example: videocrop top=100 left=35 right=0 bottom=0 Documentation: Link videobox : resizes a video stream by adding borders or cropping Example: videobox fill=black top=20 bottom=20 left=-10 right=-10 Documentation: Link chromahold : removes all colors from the video stream except the RGB indicated one Example: chromahold target-r=0 target-g=0 target-b=255 tolerance=90 Documentation: Link coloreffects : applies different color filters to the video stream Example: coloreffects preset=heat Documentation: Link videobalance : changes different properties of the video stream such as brightness, contrast, hue or saturation Example: videobalance saturation=0.0 Documentation: Link gamma : adjusts gamma level of the video stream Example: gamma gamma=5.0 Documentation: Link videomedian : adds a median filter to the video stream Example: videomedian filtersize=9 lum-only=false Documentation: Link Many effects of effectv project : funny filters for the video stream like agingtv , dicetv , optv , quarktv , radioactv , revtv , rippletv , shagadelictv , streaktv , vertigotv , warptv Example: radioactv","title":"Video effect filters"},{"location":"advanced-features/filters/#audio-filters","text":"audioecho : adds reverb to the audio stream Example: audioecho delay=50000000 intensity=0.6 feedback=0.4 Documentation: Link audioamplify : amplifies an audio stream by a given factor Example: audioamplify amplification=1.5 clipping-method=wrap-positive Documentation: Link pitch : controls the pitch of an audio stream Example: pitch pitch=1.2 Documentation: Link Other audio filters: check them out in GStreamer site All available GStreamer plugins can be found in GStreamer site .","title":"Audio filters"},{"location":"advanced-features/filters/#kurento-filters","text":"FaceOverlayFilter (overlay an image over detected faces) publisher.stream.applyFilter(\"FaceOverlayFilter\") .then(filter => { filter.execMethod( \"setOverlayedImage\", { \"uri\":\"https://cdn.pixabay.com/photo/2013/07/12/14/14/derby-148046_960_720.png\", \"offsetXPercent\":\"-0.2F\", \"offsetYPercent\":\"-0.8F\", \"widthPercent\":\"1.3F\", \"heightPercent\":\"1.0F\" }); }); ChromaFilter (set a chroma background) publisher.stream.applyFilter( \"ChromaFilter\", { \"window\": { \"topRightCornerX\": 0, \"topRightCornerY\": 0, \"width\": 50, \"height\": 50 }, \"backgroundImage\": \"https://www.maxpixel.net/static/photo/1x/Cool-Blue-Liquid-Lake-Abstract-Background-Clear-316144.jpg\" }); You must install Kurento ChromaFilter library in the same host as Kurento Media Server: sudo apt-get install kms-chroma ZBarFilter (detect and read bar codes information) publisher.stream.applyFilter(\"ZBarFilter\") .then(filter => { filter.addEventListener(\"CodeFound\", filterEvent => { console.log('Bar code found!. Data: ' + filterEvent.data); } }); function changeLangTab(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.textContent || event.target.innerText; var txt = txt.replace(/\\s/g, \"-\").toLowerCase(); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of language buttons if (child.classList.contains(\"lang-tabs-header\")) { for (var j = 0; j < child.children.length; j++) { var btn = child.children[j]; if (btn.classList.contains(\"lang-tabs-btn\")) { btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9'; btn.style.fontWeight = btn === event.target ? 'bold' : 'normal'; } } } // Change visibility of language content if (child.classList.contains(\"lang-tabs-content\")) { if (child.id === txt) { child.style.display = \"block\"; } else { child.style.display = \"none\"; } } } }","title":"Kurento filters"},{"location":"advanced-features/ip-cameras/","text":"IP cameras How to publish IP cameras How to unpublish IP cameras Configuring IP cameras How to publish IP cameras From release 2.12.0 you can publish any IP camera sending video over RTSP . You perform this operation from your server by consuming OpenVidu Server REST API. REST API Java Node Use method POST /sessions/{sessionId}/connection Not available yet Not available yet Events dispatched in the clients Whenever you call this method, a new participant will join the chosen session, and a new stream will be published to it. All the expected events are triggered in every client connected to the Session, just as when a regular client joins and publishes to a session. The workflow is: Your backend publishes an IP Camera to the session as shown in the code snippets above Every client connected to that session will receive a connectionCreated event. This event will be no different to any connectionCreated event dispatched by a regular client joining the session Every client connected to that session will receive a streamCreated event. The only difference with any other streamCreated event dispatched by a regular client publishing to the session is that the Stream object returned by the event will have property typeOfVideo set to \"IPCAM\" . Users can subscribe to this stream as any other regular stream (see Subscribe/Unsubscribe from a stream ) After unpublishing the IP camera all participants connected to the session will receive the proper streamDestroyed and connectionDestroyed events. Events dispatched in the backend Your backend side will also receive the expected events in the CDR and Webhook . Just as happens for the client-side events, for the backend same events will be dispatched as for any other regular user: participantJoined event fot the new IP camera participant {\"participantJoined\":{\"sessionId\":\"MySurveillanceSession\",\"timestamp\":1582108095130,\"participantId\":\"ipc_IPCAM_rtsp_C4CU_b1_dnsdojo_com_1935_live_sys3_stream\",\"location\":\"Amsterdam, Netherlands\",\"platform\":\"IPCAM\",\"clientData\":\"\",\"serverData\":\"Beach camera\"}} webrtcConnectionCreated event fot the new IP camera stream. It is actually an RTSP stream and not a WebRTC stream, but for the shake of compatibility the name of the event will remain the same for now {\"webrtcConnectionCreated\":{\"sessionId\":\"MySurveillanceSession\",\"timestamp\":1582108095351,\"streamId\":\"str_IPC_SJmx_ipc_IPCAM_rtsp_C4CU_b1_dnsdojo_com_1935_live_sys3_stream\",\"participantId\":\"ipc_IPCAM_rtsp_C4CU_b1_dnsdojo_com_1935_live_sys3_stream\",\"connection\":\"OUTBOUND\",\"rtspUri\":\"rtsp://b1.dnsdojo.com:1935/live/sys3.stream\",\"adaptativeBitrate\":true,\"onlyPlayWithSubscribers\":true,\"videoSource\":\"IPCAM\",\"videoFramerate\":null,\"videoDimensions\":null,\"audioEnabled\":true,\"videoEnabled\":true}} After unpublishing the IP camera your backend will receive the proper events webrtcConnectionDestroyed (one for the IP camera's stream itself and one for each user that was subscribed to the camera's stream) and participantLeft event (only one for the camera's connection). How to unpublish IP cameras To unpublish an IP camera stream you must remove the connection owning the stream. You can do it from your server: REST API Java Node Use method DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> // Find the desired Connection object in the list returned by Session.getActiveConnections() session.forceDisconnect(connection); See JavaDoc // Find the desired Connection object in the array Session.activeConnections session.forceDisconnect(connection); See TypeDoc WARNING : you cannot remove an IP camera by directly deleting its Stream. You must delete the Connection object instead. Trying to remove an IP camera by deleting its Stream instead of its Connection will result in an error. See HTTP responses of method DELETE /api/sessions/<SESSION_ID>/stream/<STREAM_ID> Configuring IP cameras When publishing an IP camera , you can configure 2 properties that will affect the management of the camera's media stream. These are: adaptativeBitrate Whether to decode the IP camera stream in OpenVidu to allow adapting the bitrate depending on network conditions or not. It is active by default, and it allows OpenVidu Server to provide a robust and reliable flow of the camera's stream. But of course this has a CPU cost. Some use cases may not need this decoding process for the IP camera video. For example, if your IP camera and OpenVidu are both located in the same network (and therefore there will be no packet losses or buffer congestion) and you are sure that the clients subscribing to the stream will support the same codec used by the RTSP camera stream, then setting this property to false will save valuable CPU power. onlyPlayWithSubscribers Whether to enable the IP camera stream only when some user is subscribed to it or not. What this means is that OpenVidu Server will only establish the RTSP connection with the IP camera when some participant asks to subscribe to the camera's stream. The rest of the time OpenVidu Server will not be effectively receiving any packets from the IP camera, saving CPU power and bandwidth. This option is active by default. The counterpart to this option, which is in principle so obvious, is that the first participant requesting to subscribe to the camera's stream will take a little longer to do so, as OpenVidu Server has to establish the RTSP connection with the camera in the first place. Just after the last participant subscribed to the camera's stream unsubscribes from it, the RTSP connection between OpenVidu Server and the IP camera will be closed again, and the cycle starts again (next participant subscribing to the camera's stream will have to wait longer than usual to receive the video). Generally speaking you'll want this option set to true, but if for your particular use case the response time of the first subscriber to the camera's stream is vital, you can set this option to false to never stop receiving the camera's feed. function changeLangTab(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.textContent || event.target.innerText; var txt = txt.replace(/\\s/g, \"-\").toLowerCase(); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of language buttons if (child.classList.contains(\"lang-tabs-header\")) { for (var j = 0; j < child.children.length; j++) { var btn = child.children[j]; if (btn.classList.contains(\"lang-tabs-btn\")) { btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9'; btn.style.fontWeight = btn === event.target ? 'bold' : 'normal'; } } } // Change visibility of language content if (child.classList.contains(\"lang-tabs-content\")) { if (child.id === txt) { child.style.display = \"block\"; } else { child.style.display = \"none\"; } } } }","title":"IP cameras"},{"location":"advanced-features/ip-cameras/#ip-cameras","text":"How to publish IP cameras How to unpublish IP cameras Configuring IP cameras","title":"IP cameras"},{"location":"advanced-features/ip-cameras/#how-to-publish-ip-cameras","text":"From release 2.12.0 you can publish any IP camera sending video over RTSP . You perform this operation from your server by consuming OpenVidu Server REST API. REST API Java Node Use method POST /sessions/{sessionId}/connection Not available yet Not available yet","title":"How to publish IP cameras"},{"location":"advanced-features/ip-cameras/#events-dispatched-in-the-clients","text":"Whenever you call this method, a new participant will join the chosen session, and a new stream will be published to it. All the expected events are triggered in every client connected to the Session, just as when a regular client joins and publishes to a session. The workflow is: Your backend publishes an IP Camera to the session as shown in the code snippets above Every client connected to that session will receive a connectionCreated event. This event will be no different to any connectionCreated event dispatched by a regular client joining the session Every client connected to that session will receive a streamCreated event. The only difference with any other streamCreated event dispatched by a regular client publishing to the session is that the Stream object returned by the event will have property typeOfVideo set to \"IPCAM\" . Users can subscribe to this stream as any other regular stream (see Subscribe/Unsubscribe from a stream ) After unpublishing the IP camera all participants connected to the session will receive the proper streamDestroyed and connectionDestroyed events.","title":"Events dispatched in the clients"},{"location":"advanced-features/ip-cameras/#events-dispatched-in-the-backend","text":"Your backend side will also receive the expected events in the CDR and Webhook . Just as happens for the client-side events, for the backend same events will be dispatched as for any other regular user: participantJoined event fot the new IP camera participant {\"participantJoined\":{\"sessionId\":\"MySurveillanceSession\",\"timestamp\":1582108095130,\"participantId\":\"ipc_IPCAM_rtsp_C4CU_b1_dnsdojo_com_1935_live_sys3_stream\",\"location\":\"Amsterdam, Netherlands\",\"platform\":\"IPCAM\",\"clientData\":\"\",\"serverData\":\"Beach camera\"}} webrtcConnectionCreated event fot the new IP camera stream. It is actually an RTSP stream and not a WebRTC stream, but for the shake of compatibility the name of the event will remain the same for now {\"webrtcConnectionCreated\":{\"sessionId\":\"MySurveillanceSession\",\"timestamp\":1582108095351,\"streamId\":\"str_IPC_SJmx_ipc_IPCAM_rtsp_C4CU_b1_dnsdojo_com_1935_live_sys3_stream\",\"participantId\":\"ipc_IPCAM_rtsp_C4CU_b1_dnsdojo_com_1935_live_sys3_stream\",\"connection\":\"OUTBOUND\",\"rtspUri\":\"rtsp://b1.dnsdojo.com:1935/live/sys3.stream\",\"adaptativeBitrate\":true,\"onlyPlayWithSubscribers\":true,\"videoSource\":\"IPCAM\",\"videoFramerate\":null,\"videoDimensions\":null,\"audioEnabled\":true,\"videoEnabled\":true}} After unpublishing the IP camera your backend will receive the proper events webrtcConnectionDestroyed (one for the IP camera's stream itself and one for each user that was subscribed to the camera's stream) and participantLeft event (only one for the camera's connection).","title":"Events dispatched in the backend"},{"location":"advanced-features/ip-cameras/#how-to-unpublish-ip-cameras","text":"To unpublish an IP camera stream you must remove the connection owning the stream. You can do it from your server: REST API Java Node Use method DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> // Find the desired Connection object in the list returned by Session.getActiveConnections() session.forceDisconnect(connection); See JavaDoc // Find the desired Connection object in the array Session.activeConnections session.forceDisconnect(connection); See TypeDoc WARNING : you cannot remove an IP camera by directly deleting its Stream. You must delete the Connection object instead. Trying to remove an IP camera by deleting its Stream instead of its Connection will result in an error. See HTTP responses of method DELETE /api/sessions/<SESSION_ID>/stream/<STREAM_ID>","title":"How to unpublish IP cameras"},{"location":"advanced-features/ip-cameras/#configuring-ip-cameras","text":"When publishing an IP camera , you can configure 2 properties that will affect the management of the camera's media stream. These are:","title":"Configuring IP cameras"},{"location":"advanced-features/ip-cameras/#adaptativebitrate","text":"Whether to decode the IP camera stream in OpenVidu to allow adapting the bitrate depending on network conditions or not. It is active by default, and it allows OpenVidu Server to provide a robust and reliable flow of the camera's stream. But of course this has a CPU cost. Some use cases may not need this decoding process for the IP camera video. For example, if your IP camera and OpenVidu are both located in the same network (and therefore there will be no packet losses or buffer congestion) and you are sure that the clients subscribing to the stream will support the same codec used by the RTSP camera stream, then setting this property to false will save valuable CPU power.","title":"adaptativeBitrate"},{"location":"advanced-features/ip-cameras/#onlyplaywithsubscribers","text":"Whether to enable the IP camera stream only when some user is subscribed to it or not. What this means is that OpenVidu Server will only establish the RTSP connection with the IP camera when some participant asks to subscribe to the camera's stream. The rest of the time OpenVidu Server will not be effectively receiving any packets from the IP camera, saving CPU power and bandwidth. This option is active by default. The counterpart to this option, which is in principle so obvious, is that the first participant requesting to subscribe to the camera's stream will take a little longer to do so, as OpenVidu Server has to establish the RTSP connection with the camera in the first place. Just after the last participant subscribed to the camera's stream unsubscribes from it, the RTSP connection between OpenVidu Server and the IP camera will be closed again, and the cycle starts again (next participant subscribing to the camera's stream will have to wait longer than usual to receive the video). Generally speaking you'll want this option set to true, but if for your particular use case the response time of the first subscriber to the camera's stream is vital, you can set this option to false to never stop receiving the camera's feed. function changeLangTab(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.textContent || event.target.innerText; var txt = txt.replace(/\\s/g, \"-\").toLowerCase(); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of language buttons if (child.classList.contains(\"lang-tabs-header\")) { for (var j = 0; j < child.children.length; j++) { var btn = child.children[j]; if (btn.classList.contains(\"lang-tabs-btn\")) { btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9'; btn.style.fontWeight = btn === event.target ? 'bold' : 'normal'; } } } // Change visibility of language content if (child.classList.contains(\"lang-tabs-content\")) { if (child.id === txt) { child.style.display = \"block\"; } else { child.style.display = \"none\"; } } } }","title":"onlyPlayWithSubscribers"},{"location":"advanced-features/recording/","text":"Recording How to record sessions Composed recording Individual stream recording Audio-only and video-only recordings Automatic stop of recordings Custom recording layouts Configuring multiple custom layouts Using an external custom layout Debugging your custom layouts Sample custom layout Local recording in the browser OpenVidu Server can be configured to record sessions. Two types of recordings are available: COMPOSED : every publisher stream is composed in the same video file in a grid layout. You can use the default layout, that will evenly distribute each stream in the available space, or you can use your own custom layout. INDIVIDUAL : every publisher stream is recorded in its own file, generating a ZIP file containing all videos along with a text file for synchronization data. How to record sessions To start OpenVidu Server properly configured to allow session recording it is necessary to: 1. Have Docker CE installed in the host machine OpenVidu recording module may use a Docker image that needs to be downloaded from the cloud. The process is 100% automatic , but you will need Docker CE installed in your server. If you enable OpenVidu recording service but there's no Docker installed, OpenVidu Server will fail to init, throwing the following exception: Exception connecting to Docker daemon: you need Docker installed in this machine to enable OpenVidu recorder service OpenVidu AWS deployment already includes the Docker image for recording service and is always launched with recording module enabled. You don't need to install anything or wait during the first execution if you use this type of deployment for OpenVidu Server. You can go straight to step 3 2. Launch OpenVidu Server with new properties For OpenVidu Server JAR java -jar \\ -Dopenvidu.recording=true \\ -Dopenvidu.recording.path=/PATH/TO/VIDEO/FILES \\ openvidu-server.jar openvidu.recording : if true OpenVidu recording service is enabled and sessions can be configured to be recorded. During the first execution of openvidu-server.jar , a Docker image ( openvidu/openvidu-recording ) will be downloaded. openvidu.recording.path : where to store the recorded video files on the host machine. OpenVidu Server must have write access to this path There are other environment variables related to recordings configuration that may be set. To see the full list, visit OpenVidu Server configuration parameters For OpenVidu Server Docker image (development environment) docker run -p 4443:4443 --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\ -e openvidu.recording=true \\ -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\ openvidu/openvidu-server-kms:2.12.0 openvidu.recording : same as in OpenVidu Server JAR openvidu.recording.path : same as in OpenVidu Server JAR It is also necessary to mount 2 volumes: -v /var/run/docker.sock:/var/run/docker.sock : gives openvidu-server container access to the local Docker daemon -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES : gives access to the recorded video files through the container IMPORTANT! /PATH/TO/VIDEO/FILES must be the same in property openvidu.recording.path=/PATH/TO/VIDEO/FILES and in both sides of flag -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES 3. Configure your Sessions to be recorded Recording can be configured in two ways: ALWAYS : the session will be automatically recorded from the moment the first participant starts publishing. MANUAL : you will have to tell openvidu-server when to start the recording of the session. In both cases you can stop the recording manually, and every recording will always be automatically stopped if last user leaves the session and certain timeout elapses (see Automatic stop of recordings ). You can use REST API or any of the server SDKs ( openvidu-java-client , openvidu-node-client ) to manage your recorded sessions. REST API Java Node Initialize your sessions with this POST method: POST /api/sessions You may configure default values for recordings started for this session by sending params such as defaultOutputMode or defaultRecordingLayout . This way you can pre-configure recordings that will be automatically started (for sessions with {\"recordingMode\": \"ALWAYS\"} ). For these sessions configured with ALWAYS recording mode, no more steps are needed. If you have configured your session with \"recordingMode\": \"MANUAL\" Start the recording with this POST method: POST /api/recordings/start You can pass parameters to override default recording configuration values set in step 1 and to further configure it with other available options Stop the recording with this POST method: POST /api/recordings/stop Call OpenVidu.createSession() passing as an optional parameter a SessionProperties object. You may configure default values for recordings started for this session with that object. This way you can pre-configure recordings that will be automatically started (for sessions with RecordingMode.ALWAYS ) OpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); SessionProperties properties = new SessionProperties.Builder() .recordingMode(RecordingMode.MANUAL) // RecordingMode.ALWAYS for automatic recording .defaultOutputMode(Recording.OutputMode.INDIVIDUAL) .build(); Session session = openVidu.createSession(properties); If Session is configured with RecordingMode.MANUAL , manually start and stop the recording whenever you want. You may pass a RecordingProperties object when calling OpenVidu.startRecording method to override default values configured in step 1 and to further configure it with other available options RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .name(\"MY_RECORDING_NAME\") .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); // Starts recording recording = openVidu.stopRecording(recording.getId()); // Stops recording Call OpenVidu.createSession() passing as an optional parameter a SessionProperties object. You may configure default values for recordings started for this session with that object. This way you can pre-configure recordings that will be automatically started (for sessions with RecordingMode.ALWAYS ) var openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); var properties = { recordingMode: RecordingMode.MANUAL, // RecordingMode.ALWAYS for automatic recording defaultOutputMode: Recording.OutputMode.INDIVIDUAL }; var mySession = openvidu.createSession(properties); If Session is configured with RecordingMode.MANUAL , manually start and stop the recording whenever you want. You may pass a RecordingProperties object when calling OpenVidu.startRecording method to override default values configured in step 1 and to further configure it with other available options var recording; // Starts recording openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, name: \"MY_RECORDING_NAME\" }) .then(response => recording = response) .catch(error => console.error(error)); // Stops recording openvidu.stopRecording(recording.id) .then(response => recording = response) .catch(error => console.error(error)); Composed recording Every publisher stream is composed in the same video file in a grid layout. This is the default recording mode, and it will generate as output an MP4 file. You can use the default layout, that will evenly distribute each stream in the available space, or you can use your own custom layout . To use the default layout: REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameters {\"outputMode: \"COMPOSED\", \"recordingLayout\": \"BEST_FIT\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .recordingLayout(RecordingLayout.BEST_FIT) .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, recordingLayout: RecordingLayout.BEST_FIT }) .then(response => recording = response) .catch(error => console.error(error)); For example, for a session with two publishers the video file will look like this when using output mode COMPOSED and recording layout BEST_FIT Notes on COMPOSED recordings If a COMPOSED recording is configured to record video (that is, not being an audio-only recording ), this type of grid recording can be a pretty heavy consuming process . A maximum number of 4 publishers is recommended, and starting more than 2 recordings of this type at the same time can overload server CPUs. For these reasons, it is desirable to launch OpenVidu Server in a host with significant CPU power if COMPOSED video recordings are expected. In comparison, INDIVIDUAL stream recording (and COMPOSED audio-only recording) can be 4x up to 10x more efficient You can configure the resolution of the MP4 file for COMPOSED recordings by using resolution property when starting the recording A thumbnail got from the middle of the video will be generated for COMPOSED recordings that have video. They will be stored next to the MP4 file and named [RECORDING_ID].jpg Individual stream recording Every publisher stream is recorded in its own file. The final result is a ZIP file containing one WEBM file for each published stream during the recording (named after each stream identifier), along with a text file with synchronization information. REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameter {\"outputMode:\"INDIVIDUAL\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.INDIVIDUAL) .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.INDIVIDUAL }) .then(response => recording = response) .catch(error => console.error(error)); For example, for a session with 2 publishers the final content of the ZIP file could be: MyRecording.zip +-- MyRecording.json +-- tzk08sgffcqqwpor_CAMERA_DFDAE.webm +-- ugkmpnz4bn6yewbi_CAMERA_PAHHB.webm And the content of the JSON synchronization file might be: { \"createdAt\": 1548947712287, \"id\": \"zfgmthb8jl9uellk\", \"name\": \"MyRecording\", \"sessionId\": \"zfgmthb8jl9uellk\", \"files\": [ { \"connectionId\": \"ugkmpnz4bn6yewbi\", \"streamId\": \"ugkmpnz4bn6yewbi_CAMERA_PAHHB\", \"size\": 4006190, \"clientData\": \"\", \"serverData\": \"UserA\", \"hasAudio\": true, \"hasVideo\": true, \"typeOfVideo\": \"SCREEN\", \"startTimeOffset\": 95, \"endTimeOffset\": 56445 }, { \"connectionId\": \"tzk08sgffcqqwpor\", \"streamId\": \"tzk08sgffcqqwpor_CAMERA_DFDAE\", \"size\": 2404760, \"clientData\": \"\", \"serverData\": \"UserB\", \"hasAudio\": false, \"hasVideo\": true, \"typeOfVideo\": \"CAMERA\", \"startTimeOffset\": 148, \"endTimeOffset\": 56398 } ] } These are the properties in the JSON file createdAt : time when the recording was started in UTC milliseconds id : unique identifier of the recording name : custom name of the recording. You can set this parameter when starting the recording, and the final ZIP file will be named after it sessionId : unique identifier of the session that was recorded files : array containing one JSON object for each one of the WEBM videos inside the ZIP file connectionId : unique identifier of the connection that published the stream streamId : unique identifier of the recorded stream size : size in bytes of this particular recorded file clientData : data associated to the connection that published the stream, in the client side. You can use this field to identify the user that published this particular recorded stream serverData : data associated to the connection that published the stream, in the server side. You can use this field to identify the user that published this particular recorded stream hasAudio : whether this recorded stream has an audio track or not hasVideo : whether this recorded stream has a video track or not typeOfVideo : type of video (\"CAMERA\" or \"SCREEN\"). Only defined if hasVideo is true startTimeOffset : the offset in milliseconds for when this particular stream started being recorded, from the createdAt property of the root element endTimeOffset : the offset in milliseconds for when this particular stream stopped being recorded, from the createdAt property of the root element Audio-only and video-only recordings By default recordings will be generated with both audio and video, but you can configure them to record audio-only or video-only files. REST API Java Node When starting the recording of a session with method POST /api/recordings/start simply pass parameters hasAudio or hasVideo with the desired values. RecordingProperties properties = new RecordingProperties.Builder() .hasAudio(true) .hasVideo(false) .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { hasAudio: true, hasVideo: false }) .then(response => recording = response) .catch(error => console.error(error)); Notes on audio/video only recordings Recordings configured to not record neither audio nor video will fail to start, returning a status error of 422 COMPOSED video-only recordings will generate an MP4 file. COMPOSED audio-only recordings will generate a WEBM file. INDIVIDUAL recordings will always generate a ZIP file containing one WEBM file for each recorded stream Streams published during a video-only recording that are audio-only won't be recorded: they won't be included in the grid layout for COMPOSED recordings and won't generate a WEBM file in INDIVIDUAL recordings. Same for audio-only recordings with video-only streams Recordings started automatically (with recording mode ALWAYS ) will record both audio and video Automatic stop of recordings Any started recording will automatically be stopped when any of the following situations occur and certain timeout elapses. This timeout is by default 120 seconds, but you can configure it with system property openvidu.recording.autostop-timeout . The automatic recording stop timout will start: For any recorded session, if last user disconnects from the session For sessions with recording mode MANUAL , if the recording is started and no user is publishing a stream The only condition to abort the timeout is to have any user publishing a stream to the session within the timeout. Sessions will always remain opened and the recording active during the timeout. If it elapses and no stream is being published to the session, the recording will be stopped. If in addition there's no user connected to the session, the session will also be automatically closed. You can always manually stop any recording at any time: REST API Java Node POST /api/recordings/stop/<RECORDING_ID> Recording stoppedRecording = openVidu.stopRecording(recordingId); var stoppedRecording; openvidu.stopRecording(recordingId) .then(response => stoppedRecording = response) .catch(error => console.error(error)); Custom recording layouts You can create your own layouts for the session recording process. They are implemented with HTML/CSS/JS files, just as your OpenVidu application client-side. 1. Create your layout with HTML/CSS/JS files Put them in a path accessible to openvidu-server. There must be an index.html file as entrypoint for your custom layout: WHAT SHOULD YOUR JS CODE DO : by making use of openvidu-browser.js library, you need to connect a recorder participant to the session. This means: 1) Your layout must connect to the session using a token like this: 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '&secret=' + SECRET + '&recorder=true'; Being SESSION_ID and SECRET two parameters that will be url-encoded under ids sessionId and secret respectively. So, for example: var url = new URL(window.location.href); var SESSION_ID = url.searchParams.get(\"sessionId\"); var SECRET = url.searchParams.get(\"secret\"); var TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '&secret=' + SECRET + '&recorder=true'; var session = OV.initSession(); session.connect(TOKEN); 2) You will need to subscribe to, at least, one event: streamCreated of Session object. That way you can subscribe your recorder to every stream when any user starts publishing (by default, the video element will be automatically removed on every streamDestroyed event). To sum up, this would be the simplest code you need to properly start your recorder participant: var OV = new OpenVidu(); var url = new URL(window.location.href); var SESSION_ID = url.searchParams.get(\"sessionId\"); var SECRET = url.searchParams.get(\"secret\"); var TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '&secret=' + SECRET + '&recorder=true'; var session = OV.initSession(); session.on(\"streamCreated\", (event) => { session.subscribe(event.stream, 'html-id-where-insert-video'); }); session.connect(TOKEN); HOW TO IDENTIFY YOUR USERS : you can identify them by making use of property Stream.connection.data of the Stream object retrieved in Session event \"streamCreated\". That way you may know which particular user should be displayed in which particular HTML element of your layout. For example: session.on(\"streamCreated\", (event) => { var stream = event.stream; if (stream.connection.data === 'userBigVideo') { session.subscribe(stream, 'big-video-div'); } else if (stream.connection.data === 'userSmallVideo') { session.subscribe(stream, 'small-video-div'); } }); 2. Add new properties when launching openvidu-server You can configure where should OpenVidu Server look for your custom layout in the system. Default path is /opt/openvidu/custom-layout , but you can configure it with system property openvidu.recording.custom-layout . OpenVidu Server must have read access to that path, where you must have stored the index.html file of your layout. openvidu-server.jar java -jar \\ -Dopenvidu.recording=true \\ -Dopenvidu.recording.path=/PATH/TO/VIDEO/FILES \\ -Dopenvidu.recording.custom-layout: /PATH/TO/INDEX/CUSTOM/LAYOUT \\ openvidu-server.jar openvidu/openvidu-server-kms Docker container (development environment) docker run -p 4443:4443 --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\ -v /PATH/TO/INDEX/CUSTOM/LAYOUT:/PATH/TO/INDEX/CUSTOM/LAYOUT \\ -e MY_UID=$(id -u $USER) \\ -e openvidu.recording=true \\ -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\ -e openvidu.recording.custom-layout=/PATH/TO/INDEX/CUSTOM/LAYOUT \\ openvidu/openvidu-server-kms:2.12.0 WARNING : remember to add the -v option mounting the path defined with openvidu.recording.custom-layout OpenVidu AWS deployment You must store your custom layouts in the server under default path /opt/openvidu/custom-layout 3. Configure your recordings to use your custom layout REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameters {\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .recordingLayout(RecordingLayout.CUSTOM) .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, recordingLayout: RecordingLayout.CUSTOM }) .then(response => recording = response) .catch(error => console.error(error)); Configuring multiple custom layouts You can implement as many custom recording layouts as you want. Simply store each one of them (each one with its own index.html entrypoint file) in a subfolder under path defined with system property openvidu.recording.custom-layout (default value /opt/openvidu/custom-layout ). Then, when configuring your sessions as stated above in point 3, just add a new parameter: REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameters {\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\", \"customLayout\": \"RELATIVE/PATH/TO/INDEX\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .recordingLayout(RecordingLayout.CUSTOM) .customLayout(\"RELATIVE/PATH/TO/INDEX\") .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, recordingLayout: RecordingLayout.CUSTOM, customLayout: \"RELATIVE/PATH/TO/INDEX\" }) .then(response => recording = response) .catch(error => console.error(error)); In the snippets above, string RELATIVE/PATH/TO/INDEX is the path from openvidu-server configuration property openvidu.recording.custom-layout to the specific index.html you want to use for a particular recording. So, if you have the following folder tree structure in your OpenVidu Server host: /opt +-- /openvidu | +-- /my_custom_layouts | +-- index.html | +-- /layout1 | +-- index.html | +-- /layout2 | +-- index.html /etc ... You should start openvidu-server with property openvidu.recording.custom-layout=/opt/openvidu/my_custom_layouts and you can use any of the 3 index.html files for recording any of your sessions. To use the outer layout in a recording, just configure in recording properties recordingLayout to CUSTOM . To use any of the inner layouts, also configure customLayout to layout1 or layout2 . Using an external custom layout OpenVidu allows you to configure a recording to use a custom layout deployed outside OpenVidu host. This is useful if, for whatever reason, you have your layout being served in a different server. To achieve this, you just have to configure the complete URL where your layout is served in property customLayout : REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameters {\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\", \"customLayout\": \"https://USER:PASS@my.domain.com:8888/path?myParam=123\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .recordingLayout(RecordingLayout.CUSTOM) .customLayout(\"https://USER:PASS@my.domain.com:8888/path?myParam=123\") .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, recordingLayout: RecordingLayout.CUSTOM, customLayout: \"https://USER:PASS@my.domain.com:8888/path?myParam=123\" }) .then(response => recording = response) .catch(error => console.error(error)); As you can see, this URL may have credentials and any query parameter or token you may need in your custom layout. For example, in the snippets above the layout files would be protected by Basic Auth with \"USER\" ans \"PASS\" as username and password, and you could access value 123 in your layout JS code just by calling new URL(window.location.href).searchParams.get(\"myParam\"); Debugging your custom layouts To debug your custom layout, you just need to store it in the path declared with property openvidu.recording.custom-layout , as explained in section Add new properties when launching openvidu-server . Then, by using your OpenVidu application, start a session and as many publishers as you expect to be recorded in your custom layout. Finally you just have to connect to your layout through Chrome by entering url: https://OPENVIDUAPP: SECRET @ OPENVIDU_IP :4443/layouts/custom/index.html?sessionId= SESSION_ID &secret= SECRET Being: SECRET : parameter openvidu.secret configured when launching openvidu-server OPENVIDU_IP : the IP where openvidu-server is accessible in your development machine. You will be probably using openvidu-server-kms docker container in your development environment, so this parameter is localhost if you are in Mac or Linux, and the docker IP of the container if you are in Windows (see this FAQ ) SESSION_ID : the session ID you have initialized for the debugging process. Here's a little tip: you can initialize the session in openvidu-server ( REST API , openvidu-java-client , openvidu-node-client ) configuring parameter customSessionId to fix this session ID and avoid having to change it every time you restart your session. By connecting with Chrome to the above URL you will see the exact result obtained when recording a session with your custom layout. You can now start changing the HTML/CSS/JS files of your layout until you are happy with the outcome Sample custom layout This is literally the simplest HTML for a custom recording layout. Use it as a template for building more complex ones (you will need latest openvidu-browser-VERSION.min.js file to be in the same folder. Be sure to use the same version number as your openvidu-server!) <html> <head><script src=\"openvidu-browser-2.8.0.min.js\"></script></head> <body> <div id=\"videos\"></div> </body> <script> var url = new URL(window.location.href); var SESSION_ID = url.searchParams.get(\"sessionId\"); var SECRET = url.searchParams.get(\"secret\"); var TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '&secret=' + SECRET + '&recorder=true'; var OV = new OpenVidu(); var session = OV.initSession(); session.on(\"streamCreated\", (event) => { session.subscribe(event.stream, 'videos'); }); session.connect(TOKEN) .then(() => { console.log('Recorder participant connected') }) .catch(error => { console.error(error) }); </script> </html> Local recording in the browser OpenVidu Browser offers an extremely simple API to record Streams directly in the client's browser. Check it out here . function changeLangTab(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.textContent || event.target.innerText; var txt = txt.replace(/\\s/g, \"-\").toLowerCase(); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of language buttons if (child.classList.contains(\"lang-tabs-header\")) { for (var j = 0; j < child.children.length; j++) { var btn = child.children[j]; if (btn.classList.contains(\"lang-tabs-btn\")) { btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9'; btn.style.fontWeight = btn === event.target ? 'bold' : 'normal'; } } } // Change visibility of language content if (child.classList.contains(\"lang-tabs-content\")) { if (child.id === txt) { child.style.display = \"block\"; } else { child.style.display = \"none\"; } } } }","title":"Recording"},{"location":"advanced-features/recording/#recording","text":"How to record sessions Composed recording Individual stream recording Audio-only and video-only recordings Automatic stop of recordings Custom recording layouts Configuring multiple custom layouts Using an external custom layout Debugging your custom layouts Sample custom layout Local recording in the browser OpenVidu Server can be configured to record sessions. Two types of recordings are available: COMPOSED : every publisher stream is composed in the same video file in a grid layout. You can use the default layout, that will evenly distribute each stream in the available space, or you can use your own custom layout. INDIVIDUAL : every publisher stream is recorded in its own file, generating a ZIP file containing all videos along with a text file for synchronization data.","title":"Recording"},{"location":"advanced-features/recording/#how-to-record-sessions","text":"To start OpenVidu Server properly configured to allow session recording it is necessary to:","title":"How to record sessions"},{"location":"advanced-features/recording/#1-have-docker-ce-installed-in-the-host-machine","text":"OpenVidu recording module may use a Docker image that needs to be downloaded from the cloud. The process is 100% automatic , but you will need Docker CE installed in your server. If you enable OpenVidu recording service but there's no Docker installed, OpenVidu Server will fail to init, throwing the following exception: Exception connecting to Docker daemon: you need Docker installed in this machine to enable OpenVidu recorder service OpenVidu AWS deployment already includes the Docker image for recording service and is always launched with recording module enabled. You don't need to install anything or wait during the first execution if you use this type of deployment for OpenVidu Server. You can go straight to step 3","title":"1. Have Docker CE installed in the host machine"},{"location":"advanced-features/recording/#2-launch-openvidu-server-with-new-properties","text":"","title":"2. Launch OpenVidu Server with new properties"},{"location":"advanced-features/recording/#for-openvidu-server-jar","text":"java -jar \\ -Dopenvidu.recording=true \\ -Dopenvidu.recording.path=/PATH/TO/VIDEO/FILES \\ openvidu-server.jar openvidu.recording : if true OpenVidu recording service is enabled and sessions can be configured to be recorded. During the first execution of openvidu-server.jar , a Docker image ( openvidu/openvidu-recording ) will be downloaded. openvidu.recording.path : where to store the recorded video files on the host machine. OpenVidu Server must have write access to this path There are other environment variables related to recordings configuration that may be set. To see the full list, visit OpenVidu Server configuration parameters","title":"For OpenVidu Server JAR"},{"location":"advanced-features/recording/#for-openvidu-server-docker-image-development-environment","text":"docker run -p 4443:4443 --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\ -e openvidu.recording=true \\ -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\ openvidu/openvidu-server-kms:2.12.0 openvidu.recording : same as in OpenVidu Server JAR openvidu.recording.path : same as in OpenVidu Server JAR It is also necessary to mount 2 volumes: -v /var/run/docker.sock:/var/run/docker.sock : gives openvidu-server container access to the local Docker daemon -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES : gives access to the recorded video files through the container IMPORTANT! /PATH/TO/VIDEO/FILES must be the same in property openvidu.recording.path=/PATH/TO/VIDEO/FILES and in both sides of flag -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES","title":"For OpenVidu Server Docker image (development environment)"},{"location":"advanced-features/recording/#3-configure-your-sessions-to-be-recorded","text":"Recording can be configured in two ways: ALWAYS : the session will be automatically recorded from the moment the first participant starts publishing. MANUAL : you will have to tell openvidu-server when to start the recording of the session. In both cases you can stop the recording manually, and every recording will always be automatically stopped if last user leaves the session and certain timeout elapses (see Automatic stop of recordings ). You can use REST API or any of the server SDKs ( openvidu-java-client , openvidu-node-client ) to manage your recorded sessions. REST API Java Node Initialize your sessions with this POST method: POST /api/sessions You may configure default values for recordings started for this session by sending params such as defaultOutputMode or defaultRecordingLayout . This way you can pre-configure recordings that will be automatically started (for sessions with {\"recordingMode\": \"ALWAYS\"} ). For these sessions configured with ALWAYS recording mode, no more steps are needed. If you have configured your session with \"recordingMode\": \"MANUAL\" Start the recording with this POST method: POST /api/recordings/start You can pass parameters to override default recording configuration values set in step 1 and to further configure it with other available options Stop the recording with this POST method: POST /api/recordings/stop Call OpenVidu.createSession() passing as an optional parameter a SessionProperties object. You may configure default values for recordings started for this session with that object. This way you can pre-configure recordings that will be automatically started (for sessions with RecordingMode.ALWAYS ) OpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); SessionProperties properties = new SessionProperties.Builder() .recordingMode(RecordingMode.MANUAL) // RecordingMode.ALWAYS for automatic recording .defaultOutputMode(Recording.OutputMode.INDIVIDUAL) .build(); Session session = openVidu.createSession(properties); If Session is configured with RecordingMode.MANUAL , manually start and stop the recording whenever you want. You may pass a RecordingProperties object when calling OpenVidu.startRecording method to override default values configured in step 1 and to further configure it with other available options RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .name(\"MY_RECORDING_NAME\") .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); // Starts recording recording = openVidu.stopRecording(recording.getId()); // Stops recording Call OpenVidu.createSession() passing as an optional parameter a SessionProperties object. You may configure default values for recordings started for this session with that object. This way you can pre-configure recordings that will be automatically started (for sessions with RecordingMode.ALWAYS ) var openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); var properties = { recordingMode: RecordingMode.MANUAL, // RecordingMode.ALWAYS for automatic recording defaultOutputMode: Recording.OutputMode.INDIVIDUAL }; var mySession = openvidu.createSession(properties); If Session is configured with RecordingMode.MANUAL , manually start and stop the recording whenever you want. You may pass a RecordingProperties object when calling OpenVidu.startRecording method to override default values configured in step 1 and to further configure it with other available options var recording; // Starts recording openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, name: \"MY_RECORDING_NAME\" }) .then(response => recording = response) .catch(error => console.error(error)); // Stops recording openvidu.stopRecording(recording.id) .then(response => recording = response) .catch(error => console.error(error));","title":"3. Configure your Sessions to be recorded"},{"location":"advanced-features/recording/#composed-recording","text":"Every publisher stream is composed in the same video file in a grid layout. This is the default recording mode, and it will generate as output an MP4 file. You can use the default layout, that will evenly distribute each stream in the available space, or you can use your own custom layout . To use the default layout: REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameters {\"outputMode: \"COMPOSED\", \"recordingLayout\": \"BEST_FIT\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .recordingLayout(RecordingLayout.BEST_FIT) .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, recordingLayout: RecordingLayout.BEST_FIT }) .then(response => recording = response) .catch(error => console.error(error)); For example, for a session with two publishers the video file will look like this when using output mode COMPOSED and recording layout BEST_FIT Notes on COMPOSED recordings If a COMPOSED recording is configured to record video (that is, not being an audio-only recording ), this type of grid recording can be a pretty heavy consuming process . A maximum number of 4 publishers is recommended, and starting more than 2 recordings of this type at the same time can overload server CPUs. For these reasons, it is desirable to launch OpenVidu Server in a host with significant CPU power if COMPOSED video recordings are expected. In comparison, INDIVIDUAL stream recording (and COMPOSED audio-only recording) can be 4x up to 10x more efficient You can configure the resolution of the MP4 file for COMPOSED recordings by using resolution property when starting the recording A thumbnail got from the middle of the video will be generated for COMPOSED recordings that have video. They will be stored next to the MP4 file and named [RECORDING_ID].jpg","title":"Composed recording"},{"location":"advanced-features/recording/#individual-stream-recording","text":"Every publisher stream is recorded in its own file. The final result is a ZIP file containing one WEBM file for each published stream during the recording (named after each stream identifier), along with a text file with synchronization information. REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameter {\"outputMode:\"INDIVIDUAL\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.INDIVIDUAL) .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.INDIVIDUAL }) .then(response => recording = response) .catch(error => console.error(error)); For example, for a session with 2 publishers the final content of the ZIP file could be: MyRecording.zip +-- MyRecording.json +-- tzk08sgffcqqwpor_CAMERA_DFDAE.webm +-- ugkmpnz4bn6yewbi_CAMERA_PAHHB.webm And the content of the JSON synchronization file might be: { \"createdAt\": 1548947712287, \"id\": \"zfgmthb8jl9uellk\", \"name\": \"MyRecording\", \"sessionId\": \"zfgmthb8jl9uellk\", \"files\": [ { \"connectionId\": \"ugkmpnz4bn6yewbi\", \"streamId\": \"ugkmpnz4bn6yewbi_CAMERA_PAHHB\", \"size\": 4006190, \"clientData\": \"\", \"serverData\": \"UserA\", \"hasAudio\": true, \"hasVideo\": true, \"typeOfVideo\": \"SCREEN\", \"startTimeOffset\": 95, \"endTimeOffset\": 56445 }, { \"connectionId\": \"tzk08sgffcqqwpor\", \"streamId\": \"tzk08sgffcqqwpor_CAMERA_DFDAE\", \"size\": 2404760, \"clientData\": \"\", \"serverData\": \"UserB\", \"hasAudio\": false, \"hasVideo\": true, \"typeOfVideo\": \"CAMERA\", \"startTimeOffset\": 148, \"endTimeOffset\": 56398 } ] } These are the properties in the JSON file createdAt : time when the recording was started in UTC milliseconds id : unique identifier of the recording name : custom name of the recording. You can set this parameter when starting the recording, and the final ZIP file will be named after it sessionId : unique identifier of the session that was recorded files : array containing one JSON object for each one of the WEBM videos inside the ZIP file connectionId : unique identifier of the connection that published the stream streamId : unique identifier of the recorded stream size : size in bytes of this particular recorded file clientData : data associated to the connection that published the stream, in the client side. You can use this field to identify the user that published this particular recorded stream serverData : data associated to the connection that published the stream, in the server side. You can use this field to identify the user that published this particular recorded stream hasAudio : whether this recorded stream has an audio track or not hasVideo : whether this recorded stream has a video track or not typeOfVideo : type of video (\"CAMERA\" or \"SCREEN\"). Only defined if hasVideo is true startTimeOffset : the offset in milliseconds for when this particular stream started being recorded, from the createdAt property of the root element endTimeOffset : the offset in milliseconds for when this particular stream stopped being recorded, from the createdAt property of the root element","title":"Individual stream recording"},{"location":"advanced-features/recording/#audio-only-and-video-only-recordings","text":"By default recordings will be generated with both audio and video, but you can configure them to record audio-only or video-only files. REST API Java Node When starting the recording of a session with method POST /api/recordings/start simply pass parameters hasAudio or hasVideo with the desired values. RecordingProperties properties = new RecordingProperties.Builder() .hasAudio(true) .hasVideo(false) .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { hasAudio: true, hasVideo: false }) .then(response => recording = response) .catch(error => console.error(error)); Notes on audio/video only recordings Recordings configured to not record neither audio nor video will fail to start, returning a status error of 422 COMPOSED video-only recordings will generate an MP4 file. COMPOSED audio-only recordings will generate a WEBM file. INDIVIDUAL recordings will always generate a ZIP file containing one WEBM file for each recorded stream Streams published during a video-only recording that are audio-only won't be recorded: they won't be included in the grid layout for COMPOSED recordings and won't generate a WEBM file in INDIVIDUAL recordings. Same for audio-only recordings with video-only streams Recordings started automatically (with recording mode ALWAYS ) will record both audio and video","title":"Audio-only and video-only recordings"},{"location":"advanced-features/recording/#automatic-stop-of-recordings","text":"Any started recording will automatically be stopped when any of the following situations occur and certain timeout elapses. This timeout is by default 120 seconds, but you can configure it with system property openvidu.recording.autostop-timeout . The automatic recording stop timout will start: For any recorded session, if last user disconnects from the session For sessions with recording mode MANUAL , if the recording is started and no user is publishing a stream The only condition to abort the timeout is to have any user publishing a stream to the session within the timeout. Sessions will always remain opened and the recording active during the timeout. If it elapses and no stream is being published to the session, the recording will be stopped. If in addition there's no user connected to the session, the session will also be automatically closed. You can always manually stop any recording at any time: REST API Java Node POST /api/recordings/stop/<RECORDING_ID> Recording stoppedRecording = openVidu.stopRecording(recordingId); var stoppedRecording; openvidu.stopRecording(recordingId) .then(response => stoppedRecording = response) .catch(error => console.error(error));","title":"Automatic stop of recordings"},{"location":"advanced-features/recording/#custom-recording-layouts","text":"You can create your own layouts for the session recording process. They are implemented with HTML/CSS/JS files, just as your OpenVidu application client-side.","title":"Custom recording layouts"},{"location":"advanced-features/recording/#1-create-your-layout-with-htmlcssjs-files","text":"Put them in a path accessible to openvidu-server. There must be an index.html file as entrypoint for your custom layout: WHAT SHOULD YOUR JS CODE DO : by making use of openvidu-browser.js library, you need to connect a recorder participant to the session. This means: 1) Your layout must connect to the session using a token like this: 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '&secret=' + SECRET + '&recorder=true'; Being SESSION_ID and SECRET two parameters that will be url-encoded under ids sessionId and secret respectively. So, for example: var url = new URL(window.location.href); var SESSION_ID = url.searchParams.get(\"sessionId\"); var SECRET = url.searchParams.get(\"secret\"); var TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '&secret=' + SECRET + '&recorder=true'; var session = OV.initSession(); session.connect(TOKEN); 2) You will need to subscribe to, at least, one event: streamCreated of Session object. That way you can subscribe your recorder to every stream when any user starts publishing (by default, the video element will be automatically removed on every streamDestroyed event). To sum up, this would be the simplest code you need to properly start your recorder participant: var OV = new OpenVidu(); var url = new URL(window.location.href); var SESSION_ID = url.searchParams.get(\"sessionId\"); var SECRET = url.searchParams.get(\"secret\"); var TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '&secret=' + SECRET + '&recorder=true'; var session = OV.initSession(); session.on(\"streamCreated\", (event) => { session.subscribe(event.stream, 'html-id-where-insert-video'); }); session.connect(TOKEN); HOW TO IDENTIFY YOUR USERS : you can identify them by making use of property Stream.connection.data of the Stream object retrieved in Session event \"streamCreated\". That way you may know which particular user should be displayed in which particular HTML element of your layout. For example: session.on(\"streamCreated\", (event) => { var stream = event.stream; if (stream.connection.data === 'userBigVideo') { session.subscribe(stream, 'big-video-div'); } else if (stream.connection.data === 'userSmallVideo') { session.subscribe(stream, 'small-video-div'); } });","title":"1. Create your layout with HTML/CSS/JS files"},{"location":"advanced-features/recording/#2-add-new-properties-when-launching-openvidu-server","text":"You can configure where should OpenVidu Server look for your custom layout in the system. Default path is /opt/openvidu/custom-layout , but you can configure it with system property openvidu.recording.custom-layout . OpenVidu Server must have read access to that path, where you must have stored the index.html file of your layout. openvidu-server.jar java -jar \\ -Dopenvidu.recording=true \\ -Dopenvidu.recording.path=/PATH/TO/VIDEO/FILES \\ -Dopenvidu.recording.custom-layout: /PATH/TO/INDEX/CUSTOM/LAYOUT \\ openvidu-server.jar openvidu/openvidu-server-kms Docker container (development environment) docker run -p 4443:4443 --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\ -v /PATH/TO/INDEX/CUSTOM/LAYOUT:/PATH/TO/INDEX/CUSTOM/LAYOUT \\ -e MY_UID=$(id -u $USER) \\ -e openvidu.recording=true \\ -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\ -e openvidu.recording.custom-layout=/PATH/TO/INDEX/CUSTOM/LAYOUT \\ openvidu/openvidu-server-kms:2.12.0 WARNING : remember to add the -v option mounting the path defined with openvidu.recording.custom-layout OpenVidu AWS deployment You must store your custom layouts in the server under default path /opt/openvidu/custom-layout","title":"2. Add new properties when launching openvidu-server"},{"location":"advanced-features/recording/#3-configure-your-recordings-to-use-your-custom-layout","text":"REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameters {\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .recordingLayout(RecordingLayout.CUSTOM) .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, recordingLayout: RecordingLayout.CUSTOM }) .then(response => recording = response) .catch(error => console.error(error));","title":"3. Configure your recordings to use your custom layout"},{"location":"advanced-features/recording/#configuring-multiple-custom-layouts","text":"You can implement as many custom recording layouts as you want. Simply store each one of them (each one with its own index.html entrypoint file) in a subfolder under path defined with system property openvidu.recording.custom-layout (default value /opt/openvidu/custom-layout ). Then, when configuring your sessions as stated above in point 3, just add a new parameter: REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameters {\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\", \"customLayout\": \"RELATIVE/PATH/TO/INDEX\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .recordingLayout(RecordingLayout.CUSTOM) .customLayout(\"RELATIVE/PATH/TO/INDEX\") .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, recordingLayout: RecordingLayout.CUSTOM, customLayout: \"RELATIVE/PATH/TO/INDEX\" }) .then(response => recording = response) .catch(error => console.error(error)); In the snippets above, string RELATIVE/PATH/TO/INDEX is the path from openvidu-server configuration property openvidu.recording.custom-layout to the specific index.html you want to use for a particular recording. So, if you have the following folder tree structure in your OpenVidu Server host: /opt +-- /openvidu | +-- /my_custom_layouts | +-- index.html | +-- /layout1 | +-- index.html | +-- /layout2 | +-- index.html /etc ... You should start openvidu-server with property openvidu.recording.custom-layout=/opt/openvidu/my_custom_layouts and you can use any of the 3 index.html files for recording any of your sessions. To use the outer layout in a recording, just configure in recording properties recordingLayout to CUSTOM . To use any of the inner layouts, also configure customLayout to layout1 or layout2 .","title":"Configuring multiple custom layouts"},{"location":"advanced-features/recording/#using-an-external-custom-layout","text":"OpenVidu allows you to configure a recording to use a custom layout deployed outside OpenVidu host. This is useful if, for whatever reason, you have your layout being served in a different server. To achieve this, you just have to configure the complete URL where your layout is served in property customLayout : REST API Java Node When starting the recording of a session with method POST /api/recordings/start pass parameters {\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\", \"customLayout\": \"https://USER:PASS@my.domain.com:8888/path?myParam=123\"} RecordingProperties properties = new RecordingProperties.Builder() .outputMode(Recording.OutputMode.COMPOSED) .recordingLayout(RecordingLayout.CUSTOM) .customLayout(\"https://USER:PASS@my.domain.com:8888/path?myParam=123\") .build(); Recording recording = openVidu.startRecording(session.getSessionId(), properties); var recording; openvidu.startRecording(sessionId, { outputMode: Recording.OutputMode.COMPOSED, recordingLayout: RecordingLayout.CUSTOM, customLayout: \"https://USER:PASS@my.domain.com:8888/path?myParam=123\" }) .then(response => recording = response) .catch(error => console.error(error)); As you can see, this URL may have credentials and any query parameter or token you may need in your custom layout. For example, in the snippets above the layout files would be protected by Basic Auth with \"USER\" ans \"PASS\" as username and password, and you could access value 123 in your layout JS code just by calling new URL(window.location.href).searchParams.get(\"myParam\");","title":"Using an external custom layout"},{"location":"advanced-features/recording/#debugging-your-custom-layouts","text":"To debug your custom layout, you just need to store it in the path declared with property openvidu.recording.custom-layout , as explained in section Add new properties when launching openvidu-server . Then, by using your OpenVidu application, start a session and as many publishers as you expect to be recorded in your custom layout. Finally you just have to connect to your layout through Chrome by entering url: https://OPENVIDUAPP: SECRET @ OPENVIDU_IP :4443/layouts/custom/index.html?sessionId= SESSION_ID &secret= SECRET Being: SECRET : parameter openvidu.secret configured when launching openvidu-server OPENVIDU_IP : the IP where openvidu-server is accessible in your development machine. You will be probably using openvidu-server-kms docker container in your development environment, so this parameter is localhost if you are in Mac or Linux, and the docker IP of the container if you are in Windows (see this FAQ ) SESSION_ID : the session ID you have initialized for the debugging process. Here's a little tip: you can initialize the session in openvidu-server ( REST API , openvidu-java-client , openvidu-node-client ) configuring parameter customSessionId to fix this session ID and avoid having to change it every time you restart your session. By connecting with Chrome to the above URL you will see the exact result obtained when recording a session with your custom layout. You can now start changing the HTML/CSS/JS files of your layout until you are happy with the outcome","title":"Debugging your custom layouts"},{"location":"advanced-features/recording/#sample-custom-layout","text":"This is literally the simplest HTML for a custom recording layout. Use it as a template for building more complex ones (you will need latest openvidu-browser-VERSION.min.js file to be in the same folder. Be sure to use the same version number as your openvidu-server!) <html> <head><script src=\"openvidu-browser-2.8.0.min.js\"></script></head> <body> <div id=\"videos\"></div> </body> <script> var url = new URL(window.location.href); var SESSION_ID = url.searchParams.get(\"sessionId\"); var SECRET = url.searchParams.get(\"secret\"); var TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '&secret=' + SECRET + '&recorder=true'; var OV = new OpenVidu(); var session = OV.initSession(); session.on(\"streamCreated\", (event) => { session.subscribe(event.stream, 'videos'); }); session.connect(TOKEN) .then(() => { console.log('Recorder participant connected') }) .catch(error => { console.error(error) }); </script> </html>","title":"Sample custom layout"},{"location":"advanced-features/recording/#local-recording-in-the-browser","text":"OpenVidu Browser offers an extremely simple API to record Streams directly in the client's browser. Check it out here . function changeLangTab(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.textContent || event.target.innerText; var txt = txt.replace(/\\s/g, \"-\").toLowerCase(); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of language buttons if (child.classList.contains(\"lang-tabs-header\")) { for (var j = 0; j < child.children.length; j++) { var btn = child.children[j]; if (btn.classList.contains(\"lang-tabs-btn\")) { btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9'; btn.style.fontWeight = btn === event.target ? 'bold' : 'normal'; } } } // Change visibility of language content if (child.classList.contains(\"lang-tabs-content\")) { if (child.id === txt) { child.style.display = \"block\"; } else { child.style.display = \"none\"; } } } }","title":"Local recording in the browser"},{"location":"advanced-features/screen-share/","text":"Screen share How to screen share How to know when the user stops sharing the screen Custom Screen Sharing extension for Chrome How to screen share Chrome , Opera , Firefox and desktop Electron apps support screen sharing. Chrome >=72, Opera (based on Chrome >=72) and Firefox >=66 To share your screen instead of your webcam, the process is exactly the same as stated in Publish a stream section, but setting to \"screen\" videoSource property when initializing a Publisher object: var OV = new OpenVidu(); var publisher = OV.initPublisher(\"html-element-id\", { videoSource: \"screen\" }); Chrome <72 and Opera (based on Chrome <72) In these cases there's need of a browser extension. An OpenViduError object may be returned with the following OpenViduError.name property in the callback function: SCREEN_SHARING_NOT_SUPPORTED : if the client does not support screen sharing. SCREEN_EXTENSION_NOT_INSTALLED : Chrome <72 needs an extension to allow screen sharing. error.message has the URL of Chrome Web Store where to install the extension. SCREEN_EXTENSION_DISABLED : if Chrome's screen extension is installed but disabled SCREEN_CAPTURE_DENIED : if the user doesn't grant permissions to capture the screen when the browser asks to. var OV = new OpenVidu(); var publisher = OV.initPublisher('html-element-id', { videoSource: \"screen\" }, function(error) { if (error.name == 'SCREEN_EXTENSION_NOT_INSTALLED') { showWarning(error.message); // showWarning could show a button with href 'error.message', // so the user can navigate to install the extension. // A browser refresh is also needed after installation } else if (error.name == 'SCREEN_SHARING_NOT_SUPPORTED') { alert('Your browser does not support screen sharing'); } else if (error.name == 'SCREEN_EXTENSION_DISABLED') { alert('You need to enable screen sharing extension'); } else if (error.name == 'SCREEN_CAPTURE_DENIED') { alert('You need to choose a window or application to share'); } }); Firefox <66 For Firefox <66 two different videoSource strings are allowed in order to screen share: \"screen\" : entire screen \"window\" : specific application window In Chrome, Opera and Firefox >=66 both values will always give access to both entire screen and specific application windows. Desktop Electron apps Electron allows screen-sharing, but there's no default screen selector built in the framework. For the rest of supported platforms, a native dialog will be shown when calling OpenVidu.initPublisher with { videoSource: \"screen\" } , so the user can pick up the screen or application window to share. For Electron, you must build your own screen selection dialog using desktopCapturer API and then append the desired screen identifier to string \"screen\" like this: { videoSource: \"screen:SCREEN_IDENTIFIER\" } To do so: desktopCapturer.getSources({ types: ['window', 'screen'] }).then(async sources => { sources.forEach(source => { // Name of the screen or window console.log(source.name); // Thumbnail of the screen or window. You can set this as the src attribute of an <img> element console.log(source.thumbnail.toDataURL()); // ID of the screen or window. This is the required value console.log(source.id); if (my_condition) { var OV = new OpenVidu(); var publisher = OV.initPublisher(\"html-element-id\", { videoSource: \"screen:\" + source.id }); } }); }); You can check out openvidu-electron tutorial , which includes a fully functional screen selector dialog. How to know when the user stops sharing the screen You can use native Web API to add a listener for determining when the user pressed the \"Stop sharing\" button shown by browsers when sharing a window or screen. You can do it like this: var OV = new OpenVidu(); var publisher = OV.initPublisherAsync({ videoSource: \"screen\" }).then(publisher => { publisher.stream.getMediaStream().addEventListener('inactive', () => { console.log('User pressed the \"Stop sharing\" button'); // You can send a signal with Session.signal method to warn other participants }); }); Event ended of MediaStreamTrack servers the same purpose. If you have any problem with inactive event of MediaStream object, you can try with ended event of MediaStreamTrack object. In the snippet above, that would be: publisher.stream.getMediaStream().getVideoTracks()[0].addEventListener('ended', () => { ... }) Custom Screen Sharing extension for Chrome We provide a default extension that will work on any domain in case the client is using Chrome <72 or Opera based on it. But you can create your own Chrome extension always based on ours ( OpenVidu Screen Sharing extension ). This way your extension may have your own icon, name, description and custom valid domains. To use your extension, just configure OpenVidu object like this after initializing it: var OV = new OpenVidu(); OV.setAdvancedConfiguration( { screenShareChromeExtension: \"https://chrome.google.com/webstore/detail/EXTENSION_NAME/EXTENSION_ID\" } ); Check the GitHub README for further information.","title":"Screen share"},{"location":"advanced-features/screen-share/#screen-share","text":"How to screen share How to know when the user stops sharing the screen Custom Screen Sharing extension for Chrome","title":"Screen share"},{"location":"advanced-features/screen-share/#how-to-screen-share","text":"Chrome , Opera , Firefox and desktop Electron apps support screen sharing.","title":"How to screen share"},{"location":"advanced-features/screen-share/#chrome-72-opera-based-on-chrome-72-and-firefox-66","text":"To share your screen instead of your webcam, the process is exactly the same as stated in Publish a stream section, but setting to \"screen\" videoSource property when initializing a Publisher object: var OV = new OpenVidu(); var publisher = OV.initPublisher(\"html-element-id\", { videoSource: \"screen\" });","title":"Chrome &gt;=72, Opera (based on Chrome &gt;=72) and Firefox &gt;=66"},{"location":"advanced-features/screen-share/#chrome-72-and-opera-based-on-chrome-72","text":"In these cases there's need of a browser extension. An OpenViduError object may be returned with the following OpenViduError.name property in the callback function: SCREEN_SHARING_NOT_SUPPORTED : if the client does not support screen sharing. SCREEN_EXTENSION_NOT_INSTALLED : Chrome <72 needs an extension to allow screen sharing. error.message has the URL of Chrome Web Store where to install the extension. SCREEN_EXTENSION_DISABLED : if Chrome's screen extension is installed but disabled SCREEN_CAPTURE_DENIED : if the user doesn't grant permissions to capture the screen when the browser asks to. var OV = new OpenVidu(); var publisher = OV.initPublisher('html-element-id', { videoSource: \"screen\" }, function(error) { if (error.name == 'SCREEN_EXTENSION_NOT_INSTALLED') { showWarning(error.message); // showWarning could show a button with href 'error.message', // so the user can navigate to install the extension. // A browser refresh is also needed after installation } else if (error.name == 'SCREEN_SHARING_NOT_SUPPORTED') { alert('Your browser does not support screen sharing'); } else if (error.name == 'SCREEN_EXTENSION_DISABLED') { alert('You need to enable screen sharing extension'); } else if (error.name == 'SCREEN_CAPTURE_DENIED') { alert('You need to choose a window or application to share'); } });","title":"Chrome &lt;72 and Opera (based on Chrome &lt;72)"},{"location":"advanced-features/screen-share/#firefox-66","text":"For Firefox <66 two different videoSource strings are allowed in order to screen share: \"screen\" : entire screen \"window\" : specific application window In Chrome, Opera and Firefox >=66 both values will always give access to both entire screen and specific application windows.","title":"Firefox &lt;66"},{"location":"advanced-features/screen-share/#desktop-electron-apps","text":"Electron allows screen-sharing, but there's no default screen selector built in the framework. For the rest of supported platforms, a native dialog will be shown when calling OpenVidu.initPublisher with { videoSource: \"screen\" } , so the user can pick up the screen or application window to share. For Electron, you must build your own screen selection dialog using desktopCapturer API and then append the desired screen identifier to string \"screen\" like this: { videoSource: \"screen:SCREEN_IDENTIFIER\" } To do so: desktopCapturer.getSources({ types: ['window', 'screen'] }).then(async sources => { sources.forEach(source => { // Name of the screen or window console.log(source.name); // Thumbnail of the screen or window. You can set this as the src attribute of an <img> element console.log(source.thumbnail.toDataURL()); // ID of the screen or window. This is the required value console.log(source.id); if (my_condition) { var OV = new OpenVidu(); var publisher = OV.initPublisher(\"html-element-id\", { videoSource: \"screen:\" + source.id }); } }); }); You can check out openvidu-electron tutorial , which includes a fully functional screen selector dialog.","title":"Desktop Electron apps"},{"location":"advanced-features/screen-share/#how-to-know-when-the-user-stops-sharing-the-screen","text":"You can use native Web API to add a listener for determining when the user pressed the \"Stop sharing\" button shown by browsers when sharing a window or screen. You can do it like this: var OV = new OpenVidu(); var publisher = OV.initPublisherAsync({ videoSource: \"screen\" }).then(publisher => { publisher.stream.getMediaStream().addEventListener('inactive', () => { console.log('User pressed the \"Stop sharing\" button'); // You can send a signal with Session.signal method to warn other participants }); }); Event ended of MediaStreamTrack servers the same purpose. If you have any problem with inactive event of MediaStream object, you can try with ended event of MediaStreamTrack object. In the snippet above, that would be: publisher.stream.getMediaStream().getVideoTracks()[0].addEventListener('ended', () => { ... })","title":"How to know when the user stops sharing the screen"},{"location":"advanced-features/screen-share/#custom-screen-sharing-extension-for-chrome","text":"We provide a default extension that will work on any domain in case the client is using Chrome <72 or Opera based on it. But you can create your own Chrome extension always based on ours ( OpenVidu Screen Sharing extension ). This way your extension may have your own icon, name, description and custom valid domains. To use your extension, just configure OpenVidu object like this after initializing it: var OV = new OpenVidu(); OV.setAdvancedConfiguration( { screenShareChromeExtension: \"https://chrome.google.com/webstore/detail/EXTENSION_NAME/EXTENSION_ID\" } ); Check the GitHub README for further information.","title":"Custom Screen Sharing extension for Chrome"},{"location":"advanced-features/speech-detection/","text":"Speech detection A pretty common requested event is one that allows you to detect when a publisher starts and stops speaking. OpenVidu offers this ability through PublisherSpeakingEvents that can be configured for Session objects: session.on('publisherStartSpeaking', (event) => { console.log('Publisher ' + event.connection.connectionId + ' start speaking'); }); session.on('publisherStopSpeaking', (event) => { console.log('Publisher ' + event.connection.connectionId + ' stop speaking'); }); PublisherSpeakingEvents only apply to Subscribers. This means that publisherStartSpeaking and publisherStopSpeaking will only be triggered for remote Streams : those owned by a Subscriber object You can further globally configure the behavior of these two events by using OpenVidu.setAdvancedConfiguration method: var OV = new OpenVidu(); OV.setAdvancedConfiguration({ publisherSpeakingEventsOptions: { interval: 100, // Frequency of the polling of audio streams in ms (default 100) threshold: -50 // Threshold volume in dB (default -50) } }); You can adjust dynamically this property for each specific Stream by using StreamManager.updatePublisherSpeakingEventsOptions method: // 'streamManager' being a Publisher or Subscriber object streamManager.updatePublisherSpeakingEventsOptions({ interval: 100, // Frequency of the polling of audio streams in ms threshold: -50 // Threshold volume in dB }); With these events it is really easy to build a layout that can make the main speaker video the bigger one, and alternate the main view between the participants of a session as they take the floor. Audio volume detection Since release 2.7.0, you have also available a new StreamManagerEvent called streamAudioVolumeChange . You can get the audio volume (-100 being silence to 0 being max volume) of any Publisher or Subscriber by doing this: publisher.on('streamAudioVolumeChange', (event) => { console.log('Publisher audio volume change from ' + event.value.oldValue + ' to' + event.value.newValue); }); Event streamAudioVolumeChange will be triggered by both Subscriber and Publisher objects (while PublisherSpeakingEvents only work with Subscriber objects). By working fine with Publisher objects, you can for example build a volume meter to inform your users that their microphone is working ok, showing the volume being received by the input device. The frequency streamAudioVolumeChange event is fired with is defined by property interval of OpenVidu.setAdvancedConfiguration (default 100ms). You can also adjust these values for each specific Publisher or Subscriber object with method StreamManager.updatePublisherSpeakingEventsOptions","title":"Speech detection"},{"location":"advanced-features/speech-detection/#speech-detection","text":"A pretty common requested event is one that allows you to detect when a publisher starts and stops speaking. OpenVidu offers this ability through PublisherSpeakingEvents that can be configured for Session objects: session.on('publisherStartSpeaking', (event) => { console.log('Publisher ' + event.connection.connectionId + ' start speaking'); }); session.on('publisherStopSpeaking', (event) => { console.log('Publisher ' + event.connection.connectionId + ' stop speaking'); }); PublisherSpeakingEvents only apply to Subscribers. This means that publisherStartSpeaking and publisherStopSpeaking will only be triggered for remote Streams : those owned by a Subscriber object You can further globally configure the behavior of these two events by using OpenVidu.setAdvancedConfiguration method: var OV = new OpenVidu(); OV.setAdvancedConfiguration({ publisherSpeakingEventsOptions: { interval: 100, // Frequency of the polling of audio streams in ms (default 100) threshold: -50 // Threshold volume in dB (default -50) } }); You can adjust dynamically this property for each specific Stream by using StreamManager.updatePublisherSpeakingEventsOptions method: // 'streamManager' being a Publisher or Subscriber object streamManager.updatePublisherSpeakingEventsOptions({ interval: 100, // Frequency of the polling of audio streams in ms threshold: -50 // Threshold volume in dB }); With these events it is really easy to build a layout that can make the main speaker video the bigger one, and alternate the main view between the participants of a session as they take the floor.","title":"Speech detection"},{"location":"advanced-features/speech-detection/#audio-volume-detection","text":"Since release 2.7.0, you have also available a new StreamManagerEvent called streamAudioVolumeChange . You can get the audio volume (-100 being silence to 0 being max volume) of any Publisher or Subscriber by doing this: publisher.on('streamAudioVolumeChange', (event) => { console.log('Publisher audio volume change from ' + event.value.oldValue + ' to' + event.value.newValue); }); Event streamAudioVolumeChange will be triggered by both Subscriber and Publisher objects (while PublisherSpeakingEvents only work with Subscriber objects). By working fine with Publisher objects, you can for example build a volume meter to inform your users that their microphone is working ok, showing the volume being received by the input device. The frequency streamAudioVolumeChange event is fired with is defined by property interval of OpenVidu.setAdvancedConfiguration (default 100ms). You can also adjust these values for each specific Publisher or Subscriber object with method StreamManager.updatePublisherSpeakingEventsOptions","title":"Audio volume detection"},{"location":"advanced-features/switch-camera/","text":"Switch camera As a first step, we strongly recommend taking a look at Publish/Unpublish stream documentation, as we need to be very clear about those concepts before we address the switching camera operation. That being said, there are two ways of switching the media source of a published stream: By using method Publisher.replaceTrack You can use method Publisher.replaceTrack to seamlessly change the video track being published by a Publisher object. // 'myPublisher' a Publisher object obtained through 'OpenVidu.initPublisher()' method // 'myTrack' a MediaStreamTrack object myPublisher.replaceTrack(myTrack) .then(() => console.log('New track is being published')) .catch(error => console.error('Error replacing track')); You can obtain this new MediaStreamTrack by using the native Web API or simply with OpenVidu.getUserMedia method. WARNING: this method has been proven to work, but there may be some combinations of published/replaced tracks that may be incompatible between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case By initializing a new Publisher You can also take a more \"radical\" path and directly use a new Publisher initialized with the new desired audio or video source. The general steps to switch the camera/microphone device in this way are: List all the client's available media devices Create a new Publisher with the desired device. If we want to switch the video, the videoSource field will be the new video deviceId Unpublish the old Publisher Publish our new Publisher created with the new videoSource To list the video and audio devices of a client, you must use OpenVidu.getDevices() method (take a look to getDevices method and Device object in openvidu-browser documentation) var OV = new OpenVidu(); OV.getDevices().then(devices => { // 'devices' array contains all available media devices }); Now we can create a new publisher with the specific videoSource , unpublish the old stream and publish the new one: var isFrontCamera = false; // This allows as to toggle the camera between the front and back one function toggleCamera() { getDevices().then(devices => { // Getting only the video devices var videoDevices = devices.filter(device => device.kind === 'videoinput'); if (videoDevices && videoDevices.length > 1){ // Creating a new publisher with specific videoSource // In mobile devices the default and first camera is the front one var newPublisher = OV.initPublisher('html-element-id', { videoSource: isFrontCamera ? videoDevices[1].deviceId : videoDevices[0].deviceId, publishAudio: true, publishVideo: true, mirror: isFrontCamera // Setting mirror enable if front camera is selected }); // Changing isFrontCamera value isFrontCamera = !isFrontCamera; // Unpublishing the old publisher session.unpublish(publisher); // Assigning the new publisher to our global variable 'publisher' publisher = newPublisher; // Publishing the new publisher this.session.publish(publisher); } }); } React Native In React Native the camera switching works in a different way. As we are using plugin react-native-webrtc , we must use a specific method provided by the plugin to switch the camera. This function allows us to switch between the front/back camera in a video track on the fly, without the need for adding/removing tracks or renegotiating the media. // _switchCamera() Method provided by react-native-webrtc plugin // It belongs to MediaStream object, contained in Stream object of openvidu-browser API stream.getMediaStream().getVideoTracks()[0]._switchCamera();","title":"Switch camera"},{"location":"advanced-features/switch-camera/#switch-camera","text":"As a first step, we strongly recommend taking a look at Publish/Unpublish stream documentation, as we need to be very clear about those concepts before we address the switching camera operation. That being said, there are two ways of switching the media source of a published stream:","title":"Switch camera"},{"location":"advanced-features/switch-camera/#by-using-method-publisherreplacetrack","text":"You can use method Publisher.replaceTrack to seamlessly change the video track being published by a Publisher object. // 'myPublisher' a Publisher object obtained through 'OpenVidu.initPublisher()' method // 'myTrack' a MediaStreamTrack object myPublisher.replaceTrack(myTrack) .then(() => console.log('New track is being published')) .catch(error => console.error('Error replacing track')); You can obtain this new MediaStreamTrack by using the native Web API or simply with OpenVidu.getUserMedia method. WARNING: this method has been proven to work, but there may be some combinations of published/replaced tracks that may be incompatible between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case","title":"By using method Publisher.replaceTrack"},{"location":"advanced-features/switch-camera/#by-initializing-a-new-publisher","text":"You can also take a more \"radical\" path and directly use a new Publisher initialized with the new desired audio or video source. The general steps to switch the camera/microphone device in this way are: List all the client's available media devices Create a new Publisher with the desired device. If we want to switch the video, the videoSource field will be the new video deviceId Unpublish the old Publisher Publish our new Publisher created with the new videoSource To list the video and audio devices of a client, you must use OpenVidu.getDevices() method (take a look to getDevices method and Device object in openvidu-browser documentation) var OV = new OpenVidu(); OV.getDevices().then(devices => { // 'devices' array contains all available media devices }); Now we can create a new publisher with the specific videoSource , unpublish the old stream and publish the new one: var isFrontCamera = false; // This allows as to toggle the camera between the front and back one function toggleCamera() { getDevices().then(devices => { // Getting only the video devices var videoDevices = devices.filter(device => device.kind === 'videoinput'); if (videoDevices && videoDevices.length > 1){ // Creating a new publisher with specific videoSource // In mobile devices the default and first camera is the front one var newPublisher = OV.initPublisher('html-element-id', { videoSource: isFrontCamera ? videoDevices[1].deviceId : videoDevices[0].deviceId, publishAudio: true, publishVideo: true, mirror: isFrontCamera // Setting mirror enable if front camera is selected }); // Changing isFrontCamera value isFrontCamera = !isFrontCamera; // Unpublishing the old publisher session.unpublish(publisher); // Assigning the new publisher to our global variable 'publisher' publisher = newPublisher; // Publishing the new publisher this.session.publish(publisher); } }); }","title":"By initializing a new Publisher"},{"location":"advanced-features/switch-camera/#react-native","text":"In React Native the camera switching works in a different way. As we are using plugin react-native-webrtc , we must use a specific method provided by the plugin to switch the camera. This function allows us to switch between the front/back camera in a video track on the fly, without the need for adding/removing tracks or renegotiating the media. // _switchCamera() Method provided by react-native-webrtc plugin // It belongs to MediaStream object, contained in Stream object of openvidu-browser API stream.getMediaStream().getVideoTracks()[0]._switchCamera();","title":"React Native"},{"location":"cheatsheet/join-session/","text":"Join a session First initialize a Session object: var OV = new OpenVidu(); var session = OV.initSession(); Then by calling session.connect method you can join a properly initialized session. // After retrieving a token from OpenVidu Server... session.connect(token) .then( ... ) .catch( ... ); You must ask OpenVidu Server for a user token. To do so: Initialize a Session in OpenVidu Server API REST openvidu-java-client openvidu-node-client Generate a token for this session in OpenVidu Server API REST openvidu-java-client openvidu-node-client Return this token to your client-side to use it on Session.connect() You can add an optional second parameter to pass some user metadata that will be recieved by every other user connected to the same session (check Share data between users to learn more). session.connect(token, DATA) .then( ... ) .catch( ... );","title":"Join a session"},{"location":"cheatsheet/join-session/#join-a-session","text":"First initialize a Session object: var OV = new OpenVidu(); var session = OV.initSession(); Then by calling session.connect method you can join a properly initialized session. // After retrieving a token from OpenVidu Server... session.connect(token) .then( ... ) .catch( ... ); You must ask OpenVidu Server for a user token. To do so: Initialize a Session in OpenVidu Server API REST openvidu-java-client openvidu-node-client Generate a token for this session in OpenVidu Server API REST openvidu-java-client openvidu-node-client Return this token to your client-side to use it on Session.connect() You can add an optional second parameter to pass some user metadata that will be recieved by every other user connected to the same session (check Share data between users to learn more). session.connect(token, DATA) .then( ... ) .catch( ... );","title":"Join a session"},{"location":"cheatsheet/leave-session/","text":"Leave a session By calling session.disconnect method you can leave the session. session.disconnect(); This action will trigger the following events: sessionDisconnected : dispatched by Session object of the local user that is leaving. Automatically cleans all remote videos. streamDestroyed : dispatched by Publisher object of the local user that is leaving (only if publishing). Automatically cleans the local video. streamDestroyed : dispatched by Session object of every other remote user connected to the session. Automatically cleans the remote video. connectionDestroyed : dispatched by Session object of every other remote user connected to the session.","title":"Leave a session"},{"location":"cheatsheet/leave-session/#leave-a-session","text":"By calling session.disconnect method you can leave the session. session.disconnect(); This action will trigger the following events: sessionDisconnected : dispatched by Session object of the local user that is leaving. Automatically cleans all remote videos. streamDestroyed : dispatched by Publisher object of the local user that is leaving (only if publishing). Automatically cleans the local video. streamDestroyed : dispatched by Session object of every other remote user connected to the session. Automatically cleans the remote video. connectionDestroyed : dispatched by Session object of every other remote user connected to the session.","title":"Leave a session"},{"location":"cheatsheet/manage-videos/","text":"Manage videos OpenVidu makes very easy the management of the video players. You can let OpenVidu take care of their lifecycle or you can use your own HTML video elements. Every Publisher and Subscriber object can display a media stream in as many video players as you want. Let OpenVidu take care of the video players A) Publisher videos When initalizing a Publisher object, you can insert a video player by passing a valid targetElement in method OpenVidu.initPublisher (can be an HTMLElement or its id attribute). Second parameter allows you to customize the publisher's stream, including how OpenVidu must insert the video player according to targetElement (more info in OpenVidu Browser Docs ): var publisher = OV.initPublisher(targetElement, {insertMode: 'APPEND'}); After getting the Publisher object, you can create more video players to display its media stream just by calling Publisher.createVideoElement . Pass a valid targetElement and the insertMode : publisher.createVideoElement(targetElement, 'APPEND'); B) Subscriber videos When subscribing to a Stream, you can insert a video player by passing a valid targetElement in method Session.subscribe (can be an HTMLElement or its id attribute). Third parameter allows you to customize the subscriber's stream, including how OpenVidu must insert the video player according to targetElement (more info in OpenVidu Browser Docs ): var subscriber; session.on('streamCreated', event => { subscriber = session.subscribe(event.stream, targetElement, {insertMode: 'APPEND'}); }); After getting the Subscriber object, you can create more video players to display its media stream just by calling Subscriber.createVideoElement . Pass a valid targetElement and the insertMode : subscriber.createVideoElement(targetElement, 'APPEND'); Publisher and Subscriber objects will dispatch a videoElementCreated event for every video inserted into DOM by these methods. Also these videos will be automatically removed from DOM when required and Publisher and Subscriber objects will dispatch a videoElementDestroyed event for every one of them You take care of the video players A) Publisher videos Pass undefined as targetElement when initializing your Publisher and when you have it available just call method Publisher.addVideoElement , passing an already existing HTML video element of the DOM: var publisher = OV.initPublisher(undefined, publisherProperties); publisher.addVideoElement(videoElement); B) Subscriber videos Pass undefined as targetElement when subscribing to a Stream and when you have Subscriber object available just call method Subscriber.addVideoElement , passing an already existing HTML video element of the DOM: var subscriber; session.on('streamCreated', event => { subscriber = session.subscribe(event.stream, undefined); subscriber.addVideoElement(videoElement); }); This way of managing the video players is very useful when developing your application with some frontend declarative framework such as Angular , React or Vue.js . It allows you to add to the proper Publisher or Subscriber any video element managed by the framework. Besides, it is possible to treat both Publishers and Subscribers the same way regarding their rendering in the page, as they both inherit from the parent class StreamManager . If you are interested in these concepts, you can check out our super simple Angular tutorial .","title":"Manage video players"},{"location":"cheatsheet/manage-videos/#manage-videos","text":"OpenVidu makes very easy the management of the video players. You can let OpenVidu take care of their lifecycle or you can use your own HTML video elements. Every Publisher and Subscriber object can display a media stream in as many video players as you want.","title":"Manage videos"},{"location":"cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players","text":"","title":"Let OpenVidu take care of the video players"},{"location":"cheatsheet/manage-videos/#a-publisher-videos","text":"When initalizing a Publisher object, you can insert a video player by passing a valid targetElement in method OpenVidu.initPublisher (can be an HTMLElement or its id attribute). Second parameter allows you to customize the publisher's stream, including how OpenVidu must insert the video player according to targetElement (more info in OpenVidu Browser Docs ): var publisher = OV.initPublisher(targetElement, {insertMode: 'APPEND'}); After getting the Publisher object, you can create more video players to display its media stream just by calling Publisher.createVideoElement . Pass a valid targetElement and the insertMode : publisher.createVideoElement(targetElement, 'APPEND');","title":"A) Publisher videos"},{"location":"cheatsheet/manage-videos/#b-subscriber-videos","text":"When subscribing to a Stream, you can insert a video player by passing a valid targetElement in method Session.subscribe (can be an HTMLElement or its id attribute). Third parameter allows you to customize the subscriber's stream, including how OpenVidu must insert the video player according to targetElement (more info in OpenVidu Browser Docs ): var subscriber; session.on('streamCreated', event => { subscriber = session.subscribe(event.stream, targetElement, {insertMode: 'APPEND'}); }); After getting the Subscriber object, you can create more video players to display its media stream just by calling Subscriber.createVideoElement . Pass a valid targetElement and the insertMode : subscriber.createVideoElement(targetElement, 'APPEND'); Publisher and Subscriber objects will dispatch a videoElementCreated event for every video inserted into DOM by these methods. Also these videos will be automatically removed from DOM when required and Publisher and Subscriber objects will dispatch a videoElementDestroyed event for every one of them","title":"B) Subscriber videos"},{"location":"cheatsheet/manage-videos/#you-take-care-of-the-video-players","text":"","title":"You take care of the video players"},{"location":"cheatsheet/manage-videos/#a-publisher-videos_1","text":"Pass undefined as targetElement when initializing your Publisher and when you have it available just call method Publisher.addVideoElement , passing an already existing HTML video element of the DOM: var publisher = OV.initPublisher(undefined, publisherProperties); publisher.addVideoElement(videoElement);","title":"A) Publisher videos"},{"location":"cheatsheet/manage-videos/#b-subscriber-videos_1","text":"Pass undefined as targetElement when subscribing to a Stream and when you have Subscriber object available just call method Subscriber.addVideoElement , passing an already existing HTML video element of the DOM: var subscriber; session.on('streamCreated', event => { subscriber = session.subscribe(event.stream, undefined); subscriber.addVideoElement(videoElement); }); This way of managing the video players is very useful when developing your application with some frontend declarative framework such as Angular , React or Vue.js . It allows you to add to the proper Publisher or Subscriber any video element managed by the framework. Besides, it is possible to treat both Publishers and Subscribers the same way regarding their rendering in the page, as they both inherit from the parent class StreamManager . If you are interested in these concepts, you can check out our super simple Angular tutorial .","title":"B) Subscriber videos"},{"location":"cheatsheet/mute-audio-video/","text":"Mute/Unmute audio and video By calling Publisher.publishAudio() or Publisher.publishVideo() method you can toggle audio and video of your Publisher object. Every user subscribed to its stream will stop receiving audio or video. publisher.publishAudio(audioEnabled); // true to unmute the audio track, false to mute it publisher.publishVideo(videoEnabled); // true to enable the video track, false to disable it By calling Subscriber.subscribeToAudio() or Subscriber.subscribeToVideo() method you can toggle audio and video of any Subscriber object. You will stop receiving audio or video from it (only affects the client calling the method). subscriber.subscribeToAudio(audioEnabled); // true to unmute the audio track, false to mute it subscriber.subscribeToVideo(videoEnabled); // true to enable the video, false to disable it","title":"Mute/Unmute audio and video"},{"location":"cheatsheet/mute-audio-video/#muteunmute-audio-and-video","text":"By calling Publisher.publishAudio() or Publisher.publishVideo() method you can toggle audio and video of your Publisher object. Every user subscribed to its stream will stop receiving audio or video. publisher.publishAudio(audioEnabled); // true to unmute the audio track, false to mute it publisher.publishVideo(videoEnabled); // true to enable the video track, false to disable it By calling Subscriber.subscribeToAudio() or Subscriber.subscribeToVideo() method you can toggle audio and video of any Subscriber object. You will stop receiving audio or video from it (only affects the client calling the method). subscriber.subscribeToAudio(audioEnabled); // true to unmute the audio track, false to mute it subscriber.subscribeToVideo(videoEnabled); // true to enable the video, false to disable it","title":"Mute/Unmute audio and video"},{"location":"cheatsheet/publish-unpublish/","text":"Publish/Unpublish a stream You can publish a stream after joining a session: get a Publisher object through OpenVidu object ( OpenVidu.initPublisher ) and publish it with Session object. var publisher = OV.initPublisher(targetElement); // Register all the events you want with 'publisher.on(...)' session.publish(publisher); // Method Session.publish must always be called after successfully connecting to session OpenVidu.initPublisher method will insert into DOM a new HTML video element inside the element targetElement , showing your camera. This target element can be an HTMLElement or its id attribute, and you can also indicate how to insert the video according to it (see PublisherProperties.insertMode ). You can then publish it to the session whenever you want (perhaps you want the user to confirm that the camera is working well before publishing it). Session.publish method will make Publisher object trigger streamCreated event in the local user that is publishing and will make Session object trigger streamCreated event in every other remote user connected to the session. You can add two more parameters to initPublisher method: an object with properties about your publisher stream and a callback function to be executed just after the method finishes and before the publisher object dispatches accessAllowed or accessDenied event: OV.initPublisher( targetElement, { audioSource: undefined, // The source of audio. If undefined default audio input videoSource: undefined, // The source of video. If undefined default video input publishAudio: true, // Whether you want to start the publishing with audio unmuted or muted publishVideo: true, // Whether you want to start the publishing with video enabled or disabled resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video will be inserted according to targetElement mirror: false // Whether to mirror your local video or not }, (error) => { // Function to be executed when the method finishes if (error) { console.error('Error while initializing publisher: ', error); } else { console.log('Publisher successfully initialized'); } } ); To unpublish the stream: session.unpublish(publisher); As long as you have the Publisher object available, you can alternately call Session.publish and Session.unpublish as many times as you want. It is also possible to change the Publisher dynamically (for example if you want to stop transmitting your webcam and start sharing your screen, all of it without leaving the session). To do so: session.unpublish(oldPubliser); newPublisher = OV.initPublisher(newOptions); // Register all the events you want with 'newPublisher.on(...)' session.publish(newPublisher); NOTE : only users with Role PUBLISHER or MODERATOR can call Session.publish method. You can check OpenViduRole section of OpenVidu Node Client for a complete description","title":"Publish/Unpublish a stream"},{"location":"cheatsheet/publish-unpublish/#publishunpublish-a-stream","text":"You can publish a stream after joining a session: get a Publisher object through OpenVidu object ( OpenVidu.initPublisher ) and publish it with Session object. var publisher = OV.initPublisher(targetElement); // Register all the events you want with 'publisher.on(...)' session.publish(publisher); // Method Session.publish must always be called after successfully connecting to session OpenVidu.initPublisher method will insert into DOM a new HTML video element inside the element targetElement , showing your camera. This target element can be an HTMLElement or its id attribute, and you can also indicate how to insert the video according to it (see PublisherProperties.insertMode ). You can then publish it to the session whenever you want (perhaps you want the user to confirm that the camera is working well before publishing it). Session.publish method will make Publisher object trigger streamCreated event in the local user that is publishing and will make Session object trigger streamCreated event in every other remote user connected to the session. You can add two more parameters to initPublisher method: an object with properties about your publisher stream and a callback function to be executed just after the method finishes and before the publisher object dispatches accessAllowed or accessDenied event: OV.initPublisher( targetElement, { audioSource: undefined, // The source of audio. If undefined default audio input videoSource: undefined, // The source of video. If undefined default video input publishAudio: true, // Whether you want to start the publishing with audio unmuted or muted publishVideo: true, // Whether you want to start the publishing with video enabled or disabled resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video will be inserted according to targetElement mirror: false // Whether to mirror your local video or not }, (error) => { // Function to be executed when the method finishes if (error) { console.error('Error while initializing publisher: ', error); } else { console.log('Publisher successfully initialized'); } } ); To unpublish the stream: session.unpublish(publisher); As long as you have the Publisher object available, you can alternately call Session.publish and Session.unpublish as many times as you want. It is also possible to change the Publisher dynamically (for example if you want to stop transmitting your webcam and start sharing your screen, all of it without leaving the session). To do so: session.unpublish(oldPubliser); newPublisher = OV.initPublisher(newOptions); // Register all the events you want with 'newPublisher.on(...)' session.publish(newPublisher); NOTE : only users with Role PUBLISHER or MODERATOR can call Session.publish method. You can check OpenViduRole section of OpenVidu Node Client for a complete description","title":"Publish/Unpublish a stream"},{"location":"cheatsheet/send-messages/","text":"Send text messages between users Any user connected to a session can send messages to every other participant of the session, as a broadcast message for everyone or to one or more specific participants. To do so: // Sender of the message (after 'session.connect') session.signal({ data: 'My custom message', // Any string (optional) to: [], // Array of Connection objects (optional. Broadcast to everyone if empty) type: 'my-chat' // The type of message (optional) }) .then(() => { console.log('Message successfully sent'); }) .catch(error => { console.error(error); }); Any user subscribed to that type will receive the message: // Receiver of the message (usually before calling 'session.connect') session.on('signal:my-chat', (event) => { console.log(event.data); // Message console.log(event.from); // Connection object of the sender console.log(event.type); // The type of message (\"my-chat\") }); You can subscribe to all signals just by calling: // Receiver of all messages (usually before calling 'session.connect') session.on('signal', (event) => { console.log(event.data); // Message console.log(event.from); // Connection object of the sender console.log(event.type); // The type of message }); You can send messages to specific users adding to to array the proper Connection objects: // Sender of the adressed message (after calling 'session.connect') session.signal({ data: 'My private custom message', to: [connection1, connection2], type: 'my-private-chat' }); In this last case, only participants represented by connection1 and connection2 objects will receive the signal event (only if they are subscribed to it!). You can get Connection objects by subscribing to connectionCreated event before connecting to a session: this.session.on('connectionCreated', (event) => { console.log(event.connection); });","title":"Send text messages"},{"location":"cheatsheet/send-messages/#send-text-messages-between-users","text":"Any user connected to a session can send messages to every other participant of the session, as a broadcast message for everyone or to one or more specific participants. To do so: // Sender of the message (after 'session.connect') session.signal({ data: 'My custom message', // Any string (optional) to: [], // Array of Connection objects (optional. Broadcast to everyone if empty) type: 'my-chat' // The type of message (optional) }) .then(() => { console.log('Message successfully sent'); }) .catch(error => { console.error(error); }); Any user subscribed to that type will receive the message: // Receiver of the message (usually before calling 'session.connect') session.on('signal:my-chat', (event) => { console.log(event.data); // Message console.log(event.from); // Connection object of the sender console.log(event.type); // The type of message (\"my-chat\") }); You can subscribe to all signals just by calling: // Receiver of all messages (usually before calling 'session.connect') session.on('signal', (event) => { console.log(event.data); // Message console.log(event.from); // Connection object of the sender console.log(event.type); // The type of message }); You can send messages to specific users adding to to array the proper Connection objects: // Sender of the adressed message (after calling 'session.connect') session.signal({ data: 'My private custom message', to: [connection1, connection2], type: 'my-private-chat' }); In this last case, only participants represented by connection1 and connection2 objects will receive the signal event (only if they are subscribed to it!). You can get Connection objects by subscribing to connectionCreated event before connecting to a session: this.session.on('connectionCreated', (event) => { console.log(event.connection); });","title":"Send text messages between users"},{"location":"cheatsheet/share-data/","text":"Share data between users Whatever app you are developing, chances are you will need to pass some data for each user, at least a nickname. You can do it in two different places: Client-Side : when calling Session.connect method in openvidu-browser: session.connect(token, \"USER_DATA\") .then( ... ) .catch( ... ); Server-Side : when generating a token API REST : add body parameter \"data\" to the POST operation openvidu-java-client : construct TokenOptions with TokenOptions.Builder().data(\"USER_DATA\").build() openvidu-node-client : construct TokenOptions with {data: \"USER_DATA\"} The result will be that in all clients, Connection objects will have in their data property the pertinent value you have provided for each user. So, an easy way to get the data associated to any user would be: session.on(\"streamCreated\", function (event) { session.subscribe(event.stream, \"subscriber\"); console.log(\"USER DATA: \" + event.stream.connection.data); }); Some clarifications: Using only first option is not secure, as clients could modify the value of the second parameter. It is intended for development environments or non critical data. If you want total control over shared data, please use the server-side way. Connection.data will be a simple string if you have provided data only with one of the methods, and will be a string with the following format if you provide data both from openvidu-browser and your backend: \"CLIENT_SIDE_DATA%/%SERVER_SIDE_DATA\" (both separated by string %/% ). You can choose whatever format you like for the data string, but if you are planning to share more than a simple field, maybe a standard format as JSON would be a wise choice. Method Session.connect in Openvidu Browser directly admits as data parameter a standard object (it will be finally stringified).","title":"Share data between users"},{"location":"cheatsheet/share-data/#share-data-between-users","text":"Whatever app you are developing, chances are you will need to pass some data for each user, at least a nickname. You can do it in two different places: Client-Side : when calling Session.connect method in openvidu-browser: session.connect(token, \"USER_DATA\") .then( ... ) .catch( ... ); Server-Side : when generating a token API REST : add body parameter \"data\" to the POST operation openvidu-java-client : construct TokenOptions with TokenOptions.Builder().data(\"USER_DATA\").build() openvidu-node-client : construct TokenOptions with {data: \"USER_DATA\"} The result will be that in all clients, Connection objects will have in their data property the pertinent value you have provided for each user. So, an easy way to get the data associated to any user would be: session.on(\"streamCreated\", function (event) { session.subscribe(event.stream, \"subscriber\"); console.log(\"USER DATA: \" + event.stream.connection.data); }); Some clarifications: Using only first option is not secure, as clients could modify the value of the second parameter. It is intended for development environments or non critical data. If you want total control over shared data, please use the server-side way. Connection.data will be a simple string if you have provided data only with one of the methods, and will be a string with the following format if you provide data both from openvidu-browser and your backend: \"CLIENT_SIDE_DATA%/%SERVER_SIDE_DATA\" (both separated by string %/% ). You can choose whatever format you like for the data string, but if you are planning to share more than a simple field, maybe a standard format as JSON would be a wise choice. Method Session.connect in Openvidu Browser directly admits as data parameter a standard object (it will be finally stringified).","title":"Share data between users"},{"location":"cheatsheet/subscribe-unsubscribe/","text":"Subscribe/Unsubscribe from other user's stream To receive the stream of a publisher of the session: var subscriber; session.on('streamCreated', (event) => { subscriber = session.subscribe(event.stream, targetElement); }); A new HTML video element will be appended to DOM inside the element targetElement . It can be an HTMLElement or its id attribute, and you can also indicate how to insert the video according to it (see SubscriberProperties.insertMode ). To cancel the subscription and stop receiving media: session.unsubscribe(subscriber); As long as you have the Subscriber object available, you can alternately call Session.subscribe and Session.unsubscribe as many times as you want.","title":"Subscribe/Unsubscribe from a stream"},{"location":"cheatsheet/subscribe-unsubscribe/#subscribeunsubscribe-from-other-users-stream","text":"To receive the stream of a publisher of the session: var subscriber; session.on('streamCreated', (event) => { subscriber = session.subscribe(event.stream, targetElement); }); A new HTML video element will be appended to DOM inside the element targetElement . It can be an HTMLElement or its id attribute, and you can also indicate how to insert the video according to it (see SubscriberProperties.insertMode ). To cancel the subscription and stop receiving media: session.unsubscribe(subscriber); As long as you have the Subscriber object available, you can alternately call Session.subscribe and Session.unsubscribe as many times as you want.","title":"Subscribe/Unsubscribe from other user's stream"},{"location":"demos/openvidu-call-ionic/","text":"openvidu-call-ionic Check it on GitHub OpenVidu Call Ionic demo, built with Ionic v4 and Angular 8 , allows users to make videoconference calls in theirs devices with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application. OpenVidu-Call-Ionic is composed by the five Angular components displayed in the image below. Android 5 (Lollipop) and 6 (Marshmallow) will not work with Ionic v4 until this issue is properly solved Running this demo Using the browser 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-call-ionic.git 2) You will need ionic-cli (and of course node 8.9 or greater) to serve the Ionic app. You can install it with the following command: npm install -g ionic@latest 3) Run the tutorial: cd openvidu-call-ionic npm install ionic serve 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8100 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. 6) To show the app with the device appearance, press F12 button in your keyboard and the browser DevTool will be opened. 7) Then, you can find a button with a device icon at the top of the browser page. Pressing this button, you should see the device appearance and it will allow you choose your favourite device. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Using the Android apk in an Android device To deploy the apk Android not only you need to have Java JDK8 , Android Studio and Android SDK installed but also you have to set up the specific environment variables . Fortunately, Ionic provide us a great guide to allows us to configure step by step all the requirements. After we have completed all the steps of the Ionic guide and performed steps 1) and 2) stated above, we must continue with the following commands: 3) Connect the device to the same network as the PC. 4) Establishing the same WIFI in both devices, you need to know IP of your PC in the network. For know that, you can execute ifconfig in your command shell and you will can find something like 192.168.0.105 . Your public_url will be https://192.168.0.105 with the port 4443 (https://192.168.0.105:4443). Finally, you will must set the OPENVIDU_SERVER_URL variable in the app and the openvidu.publicurl parameter used to run openvidu-server with your public_url and the port . 5) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=\"your_public_url\":4443 openvidu/openvidu-server-kms:2.12.0 6) Connect the device to the PC. You can check if your device is authoriced with the adb devices command. 7) Run the tutorial: cd openvidu-call-ionic npm install ionic cordova run android To deploy apps to an Android device and debug them, developer mode must be enabled and allow for USB debugging turned on. Check out these instructions to do this on a device. In an iOS device with native app To deploy the iOS app you will need first to follow this guide to properly configure your development environment. Then, it is crucial to have an OpenVidu Server properly deployed with a valid certificate . iOS devices will require OpenVidu Server to be deployed in a valid domain well-protected with a certificate. No iPhone or iPad will allow connections to a non-secure OpenVidu Server from within a native application. To facilitate first steps with OpenVidu and Ionic on iOS devices, if no custom url is defined here in the app then our demos OpenVidu Server will be used. Note: this is a publicly accessible OpenVidu Server. Anyone could access your sessions. Use it only for an initial test and under your own responsibility After we have completed all the steps of the Ionic guide and performed steps 1) and 2) stated above, we must continue with the following commands: 4) Add ios platform # In openvidu-tutorials/openvidu-ionic ionic cordova platform add ios 5) Run the tutorial. The app will be automatically launched in your iOS device. First execution you'll need to trust your developer account in your device under Settings -> General -> Device management -> your_apple_developer_account # In openvidu-tutorials/openvidu-ionic ionic cordova run ios You will need to sign your application in Xcode (opening folder openvidu-ionic/platforms/ios ) with your developer team to avoid any errors. From Apple official documentation : $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.screenshots-gallery').slick({ autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', autoplaySpeed: 4000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] });","title":"openvidu-call-ionic"},{"location":"demos/openvidu-call-ionic/#openvidu-call-ionic","text":"Check it on GitHub OpenVidu Call Ionic demo, built with Ionic v4 and Angular 8 , allows users to make videoconference calls in theirs devices with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application. OpenVidu-Call-Ionic is composed by the five Angular components displayed in the image below. Android 5 (Lollipop) and 6 (Marshmallow) will not work with Ionic v4 until this issue is properly solved","title":"openvidu-call-ionic"},{"location":"demos/openvidu-call-ionic/#running-this-demo","text":"","title":"Running this demo"},{"location":"demos/openvidu-call-ionic/#using-the-browser","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-call-ionic.git 2) You will need ionic-cli (and of course node 8.9 or greater) to serve the Ionic app. You can install it with the following command: npm install -g ionic@latest 3) Run the tutorial: cd openvidu-call-ionic npm install ionic serve 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8100 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. 6) To show the app with the device appearance, press F12 button in your keyboard and the browser DevTool will be opened. 7) Then, you can find a button with a device icon at the top of the browser page. Pressing this button, you should see the device appearance and it will allow you choose your favourite device. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Using the browser"},{"location":"demos/openvidu-call-ionic/#using-the-android-apk-in-an-android-device","text":"To deploy the apk Android not only you need to have Java JDK8 , Android Studio and Android SDK installed but also you have to set up the specific environment variables . Fortunately, Ionic provide us a great guide to allows us to configure step by step all the requirements. After we have completed all the steps of the Ionic guide and performed steps 1) and 2) stated above, we must continue with the following commands: 3) Connect the device to the same network as the PC. 4) Establishing the same WIFI in both devices, you need to know IP of your PC in the network. For know that, you can execute ifconfig in your command shell and you will can find something like 192.168.0.105 . Your public_url will be https://192.168.0.105 with the port 4443 (https://192.168.0.105:4443). Finally, you will must set the OPENVIDU_SERVER_URL variable in the app and the openvidu.publicurl parameter used to run openvidu-server with your public_url and the port . 5) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=\"your_public_url\":4443 openvidu/openvidu-server-kms:2.12.0 6) Connect the device to the PC. You can check if your device is authoriced with the adb devices command. 7) Run the tutorial: cd openvidu-call-ionic npm install ionic cordova run android To deploy apps to an Android device and debug them, developer mode must be enabled and allow for USB debugging turned on. Check out these instructions to do this on a device.","title":"Using the Android apk in an Android device"},{"location":"demos/openvidu-call-ionic/#in-an-ios-device-with-native-app","text":"To deploy the iOS app you will need first to follow this guide to properly configure your development environment. Then, it is crucial to have an OpenVidu Server properly deployed with a valid certificate . iOS devices will require OpenVidu Server to be deployed in a valid domain well-protected with a certificate. No iPhone or iPad will allow connections to a non-secure OpenVidu Server from within a native application. To facilitate first steps with OpenVidu and Ionic on iOS devices, if no custom url is defined here in the app then our demos OpenVidu Server will be used. Note: this is a publicly accessible OpenVidu Server. Anyone could access your sessions. Use it only for an initial test and under your own responsibility After we have completed all the steps of the Ionic guide and performed steps 1) and 2) stated above, we must continue with the following commands: 4) Add ios platform # In openvidu-tutorials/openvidu-ionic ionic cordova platform add ios 5) Run the tutorial. The app will be automatically launched in your iOS device. First execution you'll need to trust your developer account in your device under Settings -> General -> Device management -> your_apple_developer_account # In openvidu-tutorials/openvidu-ionic ionic cordova run ios You will need to sign your application in Xcode (opening folder openvidu-ionic/platforms/ios ) with your developer team to avoid any errors. From Apple official documentation : $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.screenshots-gallery').slick({ autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', autoplaySpeed: 4000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] });","title":"In an iOS device with native app"},{"location":"demos/openvidu-call-react/","text":"openvidu-call-react Check it on GitHub OpenVidu Call demo, built with React , allows users to make videoconference calls with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application. OpenVidu-Call-React is composed by the five React components displayed in the image below. VideoRoom Component This is the main component of OpenVidu-Call-React . It allows you to establish a connection with your video roommates. This component allows the user to mute the microphone, unpublish the webcam, share the screen, open the chat and leave the session. Chat Component This component provides to Video-room Component a chatting system, integrated with the layout, that allows users to type to each other. Stream Component With OpenVidu Layout, this component is the responsible of displaying the video stream of each user in a nice way. On the right, we can see four streams displayed in the same videoconference. Running this demo Cloning GitHub Repository 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-call-react.git 2) You will need node, NPM and to execute the app. You can install them with: sudo apt-get update sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs 3) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 4) Install NPM dependencies of Angular app: cd openvidu-call-react/openvidu-call-react npm install 5) Launch the server: npm start If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-call-react"},{"location":"demos/openvidu-call-react/#openvidu-call-react","text":"Check it on GitHub OpenVidu Call demo, built with React , allows users to make videoconference calls with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application. OpenVidu-Call-React is composed by the five React components displayed in the image below. VideoRoom Component This is the main component of OpenVidu-Call-React . It allows you to establish a connection with your video roommates. This component allows the user to mute the microphone, unpublish the webcam, share the screen, open the chat and leave the session. Chat Component This component provides to Video-room Component a chatting system, integrated with the layout, that allows users to type to each other. Stream Component With OpenVidu Layout, this component is the responsible of displaying the video stream of each user in a nice way. On the right, we can see four streams displayed in the same videoconference.","title":"openvidu-call-react"},{"location":"demos/openvidu-call-react/#running-this-demo","text":"","title":"Running this demo"},{"location":"demos/openvidu-call-react/#cloning-github-repository","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-call-react.git 2) You will need node, NPM and to execute the app. You can install them with: sudo apt-get update sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs 3) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 4) Install NPM dependencies of Angular app: cd openvidu-call-react/openvidu-call-react npm install 5) Launch the server: npm start If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Cloning GitHub Repository"},{"location":"demos/openvidu-call/","text":"openvidu-call Check it on GitHub OpenVidu Call demo, built with Angular 8 , allows users to make videoconference calls with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application. OpenVidu-Call is composed by the six Angular components displayed in the image below. Login Component This component allows you to set the videocall name and login in that session. That session name can be shared with whomever the user wants to join the videoconference. Video-room Component This is the main component of OpenVidu-Call . It allows you to set up the session before join to the room. You will can check and set your microphone and your webcam device, create your own avatar or to choose the default avatar and to establish the nickname. Chat Component This component provides to Video-room Component a chatting system that allows users to type to each other. Stream Component With OpenVidu Layout, this component is the responsible of displaying the video stream of each user in a nice way. On the right, we can see four streams displayed in the same videoconference. Running this demo You have several options to run OpenVidu Call: Using Docker The easiest way is running this Docker container (you will need Docker CE ): docker run -p 4443:4443 openvidu/openvidu-call Cloning GitHub Repository 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-call.git 2) You will need node, NPM and angular-cli to execute the app. You can install them with: sudo apt-get update sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g @angular/cli 3) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 4) Install NPM dependencies of Angular app: cd openvidu-call/front/openvidu-call npm install 5) Launch the server: ng serve --open If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Using the Release Here are OpenVidu Call releases. The openvidu-call-X.X.X.tar.gz file contains the compiled app served in / and openvidu-call-demos-X.X.X.tar.gz file contains the compiled app served in /openvidu-call/ . To run OpenVidu Call with the compiled files you will need: 1) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 2) Download the release: wget https://github.com/OpenVidu/openvidu-call/releases/download/v2.8.0/openvidu-call-demos-2.8.0.tar.gz 3) Decompress the downloaded file: mkdir openvidu-call tar -xvzf openvidu-call-2.8.0.tar.gz -C openvidu-call/ cd openvidu-call 4) You will need a HTTP server to display the app like NGINX or http-server . We will use http-server : You will need node and NPM to install http-server. You can install them with: sudo apt-get update sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs Install http-server : npm i http-server 5) Serve the app: http-server Wait until you see on the output a line IP address. By default, the app will be served in localhost:8080 address. You will need go to https://localhost:4443/ to accept the self-signed certificate. Once accepted, you will be able to test OpenVidu Call in the default IP localhost:8080 Extra features Using the OpenVidu Call release, you can set up the address where your app will be served with http-server -a \"your_address\" . Moreover, by including a JSON file named ov-settings.json in the root directory, you can configure the openvidu_url and openvidu_secret ; { \"openviduCredentials\": { \"openvidu_url\": \"https://0.0.0.0:4443\", \"openvidu_secret\": \"MY_SECRET\" } } Not only you can establish your own openvidu_url and openvidu_secret parameters, but also you can customize the session interface adding an extra JSON object named openviduSettings inside of the file. You have explained how openviduSettings object must be treated in detail here . $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-call"},{"location":"demos/openvidu-call/#openvidu-call","text":"Check it on GitHub OpenVidu Call demo, built with Angular 8 , allows users to make videoconference calls with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application. OpenVidu-Call is composed by the six Angular components displayed in the image below. Login Component This component allows you to set the videocall name and login in that session. That session name can be shared with whomever the user wants to join the videoconference. Video-room Component This is the main component of OpenVidu-Call . It allows you to set up the session before join to the room. You will can check and set your microphone and your webcam device, create your own avatar or to choose the default avatar and to establish the nickname. Chat Component This component provides to Video-room Component a chatting system that allows users to type to each other. Stream Component With OpenVidu Layout, this component is the responsible of displaying the video stream of each user in a nice way. On the right, we can see four streams displayed in the same videoconference.","title":"openvidu-call"},{"location":"demos/openvidu-call/#running-this-demo","text":"You have several options to run OpenVidu Call:","title":"Running this demo"},{"location":"demos/openvidu-call/#using-docker","text":"The easiest way is running this Docker container (you will need Docker CE ): docker run -p 4443:4443 openvidu/openvidu-call","title":"Using Docker"},{"location":"demos/openvidu-call/#cloning-github-repository","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-call.git 2) You will need node, NPM and angular-cli to execute the app. You can install them with: sudo apt-get update sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g @angular/cli 3) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 4) Install NPM dependencies of Angular app: cd openvidu-call/front/openvidu-call npm install 5) Launch the server: ng serve --open If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Cloning GitHub Repository"},{"location":"demos/openvidu-call/#using-the-release","text":"Here are OpenVidu Call releases. The openvidu-call-X.X.X.tar.gz file contains the compiled app served in / and openvidu-call-demos-X.X.X.tar.gz file contains the compiled app served in /openvidu-call/ . To run OpenVidu Call with the compiled files you will need: 1) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 2) Download the release: wget https://github.com/OpenVidu/openvidu-call/releases/download/v2.8.0/openvidu-call-demos-2.8.0.tar.gz 3) Decompress the downloaded file: mkdir openvidu-call tar -xvzf openvidu-call-2.8.0.tar.gz -C openvidu-call/ cd openvidu-call 4) You will need a HTTP server to display the app like NGINX or http-server . We will use http-server : You will need node and NPM to install http-server. You can install them with: sudo apt-get update sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs Install http-server : npm i http-server 5) Serve the app: http-server Wait until you see on the output a line IP address. By default, the app will be served in localhost:8080 address. You will need go to https://localhost:4443/ to accept the self-signed certificate. Once accepted, you will be able to test OpenVidu Call in the default IP localhost:8080","title":"Using the Release"},{"location":"demos/openvidu-call/#extra-features","text":"Using the OpenVidu Call release, you can set up the address where your app will be served with http-server -a \"your_address\" . Moreover, by including a JSON file named ov-settings.json in the root directory, you can configure the openvidu_url and openvidu_secret ; { \"openviduCredentials\": { \"openvidu_url\": \"https://0.0.0.0:4443\", \"openvidu_secret\": \"MY_SECRET\" } } Not only you can establish your own openvidu_url and openvidu_secret parameters, but also you can customize the session interface adding an extra JSON object named openviduSettings inside of the file. You have explained how openviduSettings object must be treated in detail here . $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Extra features"},{"location":"demos/openvidu-classroom/","text":"openvidu-classroom Check it on GitHub This is a fully functional application that makes use of the secure version of OpenVidu to connect teachers and students in video sessions. It has a frontend built with Angular 7 , a backend built with Spring Boot and a MySQL database. There are two types of roles: teachers and students. First ones can create/edit/remove lessons and invite students to them. Only when a teacher initialize a lesson authorized students can connect to it. Running this demo 1) Clone the repo: git clone https://github.com/OpenVidu/classroom-demo.git 2) You will need node, NPM and angular-cli to execute the app. You can install them with: sudo apt-get update sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g @angular/cli 3) This demo needs a MySQL database to store the info. Install MySQL: sudo apt-get install -y mysql-server sudo mysql_secure_installation And create a new database: mysql -u root -p (Enter the same password you set during the installation process) CREATE DATABASE openvidu_sample_app; exit 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Install NPM dependencies of frontend: cd classroom-demo/src/angular/frontend npm install 6) Build the frontend, exporting the files to the static folder of the Java application: ng build --output-path ../../main/resources/static 7) Finally run the Spring Boot application: cd ../../../ mvn clean package exec:java Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. Without going into greater detail, the backend has one controller for the REST operations of the lessons (create new ones or edit/remove existing ones) and one controller for handling the videoconferences. This controller is pretty similar to the one described in any of the secure tutorials. Basically it listens to the operations of creating a new session (returning a sessionId from openvidu-server ), generating a new user token (returning the token from openvidu-server ) and removing the users when they leave the session. $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-classroom"},{"location":"demos/openvidu-classroom/#openvidu-classroom","text":"Check it on GitHub This is a fully functional application that makes use of the secure version of OpenVidu to connect teachers and students in video sessions. It has a frontend built with Angular 7 , a backend built with Spring Boot and a MySQL database. There are two types of roles: teachers and students. First ones can create/edit/remove lessons and invite students to them. Only when a teacher initialize a lesson authorized students can connect to it.","title":"openvidu-classroom"},{"location":"demos/openvidu-classroom/#running-this-demo","text":"1) Clone the repo: git clone https://github.com/OpenVidu/classroom-demo.git 2) You will need node, NPM and angular-cli to execute the app. You can install them with: sudo apt-get update sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g @angular/cli 3) This demo needs a MySQL database to store the info. Install MySQL: sudo apt-get install -y mysql-server sudo mysql_secure_installation And create a new database: mysql -u root -p (Enter the same password you set during the installation process) CREATE DATABASE openvidu_sample_app; exit 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Install NPM dependencies of frontend: cd classroom-demo/src/angular/frontend npm install 6) Build the frontend, exporting the files to the static folder of the Java application: ng build --output-path ../../main/resources/static 7) Finally run the Spring Boot application: cd ../../../ mvn clean package exec:java Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. Without going into greater detail, the backend has one controller for the REST operations of the lessons (create new ones or edit/remove existing ones) and one controller for handling the videoconferences. This controller is pretty similar to the one described in any of the secure tutorials. Basically it listens to the operations of creating a new session (returning a sessionId from openvidu-server ), generating a new user token (returning the token from openvidu-server ) and removing the users when they leave the session. $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Running this demo"},{"location":"demos/openvidu-getaroom/","text":"openvidu-getaroom Check it on GitHub OpenVidu-Getaroom demo, built with Vanilla JS, allows users to connect to a room and share the link with others, so they can connect to it straight away just by visiting that link. It is a frontend-only application and it makes use of OpenVidu the same way openvidu-insecure-js does. OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flows transmission Running this demo 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need an http web server installed in your development computer to execute the sample application. If you have node.js installed, you can use http-server to serve application files. It can be installed with: npm install -g http-server 3) Run the tutorial: http-server openvidu-tutorials/openvidu-getaroom/web 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8080 {:target=\" blank\"} to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of _openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This application is very simple. It has only 4 files: openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . You can manipulate this file to suit your needs. index.html : HTML code for the welcome page to join a new room and for the room itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js.js\"></script> <script src=\"app.js\"></script> style.css : some CSS classes to style index.html . You can manipulate this file to suit your needs. index.html uses also Bootstrap as its main style framework. Down below we will describe the most important code snippets in app.js : Declaration of variables We will need some variables accesible from differents methods var OV; // OpenVidu object to initialize a session var session; // Session object where the user will connect var publisher; // Publisher object which the user will publish var sessionId; // Unique identifier of the session var audioEnabled = true; // True if the audio track of publisher is active var videoEnabled = true; // True if the video track of publisher is active var numOfVideos = 0; // Keeps track of the number of videos that are being shown Window callbacks On load we will check if the user is connecting to an existing room or to a new one depending on the browser's location, on beforeunload we will disconnect the user from the room // Check if the URL already has a room window.addEventListener('load', function () { sessionId = window.location.hash.slice(1); // For 'https://myurl/#roomId', sessionId would be 'roomId' if (sessionId) { // The URL has a session id. Join the room right away console.log(\"Joining to room \" + sessionId); showSessionHideJoin(); joinRoom(); } else { // The URL has not a session id. Show welcome page showJoinHideSession(); } }); // Disconnect participant on browser's window closed window.addEventListener('beforeunload', function () { if (session) session.disconnect(); }); joinRoom method Here we initialize our session and set the events we need for the desired behaviuor. Then we connect to it and finally publish our own webcam to the session. function joinRoom() { if (!sessionId) { // If the user is joining to a new room sessionId = randomString(); } // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', function (event) { // Subscribe to the Stream to receive it. HTML video will be appended to element with 'subscriber' id var subscriber = session.subscribe(event.stream, 'videos'); // When the new video is added to DOM, update the page layout to fit one more participant subscriber.on('videoElementCreated', function (event) { numOfVideos++; updateLayout(); }); }); // On every new Stream destroyed... session.on('streamDestroyed', function (event) { // Update the page layout numOfVideos--; updateLayout(); }); // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend getToken(sessionId).then(token => { // Connect with the token session.connect(token) .then(() => { // --- 5) Set page layout for active call --- // Update the URL shown in the browser's navigation bar to show the session id var path = (location.pathname.slice(-1) == \"/\" ? location.pathname : location.pathname + \"/\"); window.history.pushState(\"\", \"\", path + '#' + sessionId); // Auxiliary methods to show the session's view showSessionHideJoin(); initializeSessionView(); // --- 6) Get your own camera stream with the desired properties --- publisher = OV.initPublisher('publisher', { audioSource: undefined, // The source of audio. If undefined default audio input videoSource: undefined, // The source of video. If undefined default video input publishAudio: true, // Whether to start publishing with your audio unmuted or not publishVideo: true, // Whether to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in target element 'video-container' mirror: true // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', function (event) { // When your own video is added to DOM, update the page layout to fit it numOfVideos++; updateLayout(); $(event.element).prop('muted', true); // Mute local video to avoid feedback }); // --- 8) Publish your stream --- session.publish(publisher); }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); } leaveRoom method function leaveRoom() { // --- 9) Leave the session by calling 'disconnect' method over the Session object --- session.disconnect(); // Back to welcome page window.location.href = window.location.origin + window.location.pathname; } $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-getaroom"},{"location":"demos/openvidu-getaroom/#openvidu-getaroom","text":"Check it on GitHub OpenVidu-Getaroom demo, built with Vanilla JS, allows users to connect to a room and share the link with others, so they can connect to it straight away just by visiting that link. It is a frontend-only application and it makes use of OpenVidu the same way openvidu-insecure-js does. OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flows transmission","title":"openvidu-getaroom"},{"location":"demos/openvidu-getaroom/#running-this-demo","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need an http web server installed in your development computer to execute the sample application. If you have node.js installed, you can use http-server to serve application files. It can be installed with: npm install -g http-server 3) Run the tutorial: http-server openvidu-tutorials/openvidu-getaroom/web 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8080 {:target=\" blank\"} to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of _openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this demo"},{"location":"demos/openvidu-getaroom/#understanding-the-code","text":"This application is very simple. It has only 4 files: openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . You can manipulate this file to suit your needs. index.html : HTML code for the welcome page to join a new room and for the room itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js.js\"></script> <script src=\"app.js\"></script> style.css : some CSS classes to style index.html . You can manipulate this file to suit your needs. index.html uses also Bootstrap as its main style framework. Down below we will describe the most important code snippets in app.js :","title":"Understanding the code"},{"location":"demos/openvidu-getaroom/#declaration-of-variables","text":"We will need some variables accesible from differents methods var OV; // OpenVidu object to initialize a session var session; // Session object where the user will connect var publisher; // Publisher object which the user will publish var sessionId; // Unique identifier of the session var audioEnabled = true; // True if the audio track of publisher is active var videoEnabled = true; // True if the video track of publisher is active var numOfVideos = 0; // Keeps track of the number of videos that are being shown","title":"Declaration of variables"},{"location":"demos/openvidu-getaroom/#window-callbacks","text":"On load we will check if the user is connecting to an existing room or to a new one depending on the browser's location, on beforeunload we will disconnect the user from the room // Check if the URL already has a room window.addEventListener('load', function () { sessionId = window.location.hash.slice(1); // For 'https://myurl/#roomId', sessionId would be 'roomId' if (sessionId) { // The URL has a session id. Join the room right away console.log(\"Joining to room \" + sessionId); showSessionHideJoin(); joinRoom(); } else { // The URL has not a session id. Show welcome page showJoinHideSession(); } }); // Disconnect participant on browser's window closed window.addEventListener('beforeunload', function () { if (session) session.disconnect(); });","title":"Window callbacks"},{"location":"demos/openvidu-getaroom/#joinroom-method","text":"Here we initialize our session and set the events we need for the desired behaviuor. Then we connect to it and finally publish our own webcam to the session. function joinRoom() { if (!sessionId) { // If the user is joining to a new room sessionId = randomString(); } // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', function (event) { // Subscribe to the Stream to receive it. HTML video will be appended to element with 'subscriber' id var subscriber = session.subscribe(event.stream, 'videos'); // When the new video is added to DOM, update the page layout to fit one more participant subscriber.on('videoElementCreated', function (event) { numOfVideos++; updateLayout(); }); }); // On every new Stream destroyed... session.on('streamDestroyed', function (event) { // Update the page layout numOfVideos--; updateLayout(); }); // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend getToken(sessionId).then(token => { // Connect with the token session.connect(token) .then(() => { // --- 5) Set page layout for active call --- // Update the URL shown in the browser's navigation bar to show the session id var path = (location.pathname.slice(-1) == \"/\" ? location.pathname : location.pathname + \"/\"); window.history.pushState(\"\", \"\", path + '#' + sessionId); // Auxiliary methods to show the session's view showSessionHideJoin(); initializeSessionView(); // --- 6) Get your own camera stream with the desired properties --- publisher = OV.initPublisher('publisher', { audioSource: undefined, // The source of audio. If undefined default audio input videoSource: undefined, // The source of video. If undefined default video input publishAudio: true, // Whether to start publishing with your audio unmuted or not publishVideo: true, // Whether to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in target element 'video-container' mirror: true // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', function (event) { // When your own video is added to DOM, update the page layout to fit it numOfVideos++; updateLayout(); $(event.element).prop('muted', true); // Mute local video to avoid feedback }); // --- 8) Publish your stream --- session.publish(publisher); }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); }","title":"joinRoom method"},{"location":"demos/openvidu-getaroom/#leaveroom-method","text":"function leaveRoom() { // --- 9) Leave the session by calling 'disconnect' method over the Session object --- session.disconnect(); // Back to welcome page window.location.href = window.location.origin + window.location.pathname; } $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"leaveRoom method"},{"location":"deployment/deploying-app/","text":"Deploying your OpenVidu application Adding your own app to OpenVidu AWS deployment In order to show how an application that makes use of OpenVidu might be deployed, here you have a guide to do so in AWS after launching it with CloudFormation OpenVidu . Once you have checked that your AWS OpenVidu Server is up and running, adding your own application to the same instance is not hard. Follow these steps: 1. Upload your app to your EC2 instance In Linux/Mac you can use scp command. In Windows (or If you prefer a more friendly GUI) you can use FileZilla . Furthermore, if your app is stored in a GitHub repo, you can directly clone it once you connect to your instance. Remember that the key will be the same you indicated when configuring the CloudFormation fields . 2. Connect to your EC2 instance through SSH Remember that the key will be the same you indicated when configuring the CloudFormation fields . In case of doubt, check AWS docs . 3. Configure your app Depending on the framework of your app: Plain HTML/CSS/JS If your app doesn't have a server-side and it is plain HTML, CSS and JavaScript, you just have to add your web files into /var/www/html/ . You will have instant access to it through https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/ If you want to test the deployment of a plain HTML/CSS/JS app, you can use openvidu-insecure-js Java Copy your JAR or WAR into /opt/ Write a script to launch your app with all the parameters it needs, and store it under /opt/ . For example, a file /opt/YOUR_LAUNCHER.sh containing: cd /opt java -jar -Dserver.port=4040 myapp.jar IMPORTANT 1 : It is crucial to navigate to /opt before the launching command. Otherwise, the system will surely have some problems for finding your files IMPORTANT 2 : Obviously your app will need Java to run. You must install the correct version of Java in your machine (check version: java -version ) IMPORTANT 3 : Make sure the script you made is executable ( chmod +x YOUR_LAUNCHER.sh ) Configure Nginx: add a new location directive to the file /etc/nginx/sites-enabled/default , inside the server { } group: location / { rewrite /(.*) /$1 break; proxy_pass https://localhost:PORT; } For example location / { rewrite /(.*) /$1 break; proxy_pass https://localhost:4040; } Configure Supervisor: add the script you wrote in the second step to the file /etc/supervisor/conf.d/openvidu.conf like this: [program:YOUR_APP] command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ... redirect_stderr=true Now your /etc/supervisor/conf.d/openvidu.conf must look like this: [supervisord] nodaemon=true logfile=/var/log/supervisor/supervisord.log pidfile=/var/run/supervisord.pid loglevel=debug [program:openvidu-server] command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$ [program:YOUR_APP] command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ... redirect_stderr=true To connect your Java app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the REST API or openvidu-java-client ) , you will need to use the URL https://localhost:4443 . localhost because in this case both your app and OpenVidu Server run in the same machine. 4443 because there's where OpenVidu Server listens for petitions. For example, our tutorial openvidu-js-java sets this parameter as an environment variable right here Restart Nginx: systemctl restart nginx Restart Supervisor: systemctl restart supervisor You will have access to your app through https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/ Troubleshooting: If your app is not working as expected, there are a few files you should check for debugging: /var/log/nginx/ (info about the proxy), /var/log/supervisor/ (output of your app). You can also try to connect to your app directly through the port like https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT If you want to test the deployment of a Java app, you can use openvidu-js-java or openvidu-mvc-java ( release here ) Node Add your web files into /opt/ Write a script to launch your app with all the parameters it needs, and store it under /opt/ . For example, a file /opt/YOUR_LAUNCHER.sh containing: cd /opt node myserver.js 4040 IMPORTANT 1 : It is crucial to navigate to /opt before the launching command. Otherwise, the system will surely have some problems for finding your files IMPORTANT 2 : Obviously your app will need Node to run. You must install the correct version of Node in your machine (check version: nodejs -v ) IMPORTANT 3 : Make sure the script you made is executable ( chmod +x YOUR_LAUNCHER.sh ) Configure Nginx: add a new location directive to the file /etc/nginx/sites-enabled/default , inside the server { } group:: location / { rewrite /(.*) /$1 break; proxy_pass https://localhost:PORT; } For example location / { rewrite /(.*) /$1 break; proxy_pass https://localhost:4040; } Restart Nginx: systemctl restart nginx Configure Supervisor: add the script you wrote in the second step to /etc/supervisor/conf.d/openvidu.conf like this: [program:YOUR_APP] command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ... redirect_stderr=true Now your /etc/supervisor/conf.d/openvidu.conf must look like this: [supervisord] nodaemon=true logfile=/var/log/supervisor/supervisord.log pidfile=/var/run/supervisord.pid loglevel=debug [program:openvidu-server] command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$ [program:YOUR_APP] command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ... redirect_stderr=true To connect your Node app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the REST API or openvidu-node-client ), you will need to use the URL https://localhost:4443 . localhost because in this case both your app and OpenVidu Server run in the same machine. 4443 because there's where OpenVidu Server listens for petitions. For example, our tutorial openvidu-js-node expects this parameter as the first argument on launch command right here Restart Supervisor: systemctl restart supervisor You will have access to your app through https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/ Troubleshooting: If your app is not working as expected, there are a few files you should check for debugging: /var/log/nginx/ (info about the proxy), /var/log/supervisor/ (output of your app). You can also try to connect to your app directly through the port like https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT If you want to test the deployment of a Node app, you can use openvidu-js-node PHP, Ruby, Python, .NET... We are not going to spell out in detail what is to be done with the rest of backend technologies, but you can get the idea from the Java and Node steps above. It is always the same process: take your app to your instance, place it under /opt/ , configure Nginx and Supervisor (this last with the necessary launching script depending on your technology) and relaunch both services. Be sure that your machine has all the necessary dependencies and technologies to execute your application, depending on the framework (Java for a Java app, Node for a Node app, Ruby for a Ruby app...) Voil\u00e0! It is really this simple. PS: Multiple apps in the same instance To launch multiple apps in the same instance, just store each one of them inside its own folder under /opt/ . For example: /opt/YOUR_APP_1 : will be available at https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_1/ /opt/YOUR_APP_2 : will be available at https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_2/ The other steps explained above also need some adjustments related to paths: Configure Nginx: now it would be... location /YOUR_APP_1 { rewrite /YOUR_APP_1(.*) /$1 break; proxy_pass https://localhost:PORT1; } location /YOUR_APP_2 { rewrite /YOUR_APP_2(.*) /$1 break; proxy_pass https://localhost:PORT2; } Configure Supervisor: now... [program:YOUR_APP_1] command=/bin/bash /opt/YOUR_APP_1/YOUR_LAUNCHER_1.sh YOUR_APP1_PARAM_1 YOUR_APP1_PARAM_2 ... redirect_stderr=true [program:YOUR_APP_2] command=/bin/bash /opt/YOUR_APP_2/YOUR_LAUNCHER_2.sh YOUR_APP2_PARAM_1 YOUR_APP2_PARAM_2 ... redirect_stderr=true Connecting your external app to OpenVidu The best production setup for OpenVidu is having your application deployed in a different dedicated server. That is, not being included in the same host as OpenVidu, which is the scenario explained in the previous section (that all-in-one scenario is easier for the first approach to the deployment of your OpenVidu app. Try it if you want detailed instructions on how to deploy your app). Once you have deployed OpenVidu and checked that it is up and running, and after setting up your own application in its dedicated server: Make sure you know your OpenVidu Server public IP . That includes the protocol ( https ), the location and the port. For example: https://OPENVIDUSERVER_PUBLIC_IP:4443/ . Or if you have set up a domain name you can use it instead of the public ip (this is highly recommended for production setups) Use it in your application server to perform the REST operations, or to initialize your OpenVidu object if you are making use of openvdiu-java-client or openvidu-node-client : REST operations to https://OPENVIDUSERVER_PUBLIC_IP:4443/api/METHOD openvidu-java-client entrypoint is new OpenVidu(https://OPENVIDUSERVER_PUBLIC_IP:4443/, OPENVIDU_SECRET) openvidu-node-client entrypoint is new OpenVidu(https://OPENVIDUSERVER_PUBLIC_IP:4443/, OPENVIDU_SECRET) In the one-server-scenario of the previous section the OpenVidu Server public IP would be https://localhost:4443 , as both OpenVidu Server and your app live in the same host.","title":"Deploying your OpenVidu app"},{"location":"deployment/deploying-app/#adding-your-own-app-to-openvidu-aws-deployment","text":"In order to show how an application that makes use of OpenVidu might be deployed, here you have a guide to do so in AWS after launching it with CloudFormation OpenVidu . Once you have checked that your AWS OpenVidu Server is up and running, adding your own application to the same instance is not hard. Follow these steps:","title":"Adding your own app to OpenVidu AWS deployment"},{"location":"deployment/deploying-app/#1-upload-your-app-to-your-ec2-instance","text":"In Linux/Mac you can use scp command. In Windows (or If you prefer a more friendly GUI) you can use FileZilla . Furthermore, if your app is stored in a GitHub repo, you can directly clone it once you connect to your instance. Remember that the key will be the same you indicated when configuring the CloudFormation fields .","title":"1. Upload your app to your EC2 instance"},{"location":"deployment/deploying-app/#2-connect-to-your-ec2-instance-through-ssh","text":"Remember that the key will be the same you indicated when configuring the CloudFormation fields . In case of doubt, check AWS docs .","title":"2. Connect to your EC2 instance through SSH"},{"location":"deployment/deploying-app/#3-configure-your-app","text":"Depending on the framework of your app:","title":"3. Configure your app"},{"location":"deployment/deploying-app/#plain-htmlcssjs","text":"If your app doesn't have a server-side and it is plain HTML, CSS and JavaScript, you just have to add your web files into /var/www/html/ . You will have instant access to it through https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/ If you want to test the deployment of a plain HTML/CSS/JS app, you can use openvidu-insecure-js","title":"Plain HTML/CSS/JS"},{"location":"deployment/deploying-app/#java","text":"Copy your JAR or WAR into /opt/ Write a script to launch your app with all the parameters it needs, and store it under /opt/ . For example, a file /opt/YOUR_LAUNCHER.sh containing: cd /opt java -jar -Dserver.port=4040 myapp.jar IMPORTANT 1 : It is crucial to navigate to /opt before the launching command. Otherwise, the system will surely have some problems for finding your files IMPORTANT 2 : Obviously your app will need Java to run. You must install the correct version of Java in your machine (check version: java -version ) IMPORTANT 3 : Make sure the script you made is executable ( chmod +x YOUR_LAUNCHER.sh ) Configure Nginx: add a new location directive to the file /etc/nginx/sites-enabled/default , inside the server { } group: location / { rewrite /(.*) /$1 break; proxy_pass https://localhost:PORT; } For example location / { rewrite /(.*) /$1 break; proxy_pass https://localhost:4040; } Configure Supervisor: add the script you wrote in the second step to the file /etc/supervisor/conf.d/openvidu.conf like this: [program:YOUR_APP] command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ... redirect_stderr=true Now your /etc/supervisor/conf.d/openvidu.conf must look like this: [supervisord] nodaemon=true logfile=/var/log/supervisor/supervisord.log pidfile=/var/run/supervisord.pid loglevel=debug [program:openvidu-server] command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$ [program:YOUR_APP] command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ... redirect_stderr=true To connect your Java app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the REST API or openvidu-java-client ) , you will need to use the URL https://localhost:4443 . localhost because in this case both your app and OpenVidu Server run in the same machine. 4443 because there's where OpenVidu Server listens for petitions. For example, our tutorial openvidu-js-java sets this parameter as an environment variable right here Restart Nginx: systemctl restart nginx Restart Supervisor: systemctl restart supervisor You will have access to your app through https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/ Troubleshooting: If your app is not working as expected, there are a few files you should check for debugging: /var/log/nginx/ (info about the proxy), /var/log/supervisor/ (output of your app). You can also try to connect to your app directly through the port like https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT If you want to test the deployment of a Java app, you can use openvidu-js-java or openvidu-mvc-java ( release here )","title":"Java"},{"location":"deployment/deploying-app/#node","text":"Add your web files into /opt/ Write a script to launch your app with all the parameters it needs, and store it under /opt/ . For example, a file /opt/YOUR_LAUNCHER.sh containing: cd /opt node myserver.js 4040 IMPORTANT 1 : It is crucial to navigate to /opt before the launching command. Otherwise, the system will surely have some problems for finding your files IMPORTANT 2 : Obviously your app will need Node to run. You must install the correct version of Node in your machine (check version: nodejs -v ) IMPORTANT 3 : Make sure the script you made is executable ( chmod +x YOUR_LAUNCHER.sh ) Configure Nginx: add a new location directive to the file /etc/nginx/sites-enabled/default , inside the server { } group:: location / { rewrite /(.*) /$1 break; proxy_pass https://localhost:PORT; } For example location / { rewrite /(.*) /$1 break; proxy_pass https://localhost:4040; } Restart Nginx: systemctl restart nginx Configure Supervisor: add the script you wrote in the second step to /etc/supervisor/conf.d/openvidu.conf like this: [program:YOUR_APP] command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ... redirect_stderr=true Now your /etc/supervisor/conf.d/openvidu.conf must look like this: [supervisord] nodaemon=true logfile=/var/log/supervisor/supervisord.log pidfile=/var/run/supervisord.pid loglevel=debug [program:openvidu-server] command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$ [program:YOUR_APP] command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ... redirect_stderr=true To connect your Node app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the REST API or openvidu-node-client ), you will need to use the URL https://localhost:4443 . localhost because in this case both your app and OpenVidu Server run in the same machine. 4443 because there's where OpenVidu Server listens for petitions. For example, our tutorial openvidu-js-node expects this parameter as the first argument on launch command right here Restart Supervisor: systemctl restart supervisor You will have access to your app through https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/ Troubleshooting: If your app is not working as expected, there are a few files you should check for debugging: /var/log/nginx/ (info about the proxy), /var/log/supervisor/ (output of your app). You can also try to connect to your app directly through the port like https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT If you want to test the deployment of a Node app, you can use openvidu-js-node","title":"Node"},{"location":"deployment/deploying-app/#php-ruby-python-net","text":"We are not going to spell out in detail what is to be done with the rest of backend technologies, but you can get the idea from the Java and Node steps above. It is always the same process: take your app to your instance, place it under /opt/ , configure Nginx and Supervisor (this last with the necessary launching script depending on your technology) and relaunch both services. Be sure that your machine has all the necessary dependencies and technologies to execute your application, depending on the framework (Java for a Java app, Node for a Node app, Ruby for a Ruby app...) Voil\u00e0! It is really this simple.","title":"PHP, Ruby, Python, .NET..."},{"location":"deployment/deploying-app/#ps-multiple-apps-in-the-same-instance","text":"To launch multiple apps in the same instance, just store each one of them inside its own folder under /opt/ . For example: /opt/YOUR_APP_1 : will be available at https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_1/ /opt/YOUR_APP_2 : will be available at https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_2/ The other steps explained above also need some adjustments related to paths: Configure Nginx: now it would be... location /YOUR_APP_1 { rewrite /YOUR_APP_1(.*) /$1 break; proxy_pass https://localhost:PORT1; } location /YOUR_APP_2 { rewrite /YOUR_APP_2(.*) /$1 break; proxy_pass https://localhost:PORT2; } Configure Supervisor: now... [program:YOUR_APP_1] command=/bin/bash /opt/YOUR_APP_1/YOUR_LAUNCHER_1.sh YOUR_APP1_PARAM_1 YOUR_APP1_PARAM_2 ... redirect_stderr=true [program:YOUR_APP_2] command=/bin/bash /opt/YOUR_APP_2/YOUR_LAUNCHER_2.sh YOUR_APP2_PARAM_1 YOUR_APP2_PARAM_2 ... redirect_stderr=true","title":"PS: Multiple apps in the same instance"},{"location":"deployment/deploying-app/#connecting-your-external-app-to-openvidu","text":"The best production setup for OpenVidu is having your application deployed in a different dedicated server. That is, not being included in the same host as OpenVidu, which is the scenario explained in the previous section (that all-in-one scenario is easier for the first approach to the deployment of your OpenVidu app. Try it if you want detailed instructions on how to deploy your app). Once you have deployed OpenVidu and checked that it is up and running, and after setting up your own application in its dedicated server: Make sure you know your OpenVidu Server public IP . That includes the protocol ( https ), the location and the port. For example: https://OPENVIDUSERVER_PUBLIC_IP:4443/ . Or if you have set up a domain name you can use it instead of the public ip (this is highly recommended for production setups) Use it in your application server to perform the REST operations, or to initialize your OpenVidu object if you are making use of openvdiu-java-client or openvidu-node-client : REST operations to https://OPENVIDUSERVER_PUBLIC_IP:4443/api/METHOD openvidu-java-client entrypoint is new OpenVidu(https://OPENVIDUSERVER_PUBLIC_IP:4443/, OPENVIDU_SECRET) openvidu-node-client entrypoint is new OpenVidu(https://OPENVIDUSERVER_PUBLIC_IP:4443/, OPENVIDU_SECRET) In the one-server-scenario of the previous section the OpenVidu Server public IP would be https://localhost:4443 , as both OpenVidu Server and your app live in the same host.","title":"Connecting your external app to OpenVidu"},{"location":"deployment/deploying-aws/","text":"Deploying OpenVidu on AWS The deployment of OpenVidu can be a piece of cake if you have an AWS account. Just follow these steps: 1. Access to the console of AWS Cloud Formation Go to CloudFormation 2. Select Create Stack \ud83e\udc1a With new resources 3. Option Specify template \ud83e\udc1a Amazon S3 URL with the following URL https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-latest.yaml Copy 4. Specify stack details First of all, indicate a name for your deployment. Next fill each section of the Parameters formulary: SSL certificate configuration Configuration for your CloudFormation stack certificate. We provide 3 different scenarios: you can use the default SELF-SIGNED CERTIFICATE stored in the application (users will need to accept the browser security alert) or if you have a custom domain, either allow LET'S ENCRYPT to automatically generate a valid and free certificate for your domain or use your own CUSTOM CERTIFICATE if you already have one. Self-Signed certificate Let's Encrypt certificate Custom certificate Choose the certificate selfsigned letsencrypt owncert Email for Let's Encrypt certification authority Your choice My domain name Your fully qualified domain For example: if your full URL is https://openvidu.io/ then this is openvidu.io Your fully qualified domain For example: if your full URL is https://openvidu.io/ then this is openvidu.io Public elastic IP (EIP) One AWS Elastic IP you generated (check AWS Docs to generate a new one) One AWS Elastic IP you generated (check AWS Docs to generate a new one) URL to the CRT file URL to your public key file The CloudFormation stack must have access to this URL, at least temporarily URL to the key file URL to your private key file The CloudFormation stack must have access to this URL, at least temporarily If you are using LET'S ENCRYPT CERTIFICATE , of course you will need to register your ElasticIP in your DNS hosting service and associate it with the fully qualified domain name. Until your domain name is not accessible through the public IP you chose, this deployment won't work OpenVidu configuration All of these properties configure OpenVidu Server. You have a complete description of all available properties here . Other configuration These properties configure specific details of the CloudFormation stack. Instance type Type of EC2 Instance where to deploy OpenVidu Choose from the drop-down button Key name SSH key for your EC2 Instance Choose from the drop-down button (check AWS Docs to create a new one) Ubuntu version Version of Ubuntu where to deploy OpenVidu Choose from the drop-down button Deploy Demos Choose if you want to deploy OpenVidu demo applications. If true, then parameter openvidu.secret must be MY_SECRET for the demos to work out-of-the-box Choose from the drop-down button Do you want to send info to OpenVidu? True if don't mind sending OpenVidu team some anonymous info about your deployment (AWS zone and date) Choose from the drop-down button OpenVidu version WARNING: this parameter must only be modified when upgrading an existing stack. See Upgrading OpenVidu Default value if not upgrading an existing stack (see Upgrading OpenVidu ) 5. Create your stack No extra options are necessary. Click on Next \u279e Next \u279e Create stack CREATE_IN_PROGRESS status will show up. You will now have to wait for a few minutes (about 10) until it shows CREATE_COMPLETE . If status reaches CREATE_FAILED , check out this FAQ . After status changes to CREATE_COMPLETE , go to Outputs tab to get your brand new IP and click on it (or if you have deployed under your own custom domain, then you should access through it instead). That URL will give you access to your OpenVidu dashboard. Credentials to access to it: OPENVIDUAPP as username The secret you chose on Step 4 as password (parameter openvidu.secret ) At OpenVidu dashboard you can test the video transmission. You can now add your own application to your instance. To learn how check out section Deploying your OpenVidu app .","title":"Deploying OpenVidu on AWS"},{"location":"deployment/deploying-aws/#1-access-to-the-console-of-aws-cloud-formation","text":"Go to CloudFormation","title":"1. Access to the console of AWS Cloud Formation"},{"location":"deployment/deploying-aws/#2-select-create-stack-with-new-resources","text":"","title":"2. Select Create Stack \ud83e\udc1a With new resources"},{"location":"deployment/deploying-aws/#3-option-specify-template-amazon-s3-url-with-the-following-url","text":"https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-latest.yaml Copy","title":"3. Option Specify template \ud83e\udc1a Amazon S3 URL with the following URL"},{"location":"deployment/deploying-aws/#4-specify-stack-details","text":"First of all, indicate a name for your deployment. Next fill each section of the Parameters formulary:","title":"4. Specify stack details"},{"location":"deployment/deploying-aws/#ssl-certificate-configuration","text":"Configuration for your CloudFormation stack certificate. We provide 3 different scenarios: you can use the default SELF-SIGNED CERTIFICATE stored in the application (users will need to accept the browser security alert) or if you have a custom domain, either allow LET'S ENCRYPT to automatically generate a valid and free certificate for your domain or use your own CUSTOM CERTIFICATE if you already have one. Self-Signed certificate Let's Encrypt certificate Custom certificate Choose the certificate selfsigned letsencrypt owncert Email for Let's Encrypt certification authority Your choice My domain name Your fully qualified domain For example: if your full URL is https://openvidu.io/ then this is openvidu.io Your fully qualified domain For example: if your full URL is https://openvidu.io/ then this is openvidu.io Public elastic IP (EIP) One AWS Elastic IP you generated (check AWS Docs to generate a new one) One AWS Elastic IP you generated (check AWS Docs to generate a new one) URL to the CRT file URL to your public key file The CloudFormation stack must have access to this URL, at least temporarily URL to the key file URL to your private key file The CloudFormation stack must have access to this URL, at least temporarily If you are using LET'S ENCRYPT CERTIFICATE , of course you will need to register your ElasticIP in your DNS hosting service and associate it with the fully qualified domain name. Until your domain name is not accessible through the public IP you chose, this deployment won't work","title":"SSL certificate configuration"},{"location":"deployment/deploying-aws/#openvidu-configuration","text":"All of these properties configure OpenVidu Server. You have a complete description of all available properties here .","title":"OpenVidu configuration"},{"location":"deployment/deploying-aws/#other-configuration","text":"These properties configure specific details of the CloudFormation stack. Instance type Type of EC2 Instance where to deploy OpenVidu Choose from the drop-down button Key name SSH key for your EC2 Instance Choose from the drop-down button (check AWS Docs to create a new one) Ubuntu version Version of Ubuntu where to deploy OpenVidu Choose from the drop-down button Deploy Demos Choose if you want to deploy OpenVidu demo applications. If true, then parameter openvidu.secret must be MY_SECRET for the demos to work out-of-the-box Choose from the drop-down button Do you want to send info to OpenVidu? True if don't mind sending OpenVidu team some anonymous info about your deployment (AWS zone and date) Choose from the drop-down button OpenVidu version WARNING: this parameter must only be modified when upgrading an existing stack. See Upgrading OpenVidu Default value if not upgrading an existing stack (see Upgrading OpenVidu )","title":"Other configuration"},{"location":"deployment/deploying-aws/#5-create-your-stack","text":"No extra options are necessary. Click on Next \u279e Next \u279e Create stack CREATE_IN_PROGRESS status will show up. You will now have to wait for a few minutes (about 10) until it shows CREATE_COMPLETE . If status reaches CREATE_FAILED , check out this FAQ . After status changes to CREATE_COMPLETE , go to Outputs tab to get your brand new IP and click on it (or if you have deployed under your own custom domain, then you should access through it instead). That URL will give you access to your OpenVidu dashboard. Credentials to access to it: OPENVIDUAPP as username The secret you chose on Step 4 as password (parameter openvidu.secret ) At OpenVidu dashboard you can test the video transmission. You can now add your own application to your instance. To learn how check out section Deploying your OpenVidu app .","title":"5. Create your stack"},{"location":"deployment/deploying-ubuntu/","text":"Deploying OpenVidu on Ubuntu Installation process Ubuntu Xenial 16.04 and Ubuntu Bionic 18.04 are supported (see Ubuntu Bionic limitations ). 1. Install KMS Ubuntu Xenial 16.04 sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.13.0 xenial kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y install kurento-media-server Ubuntu Bionic 18.04 sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.13.0 bionic kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y install kurento-media-server After installing KMS, it is necessary to change the default user running it to the current one with this line: sudo sed -i \"s/DAEMON_USER=\\\"kurento\\\"/DAEMON_USER=\\\"${USER}\\\"/g\" /etc/default/kurento-media-server 2. Install COTURN sudo apt-get -y install coturn This is a great implementation of a STUN/TURN server, necessary for connecting your users under some complicated circumstances. You can check its documentation here . 3. Install Redis sudo apt-get -y install redis-server 4. File /etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini externalAddress=YOUR_MACHINE_PUBLIC_IP You can also add optional parameter networkInterfaces to optimize and speed up the negotiation process. It is a comma-separated list with the network interfaces that OpenVidu should only try when negotiating media connections. For example: externalAddress=YOUR_MACHINE_PUBLIC_IP networkInterfaces=eth0,enp0s25 5. File /etc/turnserver.conf external-ip=YOUR_MACHINE_PUBLIC_IP listening-port=3478 fingerprint lt-cred-mech max-port=65535 min-port=40000 pidfile=\"/var/run/turnserver.pid\" realm=openvidu simple-log redis-userdb=\"ip=127.0.0.1 dbname=0 password=turn connect_timeout=30\" verbose 6. File /etc/default/coturn TURNSERVER_ENABLED=1 7. Init services sudo service redis-server restart sudo service coturn restart sudo service kurento-media-server restart 8. Init Openvidu Server JAR executable java -jar -Dopenvidu.secret=MY_SECRET -Dopenvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:4443/ openvidu-server-{VERSION}.jar Being MY_SECRET the password you want for securing your OpenVidu Server. This will be needed for connecting to OpenVidu Server dashboard and for consuming OpenVidu Server REST API. Keep it safe! 1) You will need Java 8 to run OpenVidu Server: sudo apt-get install -y openjdk-8-jre 2) You can get any version of OpenVidu Server with the command below. To ensure compatibility comply with version numbers listed in releases page wget https://github.com/OpenVidu/openvidu/releases/download/v{VERSION}/openvidu-server-{VERSION}.jar 3) If you want to enable recording module of OpenVidu Server to record your sessions, you must install Docker CE and add some more system properties to the java -jar command. Check out Recording section to learn more Go to Using your own certificate to add your certificate to the JAR instead of using the self-signed default one (which will launch a security warning on the user's browser). 9. Finally check your server You can connect to OpenVidu dashboard through https://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:4443 (authorization is OPENVIDUAPP:MY_SECRET ). Make sure you allow TCP and UDP inbound connections to your machine! To connect your application to OpenVidu Server, use the same URL https://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:4443 . To learn more, check out Connecting your app to OpenVidu . Server network requirements In order for this deployment to work, you will have to meet 2 sets of needs in the machine hosting your services: First of all, you certainly need the machine to have a public, reachable IP . The reason is pretty simple: we are precisely installing COTURN service to cover those situations where the final users are hidden behind NATs or complex networks ( learn more ). If the COTURN itself is running inside an unreachable machine, your video transmission will probably fail. And also make sure the server bandwidth is significant, as each media connection can potentially consume up to several MBs. Besides, the server needs some ports opened in the firewall: 4443 TCP ( OpenVidu Server listens on port 4443 by default) 3478 UDP and TCP ( COTURN listens on port 3478 by default) 40000 - 65535 UDP and TCP (WebRTC will randomly exchange media through any of these ports. TCP might be used if client network blocks UDP connections) If you were still in trouble, we provide a ready-to-use Amazon CloudFormation Stack to easily deploy OpenVidu in just a few minutes here . Using your own certificate OpenVidu Server is a Java application and therefore needs a Java keystore ( .jks ) for providing security certificates. If you don't have it, you can easily obtain a .jks file from your certificate and private key files ( .crt and .key respectively, or maybe both of them being .pem ). You do so by using openssl and keytool : # Export certificate in p12 format (password will be asked) # YOUR_CRT.crt and YOUR_KEY.key files may be YOUR_CRT.pem and YOUR_KEY.pem files instead openssl pkcs12 -export -name YOUR_KEYSTORE_ALIAS -in YOUR_CRT.crt -inkey YOUR_PRIVATE_KEY.key -out p12keystore.p12 # Generate jks (password will be asked again) keytool -importkeystore -srckeystore p12keystore.p12 -srcstoretype pkcs12 -deststoretype pkcs12 -alias YOUR_KEYSTORE_ALIAS -destkeystore YOUR_KEYSTORE_NAME.jks In order to use your JKS, just give the proper value to the following OpenVidu Server properties on launch: server.ssl.key-store =/PATH/TO/YOUR_KEYSTORE_NAME.jks server.ssl.key-store-password =value_provided_when_generating_jks server.ssl.key-alias =YOUR_KEYSTORE_ALIAS Example java -jar -Dopenvidu.secret=MY_SECRET -Dserver.ssl.key-store=/opt/openvidu/my_keystore.jks -Dserver.ssl.key-store-password=MY_KEYSTORE_SECRET -Dserver.ssl.key-alias=my_cert_alias openvidu-server-2.5.0.jar Remember we provide a super simple way of using a FREE , AUTOMATIC and 100% VALID certificate thanks to Let's Encrypt technology: when deploying your CloudFormation Stack, just fill in the form fields with the values from the column LET'S ENCRYPT CERTIFICATE Ubuntu Bionic limitations OpenVidu supports Ubuntu Xenial 16.04 and Ubuntu Bionic 18.04 . OpenCV filters will not work in Bionic. All filters will work fine in Xenial. Regarding filters explained in Voice and video filters section, this will affect FaceOverlayFilter and ChromaFilter . In fact, no built-in module explained in Kurento Docs will work in Ubuntu Bionic ( PointerDetectorFilter , CrowdDetectorFilter , PlateDetectorFIlter ). ZBarFilter and GStreamer filters work fine in Ubuntu Bionic.","title":"Deploying OpenVidu on Ubuntu"},{"location":"deployment/deploying-ubuntu/#installation-process","text":"Ubuntu Xenial 16.04 and Ubuntu Bionic 18.04 are supported (see Ubuntu Bionic limitations ).","title":"Installation process"},{"location":"deployment/deploying-ubuntu/#1-install-kms","text":"Ubuntu Xenial 16.04 sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.13.0 xenial kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y install kurento-media-server Ubuntu Bionic 18.04 sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.13.0 bionic kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y install kurento-media-server After installing KMS, it is necessary to change the default user running it to the current one with this line: sudo sed -i \"s/DAEMON_USER=\\\"kurento\\\"/DAEMON_USER=\\\"${USER}\\\"/g\" /etc/default/kurento-media-server","title":"1. Install KMS"},{"location":"deployment/deploying-ubuntu/#2-install-coturn","text":"sudo apt-get -y install coturn This is a great implementation of a STUN/TURN server, necessary for connecting your users under some complicated circumstances. You can check its documentation here .","title":"2. Install COTURN"},{"location":"deployment/deploying-ubuntu/#3-install-redis","text":"sudo apt-get -y install redis-server","title":"3. Install Redis"},{"location":"deployment/deploying-ubuntu/#4-file-etckurentomoduleskurentowebrtcendpointconfini","text":"externalAddress=YOUR_MACHINE_PUBLIC_IP You can also add optional parameter networkInterfaces to optimize and speed up the negotiation process. It is a comma-separated list with the network interfaces that OpenVidu should only try when negotiating media connections. For example: externalAddress=YOUR_MACHINE_PUBLIC_IP networkInterfaces=eth0,enp0s25","title":"4. File /etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini"},{"location":"deployment/deploying-ubuntu/#5-file-etcturnserverconf","text":"external-ip=YOUR_MACHINE_PUBLIC_IP listening-port=3478 fingerprint lt-cred-mech max-port=65535 min-port=40000 pidfile=\"/var/run/turnserver.pid\" realm=openvidu simple-log redis-userdb=\"ip=127.0.0.1 dbname=0 password=turn connect_timeout=30\" verbose","title":"5. File /etc/turnserver.conf"},{"location":"deployment/deploying-ubuntu/#6-file-etcdefaultcoturn","text":"TURNSERVER_ENABLED=1","title":"6. File /etc/default/coturn"},{"location":"deployment/deploying-ubuntu/#7-init-services","text":"sudo service redis-server restart sudo service coturn restart sudo service kurento-media-server restart","title":"7. Init services"},{"location":"deployment/deploying-ubuntu/#8-init-openvidu-server-jar-executable","text":"java -jar -Dopenvidu.secret=MY_SECRET -Dopenvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:4443/ openvidu-server-{VERSION}.jar Being MY_SECRET the password you want for securing your OpenVidu Server. This will be needed for connecting to OpenVidu Server dashboard and for consuming OpenVidu Server REST API. Keep it safe! 1) You will need Java 8 to run OpenVidu Server: sudo apt-get install -y openjdk-8-jre 2) You can get any version of OpenVidu Server with the command below. To ensure compatibility comply with version numbers listed in releases page wget https://github.com/OpenVidu/openvidu/releases/download/v{VERSION}/openvidu-server-{VERSION}.jar 3) If you want to enable recording module of OpenVidu Server to record your sessions, you must install Docker CE and add some more system properties to the java -jar command. Check out Recording section to learn more Go to Using your own certificate to add your certificate to the JAR instead of using the self-signed default one (which will launch a security warning on the user's browser).","title":"8. Init Openvidu Server JAR executable"},{"location":"deployment/deploying-ubuntu/#9-finally-check-your-server","text":"You can connect to OpenVidu dashboard through https://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:4443 (authorization is OPENVIDUAPP:MY_SECRET ). Make sure you allow TCP and UDP inbound connections to your machine! To connect your application to OpenVidu Server, use the same URL https://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:4443 . To learn more, check out Connecting your app to OpenVidu .","title":"9. Finally check your server"},{"location":"deployment/deploying-ubuntu/#server-network-requirements","text":"In order for this deployment to work, you will have to meet 2 sets of needs in the machine hosting your services: First of all, you certainly need the machine to have a public, reachable IP . The reason is pretty simple: we are precisely installing COTURN service to cover those situations where the final users are hidden behind NATs or complex networks ( learn more ). If the COTURN itself is running inside an unreachable machine, your video transmission will probably fail. And also make sure the server bandwidth is significant, as each media connection can potentially consume up to several MBs. Besides, the server needs some ports opened in the firewall: 4443 TCP ( OpenVidu Server listens on port 4443 by default) 3478 UDP and TCP ( COTURN listens on port 3478 by default) 40000 - 65535 UDP and TCP (WebRTC will randomly exchange media through any of these ports. TCP might be used if client network blocks UDP connections) If you were still in trouble, we provide a ready-to-use Amazon CloudFormation Stack to easily deploy OpenVidu in just a few minutes here .","title":"Server network requirements"},{"location":"deployment/deploying-ubuntu/#using-your-own-certificate","text":"OpenVidu Server is a Java application and therefore needs a Java keystore ( .jks ) for providing security certificates. If you don't have it, you can easily obtain a .jks file from your certificate and private key files ( .crt and .key respectively, or maybe both of them being .pem ). You do so by using openssl and keytool : # Export certificate in p12 format (password will be asked) # YOUR_CRT.crt and YOUR_KEY.key files may be YOUR_CRT.pem and YOUR_KEY.pem files instead openssl pkcs12 -export -name YOUR_KEYSTORE_ALIAS -in YOUR_CRT.crt -inkey YOUR_PRIVATE_KEY.key -out p12keystore.p12 # Generate jks (password will be asked again) keytool -importkeystore -srckeystore p12keystore.p12 -srcstoretype pkcs12 -deststoretype pkcs12 -alias YOUR_KEYSTORE_ALIAS -destkeystore YOUR_KEYSTORE_NAME.jks In order to use your JKS, just give the proper value to the following OpenVidu Server properties on launch: server.ssl.key-store =/PATH/TO/YOUR_KEYSTORE_NAME.jks server.ssl.key-store-password =value_provided_when_generating_jks server.ssl.key-alias =YOUR_KEYSTORE_ALIAS","title":"Using your own certificate"},{"location":"deployment/deploying-ubuntu/#example","text":"java -jar -Dopenvidu.secret=MY_SECRET -Dserver.ssl.key-store=/opt/openvidu/my_keystore.jks -Dserver.ssl.key-store-password=MY_KEYSTORE_SECRET -Dserver.ssl.key-alias=my_cert_alias openvidu-server-2.5.0.jar Remember we provide a super simple way of using a FREE , AUTOMATIC and 100% VALID certificate thanks to Let's Encrypt technology: when deploying your CloudFormation Stack, just fill in the form fields with the values from the column LET'S ENCRYPT CERTIFICATE","title":"Example"},{"location":"deployment/deploying-ubuntu/#ubuntu-bionic-limitations","text":"OpenVidu supports Ubuntu Xenial 16.04 and Ubuntu Bionic 18.04 . OpenCV filters will not work in Bionic. All filters will work fine in Xenial. Regarding filters explained in Voice and video filters section, this will affect FaceOverlayFilter and ChromaFilter . In fact, no built-in module explained in Kurento Docs will work in Ubuntu Bionic ( PointerDetectorFilter , CrowdDetectorFilter , PlateDetectorFIlter ). ZBarFilter and GStreamer filters work fine in Ubuntu Bionic.","title":"Ubuntu Bionic limitations"},{"location":"deployment/upgrading/","text":"Upgrading OpenVidu These instructions are only compatible for OpenVidu >= 2.6.0 Upgrading or downgrading OpenVidu by following these steps may cause your application to fail if there are any API breaking changes between the old and new versions of OpenVidu. Carefully read the release notes of the related versions before upgrading OpenVidu, be sure to try your application with the new OpenVidu version in your development environment before upgrading and always do so at your own risk For AWS deployments The upgrading process is 100% automatic. Just navigate to AWS CloudFormation dashboard and follow below steps: 1) Select your CloudFormation stack and click on Update button 2) Select Use current template and click on Next 3) Change field OpenVidu version inside \"Other configuration\" section and at the bottom of the page click on Next \ud83e\udc46 Next \ud83e\udc46 Update stack After performing the steps above, you will be redirect to Events page, where you will see a new UPDATE_IN_PROGRESS status. Wait until UPDATE_COMPLETE and your new version of OpenVidu will be ready. Remember to update openvidu-browser library in your clients. Comply version compatibility according to Releases page For Ubuntu deployments You must perform the following general steps, that may vary depending on how you have configured your services: 1) Stop OpenVidu Server and Kurento Media Server services First one is a Java process that may be killed with a simple kill -9 PID_NUMBER command, and second one is usually stopped with sudo service kurento-media-server stop 2) Upgrade kurento-media-server package and replace openvidu-server JAR file for the new version It is mandatory to comply version compatibility between OpenVidu and Kurento Media Server. Check it out in Releases page. You should be able to reinstall a new version of KMS while maintaining all the configuration files with these commands: For Ubuntu Xenial 16.04 (do not run below command if you run this one) export DISTRO=xenial For Ubuntu Bionic 18.04 (do not run above command if you run this one) export DISTRO=bionic Now you can reinstall Kurento Media Server indicating the proper version number in the first command # Change version number in url http://ubuntu.openvidu.io/6.9.0 to the proper one depending on OpenVidu version sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 $DISTRO kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-get update sudo apt-get remove --auto-remove --yes kurento-media-server sudo apt-get install --yes -o Dpkg::Options::=\"--force-confold\" kurento-media-server You can download any openvidu-server JAR file with this command: # Change {VERSION} for the desired one. e.g. /v2.8.0/openvidu-server-2.8.0.jar wget https://github.com/OpenVidu/openvidu/releases/download/v{VERSION}/openvidu-server-{VERSION}.jar 3) Restart OpenVidu Server and Kurento Media Server services Run Kurento Media Server with sudo service kurento-media-server start and launch openvidu-server JAR file as stated in Deploying OpenVidu in Ubuntu section. Remember to update openvidu-browser library in your clients. Comply version compatibility according to Releases page $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.slick-captions').slick({ asNavFor: '.upgrade-cf-steps', arrows: false, infinite: false, speed: 200, fade: true, dots: false }); $('.upgrade-cf-steps').slick({ asNavFor: '.slick-captions', autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', infinite: false, dots: true, responsive: [ { breakpoint: 768, settings: { arrows: true, slidesToShow: 1 } }, ] });","title":"Upgrading OpenVidu"},{"location":"deployment/upgrading/#for-aws-deployments","text":"The upgrading process is 100% automatic. Just navigate to AWS CloudFormation dashboard and follow below steps: 1) Select your CloudFormation stack and click on Update button 2) Select Use current template and click on Next 3) Change field OpenVidu version inside \"Other configuration\" section and at the bottom of the page click on Next \ud83e\udc46 Next \ud83e\udc46 Update stack After performing the steps above, you will be redirect to Events page, where you will see a new UPDATE_IN_PROGRESS status. Wait until UPDATE_COMPLETE and your new version of OpenVidu will be ready. Remember to update openvidu-browser library in your clients. Comply version compatibility according to Releases page","title":"For AWS deployments"},{"location":"deployment/upgrading/#for-ubuntu-deployments","text":"You must perform the following general steps, that may vary depending on how you have configured your services:","title":"For Ubuntu deployments"},{"location":"deployment/upgrading/#1-stop-openvidu-server-and-kurento-media-server-services","text":"First one is a Java process that may be killed with a simple kill -9 PID_NUMBER command, and second one is usually stopped with sudo service kurento-media-server stop","title":"1) Stop OpenVidu Server and Kurento Media Server services"},{"location":"deployment/upgrading/#2-upgrade-kurento-media-server-package-and-replace-openvidu-server-jar-file-for-the-new-version","text":"It is mandatory to comply version compatibility between OpenVidu and Kurento Media Server. Check it out in Releases page. You should be able to reinstall a new version of KMS while maintaining all the configuration files with these commands: For Ubuntu Xenial 16.04 (do not run below command if you run this one) export DISTRO=xenial For Ubuntu Bionic 18.04 (do not run above command if you run this one) export DISTRO=bionic Now you can reinstall Kurento Media Server indicating the proper version number in the first command # Change version number in url http://ubuntu.openvidu.io/6.9.0 to the proper one depending on OpenVidu version sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 $DISTRO kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-get update sudo apt-get remove --auto-remove --yes kurento-media-server sudo apt-get install --yes -o Dpkg::Options::=\"--force-confold\" kurento-media-server You can download any openvidu-server JAR file with this command: # Change {VERSION} for the desired one. e.g. /v2.8.0/openvidu-server-2.8.0.jar wget https://github.com/OpenVidu/openvidu/releases/download/v{VERSION}/openvidu-server-{VERSION}.jar","title":"2) Upgrade kurento-media-server package and replace openvidu-server JAR file for the new version"},{"location":"deployment/upgrading/#3-restart-openvidu-server-and-kurento-media-server-services","text":"Run Kurento Media Server with sudo service kurento-media-server start and launch openvidu-server JAR file as stated in Deploying OpenVidu in Ubuntu section. Remember to update openvidu-browser library in your clients. Comply version compatibility according to Releases page $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.slick-captions').slick({ asNavFor: '.upgrade-cf-steps', arrows: false, infinite: false, speed: 200, fade: true, dots: false }); $('.upgrade-cf-steps').slick({ asNavFor: '.slick-captions', autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', infinite: false, dots: true, responsive: [ { breakpoint: 768, settings: { arrows: true, slidesToShow: 1 } }, ] });","title":"3) Restart OpenVidu Server and Kurento Media Server services"},{"location":"developing/","text":"Developing OpenVidu Prerequisites Compiling OpenVidu Server Compiling OpenVidu Server dashboard Compiling OpenVidu Browser Running KMS Example: setup for development Example: setup for advanced development Prerequisites Dependency Check version Install Java 8 JDK java -version sudo apt-get install -y openjdk-8-jdk Maven mvn -v sudo apt-get install -y maven Node node -v sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs Compiling OpenVidu Server 1) Clone OpenVidu parent repository and install local dependencies. This is only necessary the first time you compile openvidu-server git clone https://github.com/OpenVidu/openvidu.git cd openvidu mvn -DskipTests=true clean install 2) Build openvidu-server cd openvidu-server mvn clean compile package Compiling OpenVidu Server dashboard 1) You need Angular to compile OpenVidu Server dashboard: sudo npm install -g @angular/cli 2) Enter the Angular project and install NPM dependencies. This is only necessary the first time you compile openvidu-server dashboard cd openvidu/openvidu-server/src/dashboard npm install 3) Build the project. This npm command will copy the output files into the static files folder of openvidu-server. Next time you compile openvidu-server it will serve this last compilation of the dashboard. npm run build # For production compilation: npm run build-prod Compiling OpenVidu Browser 1) Clone OpenVidu parent repository and install openvidu-browser dependencies git clone https://github.com/OpenVidu/openvidu.git cd openvidu/openvidu-browser npm install 2) Build openvidu-browser npm run build 3) To install openvidu-browser as local NPM dependency sudo npm link # You can link this local dependency to any project that has openvidu-browser as # dependency in its package.json, by calling \"sudo npm link openvidu-browser\" 4) To obtain static JavaScript files VERSION=2.0.0 npm run browserify # Regular JS version VERSION=2.0.0 npm run browserify-prod # Minified JS version # Static files will be built in path ./static/js/ Running KMS How to install and run KMS in your development machine ( Ubuntu 16.04 or Ubuntu 18.04 ) Ubuntu Xenial 16.04 sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.13.0 xenial kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y install kurento-media-server Ubuntu Bionic 18.04 sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.13.0 bionic kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y install kurento-media-server Change the default user running KMS to your current user with this line: sudo sed -i \"s/DAEMON_USER=\\\"kurento\\\"/DAEMON_USER=\\\"${USER}\\\"/g\" /etc/default/kurento-media-server To start and stop KMS service: sudo service kurento-media-server start sudo service kurento-media-server stop Running with Docker You can also run Kurento on any OS that supports Docker with the following command: docker run -d --name kms -p 8888:8888 kurento/kurento-media-server:latest Here you can check Kurento's official documentation. Example: setup for development Here we show how to develop an Angular app ( openvidu-testapp ) with openvidu-browser and openvidu-server as local dependencies, waiting to be modified as you want. You can install Angular with sudo npm install -g @angular/cli . 1) Run Kurento Media Server 2) Clone repo: git clone https://github.com/OpenVidu/openvidu.git 3) openvidu/openvidu-browser/ npm install npm run build sudo npm link 4) openvidu/ mvn -DskipTests=true install 5) openvidu/openvidu-testapp/ npm install npm link openvidu-browser ng serve 6) openvidu/openvidu-server/ mvn exec:java (or if you prefer you can just run the Java application in your favourite IDE) At these point, you can start modifying openvidu-testapp , openvidu-browser or openvidu-server . openvidu-testapp : the \"ng serve\" command will take care of refreshing the browser's page whenever any change takes place openvidu-browser : after modifying any typescript file, you will need to run the following command to update your changes: /openvidu/openvidu-browser : npm run build openvidu-server : after modifying any file, there is no other alternative but to re-launch the java application if you want to update your changes /openvidu/openvidu-server : mvn clean exec:java (or re-launch the Java application in your IDE. Some IDE's support automatic re-launch in response to changes) Example: setup for advanced development (share the app through your network) You can also use different machines in the same network to build a more advanced development environment, so you can test the application in different devices at the same time. It's very similar to the process outlined above: Run exactly the same commands as in the previous section, but: On step 5) extend ng serve command with: ng serve --host 0.0.0.0 --ssl true On step 6) extend mvn exec:java command with: mvn -Dopenvidu.publicurl=https://HOST_LOCAL_IP:4443/ exec:java # Being HOST_LOCAL_IP the local IP that your machine serving the app has in your LAN network This way we first tell AngularCLI to serve our app through https and to expose the port in our LAN network, and secondly we set OpenVidu Server public url to the public IP of the machine in our LAN network. This way our devices will be able to reach it as long as they are connected to the same network. To connect to the application from any device, be sure to be connected to the same LAN network and navigate to https://HOST_LOCAL_IP:4200 (being HOST_LOCAL_IP the local IP that your machine serving the app has in your LAN network).","title":"Developing OpenVidu"},{"location":"developing/#prerequisites","text":"Dependency Check version Install Java 8 JDK java -version sudo apt-get install -y openjdk-8-jdk Maven mvn -v sudo apt-get install -y maven Node node -v sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs","title":"Prerequisites"},{"location":"developing/#compiling-openvidu-server","text":"1) Clone OpenVidu parent repository and install local dependencies. This is only necessary the first time you compile openvidu-server git clone https://github.com/OpenVidu/openvidu.git cd openvidu mvn -DskipTests=true clean install 2) Build openvidu-server cd openvidu-server mvn clean compile package","title":"Compiling OpenVidu Server"},{"location":"developing/#compiling-openvidu-server-dashboard","text":"1) You need Angular to compile OpenVidu Server dashboard: sudo npm install -g @angular/cli 2) Enter the Angular project and install NPM dependencies. This is only necessary the first time you compile openvidu-server dashboard cd openvidu/openvidu-server/src/dashboard npm install 3) Build the project. This npm command will copy the output files into the static files folder of openvidu-server. Next time you compile openvidu-server it will serve this last compilation of the dashboard. npm run build # For production compilation: npm run build-prod","title":"Compiling OpenVidu Server dashboard"},{"location":"developing/#compiling-openvidu-browser","text":"1) Clone OpenVidu parent repository and install openvidu-browser dependencies git clone https://github.com/OpenVidu/openvidu.git cd openvidu/openvidu-browser npm install 2) Build openvidu-browser npm run build 3) To install openvidu-browser as local NPM dependency sudo npm link # You can link this local dependency to any project that has openvidu-browser as # dependency in its package.json, by calling \"sudo npm link openvidu-browser\" 4) To obtain static JavaScript files VERSION=2.0.0 npm run browserify # Regular JS version VERSION=2.0.0 npm run browserify-prod # Minified JS version # Static files will be built in path ./static/js/","title":"Compiling OpenVidu Browser"},{"location":"developing/#running-kms","text":"How to install and run KMS in your development machine ( Ubuntu 16.04 or Ubuntu 18.04 ) Ubuntu Xenial 16.04 sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.13.0 xenial kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y install kurento-media-server Ubuntu Bionic 18.04 sudo echo \"deb [arch=amd64] http://ubuntu.openvidu.io/6.13.0 bionic kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y install kurento-media-server Change the default user running KMS to your current user with this line: sudo sed -i \"s/DAEMON_USER=\\\"kurento\\\"/DAEMON_USER=\\\"${USER}\\\"/g\" /etc/default/kurento-media-server To start and stop KMS service: sudo service kurento-media-server start sudo service kurento-media-server stop Running with Docker You can also run Kurento on any OS that supports Docker with the following command: docker run -d --name kms -p 8888:8888 kurento/kurento-media-server:latest Here you can check Kurento's official documentation.","title":"Running KMS"},{"location":"developing/#example-setup-for-development","text":"Here we show how to develop an Angular app ( openvidu-testapp ) with openvidu-browser and openvidu-server as local dependencies, waiting to be modified as you want. You can install Angular with sudo npm install -g @angular/cli . 1) Run Kurento Media Server 2) Clone repo: git clone https://github.com/OpenVidu/openvidu.git 3) openvidu/openvidu-browser/ npm install npm run build sudo npm link 4) openvidu/ mvn -DskipTests=true install 5) openvidu/openvidu-testapp/ npm install npm link openvidu-browser ng serve 6) openvidu/openvidu-server/ mvn exec:java (or if you prefer you can just run the Java application in your favourite IDE) At these point, you can start modifying openvidu-testapp , openvidu-browser or openvidu-server . openvidu-testapp : the \"ng serve\" command will take care of refreshing the browser's page whenever any change takes place openvidu-browser : after modifying any typescript file, you will need to run the following command to update your changes: /openvidu/openvidu-browser : npm run build openvidu-server : after modifying any file, there is no other alternative but to re-launch the java application if you want to update your changes /openvidu/openvidu-server : mvn clean exec:java (or re-launch the Java application in your IDE. Some IDE's support automatic re-launch in response to changes)","title":"Example: setup for development"},{"location":"developing/#example-setup-for-advanced-development-share-the-app-through-your-network","text":"You can also use different machines in the same network to build a more advanced development environment, so you can test the application in different devices at the same time. It's very similar to the process outlined above: Run exactly the same commands as in the previous section, but: On step 5) extend ng serve command with: ng serve --host 0.0.0.0 --ssl true On step 6) extend mvn exec:java command with: mvn -Dopenvidu.publicurl=https://HOST_LOCAL_IP:4443/ exec:java # Being HOST_LOCAL_IP the local IP that your machine serving the app has in your LAN network This way we first tell AngularCLI to serve our app through https and to expose the port in our LAN network, and secondly we set OpenVidu Server public url to the public IP of the machine in our LAN network. This way our devices will be able to reach it as long as they are connected to the same network. To connect to the application from any device, be sure to be connected to the same LAN network and navigate to https://HOST_LOCAL_IP:4200 (being HOST_LOCAL_IP the local IP that your machine serving the app has in your LAN network).","title":"Example: setup for advanced development (share the app through your network)"},{"location":"developing/rpc/","text":"OpenVidu Server RPC protocol OpenVidu Server offers a WebSocket endpoint at path /openvidu where clients must connect to ... Call methods : clients are able to directly call OpenVidu Server methods. Some of them will only be available if the user has the proper role inside the session. Receive server events : OpenVidu Server will send session events to clients connected to that specific session. OpenVidu hides all this implementation with OpenVidu Browser JavaScript library, that can be used in all officially supported platforms . But of course it would be possible to develop an SDK implementing this WebSocket based RPC protocol using any desired language or technology. For example, openvidu-android tutorial is a native Android app, so it cannot make use of OpenVidu Browser JavaScript library. The solution to this problem: the application internally implements the OpenVidu Server RPC protocol. But to do so, it is necessary to be very clear about what operations-responses and what server events are defined in OpenVidu Server. Client-Server methods All operations send by the client side must be a JSON object with these properties jsonrpc : version of JSON-RPC protocol. Always \"2.0\" method : the name of the method params : a JSON object with the method parameters id : an integer to identify this operation call. Must be unique with respect to any other operation call All responses from OpenVidu Server to each one of these operations are a JSON object with these properties jsonrpc : version of JSON-RPC protocol. Always \"2.0\" id : an integer matching the id property of the operation call that generated this response. This allows pairing the operation call sent from the client with its respective server response result : a JSON object with the operation result. Its fields are obviously dependent on the method that generated this response. Not included if error property is defined error : a JSON object with information about an error triggered during the operation call. Not included if result property is defined. This JSON object has 2 properties: code : a number identifying the type of error message : a string with a detailed description about the error Complete list of operations: ping joinRoom publishVideo receiveVideoFrom onIceCandidate unpublishVideo unsubscribeFromVideo leaveRoom sendMessage forceUnpublish forceDisconnect applyFilter removeFilter execFilterMethod addFilterEventListener removeFilterEventListener reconnectStream ping Ping message for the ping-pong mechanism. This is necessary to make OpenVidu Server aware of a client connection, and to act accordingly if no ping is received in a certain interval time. params property is only necessary in the first call to this method. Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"ping\", \"params\": { \"interval\": 5000 // Not necessary after first call }, \"id\": 0 } Response from OpenVidu Server { \"id\": 0, \"result\":{ \"value\":\"pong\" }, \"jsonrpc\":\"2.0\" } joinRoom Join a client to an already initialized session. The equivalent method in OpenVidu Browser is Session#connect Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"joinRoom\", \"params\": { \"token\": \"wss://localhost:4443?sessionId=TestSession&token=rpjyfwrwckltdtk3&role=PUBLISHER&version=2.11.0\", \"session\": \"TestSession\", \"platform\": \"Chrome 76.0.3809.132 on Linux 64-bit\", \"metadata\": \"{clientData: TestClient}\", \"secret\": \"\", \"recorder\": false }, \"id\": 1 } Response from OpenVidu Server { \"id\": 1, \"result\": { \"id\": \"y4gsjcy37m1rcjkx\", \"createdAt\": 1568198320797, \"metadata\": \"{clientData: TestClient}\", \"value\": [ { \"id\": \"ydqsx1r7jp3zmduf\", \"createdAt\": 1568197954222, \"metadata\": \"{clientData: OtherClient}\", \"streams\": [ { \"id\": \"ydqsx1r7jp3zmduf_CAMERA_MLMZG\", \"createdAt\": 1568197956221, \"hasAudio\": true, \"hasVideo\": true, \"videoActive\": true, \"audioActive\": true, \"typeOfVideo\": \"CAMERA\", \"frameRate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"filter\": {} } ] } ], \"sessionId\": \"nqo83ml4kc2kgaoe65311n7in0\" }, \"jsonrpc\": \"2.0\" } publishVideo Start publishing a stream to the session. The equivalent method in OpenVidu Browser is Session#publish Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"publishVideo\", \"params\": { \"sdpOffer\": \"v=0 ... ssrc:1665235233 label:f320e350-b667-4765-87da-4ee4f595b9fe\\r\\n\", \"doLoopback\": false, \"hasAudio\": true, \"hasVideo\": true, \"audioActive\": true, \"videoActive\": true, \"typeOfVideo\": \"CAMERA\", \"frameRate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\" }, \"id\": 2 } Response from OpenVidu Server { \"id\": 2, \"result\": { \"sdpAnswer\": \"v=0 ... :EA:63:12:29:12:D6:4B:9A:63:F1:AB:D4:CC\\r\\n\", \"id\": \"nflyoomouisnvvas_CAMERA_DYVFP\", \"createdAt\": 1568193997244, \"sessionId\": \"lu7h4for17svik11aum6qqi9v1\" }, \"jsonrpc\": \"2.0\" } receiveVideoFrom Subscribe to a stream being published to the session. The equivalent method in OpenVidu Browser is Session#subscribe Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"receiveVideoFrom\", \"params\": { \"sender\": \"ydqsx1r7jp3zmduf_CAMERA_MLMZG\", \"sdpOffer\": \"v=0 ... a=rtpmap:123 ulpfec/90000\\r\\n\" }, \"id\": 3 } Response from OpenVidu Server { \"id\": 3, \"result\": { \"sdpAnswer\": \"v=0 ... :FD:66:54:68:B4:47:25:EF:B6:04:74:AF:7B:08:66:09:F2:7C\\r\\n\", \"sessionId\": \"ajcecubc3sdcki0f6fnsefrr0t\" }, \"jsonrpc\": \"2.0\" } onIceCandidate Send and ICE candidate to the server. Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"onIceCandidate\", \"params\": { \"endpointName\": \"nflyoomouisnvvas\", \"candidate\": \"candidate:3885250869 1 udp 2122260223 172.17.0.1 53467 typ host generation 0 ufrag 3KLI network-id 1 network-cost 50\", \"sdpMid\": \"0\", \"sdpMLineIndex\": 0 }, \"id\": 4 } Response from OpenVidu Server { \"id\": 4, \"result\": { \"sessionId\": \"lu7h4for17svik11aum6qqi9v1\" }, \"jsonrpc\": \"2.0\" } unpublishVideo Stop publishing a stream to the session. The equivalent method in OpenVidu Browser is Session#unpublish Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"unpublishVideo\", \"params\": {}, \"id\": 5 } Response from OpenVidu Server { \"id\": 5, \"result\": { \"sessionId\": \"822vl7sqllncvbivsoqt8q0nes\" }, \"jsonrpc\": \"2.0\" } unsubscribeFromVideo Stop the subscription from a stream to which the user is currently subscribed. The equivalent method in OpenVidu Browser is Session#unsubscribe Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"unsubscribeFromVideo\", \"params\": { \"sender\": \"ydqsx1r7jp3zmduf\" }, \"id\": 6 } Response from OpenVidu Server { \"id\": 6, \"result\": { \"sessionId\": \"ajcecubc3sdcki0f6fnsefrr0t\" }, \"jsonrpc\": \"2.0\" } leaveRoom Disconnect a client from a session. The equivalent method in OpenVidu Browser is Session#disconnect Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"leaveRoom\", \"params\": {}, \"id\": 7 } Response from OpenVidu Server { \"id\": 7, \"result\": { \"sessionId\": \"lu7h4for17svik11aum6qqi9v1\" }, \"jsonrpc\": \"2.0\" } sendMessage Send a signal to the session. The equivalent method in OpenVidu Browser is Session#signal Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"sendMessage\", \"params\": { \"message\": \"{\\\"to\\\":[],\\\"data\\\":\\\"Test message\\\",\\\"type\\\":\\\"signal:chat\\\"}\" }, \"id\": 8 } Response from OpenVidu Server { \"id\": 8, \"result\": { \"sessionId\": \"nqo83ml4kc2kgaoe65311n7in0\" }, \"jsonrpc\": \"2.0\" } forceUnpublish Force another client to unpublish its stream from the session. Only possible for clients with role MODERATOR inside the session. The equivalent method in OpenVidu Browser is Session#forceUnpublish Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"forceUnpublish\", \"params\": { \"streamId\": \"ydqsx1r7jp3zmduf_CAMERA_MLMZG\" }, \"id\": 9 } Response from OpenVidu Server { \"id\": 9, \"result\": { \"sessionId\": \"rh75l2dg35v9pqsrsbi5n09p72\" }, \"jsonrpc\": \"2.0\" } forceDisconnect Force another client to disconnect from the session. Only possible for clients with role MODERATOR inside the session. The equivalent method in OpenVidu Browser is Session#forceDisconnect Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"forceDisconnect\", \"params\": { \"connectionId\": \"4v8cftv2zylhkjvd\" }, \"id\": 10 } Response from OpenVidu Server { \"id\": 10, \"result\": { \"sessionId\": \"6f0djrngic4ed49ov0poesp3f4\" }, \"jsonrpc\": \"2.0\" } applyFilter Apply a filter to a published stream. The equivalent method in OpenVidu Browser is Stream#applyFilter Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"applyFilter\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"type\": \"GStreamerFilter\", \"options\": \"{\\\"command\\\":\\\"videobalance saturation=0.0\\\"}\" }, \"id\": 11 } Response from OpenVidu Server { \"id\": 11, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" } removeFilter Removed an applied filter from a stream. The equivalent method in OpenVidu Browser is Stream#removeFilter Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"removeFilter\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\" }, \"id\": 12 } Response from OpenVidu Server { \"id\": 12, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" } execFilterMethod Execute a method offered by an applied filter. The equivalent method in OpenVidu Browser is Filter#execMethod Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"execFilterMethod\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"method\": \"setElementProperty\", \"params\": \"{\\\"propertyName\\\":\\\"saturation\\\",\\\"propertyValue\\\":\\\"1.0\\\"}\" }, \"id\": 13 } Response from OpenVidu Server { \"id\": 12, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" } addFilterEventListener Add a listener to an applied filter. The equivalent method in OpenVidu Browser is Filter#addEventListener Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"addFilterEventListener\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"eventType\": \"CodeFound\" }, \"id\": 14 } Response from OpenVidu Server { \"id\": 14, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" } removeFilterEventListener Remove a listener from an applied filter. The equivalent method in OpenVidu Browser is Filter#removeEventListener Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"removeFilterEventListener\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"eventType\": \"CodeFound\" }, \"id\": 15 } Response from OpenVidu Server { \"id\": 15, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" } reconnectStream (>= 2.12.0) Silently re-negotiates an already established stream. This is useful for reconnecting a frozen stream, which may happen when a client loses and recovers its network connection with OpenVidu Server, but the media plane is broken. This method will recreate a new RTC peer connection in a silent manner (without triggering any events in the clients) using the properties of the previous one. Required params are the stream identifier to reconnect and the new SDP offer generated by the client (which must have created a new RTC peer connection object). The answer will bring the new SDP answer to pass it to the newly created client's peer connection. Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"reconnectStream\", \"params\": { \"stream\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"sdpOffer\": \"v=0 ... a=rtpmap:123 ulpfec/90000\\r\\n\" }, \"id\": 16 } Response from OpenVidu Server { \"id\": 16, \"result\": { \"sdpAnswer\": \"v=0 ... :FD:66:54:68:B4:47:25:EF:B6:04:74:AF:7B:08:66:09:F2:7C\\r\\n\", \"sessionId\": \"ajcecubc3sdcki0f6fnsefrr0t\" }, \"jsonrpc\": \"2.0\" } Server events All events generated in OpenVidu Server and sent to clients are a JSON object with 3 properties: jsonrpc : version of JSON-RPC protocol. Always \"2.0\" method : the name of the event params : a JSON object with the event properties Complete list of server events: iceCandidate sendMessage participantJoined participantLeft participantEvicted participantPublished participantUnpublished streamPropertyChanged recordingStarted recordingStopped filterEventDispatched iceCandidate OpenVidu Server has generated an ICE candidate for certain stream. Client must process it on its proper WebRTC peer connection object. { \"method\": \"iceCandidate\", \"params\": { \"senderConnectionId\": \"nflyoomouisnvvas\", \"endpointName\": \"nflyoomouisnvvas_CAMERA_DYVFP\", \"sdpMLineIndex\": 0, \"sdpMid\": \"0\", \"candidate\": \"candidate:1 1 UDP 2013266431 fe80::f816:3eff:fe48:cb5b 25037 typ host\" }, \"jsonrpc\": \"2.0\" } sendMessage A message broadcasted to the session (can be generated by other client or by the application server). { \"method\": \"sendMessage\", \"params\": { \"data\": \"Test message\", \"from\": \"y4gsjcy37m1rcjkx\", \"type\": \"signal:chat\" }, \"jsonrpc\": \"2.0\" } participantJoined Some client has connected to the session. { \"method\": \"participantJoined\", \"params\": { \"id\": \"tvwerf2quejh2vio\", \"createdAt\": 1568199474610, \"metadata\": \"{clientData: TestClient}\" }, \"jsonrpc\": \"2.0\" } participantLeft Some client has disconnected from the session. { \"method\": \"participantLeft\", \"params\": { \"connectionId\": \"4v8cftv2zylhkjvd\", \"reason\": \"forceDisconnectByUser\" }, \"jsonrpc\": \"2.0\" } participantEvicted Some client has been forcibly disconnected from the session. { \"method\": \"participantEvicted\", \"params\": { \"connectionId\": \"4v8cftv2zylhkjvd\", \"reason\": \"forceDisconnectByUser\" }, \"jsonrpc\": \"2.0\" } participantPublished Some client has published a stream to the session. { \"method\": \"participantPublished\", \"params\": { \"id\": \"qpdg7gcw0vf5wb97\", \"streams\": [ { \"id\": \"qpdg7gcw0vf5wb97_CAMERA_EDGRS\", \"createdAt\": 1568199288275, \"hasAudio\": true, \"hasVideo\": true, \"audioActive\": true, \"videoActive\": true, \"typeOfVideo\": \"CAMERA\", \"frameRate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"filter\": {} } ] }, \"jsonrpc\": \"2.0\" } participantUnpublished Some client has unpublished a stream from the session. { \"method\": \"participantUnpublished\", \"params\": { \"connectionId\": \"qpdg7gcw0vf5wb97\", \"reason\": \"unpublish\" }, \"jsonrpc\": \"2.0\" } streamPropertyChanged Some client has changed a property of a stream. See StreamPropertyChangedEvent { \"method\": \"streamPropertyChanged\", \"params\": { \"connectionId\": \"lnek7tftxofol1ie\", \"streamId\": \"lnek7tftxofol1ie_CAMERA_JVBHX\", \"property\": \"videoActive\", \"newValue\": \"false\", \"reason\": \"publishVideo\" }, \"jsonrpc\": \"2.0\" } recordingStarted The recording of a session has started. { \"method\": \"recordingStarted\", \"params\": { \"id\": \"lnek7tftxofol1ie\", \"name\": \"MyLastRecording\" }, \"jsonrpc\": \"2.0\" } recordingStopped The recording of a session has stopped. { \"method\": \"recordingStopped\", \"params\": { \"id\": \"lnek7tftxofol1ie\", \"name\": \"MyLastRecording\", \"reason\": \"recordingStoppedByServer\" }, \"jsonrpc\": \"2.0\" } filterEventDispatched A filter applied to a stream by this client has dispatched an event. This can only happen if the client has previously called methods applyFilter and addFilterEventListener { \"method\": \"filterEventDispatched\", \"params\": { \"connectionId\": \"wzvwjiise4lfbhvp\", \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"filterType\": \"ZBarFilter\", \"eventType\": \"CodeFound\", \"data\": \"{timestampMillis=1568204832456, codeType=EAN-13, source=3972c92d-a489-47ae-92f8-13ea6d0e72eb_kurento.MediaPipeline/fdb2f5-19a4-47c2-a27a-705fb277_kurento.ZBarFilter, type=CodeFound, value=0092000001927}\" }, \"jsonrpc\": \"2.0\" }","title":"OpenVidu Server RPC protocol"},{"location":"developing/rpc/#client-server-methods","text":"All operations send by the client side must be a JSON object with these properties jsonrpc : version of JSON-RPC protocol. Always \"2.0\" method : the name of the method params : a JSON object with the method parameters id : an integer to identify this operation call. Must be unique with respect to any other operation call All responses from OpenVidu Server to each one of these operations are a JSON object with these properties jsonrpc : version of JSON-RPC protocol. Always \"2.0\" id : an integer matching the id property of the operation call that generated this response. This allows pairing the operation call sent from the client with its respective server response result : a JSON object with the operation result. Its fields are obviously dependent on the method that generated this response. Not included if error property is defined error : a JSON object with information about an error triggered during the operation call. Not included if result property is defined. This JSON object has 2 properties: code : a number identifying the type of error message : a string with a detailed description about the error Complete list of operations: ping joinRoom publishVideo receiveVideoFrom onIceCandidate unpublishVideo unsubscribeFromVideo leaveRoom sendMessage forceUnpublish forceDisconnect applyFilter removeFilter execFilterMethod addFilterEventListener removeFilterEventListener reconnectStream","title":"Client-Server methods"},{"location":"developing/rpc/#ping","text":"Ping message for the ping-pong mechanism. This is necessary to make OpenVidu Server aware of a client connection, and to act accordingly if no ping is received in a certain interval time. params property is only necessary in the first call to this method. Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"ping\", \"params\": { \"interval\": 5000 // Not necessary after first call }, \"id\": 0 } Response from OpenVidu Server { \"id\": 0, \"result\":{ \"value\":\"pong\" }, \"jsonrpc\":\"2.0\" }","title":"ping"},{"location":"developing/rpc/#joinroom","text":"Join a client to an already initialized session. The equivalent method in OpenVidu Browser is Session#connect Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"joinRoom\", \"params\": { \"token\": \"wss://localhost:4443?sessionId=TestSession&token=rpjyfwrwckltdtk3&role=PUBLISHER&version=2.11.0\", \"session\": \"TestSession\", \"platform\": \"Chrome 76.0.3809.132 on Linux 64-bit\", \"metadata\": \"{clientData: TestClient}\", \"secret\": \"\", \"recorder\": false }, \"id\": 1 } Response from OpenVidu Server { \"id\": 1, \"result\": { \"id\": \"y4gsjcy37m1rcjkx\", \"createdAt\": 1568198320797, \"metadata\": \"{clientData: TestClient}\", \"value\": [ { \"id\": \"ydqsx1r7jp3zmduf\", \"createdAt\": 1568197954222, \"metadata\": \"{clientData: OtherClient}\", \"streams\": [ { \"id\": \"ydqsx1r7jp3zmduf_CAMERA_MLMZG\", \"createdAt\": 1568197956221, \"hasAudio\": true, \"hasVideo\": true, \"videoActive\": true, \"audioActive\": true, \"typeOfVideo\": \"CAMERA\", \"frameRate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"filter\": {} } ] } ], \"sessionId\": \"nqo83ml4kc2kgaoe65311n7in0\" }, \"jsonrpc\": \"2.0\" }","title":"joinRoom"},{"location":"developing/rpc/#publishvideo","text":"Start publishing a stream to the session. The equivalent method in OpenVidu Browser is Session#publish Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"publishVideo\", \"params\": { \"sdpOffer\": \"v=0 ... ssrc:1665235233 label:f320e350-b667-4765-87da-4ee4f595b9fe\\r\\n\", \"doLoopback\": false, \"hasAudio\": true, \"hasVideo\": true, \"audioActive\": true, \"videoActive\": true, \"typeOfVideo\": \"CAMERA\", \"frameRate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\" }, \"id\": 2 } Response from OpenVidu Server { \"id\": 2, \"result\": { \"sdpAnswer\": \"v=0 ... :EA:63:12:29:12:D6:4B:9A:63:F1:AB:D4:CC\\r\\n\", \"id\": \"nflyoomouisnvvas_CAMERA_DYVFP\", \"createdAt\": 1568193997244, \"sessionId\": \"lu7h4for17svik11aum6qqi9v1\" }, \"jsonrpc\": \"2.0\" }","title":"publishVideo"},{"location":"developing/rpc/#receivevideofrom","text":"Subscribe to a stream being published to the session. The equivalent method in OpenVidu Browser is Session#subscribe Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"receiveVideoFrom\", \"params\": { \"sender\": \"ydqsx1r7jp3zmduf_CAMERA_MLMZG\", \"sdpOffer\": \"v=0 ... a=rtpmap:123 ulpfec/90000\\r\\n\" }, \"id\": 3 } Response from OpenVidu Server { \"id\": 3, \"result\": { \"sdpAnswer\": \"v=0 ... :FD:66:54:68:B4:47:25:EF:B6:04:74:AF:7B:08:66:09:F2:7C\\r\\n\", \"sessionId\": \"ajcecubc3sdcki0f6fnsefrr0t\" }, \"jsonrpc\": \"2.0\" }","title":"receiveVideoFrom"},{"location":"developing/rpc/#onicecandidate","text":"Send and ICE candidate to the server. Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"onIceCandidate\", \"params\": { \"endpointName\": \"nflyoomouisnvvas\", \"candidate\": \"candidate:3885250869 1 udp 2122260223 172.17.0.1 53467 typ host generation 0 ufrag 3KLI network-id 1 network-cost 50\", \"sdpMid\": \"0\", \"sdpMLineIndex\": 0 }, \"id\": 4 } Response from OpenVidu Server { \"id\": 4, \"result\": { \"sessionId\": \"lu7h4for17svik11aum6qqi9v1\" }, \"jsonrpc\": \"2.0\" }","title":"onIceCandidate"},{"location":"developing/rpc/#unpublishvideo","text":"Stop publishing a stream to the session. The equivalent method in OpenVidu Browser is Session#unpublish Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"unpublishVideo\", \"params\": {}, \"id\": 5 } Response from OpenVidu Server { \"id\": 5, \"result\": { \"sessionId\": \"822vl7sqllncvbivsoqt8q0nes\" }, \"jsonrpc\": \"2.0\" }","title":"unpublishVideo"},{"location":"developing/rpc/#unsubscribefromvideo","text":"Stop the subscription from a stream to which the user is currently subscribed. The equivalent method in OpenVidu Browser is Session#unsubscribe Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"unsubscribeFromVideo\", \"params\": { \"sender\": \"ydqsx1r7jp3zmduf\" }, \"id\": 6 } Response from OpenVidu Server { \"id\": 6, \"result\": { \"sessionId\": \"ajcecubc3sdcki0f6fnsefrr0t\" }, \"jsonrpc\": \"2.0\" }","title":"unsubscribeFromVideo"},{"location":"developing/rpc/#leaveroom","text":"Disconnect a client from a session. The equivalent method in OpenVidu Browser is Session#disconnect Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"leaveRoom\", \"params\": {}, \"id\": 7 } Response from OpenVidu Server { \"id\": 7, \"result\": { \"sessionId\": \"lu7h4for17svik11aum6qqi9v1\" }, \"jsonrpc\": \"2.0\" }","title":"leaveRoom"},{"location":"developing/rpc/#sendmessage","text":"Send a signal to the session. The equivalent method in OpenVidu Browser is Session#signal Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"sendMessage\", \"params\": { \"message\": \"{\\\"to\\\":[],\\\"data\\\":\\\"Test message\\\",\\\"type\\\":\\\"signal:chat\\\"}\" }, \"id\": 8 } Response from OpenVidu Server { \"id\": 8, \"result\": { \"sessionId\": \"nqo83ml4kc2kgaoe65311n7in0\" }, \"jsonrpc\": \"2.0\" }","title":"sendMessage"},{"location":"developing/rpc/#forceunpublish","text":"Force another client to unpublish its stream from the session. Only possible for clients with role MODERATOR inside the session. The equivalent method in OpenVidu Browser is Session#forceUnpublish Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"forceUnpublish\", \"params\": { \"streamId\": \"ydqsx1r7jp3zmduf_CAMERA_MLMZG\" }, \"id\": 9 } Response from OpenVidu Server { \"id\": 9, \"result\": { \"sessionId\": \"rh75l2dg35v9pqsrsbi5n09p72\" }, \"jsonrpc\": \"2.0\" }","title":"forceUnpublish"},{"location":"developing/rpc/#forcedisconnect","text":"Force another client to disconnect from the session. Only possible for clients with role MODERATOR inside the session. The equivalent method in OpenVidu Browser is Session#forceDisconnect Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"forceDisconnect\", \"params\": { \"connectionId\": \"4v8cftv2zylhkjvd\" }, \"id\": 10 } Response from OpenVidu Server { \"id\": 10, \"result\": { \"sessionId\": \"6f0djrngic4ed49ov0poesp3f4\" }, \"jsonrpc\": \"2.0\" }","title":"forceDisconnect"},{"location":"developing/rpc/#applyfilter","text":"Apply a filter to a published stream. The equivalent method in OpenVidu Browser is Stream#applyFilter Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"applyFilter\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"type\": \"GStreamerFilter\", \"options\": \"{\\\"command\\\":\\\"videobalance saturation=0.0\\\"}\" }, \"id\": 11 } Response from OpenVidu Server { \"id\": 11, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" }","title":"applyFilter"},{"location":"developing/rpc/#removefilter","text":"Removed an applied filter from a stream. The equivalent method in OpenVidu Browser is Stream#removeFilter Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"removeFilter\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\" }, \"id\": 12 } Response from OpenVidu Server { \"id\": 12, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" }","title":"removeFilter"},{"location":"developing/rpc/#execfiltermethod","text":"Execute a method offered by an applied filter. The equivalent method in OpenVidu Browser is Filter#execMethod Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"execFilterMethod\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"method\": \"setElementProperty\", \"params\": \"{\\\"propertyName\\\":\\\"saturation\\\",\\\"propertyValue\\\":\\\"1.0\\\"}\" }, \"id\": 13 } Response from OpenVidu Server { \"id\": 12, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" }","title":"execFilterMethod"},{"location":"developing/rpc/#addfiltereventlistener","text":"Add a listener to an applied filter. The equivalent method in OpenVidu Browser is Filter#addEventListener Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"addFilterEventListener\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"eventType\": \"CodeFound\" }, \"id\": 14 } Response from OpenVidu Server { \"id\": 14, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" }","title":"addFilterEventListener"},{"location":"developing/rpc/#removefiltereventlistener","text":"Remove a listener from an applied filter. The equivalent method in OpenVidu Browser is Filter#removeEventListener Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"removeFilterEventListener\", \"params\": { \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"eventType\": \"CodeFound\" }, \"id\": 15 } Response from OpenVidu Server { \"id\": 15, \"result\": { \"sessionId\": \"iege6n3t7c3oj8ilj91hgaktp6\" }, \"jsonrpc\": \"2.0\" }","title":"removeFilterEventListener"},{"location":"developing/rpc/#reconnectstream-2120","text":"Silently re-negotiates an already established stream. This is useful for reconnecting a frozen stream, which may happen when a client loses and recovers its network connection with OpenVidu Server, but the media plane is broken. This method will recreate a new RTC peer connection in a silent manner (without triggering any events in the clients) using the properties of the previous one. Required params are the stream identifier to reconnect and the new SDP offer generated by the client (which must have created a new RTC peer connection object). The answer will bring the new SDP answer to pass it to the newly created client's peer connection. Method sent by client { \"jsonrpc\": \"2.0\", \"method\": \"reconnectStream\", \"params\": { \"stream\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"sdpOffer\": \"v=0 ... a=rtpmap:123 ulpfec/90000\\r\\n\" }, \"id\": 16 } Response from OpenVidu Server { \"id\": 16, \"result\": { \"sdpAnswer\": \"v=0 ... :FD:66:54:68:B4:47:25:EF:B6:04:74:AF:7B:08:66:09:F2:7C\\r\\n\", \"sessionId\": \"ajcecubc3sdcki0f6fnsefrr0t\" }, \"jsonrpc\": \"2.0\" }","title":"reconnectStream (&gt;= 2.12.0)"},{"location":"developing/rpc/#server-events","text":"All events generated in OpenVidu Server and sent to clients are a JSON object with 3 properties: jsonrpc : version of JSON-RPC protocol. Always \"2.0\" method : the name of the event params : a JSON object with the event properties Complete list of server events: iceCandidate sendMessage participantJoined participantLeft participantEvicted participantPublished participantUnpublished streamPropertyChanged recordingStarted recordingStopped filterEventDispatched","title":"Server events"},{"location":"developing/rpc/#icecandidate","text":"OpenVidu Server has generated an ICE candidate for certain stream. Client must process it on its proper WebRTC peer connection object. { \"method\": \"iceCandidate\", \"params\": { \"senderConnectionId\": \"nflyoomouisnvvas\", \"endpointName\": \"nflyoomouisnvvas_CAMERA_DYVFP\", \"sdpMLineIndex\": 0, \"sdpMid\": \"0\", \"candidate\": \"candidate:1 1 UDP 2013266431 fe80::f816:3eff:fe48:cb5b 25037 typ host\" }, \"jsonrpc\": \"2.0\" }","title":"iceCandidate"},{"location":"developing/rpc/#sendmessage_1","text":"A message broadcasted to the session (can be generated by other client or by the application server). { \"method\": \"sendMessage\", \"params\": { \"data\": \"Test message\", \"from\": \"y4gsjcy37m1rcjkx\", \"type\": \"signal:chat\" }, \"jsonrpc\": \"2.0\" }","title":"sendMessage"},{"location":"developing/rpc/#participantjoined","text":"Some client has connected to the session. { \"method\": \"participantJoined\", \"params\": { \"id\": \"tvwerf2quejh2vio\", \"createdAt\": 1568199474610, \"metadata\": \"{clientData: TestClient}\" }, \"jsonrpc\": \"2.0\" }","title":"participantJoined"},{"location":"developing/rpc/#participantleft","text":"Some client has disconnected from the session. { \"method\": \"participantLeft\", \"params\": { \"connectionId\": \"4v8cftv2zylhkjvd\", \"reason\": \"forceDisconnectByUser\" }, \"jsonrpc\": \"2.0\" }","title":"participantLeft"},{"location":"developing/rpc/#participantevicted","text":"Some client has been forcibly disconnected from the session. { \"method\": \"participantEvicted\", \"params\": { \"connectionId\": \"4v8cftv2zylhkjvd\", \"reason\": \"forceDisconnectByUser\" }, \"jsonrpc\": \"2.0\" }","title":"participantEvicted"},{"location":"developing/rpc/#participantpublished","text":"Some client has published a stream to the session. { \"method\": \"participantPublished\", \"params\": { \"id\": \"qpdg7gcw0vf5wb97\", \"streams\": [ { \"id\": \"qpdg7gcw0vf5wb97_CAMERA_EDGRS\", \"createdAt\": 1568199288275, \"hasAudio\": true, \"hasVideo\": true, \"audioActive\": true, \"videoActive\": true, \"typeOfVideo\": \"CAMERA\", \"frameRate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"filter\": {} } ] }, \"jsonrpc\": \"2.0\" }","title":"participantPublished"},{"location":"developing/rpc/#participantunpublished","text":"Some client has unpublished a stream from the session. { \"method\": \"participantUnpublished\", \"params\": { \"connectionId\": \"qpdg7gcw0vf5wb97\", \"reason\": \"unpublish\" }, \"jsonrpc\": \"2.0\" }","title":"participantUnpublished"},{"location":"developing/rpc/#streampropertychanged","text":"Some client has changed a property of a stream. See StreamPropertyChangedEvent { \"method\": \"streamPropertyChanged\", \"params\": { \"connectionId\": \"lnek7tftxofol1ie\", \"streamId\": \"lnek7tftxofol1ie_CAMERA_JVBHX\", \"property\": \"videoActive\", \"newValue\": \"false\", \"reason\": \"publishVideo\" }, \"jsonrpc\": \"2.0\" }","title":"streamPropertyChanged"},{"location":"developing/rpc/#recordingstarted","text":"The recording of a session has started. { \"method\": \"recordingStarted\", \"params\": { \"id\": \"lnek7tftxofol1ie\", \"name\": \"MyLastRecording\" }, \"jsonrpc\": \"2.0\" }","title":"recordingStarted"},{"location":"developing/rpc/#recordingstopped","text":"The recording of a session has stopped. { \"method\": \"recordingStopped\", \"params\": { \"id\": \"lnek7tftxofol1ie\", \"name\": \"MyLastRecording\", \"reason\": \"recordingStoppedByServer\" }, \"jsonrpc\": \"2.0\" }","title":"recordingStopped"},{"location":"developing/rpc/#filtereventdispatched","text":"A filter applied to a stream by this client has dispatched an event. This can only happen if the client has previously called methods applyFilter and addFilterEventListener { \"method\": \"filterEventDispatched\", \"params\": { \"connectionId\": \"wzvwjiise4lfbhvp\", \"streamId\": \"wzvwjiise4lfbhvp_CAMERA_MCLFF\", \"filterType\": \"ZBarFilter\", \"eventType\": \"CodeFound\", \"data\": \"{timestampMillis=1568204832456, codeType=EAN-13, source=3972c92d-a489-47ae-92f8-13ea6d0e72eb_kurento.MediaPipeline/fdb2f5-19a4-47c2-a27a-705fb277_kurento.ZBarFilter, type=CodeFound, value=0092000001927}\" }, \"jsonrpc\": \"2.0\" }","title":"filterEventDispatched"},{"location":"home/","text":"What is OpenVidu? OpenVidu is a platform to facilitate the addition of video calls in your web or mobile application. It provides a complete stack of technologies very easy to integrate in your application. Our main goal is to allow developers to add real-time communications to their apps very fast and with low impact in their code. WebRTC videoconferences One-to-One, One-to-Many, Many-to-Many. Any combination you can think of is possible with OpenVidu Open source OpenVidu is an OpenSource project licensed under Apache License v2 . Use it for free Multiplatform Chrome, Firefox, Safari, Opera, Android, iOS, desktop apps. All compatible with each other Easy to use OpenVidu offers ready-to-use components that you can simply paste in your code to quickly get your videocalls up and running. Or if you want complete freedom when designing your videocalls, our super simple API will make it fun and quick but at the same time very customizable and powerful Easy to deploy Developing your app is just the beginning. And of course we know that the go-to-production process can sometimes be pretty annoying. OpenVidu makes this a seamless process by supporting the deployment in the most popular cloud provider in a few clicks. Or if you prefer, we have a very short step-by-step guide on how to successfully deploy OpenVidu on Ubuntu Tutorials/Demos available As developers we believe that the best way to engage other colleagues in our platform is providing lots of working examples and guides that can serve as a starting point or a fun way to learn how to take advantage of OpenVidu full potential Keep your videoconferences private WebRTC encryption, our server API and our client role-based system guarantee all your calls will be completely private Compatible with lots of frontend technologies JavaScript, TypeScript, Angular, React, Ionic... Just choose your preferred language and framework Compatible with any backend technology OpenVidu offers out of the box Java and Node clients for controlling your videocalls from your server, but it also exposes a REST API to allow any backend technology to be used. We don't want to limit any developer! Limit client capabilities with predefined roles Decide which user is allowed to subscribe, publish or moderate video streams with predefined roles. Securing your videocalls has never been so easy! Message broadcasting You can implement a chat within just a few lines of code with OpenVidu. Any user to user text-based communication your app may need can be implemented very easily Recording Record your videocalls with complete freedom: OpenVidu provides predefined layouts, but you can use your own custom layouts to accomplish any kind of result Screen sharing OpenVidu allows your clients to share their screens Audio and video filters OpenVidu is the only WebRTC technology that allows you to apply real-time audio and video filters . Detecting bar codes, settting a chroma key background or amplifying your clients voices are only just a few examples of what you can achieve with OpenVidu filters. And all of this perfectly integrated in OpenVidu simple high-level API IP cameras You can receive IP cameras in OpenVidu. Implementing a surveillance system has never been so easy! Supported plans and professional support We offer OpenVidu Pro for those companies interested in a more advanced production setup, focused on improved monitoring, scalability and fault tolerance. And OpenVidu team is opened to providing professional support for any project related to the platform. Contact us now! Some use cases Some interesting use cases you can implement with OpenVidu: An integrated 1-to-1 video-call center to attend your customers face to face A videoclassroom platform where one or more teachers publish their webcams or desktops and many students receive them Audio-only rooms where users can also interact through a chat A conference service that allows the presenter to apply audio or video filters in real-time and record the lecture in a video file A security platform where you can receive video from security cameras/webcams. You could even receive a notification when some movement is detected in a region of the video An application to receive video from drones equipped with an IP camera The possibilities are endless. You can check our Demos to get an idea of what you can do with OpenVidu. Here some cool pictures of them: OpenVidu Architecture OpenVidu is divided into two parts: OpenVidu Browser : it is a library to use in your client side (available for JavaScript and TypeScript). It allows you to create video-calls, join users to them, send and receive video and audio, etc... All the actions available with OpenVidu are managed via OpenVidu Browser. OpenVidu Server : it is an application that handles the server-side stuff. It receives the operations from OpenVidu Browser and do whatever is necessary to establish and manage your video-calls. You will never have to explicitly use it: just to run it and know its IP address. Get started These are the recommended steps for getting started with OpenVidu: The best way to get your first app working in a few minutes is following our OpenVidu Hello World Tutorial . After that, you can try any of our Client-Side-Only tutorials, or maybe go straight to step 3 if you think that you already handle OpenVidu reasonably well. Try now any of our Client-Side + Server-Side tutorials, where you can see how a complete web application works with OpenVidu. Choose your preferred framework, since all 4 applications are exactly the same regarding their look and functionality. Finally you can deploy your first app and see it working in the real world. You can follow our tutorial, where you can deploy our Demos in your own Amazon machine in a few minutes ( Deploying OpenVidu Demos on AWS ). Then you can deploy your own app following these steps ( Deploying OpenVidu Server and Deploying your app on AWS ). How does OpenVidu work? WebRTC is the ultimate responsible for all media transmission at the very heart of OpenVidu. WebRTC is a modern, cross-platform framework that democratizes media transmission over the Internet. It is promoted by Google, Mozilla, Opera and others. Kurento is the WebRTC framework on which OpenVidu is built. Openvidu was forked from KurentoRoom project . What are the differences between Kurento and OpenVidu? OpenVidu wraps and hides all the low-level operations. The main goal we pursue is to provide a simple, effective, easy-to-use API so you can forget about WebRTC, ICE candidates and media server tricky stuff. We internally use Kurento to generate, connect, modify and destroy media-pipelines, but OpenVidu simplifies as far as possible the process, focusing on the use-case of video-call sessions (one-to-one, one-to-many, many-to-many, users with different roles). Ultimately, developers can create video-calls with just a few lines of code, all from their client-side . Acknowledgments OpenVidu has been supported under Project LERNIM (RTC-2016-4674-7), co-funded by the Ministry of Economy, Finance and Competitiveness of Spain, as well as by the European Regional Development Fund , whose main goal is to promote technological development, innovation and high-quality research. $().fancybox({ selector : '[data-fancybox=\"gallery-wellcome\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.docs-gallery').slick({ autoplay: true, autoplaySpeed: 4000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] });","title":"What is OpenVidu?"},{"location":"home/#some-use-cases","text":"Some interesting use cases you can implement with OpenVidu: An integrated 1-to-1 video-call center to attend your customers face to face A videoclassroom platform where one or more teachers publish their webcams or desktops and many students receive them Audio-only rooms where users can also interact through a chat A conference service that allows the presenter to apply audio or video filters in real-time and record the lecture in a video file A security platform where you can receive video from security cameras/webcams. You could even receive a notification when some movement is detected in a region of the video An application to receive video from drones equipped with an IP camera The possibilities are endless. You can check our Demos to get an idea of what you can do with OpenVidu. Here some cool pictures of them:","title":"Some use cases"},{"location":"home/#openvidu-architecture","text":"OpenVidu is divided into two parts: OpenVidu Browser : it is a library to use in your client side (available for JavaScript and TypeScript). It allows you to create video-calls, join users to them, send and receive video and audio, etc... All the actions available with OpenVidu are managed via OpenVidu Browser. OpenVidu Server : it is an application that handles the server-side stuff. It receives the operations from OpenVidu Browser and do whatever is necessary to establish and manage your video-calls. You will never have to explicitly use it: just to run it and know its IP address.","title":"OpenVidu Architecture"},{"location":"home/#get-started","text":"These are the recommended steps for getting started with OpenVidu: The best way to get your first app working in a few minutes is following our OpenVidu Hello World Tutorial . After that, you can try any of our Client-Side-Only tutorials, or maybe go straight to step 3 if you think that you already handle OpenVidu reasonably well. Try now any of our Client-Side + Server-Side tutorials, where you can see how a complete web application works with OpenVidu. Choose your preferred framework, since all 4 applications are exactly the same regarding their look and functionality. Finally you can deploy your first app and see it working in the real world. You can follow our tutorial, where you can deploy our Demos in your own Amazon machine in a few minutes ( Deploying OpenVidu Demos on AWS ). Then you can deploy your own app following these steps ( Deploying OpenVidu Server and Deploying your app on AWS ).","title":"Get started"},{"location":"home/#how-does-openvidu-work","text":"WebRTC is the ultimate responsible for all media transmission at the very heart of OpenVidu. WebRTC is a modern, cross-platform framework that democratizes media transmission over the Internet. It is promoted by Google, Mozilla, Opera and others. Kurento is the WebRTC framework on which OpenVidu is built. Openvidu was forked from KurentoRoom project . What are the differences between Kurento and OpenVidu? OpenVidu wraps and hides all the low-level operations. The main goal we pursue is to provide a simple, effective, easy-to-use API so you can forget about WebRTC, ICE candidates and media server tricky stuff. We internally use Kurento to generate, connect, modify and destroy media-pipelines, but OpenVidu simplifies as far as possible the process, focusing on the use-case of video-call sessions (one-to-one, one-to-many, many-to-many, users with different roles). Ultimately, developers can create video-calls with just a few lines of code, all from their client-side .","title":"How does OpenVidu work?"},{"location":"home/#acknowledgments","text":"OpenVidu has been supported under Project LERNIM (RTC-2016-4674-7), co-funded by the Ministry of Economy, Finance and Competitiveness of Spain, as well as by the European Regional Development Fund , whose main goal is to promote technological development, innovation and high-quality research. $().fancybox({ selector : '[data-fancybox=\"gallery-wellcome\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.docs-gallery').slick({ autoplay: true, autoplaySpeed: 4000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] });","title":"Acknowledgments"},{"location":"livestreaming-videoconferences/","text":"Adding videoconference to web and mobile apps Video Conference or Live Streaming I) Live Streaming The videostreaming is an unidirectional platform that allows the retransmission of multimedia files (audio or audio and video) through Internet, from a place of emission to different places of reception. The video streaming is ideal for the retransmission of all kinds of events live to any part of the world and the playback can be stored for later viewing. II) VideoConferences On the other hand, we have audiovisual equipment for the development of videoconference . A two-way platform for connecting live video between different people in different places over the Internet. Videoconferencing tools allows visual communication between a group of people from anywhere in the world. It is a multipoint or point-to-point system ideal for business meetings. You can choose between P2P or Media Server : a) P2P: connect your users directly between them This is a quick and cheap solution, as the need of a server side managing the media streams is removed from the equation. It has a lot of limitations though, especially in how big your videoconferences can get. Each user has to send their video to every other user in the call, and must receive a direct video stream from every one of them. This way the amount of media streams grows exponentially. More than 3 or 4 users per videocall usually end up in a rather unfortunate user experience. Besides that, the lack of a central node for controlling your calls means that you cannot perform such useful tasks as call recording or video forwarding. And perhaps the worst thing about this option is the fact that it does not release you from the use a media routing server. Many times your clients will be located behind firewalls or complex networks, and that makes the use of TURN servers mandatory. They act as a relay server to connect your clients whenever a direct connection is not possible, and that may happen pretty frequently. b) Media Server: route every video stream through a server This is the most versatile solution. Using a media server to route your clients video streams expands every possible aspect of real-time video to a higher level (at the expense of having to maintain another service in your stack, of course). But as we stated before, dispensing with a media server is not a viable option in many use cases. Live Streaming Video Conferences When to use live streaming Live streaming technology enables high quality video to be transmitted to tens of thousands of people in near real time. Keep in mind that the high quality of video produces a higher latency with respect to video conferences. In addition to this, live streaming platforms allow viewers to interact with their videos long after their live event is over . You should be using these tools for: You want a versatile solution for a larger audience You want simplicity for the viewer You want production level quality You shouldn't be using these tools for: Face to face meetings Create live events with less than one second of latency When to use video conferences Videoconferencing tools are useful to set internal or external meetings and calls between one-on-one or small groups of people in multiple location. As it is a two-way communication , it allows an active interaction between the participants with hardly any audio and video delay . In addition, this type of tools allow you to communicate in a clearer and more consistent way to your work team. In turn, participants will have the opportunity to ask questions and provide feedback in real time . You should be using these tools for: One-on-One or groups meetings Active interaction between participants Low video and audio latency You shouldn't be using these tools for: Sending a stream to more than a few dozen people Creating high quality live video Apps or Development Platforms The next step, once you have decided to use Video Conferences or Live Streaming, is to choose which option adapts to your needs: I) Standalone third-party application Your needs may be met simply by using a third-party application as a non-integral solution, detached from your software core. Don't underestimate the most direct solution: if your user requirements allow the use of Skype , Hangouts , Periscope or YouTube Live to hold some meetings or to emit events, that's for sure the cheapest and easiest way to get real-time videocalls or retransmission in your business. As a service Live Straming Apps Periscope Twitch YouTube FB Live Boxcast Vimeo Video Conferences Apps OpenVidu Skype Hangouts Appear.in Zoom GoToMeeting On premise Video Conferences Apps OpenVidu BigBlueButton Jitsi II) Software as a Service This can be a recommended option if: a) you can afford it and b) you are allowed to outsource the service . Besides, the video conference platforms usually support both P2P and routed videocalls and also bring more advanced features pretty useful for companies such as programmable SMS or phone calls, SIP integration and so on. Streaming Companies AntMedia Wowza Video Conferences Companies Tokbox Twilio Agora.io Vidyo.io Temasys apiRTC III) On-Premises Software Video Conferences Open Source Kurento OpenVidu Janus Medooze Licode Mediasoup Video Conferences Closed Source OpenVidu Pro Frozen Mountain Flashphoner Dialogic Quobis Streaming Open Source AntMedia Red5 Streaming Closed Source AntMedia Wowza Flashphoner Red5 Pro Decision tree OpenVidu Once we have learned the differences between live streaming and video conferences and its subcategories, we will be able to clarify what openvidu is. First of all, OpenVidu is an on premise open and closed source video conferences platform . This means that OpenVidu is an OpenSource project lisenced under Apache Lisence v2 and you can use it for free. However, OpenVidu Team have developed OpenVidu PRO which consists of different modules working over OpenVidu Community Edition (OpenVidu CE). And secondly, OpenVidu offers as a service external app videoconference ( call.openvidu.io ) and on premise external app videoconference ( OpenVidu Call ). $().fancybox({ selector : '[data-fancybox=\"gallery-wellcome\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Adding videoconference to web and mobile apps"},{"location":"livestreaming-videoconferences/#adding-videoconference-to-web-and-mobile-apps","text":"","title":"Adding videoconference to web and mobile apps"},{"location":"livestreaming-videoconferences/#i-live-streaming","text":"The videostreaming is an unidirectional platform that allows the retransmission of multimedia files (audio or audio and video) through Internet, from a place of emission to different places of reception. The video streaming is ideal for the retransmission of all kinds of events live to any part of the world and the playback can be stored for later viewing.","title":"I) Live Streaming"},{"location":"livestreaming-videoconferences/#ii-videoconferences","text":"On the other hand, we have audiovisual equipment for the development of videoconference . A two-way platform for connecting live video between different people in different places over the Internet. Videoconferencing tools allows visual communication between a group of people from anywhere in the world. It is a multipoint or point-to-point system ideal for business meetings. You can choose between P2P or Media Server :","title":"II) VideoConferences"},{"location":"livestreaming-videoconferences/#a-p2p-connect-your-users-directly-between-them","text":"This is a quick and cheap solution, as the need of a server side managing the media streams is removed from the equation. It has a lot of limitations though, especially in how big your videoconferences can get. Each user has to send their video to every other user in the call, and must receive a direct video stream from every one of them. This way the amount of media streams grows exponentially. More than 3 or 4 users per videocall usually end up in a rather unfortunate user experience. Besides that, the lack of a central node for controlling your calls means that you cannot perform such useful tasks as call recording or video forwarding. And perhaps the worst thing about this option is the fact that it does not release you from the use a media routing server. Many times your clients will be located behind firewalls or complex networks, and that makes the use of TURN servers mandatory. They act as a relay server to connect your clients whenever a direct connection is not possible, and that may happen pretty frequently.","title":"a) P2P: connect your users directly between them"},{"location":"livestreaming-videoconferences/#b-media-server-route-every-video-stream-through-a-server","text":"This is the most versatile solution. Using a media server to route your clients video streams expands every possible aspect of real-time video to a higher level (at the expense of having to maintain another service in your stack, of course). But as we stated before, dispensing with a media server is not a viable option in many use cases.","title":"b) Media Server: route every video stream through a server"},{"location":"livestreaming-videoconferences/#i-standalone-third-party-application","text":"Your needs may be met simply by using a third-party application as a non-integral solution, detached from your software core. Don't underestimate the most direct solution: if your user requirements allow the use of Skype , Hangouts , Periscope or YouTube Live to hold some meetings or to emit events, that's for sure the cheapest and easiest way to get real-time videocalls or retransmission in your business.","title":"I) Standalone third-party application"},{"location":"livestreaming-videoconferences/#ii-software-as-a-service","text":"This can be a recommended option if: a) you can afford it and b) you are allowed to outsource the service . Besides, the video conference platforms usually support both P2P and routed videocalls and also bring more advanced features pretty useful for companies such as programmable SMS or phone calls, SIP integration and so on.","title":"II) Software as a Service"},{"location":"livestreaming-videoconferences/#iii-on-premises-software","text":"","title":"III) On-Premises Software"},{"location":"openvidu-pro/","text":"OpenVidu Pro Why OpenVidu is an open source project , and for sure will remain this way in the future. But OpenVidu team needs some source of income to continue working on this amazing project. The approach we'll be taking here is pretty straightforward: OpenVidu features themselves will always be open source, and only some tools or improvements related to production environments may end up being part of OpenVidu Pro stack. To sum up: You will always be able to access OpenVidu awesome features and build whatever you want with them. Our intention is to make OpenVidu platform long-term sustainable by offering advanced production stage monitoring and management tools for those companies interested in such capabilities What OpenVidu Pro consists of different modules working on top of OpenVidu Community Edition (OpenVidu CE). For now OpenVidu Pro offers: Scalability : add and remove Media Nodes on demand to adapt your cluster size depending on the expected load. OpenVidu Inspector : a powerful, easy-to-use and visually attractive dashboard that will help you monitor, manage and review all your videoconferences. Detail session monitoring : the Elastic stack integration provides a powerful and customizable way to monitor your sessions. OpenVidu Pro users will also have priority when contacting OpenVidu team with doubts about the platform. Remember we also offer custom professional support OpenVidu CE OpenVidu Pro WebRTC media streams Recording Screen sharing Audio and video filters IP cameras Clients: JS, Angular, React, Ionic, Electron Deployment on Premise Deployment on Cloud Kurento Media Server OpenVidu Inspector Advanced session monitoring Manual scalability Elasticity Fault Tolerance P2P sessions Other media servers VP9 Simulcast and SVC Kubernetes deployment License Apache 2.0 Copyrighted Support Community support on forums Email support in business hours Price Free 0.0006$ core/minute Visit Pricing OpenVidu CE Docs OpenVidu Pro Docs How You can deploy OpenVidu Pro: On AWS On premises in your own infrastructure Pricing Check out Pricing section . Run OpenVidu Pro","title":"Home"},{"location":"openvidu-pro/#why","text":"OpenVidu is an open source project , and for sure will remain this way in the future. But OpenVidu team needs some source of income to continue working on this amazing project. The approach we'll be taking here is pretty straightforward: OpenVidu features themselves will always be open source, and only some tools or improvements related to production environments may end up being part of OpenVidu Pro stack. To sum up: You will always be able to access OpenVidu awesome features and build whatever you want with them. Our intention is to make OpenVidu platform long-term sustainable by offering advanced production stage monitoring and management tools for those companies interested in such capabilities","title":"Why"},{"location":"openvidu-pro/#what","text":"OpenVidu Pro consists of different modules working on top of OpenVidu Community Edition (OpenVidu CE). For now OpenVidu Pro offers: Scalability : add and remove Media Nodes on demand to adapt your cluster size depending on the expected load. OpenVidu Inspector : a powerful, easy-to-use and visually attractive dashboard that will help you monitor, manage and review all your videoconferences. Detail session monitoring : the Elastic stack integration provides a powerful and customizable way to monitor your sessions. OpenVidu Pro users will also have priority when contacting OpenVidu team with doubts about the platform. Remember we also offer custom professional support OpenVidu CE OpenVidu Pro WebRTC media streams Recording Screen sharing Audio and video filters IP cameras Clients: JS, Angular, React, Ionic, Electron Deployment on Premise Deployment on Cloud Kurento Media Server OpenVidu Inspector Advanced session monitoring Manual scalability Elasticity Fault Tolerance P2P sessions Other media servers VP9 Simulcast and SVC Kubernetes deployment License Apache 2.0 Copyrighted Support Community support on forums Email support in business hours Price Free 0.0006$ core/minute Visit Pricing OpenVidu CE Docs OpenVidu Pro Docs","title":"What"},{"location":"openvidu-pro/#how","text":"You can deploy OpenVidu Pro: On AWS On premises in your own infrastructure","title":"How"},{"location":"openvidu-pro/#pricing","text":"Check out Pricing section . Run OpenVidu Pro","title":"Pricing"},{"location":"openvidu-pro/detailed-session-monitoring/","text":"Detailed session monitoring OpenVidu Pro brings the power of Elastic Stack . Events and monitoring stats are sent to Elasticsearch and can be visualized through Kibana . OpenVidu Sessions dahsboard This dashboard presents a summary of your video sessions and the server resources usage. That includes: CPU and memory usage of the server The number of session per day The location of your users The number of publishers and subscribers you have at any time The total streamed minutes over time Some low-level interesting stats related to the media connections The last point includes things like the average time to select a pair candidate during the negotiation process, the average milliseconds your clients take to complete the ICE gathering process with OpenVidu Server, the ratio of successful and failed connections, and some WebRTC stats for your published and subscribed streams (Jitter, packet loss, Round-Trip-Time, target bitrate...) All in all, this information will help you understand better the behavior and performance of your sessions. OpenVidu Recordings dahsboard This dashboard presents at a glance the status of your recordings. It includes information such as: The total number of recordings per day Average duration and size of your recorded files The distributions of you recordings by duration and size The ratio of recordings according to their output mode ( COMPOSED or INDIVIDUAL recordings) and their recorded tracks ( audio/video recordings ) Accessing Kibana OpenVidu Pro serves Kibana through path /kibana . So, if you have deployed OpenVidu Pro with domain my.domain.com , you will be able to access OpenVidu Inspector through https://my.domain.com/inspector and Kibana through https://my.domain.com/kibana This path is secured with Basic Auth, so when connecting to it for the first time you will have to enter the user and password specified when deploying OpenVidu Pro. Creating your own visualizations and dashboards The dashboards presented above, by default included in OpenVidu Pro, are just an example of what can be done thanks to Kibana. You can create your own visualizations, and set up your very own dashboards with them. To do so, you have available multiple events that OpenVidu Pro periodically stores in Elasticsearch, and you can then use them in Kibana to compose different types of graphs and other useful visual representations. Each one of these events stored by OpenVidu Pro in Elasticsearch has an elastic_type field to identify the specific type of event. This field may be: 2.9.0 / 2.10.0 / 2.11.0 2.12.0 cdr : event of CDR/Webhook. Can take multiple forms according to the type of event (see OpenVidu CDR ) kms : Kurento Media Server event. These events are always associated to one WebRTC endpoint (a publisher or a subscriber). Can take multiple forms according to the type of event (see Kurento docs ) monitoringStats : event of CPU, memory and network statistics usage of OpenVidu Pro host webrtcStats : event of WebRTC statistics for each media endpoint established in Kurento Media Server sessionSummary : summary of a session, stored once it is closed recordingSummary : summary of a recording, stored once its session is closed userSummary : summary of a user, stored once its session is closed connectionSummary : summary of a connection, stored once its session is closed publisherSummary : summary of a publisher, stored once its session is closed subscriberSummary : summary of a subscriber, stored once its session is closed cdr kms monitoringStats webrtcStats sessionSummary recordingSummary userSummary connectionSummary publisherSummary subscriberSummary { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848252, \"startTime\": 1554191765889, \"duration\": 82, \"reason\": \"lastParticipantLeft\", \"event\": \"sessionDestroyed\", \"elastic_type\": \"cdr\" } { \"streamId\": 1, \"componentId\": 1, \"state\": \"READY\", \"type\": \"IceComponentStateChange\", \"timestamp\": 1554191839098, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"ewztvkfl8dttvcxk\", \"endpoint\": \"ewztvkfl8dttvcxk_bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"msSinceEndpointCreation\": 11104, \"elastic_type\": \"kms\" } { \"timestamp\": 1554212258873, \"cpu\": 11.887875624741168, \"mem\": { \"used\": 7287344, \"percentage\": 45.13347034796033 }, \"net\": { \"veth2b4c47c\": { \"rxBytes\": 0, \"txBytes\": 0 }, \"wlp58s0\": { \"rxBytes\": 0, \"txBytes\": 0 } }, \"elastic_type\": \"monitoringStats\" } { \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"endpoint\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"mediaType\": \"video\", \"jitter\": 0.005244444590061903, \"bytesReceived\": 6455233, \"packetsReceived\": 6666, \"packetsLost\": 0, \"timestamp\": 1554191847505, \"fractionLost\": 0, \"remb\": 533208, \"firCount\": 6, \"pliCount\": 0, \"nackCount\": 0, \"sliCount\": 0, \"elastic_type\": \"webrtcStats\" } { \"createdAt\": 1554191765889, \"destroyedAt\": 1554191848252, \"sessionId\": \"weih6kaewklr4i05\", \"customSessionId\": \"\", \"mediaMode\": \"ROUTED\", \"recordingMode\": \"MANUAL\", \"duration\": 82, \"reason\": \"lastParticipantLeft\", \"users\": { \"numberOfElements\": 1, \"content\": [ { \"id\": \"6596FB7B9D1A7C25\", \"location\": \"Mumbai, India\", \"platform\": \"Chrome 72.0.3626.109 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1554191765994, \"destroyedAt\": 1554191848249, \"connectionId\": \"bahnv2b0n5fxbohy\", \"clientData\": \"\", \"serverData\": \"\", \"duration\": 82, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848247, \"startTime\": 1554191767577, \"duration\": 80, \"reason\": \"disconnect\", \"streamId\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"videoSource\": \"CAMERA\", \"videoFramerate\": -1, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"elastic_type\": \"publisherSummary\" } ] }, \"subscribers\": { \"numberOfElements\": 0, \"content\": [] }, \"geoPoints\": \"19.09,72.87\", \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"timestamp\": 1554191848252, \"elastic_type\": \"connectionSummary\" } ] }, \"session\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848252, \"elastic_type\": \"userSummary\" } ] }, \"recordings\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191784531, \"startTime\": 1554191770662, \"duration\": 9.734, \"reason\": \"recordingStoppedByServer\", \"id\": \"weih6kaewklr4i05\", \"name\": \"RecordingTest\", \"outputMode\": \"COMPOSED\", \"resolution\": \"1920x1080\", \"recordingLayout\": \"BEST_FIT\", \"hasAudio\": true, \"hasVideo\": true, \"size\": 1968384, \"elastic_type\": \"recordingSummary\" } ] } } { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191784531, \"startTime\": 1554191770662, \"duration\": 9.734, \"reason\": \"recordingStoppedByServer\", \"id\": \"weih6kaewklr4i05\", \"name\": \"RecordingTest\", \"outputMode\": \"COMPOSED\", \"resolution\": \"1920x1080\", \"recordingLayout\": \"BEST_FIT\", \"hasAudio\": true, \"hasVideo\": true, \"size\": 1968384, \"elastic_type\": \"recordingSummary\" } { \"id\": \"6596FB7B9D1A7C25\", \"location\": \"Mumbai, India\", \"platform\": \"Chrome 72.0.3626.109 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1554191765994, \"destroyedAt\": 1554191848249, \"connectionId\": \"bahnv2b0n5fxbohy\", \"clientData\": \"\", \"serverData\": \"\", \"duration\": 82, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848247, \"startTime\": 1554191767577, \"duration\": 80, \"reason\": \"disconnect\", \"streamId\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"videoSource\": \"CAMERA\", \"videoFramerate\": -1, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"elastic_type\": \"publisherSummary\" } ] }, \"subscribers\": { \"numberOfElements\": 0, \"content\": [] }, \"geoPoints\": \"19.09,72.87\", \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"timestamp\": 1554191848252, \"elastic_type\": \"connectionSummary\" } ] }, \"session\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848252, \"elastic_type\": \"userSummary\" } { \"createdAt\": 1554191765994, \"destroyedAt\": 1554191848249, \"connectionId\": \"bahnv2b0n5fxbohy\", \"clientData\": \"\", \"serverData\": \"\", \"duration\": 82, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848247, \"startTime\": 1554191767577, \"duration\": 80, \"reason\": \"disconnect\", \"streamId\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"videoSource\": \"CAMERA\", \"videoFramerate\": -1, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"elastic_type\": \"publisherSummary\" } ] }, \"subscribers\": { \"numberOfElements\": 0, \"content\": [] }, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"timestamp\": 1554191848252, \"elastic_type\": \"connectionSummary\" } { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848247, \"startTime\": 1554191767577, \"duration\": 80, \"reason\": \"disconnect\", \"streamId\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"videoSource\": \"CAMERA\", \"videoFramerate\": -1, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"elastic_type\": \"publisherSummary\" } { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1553694100398, \"startTime\": 1553693956035, \"duration\": 144, \"reason\": \"disconnect\", \"streamId\": \"dbslbhe2jzhhybvj_CAMERA_CSBVI\", \"receivingFrom\": \"dbslbhe2jzhhybvj\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"TestSession\", \"user\": \"A06BB386A40BBC83\", \"connection\": \"c1tgrtyzlmeix6l3\", \"elastic_type\": \"subscriberSummary\" } cdr : event of CDR/Webhook. Can take multiple forms according to the type of event (see OpenVidu CDR ) kms : Kurento Media Server event. These events are always associated to one WebRTC endpoint (a publisher or a subscriber). Can take multiple forms according to the type of event (see Kurento docs ) monitoringStats : event of CPU, memory and network statistics usage of OpenVidu Pro host webrtcStats : event of WebRTC statistics for each media endpoint established in Kurento Media Server sessionSummary : summary of a session, stored once it is closed recordingSummary : summary of a recording, stored once its session is closed userSummary : summary of a user, stored once its session is closed connectionSummary : summary of a connection, stored once its session is closed publisherSummary : summary of a publisher, stored once its session is closed subscriberSummary : summary of a subscriber, stored once its session is closed cdr kms monitoringStats webrtcStats sessionSummary recordingSummary userSummary connectionSummary publisherSummary subscriberSummary { \"sessionId\": \"TestSession\", \"timestamp\": 1582277160836, \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"participantId\": \"con_XZvrQOF5Du\", \"connection\": \"OUTBOUND\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"event\": \"webrtcConnectionCreated\", \"elastic_type\": \"cdr\" } { \"state\": \"FLOWING\", \"padName\": \"default\", \"mediaType\": \"VIDEO\", \"type\": \"MediaFlowOutStateChange\", \"timestamp\": 1582277162316, \"sessionId\": \"TestSession\", \"user\": \"70558CA23053A8E9\", \"connection\": \"con_XZvrQOF5Du\", \"endpoint\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"msSinceEndpointCreation\": 1480, \"elastic_type\": \"kms\" } { \"timestamp\": 1582276785036, \"cpu\": 15.919558359621451, \"mem\": { \"used\": 7667204, \"percentage\": 47.48673231102802 }, \"net\": { \"veth0c3780f\": { \"rxBytes\": 0, \"txBytes\": 1210 }, \"wlp58s0\": { \"rxBytes\": 1487510, \"txBytes\": 442145 } }, \"elastic_type\": \"monitoringStats\" } { \"sessionId\": \"TestSession\", \"user\": \"70558CA23053A8E9\", \"connection\": \"con_XZvrQOF5Du\", \"endpoint\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"mediaType\": \"video\", \"jitter\": 0.004166666883975267, \"bytesReceived\": 17703914, \"packetsReceived\": 17169, \"packetsLost\": 0, \"timestamp\": 1582277310832, \"fractionLost\": 0, \"remb\": 1000000, \"firCount\": 2, \"pliCount\": 0, \"nackCount\": 0, \"sliCount\": 0, \"elastic_type\": \"webrtcStats\" } { \"createdAt\": 1582277158591, \"destroyedAt\": 1582277414413, \"sessionId\": \"TestSession\", \"customSessionId\": \"TestSession\", \"mediaMode\": \"ROUTED\", \"recordingMode\": \"MANUAL\", \"duration\": 255, \"reason\": \"lastParticipantLeft\", \"users\": { \"numberOfElements\": 2, \"content\": [ { \"id\": \"7636DE7CA51A6EEC\", \"location\": \"Rome, Italy\", \"platform\": \"Chrome 80.0.3987.116 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1582277341959, \"destroyedAt\": 1582277414401, \"connectionId\": \"con_DdZXrn4e2i\", \"clientData\": \"TestClient\", \"serverData\": \"\", \"duration\": 72, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 0, \"content\": [] }, \"subscribers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277412497, \"startTime\": 1582277342542, \"duration\": 69, \"reason\": \"unsubscribe\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"receivingFrom\": \"con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"7636DE7CA51A6EEC\", \"connection\": \"con_DdZXrn4e2i\", \"elastic_type\": \"subscriberSummary\" } ] }, \"sessionId\": \"TestSession\", \"user\": \"7636DE7CA51A6EEC\", \"timestamp\": 1582277414413, \"elastic_type\": \"connectionSummary\" } ] }, \"sessionId\": \"TestSession\", \"timestamp\": 1582277414413, \"elastic_type\": \"userSummary\" }, { \"id\": \"70558CA23053A8E9\", \"location\": \"Buenos Aires, Argentina\", \"platform\": \"Chrome 80.0.3987.116 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1582277159216, \"destroyedAt\": 1582277414295, \"connectionId\": \"con_XZvrQOF5Du\", \"clientData\": \"TestClient\", \"serverData\": \"\", \"duration\": 255, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277414254, \"startTime\": 1582277160836, \"duration\": 253, \"reason\": \"disconnect\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"70558CA23053A8E9\", \"connection\": \"con_XZvrQOF5Du\", \"elastic_type\": \"publisherSummary\" } ] }, \"subscribers\": { \"numberOfElements\": 0, \"content\": [] }, \"sessionId\": \"TestSession\", \"user\": \"70558CA23053A8E9\", \"timestamp\": 1582277414413, \"elastic_type\": \"connectionSummary\" } ] }, \"sessionId\": \"TestSession\", \"timestamp\": 1582277414413, \"elastic_type\": \"userSummary\" } ] }, \"recordings\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277407182, \"startTime\": 1582277358067, \"duration\": 0, \"reason\": \"recordingStoppedByServer\", \"id\": \"TestSession\", \"name\": \"TestSession\", \"outputMode\": \"INDIVIDUAL\", \"hasAudio\": true, \"hasVideo\": false, \"size\": 0, \"elastic_type\": \"recordingSummary\" } ] }, \"timestamp\": 1582277414413, \"elastic_type\": \"sessionSummary\" } { \"sessionId\": \"TestSession\", \"timestamp\": 1582242127579, \"startTime\": 1582242114891, \"duration\": 568.8, \"reason\": \"recordingStoppedByServer\", \"id\": \"TestSession\", \"name\": \"RecordingTest\", \"outputMode\": \"COMPOSED\", \"resolution\": \"1280x720\", \"recordingLayout\": \"BEST_FIT\", \"hasAudio\": true, \"hasVideo\": true, \"size\": 38999950, \"elastic_type\": \"recordingSummary\" } { \"id\": \"7636DE7CA51A6EEC\", \"location\": \"Rome, Italy\", \"platform\": \"Chrome 80.0.3987.116 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1582277341959, \"destroyedAt\": 1582277414401, \"connectionId\": \"con_DdZXrn4e2i\", \"clientData\": \"TestClient\", \"serverData\": \"\", \"duration\": 72, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 0, \"content\": [] }, \"subscribers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277412497, \"startTime\": 1582277342542, \"duration\": 69, \"reason\": \"unsubscribe\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"receivingFrom\": \"con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"7636DE7CA51A6EEC\", \"connection\": \"con_DdZXrn4e2i\", \"elastic_type\": \"subscriberSummary\" } ] }, \"sessionId\": \"TestSession\", \"user\": \"7636DE7CA51A6EEC\", \"timestamp\": 1582277414413, \"elastic_type\": \"connectionSummary\" } ] }, \"sessionId\": \"TestSession\", \"timestamp\": 1582277414413, \"elastic_type\": \"userSummary\" } { \"createdAt\": 1582277341959, \"destroyedAt\": 1582277414401, \"connectionId\": \"con_DdZXrn4e2i\", \"clientData\": \"TestClient\", \"serverData\": \"\", \"duration\": 72, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 0, \"content\": [] }, \"subscribers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277412497, \"startTime\": 1582277342542, \"duration\": 69, \"reason\": \"unsubscribe\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"receivingFrom\": \"con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"7636DE7CA51A6EEC\", \"connection\": \"con_DdZXrn4e2i\", \"elastic_type\": \"subscriberSummary\" } ] }, \"sessionId\": \"TestSession\", \"user\": \"7636DE7CA51A6EEC\", \"timestamp\": 1582277414413, \"elastic_type\": \"connectionSummary\" } { \"sessionId\": \"TestSession\", \"timestamp\": 1582277414254, \"startTime\": 1582277160836, \"duration\": 253, \"reason\": \"disconnect\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"70558CA23053A8E9\", \"connection\": \"con_XZvrQOF5Du\", \"elastic_type\": \"publisherSummary\" } { \"sessionId\": \"TestSession\", \"timestamp\": 1582277412497, \"startTime\": 1582277342542, \"duration\": 69, \"reason\": \"unsubscribe\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"receivingFrom\": \"con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"7636DE7CA51A6EEC\", \"connection\": \"con_DdZXrn4e2i\", \"elastic_type\": \"subscriberSummary\" } NOTE 1 : sessionSummary contains all the information available in the rest of summary documents, including an array of recordingSummary and an array of userSummary . In turn userSummary contains an array of connectionSummary , that finally contains an array of publisherSummary and other of subscriberSummary . To sum up, this is just a denormalization of the sessionSummary document, so Elasticsearch requests and Kibana visualizations are more flexible and easier to accomplish NOTE 2 : recordingSummary events may not contain the final information of the actual recordings (specifically properties size and duration ). This is so because recordingSummary event is generated just after its session is closed, but since release 2.11.0 recordings may need a post-processing phase before being available for download and having these properties properly defined. To overcome this limitation, you can simply use the cdr event of type recordingStatusChanged and status ready corresponding to this recording (see event in CDR docs ). There you will have all properties of the recording well defined You can create powerful visualizations and dashboards by using these documents. Let's see a quick example. Imagine that you are interested in knowing how many users are connected to your OpenVidu sessions over time . First thing is navigating to Visualize section in Kibana and clicking on the button to add a new visualization Then we have to choose a visualization type. In this case a vertical bar graph might be a pretty good choice We select openvidu index, because that's the index of every OpenVidu Pro event stored in Elasticsearch The visualization page will be shown. Now we have to filter the desired events. In this case, we just want the userSummary event, as it gathers all the information about the final users connecting to our sessions. So, we make sure that field elastic_type.keyword is userSummary Finally we have to configure the data passed to our graph. The metric we want (Y-axis) is simply Count , because there is one \"userSummary\" event for each final user connecting to a session. And as Bucket (X-axis) we configure a Date Histogram by using timestamp field of the event To store the new visualization just click on Save button in the upper menu and give it a meaningful name The example above is a very simple visualization, but you can apply any metric to any property (or set of properties) of any event (or set of events). You can explore pre-existing visualizations included by default in OpenVidu Pro, and for further info visit Kibana docs function changeVersion(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.getAttribute('title'); var txt = txt.replace(/\\./g, ''); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of version buttons if (child.classList.contains('version-buttons')) { for (var j = 0; j < child.children.length; j++) { var a = child.children[j]; if (a === event.target) { a.classList.add('pressed-btn'); } else { a.classList.remove('pressed-btn'); } } } } // Change visibility of version content var list = document.getElementsByClassName('event-container'); for (var i = 0; i < list.length; i++) { if (list[i].id === 'list-' + txt) { list[i].style.display = 'block'; } else { list[i].style.display = 'none'; } } } function changeLangTab(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.textContent || event.target.innerText; var txt = txt.replace(/\\s/g, \"-\").toLowerCase(); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of language buttons if (child.classList.contains('lang-tabs-header')) { for (var j = 0; j < child.children.length; j++) { var btn = child.children[j]; if (btn.classList.contains('lang-tabs-btn')) { btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9'; btn.style.fontWeight = btn === event.target ? 'bold' : 'normal'; } } } // Change visibility of language content if (child.classList.contains('lang-tabs-content')) { if (child.id === txt) { child.style.display = 'block'; } else { child.style.display = 'none'; } } } } $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.slick-captions').slick({ asNavFor: '.pro-gallery-steps', arrows: false, infinite: false, speed: 200, fade: true, dots: false }); $('.pro-gallery-steps').slick({ asNavFor: '.slick-captions', autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', infinite: false, dots: true, responsive: [ { breakpoint: 768, settings: { arrows: true, slidesToShow: 1 } }, ] });","title":"Detailed session monitoring"},{"location":"openvidu-pro/detailed-session-monitoring/#openvidu-sessions-dahsboard","text":"This dashboard presents a summary of your video sessions and the server resources usage. That includes: CPU and memory usage of the server The number of session per day The location of your users The number of publishers and subscribers you have at any time The total streamed minutes over time Some low-level interesting stats related to the media connections The last point includes things like the average time to select a pair candidate during the negotiation process, the average milliseconds your clients take to complete the ICE gathering process with OpenVidu Server, the ratio of successful and failed connections, and some WebRTC stats for your published and subscribed streams (Jitter, packet loss, Round-Trip-Time, target bitrate...) All in all, this information will help you understand better the behavior and performance of your sessions.","title":"OpenVidu Sessions dahsboard"},{"location":"openvidu-pro/detailed-session-monitoring/#openvidu-recordings-dahsboard","text":"This dashboard presents at a glance the status of your recordings. It includes information such as: The total number of recordings per day Average duration and size of your recorded files The distributions of you recordings by duration and size The ratio of recordings according to their output mode ( COMPOSED or INDIVIDUAL recordings) and their recorded tracks ( audio/video recordings )","title":"OpenVidu Recordings dahsboard"},{"location":"openvidu-pro/detailed-session-monitoring/#accessing-kibana","text":"OpenVidu Pro serves Kibana through path /kibana . So, if you have deployed OpenVidu Pro with domain my.domain.com , you will be able to access OpenVidu Inspector through https://my.domain.com/inspector and Kibana through https://my.domain.com/kibana This path is secured with Basic Auth, so when connecting to it for the first time you will have to enter the user and password specified when deploying OpenVidu Pro.","title":"Accessing Kibana"},{"location":"openvidu-pro/detailed-session-monitoring/#creating-your-own-visualizations-and-dashboards","text":"The dashboards presented above, by default included in OpenVidu Pro, are just an example of what can be done thanks to Kibana. You can create your own visualizations, and set up your very own dashboards with them. To do so, you have available multiple events that OpenVidu Pro periodically stores in Elasticsearch, and you can then use them in Kibana to compose different types of graphs and other useful visual representations. Each one of these events stored by OpenVidu Pro in Elasticsearch has an elastic_type field to identify the specific type of event. This field may be: 2.9.0 / 2.10.0 / 2.11.0 2.12.0 cdr : event of CDR/Webhook. Can take multiple forms according to the type of event (see OpenVidu CDR ) kms : Kurento Media Server event. These events are always associated to one WebRTC endpoint (a publisher or a subscriber). Can take multiple forms according to the type of event (see Kurento docs ) monitoringStats : event of CPU, memory and network statistics usage of OpenVidu Pro host webrtcStats : event of WebRTC statistics for each media endpoint established in Kurento Media Server sessionSummary : summary of a session, stored once it is closed recordingSummary : summary of a recording, stored once its session is closed userSummary : summary of a user, stored once its session is closed connectionSummary : summary of a connection, stored once its session is closed publisherSummary : summary of a publisher, stored once its session is closed subscriberSummary : summary of a subscriber, stored once its session is closed cdr kms monitoringStats webrtcStats sessionSummary recordingSummary userSummary connectionSummary publisherSummary subscriberSummary { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848252, \"startTime\": 1554191765889, \"duration\": 82, \"reason\": \"lastParticipantLeft\", \"event\": \"sessionDestroyed\", \"elastic_type\": \"cdr\" } { \"streamId\": 1, \"componentId\": 1, \"state\": \"READY\", \"type\": \"IceComponentStateChange\", \"timestamp\": 1554191839098, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"ewztvkfl8dttvcxk\", \"endpoint\": \"ewztvkfl8dttvcxk_bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"msSinceEndpointCreation\": 11104, \"elastic_type\": \"kms\" } { \"timestamp\": 1554212258873, \"cpu\": 11.887875624741168, \"mem\": { \"used\": 7287344, \"percentage\": 45.13347034796033 }, \"net\": { \"veth2b4c47c\": { \"rxBytes\": 0, \"txBytes\": 0 }, \"wlp58s0\": { \"rxBytes\": 0, \"txBytes\": 0 } }, \"elastic_type\": \"monitoringStats\" } { \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"endpoint\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"mediaType\": \"video\", \"jitter\": 0.005244444590061903, \"bytesReceived\": 6455233, \"packetsReceived\": 6666, \"packetsLost\": 0, \"timestamp\": 1554191847505, \"fractionLost\": 0, \"remb\": 533208, \"firCount\": 6, \"pliCount\": 0, \"nackCount\": 0, \"sliCount\": 0, \"elastic_type\": \"webrtcStats\" } { \"createdAt\": 1554191765889, \"destroyedAt\": 1554191848252, \"sessionId\": \"weih6kaewklr4i05\", \"customSessionId\": \"\", \"mediaMode\": \"ROUTED\", \"recordingMode\": \"MANUAL\", \"duration\": 82, \"reason\": \"lastParticipantLeft\", \"users\": { \"numberOfElements\": 1, \"content\": [ { \"id\": \"6596FB7B9D1A7C25\", \"location\": \"Mumbai, India\", \"platform\": \"Chrome 72.0.3626.109 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1554191765994, \"destroyedAt\": 1554191848249, \"connectionId\": \"bahnv2b0n5fxbohy\", \"clientData\": \"\", \"serverData\": \"\", \"duration\": 82, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848247, \"startTime\": 1554191767577, \"duration\": 80, \"reason\": \"disconnect\", \"streamId\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"videoSource\": \"CAMERA\", \"videoFramerate\": -1, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"elastic_type\": \"publisherSummary\" } ] }, \"subscribers\": { \"numberOfElements\": 0, \"content\": [] }, \"geoPoints\": \"19.09,72.87\", \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"timestamp\": 1554191848252, \"elastic_type\": \"connectionSummary\" } ] }, \"session\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848252, \"elastic_type\": \"userSummary\" } ] }, \"recordings\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191784531, \"startTime\": 1554191770662, \"duration\": 9.734, \"reason\": \"recordingStoppedByServer\", \"id\": \"weih6kaewklr4i05\", \"name\": \"RecordingTest\", \"outputMode\": \"COMPOSED\", \"resolution\": \"1920x1080\", \"recordingLayout\": \"BEST_FIT\", \"hasAudio\": true, \"hasVideo\": true, \"size\": 1968384, \"elastic_type\": \"recordingSummary\" } ] } } { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191784531, \"startTime\": 1554191770662, \"duration\": 9.734, \"reason\": \"recordingStoppedByServer\", \"id\": \"weih6kaewklr4i05\", \"name\": \"RecordingTest\", \"outputMode\": \"COMPOSED\", \"resolution\": \"1920x1080\", \"recordingLayout\": \"BEST_FIT\", \"hasAudio\": true, \"hasVideo\": true, \"size\": 1968384, \"elastic_type\": \"recordingSummary\" } { \"id\": \"6596FB7B9D1A7C25\", \"location\": \"Mumbai, India\", \"platform\": \"Chrome 72.0.3626.109 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1554191765994, \"destroyedAt\": 1554191848249, \"connectionId\": \"bahnv2b0n5fxbohy\", \"clientData\": \"\", \"serverData\": \"\", \"duration\": 82, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848247, \"startTime\": 1554191767577, \"duration\": 80, \"reason\": \"disconnect\", \"streamId\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"videoSource\": \"CAMERA\", \"videoFramerate\": -1, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"elastic_type\": \"publisherSummary\" } ] }, \"subscribers\": { \"numberOfElements\": 0, \"content\": [] }, \"geoPoints\": \"19.09,72.87\", \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"timestamp\": 1554191848252, \"elastic_type\": \"connectionSummary\" } ] }, \"session\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848252, \"elastic_type\": \"userSummary\" } { \"createdAt\": 1554191765994, \"destroyedAt\": 1554191848249, \"connectionId\": \"bahnv2b0n5fxbohy\", \"clientData\": \"\", \"serverData\": \"\", \"duration\": 82, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848247, \"startTime\": 1554191767577, \"duration\": 80, \"reason\": \"disconnect\", \"streamId\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"videoSource\": \"CAMERA\", \"videoFramerate\": -1, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"elastic_type\": \"publisherSummary\" } ] }, \"subscribers\": { \"numberOfElements\": 0, \"content\": [] }, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"timestamp\": 1554191848252, \"elastic_type\": \"connectionSummary\" } { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1554191848247, \"startTime\": 1554191767577, \"duration\": 80, \"reason\": \"disconnect\", \"streamId\": \"bahnv2b0n5fxbohy_CAMERA_XHIHV\", \"videoSource\": \"CAMERA\", \"videoFramerate\": -1, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"weih6kaewklr4i05\", \"user\": \"6596FB7B9D1A7C25\", \"connection\": \"bahnv2b0n5fxbohy\", \"elastic_type\": \"publisherSummary\" } { \"sessionId\": \"weih6kaewklr4i05\", \"timestamp\": 1553694100398, \"startTime\": 1553693956035, \"duration\": 144, \"reason\": \"disconnect\", \"streamId\": \"dbslbhe2jzhhybvj_CAMERA_CSBVI\", \"receivingFrom\": \"dbslbhe2jzhhybvj\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"session\": \"TestSession\", \"user\": \"A06BB386A40BBC83\", \"connection\": \"c1tgrtyzlmeix6l3\", \"elastic_type\": \"subscriberSummary\" } cdr : event of CDR/Webhook. Can take multiple forms according to the type of event (see OpenVidu CDR ) kms : Kurento Media Server event. These events are always associated to one WebRTC endpoint (a publisher or a subscriber). Can take multiple forms according to the type of event (see Kurento docs ) monitoringStats : event of CPU, memory and network statistics usage of OpenVidu Pro host webrtcStats : event of WebRTC statistics for each media endpoint established in Kurento Media Server sessionSummary : summary of a session, stored once it is closed recordingSummary : summary of a recording, stored once its session is closed userSummary : summary of a user, stored once its session is closed connectionSummary : summary of a connection, stored once its session is closed publisherSummary : summary of a publisher, stored once its session is closed subscriberSummary : summary of a subscriber, stored once its session is closed cdr kms monitoringStats webrtcStats sessionSummary recordingSummary userSummary connectionSummary publisherSummary subscriberSummary { \"sessionId\": \"TestSession\", \"timestamp\": 1582277160836, \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"participantId\": \"con_XZvrQOF5Du\", \"connection\": \"OUTBOUND\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"event\": \"webrtcConnectionCreated\", \"elastic_type\": \"cdr\" } { \"state\": \"FLOWING\", \"padName\": \"default\", \"mediaType\": \"VIDEO\", \"type\": \"MediaFlowOutStateChange\", \"timestamp\": 1582277162316, \"sessionId\": \"TestSession\", \"user\": \"70558CA23053A8E9\", \"connection\": \"con_XZvrQOF5Du\", \"endpoint\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"msSinceEndpointCreation\": 1480, \"elastic_type\": \"kms\" } { \"timestamp\": 1582276785036, \"cpu\": 15.919558359621451, \"mem\": { \"used\": 7667204, \"percentage\": 47.48673231102802 }, \"net\": { \"veth0c3780f\": { \"rxBytes\": 0, \"txBytes\": 1210 }, \"wlp58s0\": { \"rxBytes\": 1487510, \"txBytes\": 442145 } }, \"elastic_type\": \"monitoringStats\" } { \"sessionId\": \"TestSession\", \"user\": \"70558CA23053A8E9\", \"connection\": \"con_XZvrQOF5Du\", \"endpoint\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"mediaType\": \"video\", \"jitter\": 0.004166666883975267, \"bytesReceived\": 17703914, \"packetsReceived\": 17169, \"packetsLost\": 0, \"timestamp\": 1582277310832, \"fractionLost\": 0, \"remb\": 1000000, \"firCount\": 2, \"pliCount\": 0, \"nackCount\": 0, \"sliCount\": 0, \"elastic_type\": \"webrtcStats\" } { \"createdAt\": 1582277158591, \"destroyedAt\": 1582277414413, \"sessionId\": \"TestSession\", \"customSessionId\": \"TestSession\", \"mediaMode\": \"ROUTED\", \"recordingMode\": \"MANUAL\", \"duration\": 255, \"reason\": \"lastParticipantLeft\", \"users\": { \"numberOfElements\": 2, \"content\": [ { \"id\": \"7636DE7CA51A6EEC\", \"location\": \"Rome, Italy\", \"platform\": \"Chrome 80.0.3987.116 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1582277341959, \"destroyedAt\": 1582277414401, \"connectionId\": \"con_DdZXrn4e2i\", \"clientData\": \"TestClient\", \"serverData\": \"\", \"duration\": 72, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 0, \"content\": [] }, \"subscribers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277412497, \"startTime\": 1582277342542, \"duration\": 69, \"reason\": \"unsubscribe\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"receivingFrom\": \"con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"7636DE7CA51A6EEC\", \"connection\": \"con_DdZXrn4e2i\", \"elastic_type\": \"subscriberSummary\" } ] }, \"sessionId\": \"TestSession\", \"user\": \"7636DE7CA51A6EEC\", \"timestamp\": 1582277414413, \"elastic_type\": \"connectionSummary\" } ] }, \"sessionId\": \"TestSession\", \"timestamp\": 1582277414413, \"elastic_type\": \"userSummary\" }, { \"id\": \"70558CA23053A8E9\", \"location\": \"Buenos Aires, Argentina\", \"platform\": \"Chrome 80.0.3987.116 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1582277159216, \"destroyedAt\": 1582277414295, \"connectionId\": \"con_XZvrQOF5Du\", \"clientData\": \"TestClient\", \"serverData\": \"\", \"duration\": 255, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277414254, \"startTime\": 1582277160836, \"duration\": 253, \"reason\": \"disconnect\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"70558CA23053A8E9\", \"connection\": \"con_XZvrQOF5Du\", \"elastic_type\": \"publisherSummary\" } ] }, \"subscribers\": { \"numberOfElements\": 0, \"content\": [] }, \"sessionId\": \"TestSession\", \"user\": \"70558CA23053A8E9\", \"timestamp\": 1582277414413, \"elastic_type\": \"connectionSummary\" } ] }, \"sessionId\": \"TestSession\", \"timestamp\": 1582277414413, \"elastic_type\": \"userSummary\" } ] }, \"recordings\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277407182, \"startTime\": 1582277358067, \"duration\": 0, \"reason\": \"recordingStoppedByServer\", \"id\": \"TestSession\", \"name\": \"TestSession\", \"outputMode\": \"INDIVIDUAL\", \"hasAudio\": true, \"hasVideo\": false, \"size\": 0, \"elastic_type\": \"recordingSummary\" } ] }, \"timestamp\": 1582277414413, \"elastic_type\": \"sessionSummary\" } { \"sessionId\": \"TestSession\", \"timestamp\": 1582242127579, \"startTime\": 1582242114891, \"duration\": 568.8, \"reason\": \"recordingStoppedByServer\", \"id\": \"TestSession\", \"name\": \"RecordingTest\", \"outputMode\": \"COMPOSED\", \"resolution\": \"1280x720\", \"recordingLayout\": \"BEST_FIT\", \"hasAudio\": true, \"hasVideo\": true, \"size\": 38999950, \"elastic_type\": \"recordingSummary\" } { \"id\": \"7636DE7CA51A6EEC\", \"location\": \"Rome, Italy\", \"platform\": \"Chrome 80.0.3987.116 on Linux 64-bit\", \"connections\": { \"numberOfElements\": 1, \"content\": [ { \"createdAt\": 1582277341959, \"destroyedAt\": 1582277414401, \"connectionId\": \"con_DdZXrn4e2i\", \"clientData\": \"TestClient\", \"serverData\": \"\", \"duration\": 72, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 0, \"content\": [] }, \"subscribers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277412497, \"startTime\": 1582277342542, \"duration\": 69, \"reason\": \"unsubscribe\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"receivingFrom\": \"con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"7636DE7CA51A6EEC\", \"connection\": \"con_DdZXrn4e2i\", \"elastic_type\": \"subscriberSummary\" } ] }, \"sessionId\": \"TestSession\", \"user\": \"7636DE7CA51A6EEC\", \"timestamp\": 1582277414413, \"elastic_type\": \"connectionSummary\" } ] }, \"sessionId\": \"TestSession\", \"timestamp\": 1582277414413, \"elastic_type\": \"userSummary\" } { \"createdAt\": 1582277341959, \"destroyedAt\": 1582277414401, \"connectionId\": \"con_DdZXrn4e2i\", \"clientData\": \"TestClient\", \"serverData\": \"\", \"duration\": 72, \"reason\": \"disconnect\", \"publishers\": { \"numberOfElements\": 0, \"content\": [] }, \"subscribers\": { \"numberOfElements\": 1, \"content\": [ { \"sessionId\": \"TestSession\", \"timestamp\": 1582277412497, \"startTime\": 1582277342542, \"duration\": 69, \"reason\": \"unsubscribe\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"receivingFrom\": \"con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"7636DE7CA51A6EEC\", \"connection\": \"con_DdZXrn4e2i\", \"elastic_type\": \"subscriberSummary\" } ] }, \"sessionId\": \"TestSession\", \"user\": \"7636DE7CA51A6EEC\", \"timestamp\": 1582277414413, \"elastic_type\": \"connectionSummary\" } { \"sessionId\": \"TestSession\", \"timestamp\": 1582277414254, \"startTime\": 1582277160836, \"duration\": 253, \"reason\": \"disconnect\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"70558CA23053A8E9\", \"connection\": \"con_XZvrQOF5Du\", \"elastic_type\": \"publisherSummary\" } { \"sessionId\": \"TestSession\", \"timestamp\": 1582277412497, \"startTime\": 1582277342542, \"duration\": 69, \"reason\": \"unsubscribe\", \"streamId\": \"str_CAM_AOIa_con_XZvrQOF5Du\", \"receivingFrom\": \"con_XZvrQOF5Du\", \"videoSource\": \"CAMERA\", \"videoFramerate\": 30, \"videoDimensions\": \"{\\\"width\\\":640,\\\"height\\\":480}\", \"audioEnabled\": true, \"videoEnabled\": true, \"user\": \"7636DE7CA51A6EEC\", \"connection\": \"con_DdZXrn4e2i\", \"elastic_type\": \"subscriberSummary\" } NOTE 1 : sessionSummary contains all the information available in the rest of summary documents, including an array of recordingSummary and an array of userSummary . In turn userSummary contains an array of connectionSummary , that finally contains an array of publisherSummary and other of subscriberSummary . To sum up, this is just a denormalization of the sessionSummary document, so Elasticsearch requests and Kibana visualizations are more flexible and easier to accomplish NOTE 2 : recordingSummary events may not contain the final information of the actual recordings (specifically properties size and duration ). This is so because recordingSummary event is generated just after its session is closed, but since release 2.11.0 recordings may need a post-processing phase before being available for download and having these properties properly defined. To overcome this limitation, you can simply use the cdr event of type recordingStatusChanged and status ready corresponding to this recording (see event in CDR docs ). There you will have all properties of the recording well defined You can create powerful visualizations and dashboards by using these documents. Let's see a quick example. Imagine that you are interested in knowing how many users are connected to your OpenVidu sessions over time . First thing is navigating to Visualize section in Kibana and clicking on the button to add a new visualization Then we have to choose a visualization type. In this case a vertical bar graph might be a pretty good choice We select openvidu index, because that's the index of every OpenVidu Pro event stored in Elasticsearch The visualization page will be shown. Now we have to filter the desired events. In this case, we just want the userSummary event, as it gathers all the information about the final users connecting to our sessions. So, we make sure that field elastic_type.keyword is userSummary Finally we have to configure the data passed to our graph. The metric we want (Y-axis) is simply Count , because there is one \"userSummary\" event for each final user connecting to a session. And as Bucket (X-axis) we configure a Date Histogram by using timestamp field of the event To store the new visualization just click on Save button in the upper menu and give it a meaningful name The example above is a very simple visualization, but you can apply any metric to any property (or set of properties) of any event (or set of events). You can explore pre-existing visualizations included by default in OpenVidu Pro, and for further info visit Kibana docs function changeVersion(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.getAttribute('title'); var txt = txt.replace(/\\./g, ''); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of version buttons if (child.classList.contains('version-buttons')) { for (var j = 0; j < child.children.length; j++) { var a = child.children[j]; if (a === event.target) { a.classList.add('pressed-btn'); } else { a.classList.remove('pressed-btn'); } } } } // Change visibility of version content var list = document.getElementsByClassName('event-container'); for (var i = 0; i < list.length; i++) { if (list[i].id === 'list-' + txt) { list[i].style.display = 'block'; } else { list[i].style.display = 'none'; } } } function changeLangTab(event) { var parent = event.target.parentNode.parentNode; var txt = event.target.textContent || event.target.innerText; var txt = txt.replace(/\\s/g, \"-\").toLowerCase(); for (var i = 0; i < parent.children.length; i++) { var child = parent.children[i]; // Change appearance of language buttons if (child.classList.contains('lang-tabs-header')) { for (var j = 0; j < child.children.length; j++) { var btn = child.children[j]; if (btn.classList.contains('lang-tabs-btn')) { btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9'; btn.style.fontWeight = btn === event.target ? 'bold' : 'normal'; } } } // Change visibility of language content if (child.classList.contains('lang-tabs-content')) { if (child.id === txt) { child.style.display = 'block'; } else { child.style.display = 'none'; } } } } $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.slick-captions').slick({ asNavFor: '.pro-gallery-steps', arrows: false, infinite: false, speed: 200, fade: true, dots: false }); $('.pro-gallery-steps').slick({ asNavFor: '.slick-captions', autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', infinite: false, dots: true, responsive: [ { breakpoint: 768, settings: { arrows: true, slidesToShow: 1 } }, ] });","title":"Creating your own visualizations and dashboards"},{"location":"openvidu-pro/openvidu-inspector/","text":"OpenVidu Inspector A powerful, easy-to-use and visually attractive dashboard that will help you monitor, manage and review all your videoconferences. Some features already available in the current version of OpenVidu Pro are: Full in-depth visualization of your ongoing video sessions Review each client connected to a video session and the media streams each one is sending and receiving. Our intuitive graph visualization will give you a complete summary of your sessions. Moderation capabilities of ongoing video sessions Through OpenVidu Inspector you are able to administrate your video sessions just by pressing buttons: cut the video or audio of any publisher, force the disconnection of any participant, start and stop the recording of any video session and close them whenever you want. Recording management OpenVidu Inspector allows you to review all your recordings in a simple way. Preview them, download them or delete those you don't need anymore. Just with a couple of clicks. Session history Every OpenVidu session event-flow is stored with great detail in OpenVidu Pro. This way you can review any past session in OpenVidu Inspector: its duration, the total streaming time, the users connected to it, who published and subscribed, the recordings started for the session... Lots of data to analyse your sessions once they are closed. Cluster management OpenVidu Pro provides clustering features for scalable video sessions. You can manage your cluster from OpenVidu Inspector, launching and dropping Media Nodes with the click of a button to adapt your cluster according to user load. Client geographic location OpenVidu Pro is able to locate your clients by city and country to make easier the identification of the users connecting to your sessions. You can consult this property to OpenVidu Server whenever you want with REST API or any server SDK. You also have available this info in OpenVidu Inspector: This product includes GeoLite2 data created by MaxMind, available from http://www.maxmind.com Programmatic reset OpenVidu Pro supports programmatic reset. You may call a REST API method to restart your OpenVidu Server process. This way you can: A) Change OpenVidu Server configuration properties B) Easily clean up any garbage process or file that may have been stranded You may also restart OpenVidu Server Pro directly in OpenVidu Inspector: $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.pro-gallery').slick({ autoplay: true, arrows: false, autoplaySpeed: 3000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] });","title":"OpenVidu Inspector"},{"location":"openvidu-pro/openvidu-inspector/#full-in-depth-visualization-of-your-ongoing-video-sessions","text":"Review each client connected to a video session and the media streams each one is sending and receiving. Our intuitive graph visualization will give you a complete summary of your sessions.","title":"Full in-depth visualization of your ongoing video sessions"},{"location":"openvidu-pro/openvidu-inspector/#moderation-capabilities-of-ongoing-video-sessions","text":"Through OpenVidu Inspector you are able to administrate your video sessions just by pressing buttons: cut the video or audio of any publisher, force the disconnection of any participant, start and stop the recording of any video session and close them whenever you want.","title":"Moderation capabilities of ongoing video sessions"},{"location":"openvidu-pro/openvidu-inspector/#recording-management","text":"OpenVidu Inspector allows you to review all your recordings in a simple way. Preview them, download them or delete those you don't need anymore. Just with a couple of clicks.","title":"Recording management"},{"location":"openvidu-pro/openvidu-inspector/#session-history","text":"Every OpenVidu session event-flow is stored with great detail in OpenVidu Pro. This way you can review any past session in OpenVidu Inspector: its duration, the total streaming time, the users connected to it, who published and subscribed, the recordings started for the session... Lots of data to analyse your sessions once they are closed.","title":"Session history"},{"location":"openvidu-pro/openvidu-inspector/#cluster-management","text":"OpenVidu Pro provides clustering features for scalable video sessions. You can manage your cluster from OpenVidu Inspector, launching and dropping Media Nodes with the click of a button to adapt your cluster according to user load.","title":"Cluster management"},{"location":"openvidu-pro/openvidu-inspector/#client-geographic-location","text":"OpenVidu Pro is able to locate your clients by city and country to make easier the identification of the users connecting to your sessions. You can consult this property to OpenVidu Server whenever you want with REST API or any server SDK. You also have available this info in OpenVidu Inspector: This product includes GeoLite2 data created by MaxMind, available from http://www.maxmind.com","title":"Client geographic location"},{"location":"openvidu-pro/openvidu-inspector/#programmatic-reset","text":"OpenVidu Pro supports programmatic reset. You may call a REST API method to restart your OpenVidu Server process. This way you can: A) Change OpenVidu Server configuration properties B) Easily clean up any garbage process or file that may have been stranded You may also restart OpenVidu Server Pro directly in OpenVidu Inspector: $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.pro-gallery').slick({ autoplay: true, arrows: false, autoplaySpeed: 3000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] });","title":"Programmatic reset"},{"location":"openvidu-pro/scalability/","text":"Scalability OpenVidu Pro architecture Pricing of an OpenVidu Pro cluster How to deploy your OpenVidu Pro cluster Set the number of Media Nodes on startup Change the number of Media Nodes on the fly OpenVidu Pro cluster events How many users can an OpenVidu Pro cluster handle Current limitations of OpenVidu Pro scalability OpenVidu Pro architecture OpenVidu Pro consists of different nodes that work together to offer OpenVidu services in a distributed and scalable way. Currently, OpenVidu Pro has two types of nodes, following a Master-Slave model: OpenVidu Server Pro Node : this is the master node. It takes care of the signaling plane . Manages OpenVidu sessions, forwarding events and messages to clients and distributing the load across the available Media Nodes. Media Nodes : these are the slave nodes, in charge of managing the media plane . For that reason, Media Nodes are the actual bottleneck of the OpenVidu cluster and the ones that determine its capacity: more Media Nodes means more concurrent OpenVidu sessions. Two important aspects of Media Nodes: Each OpenVidu session is currently hosted in one Media Node. Each Media Node can manage multiple OpenVidu sessions. Pricing of an OpenVidu Pro cluster The price of an OpenVidu Pro cluster is rather simple: You pay 0.0006$ per core per minute in your OpenVidu Pro cluster There are 3 important aspects to consider: You only pay for your OpenVidu Pro cluster for the time it is running. Usage will be registered the moment you start your cluster and will stop as soon as you shut your cluster down. You pay for every available core at any given time: if you cluster grows for one hour, that hour you will pay more. If your cluster decreases the next hour, next hour will be cheaper. Currently all Nodes have the same core per minute price. Your cluster (specifically your OpenVidu Server Pro Node) needs Internet access at all times. If your specific use case doesn't allow your cluster to have Internet access, please contact us through Commercial page . In Pricing section you will find a detailed with different use cases of OpenVidu Pro clusters and their associated cost depending on their size and running time How to deploy your OpenVidu Pro cluster Different environments are supported when deploying an OpenVidu Pro cluster. At the current moment you can: Deploy your OpenVidu Pro cluster in AWS Deploy your OpenVidu Pro cluster on premises in your own infrastructure We are currently working to natively support other cloud providers such as Azure , Google Cloud and Digital Ocean the same way we support Amazon. But remember you are still able to deploy OpenVidu Pro wherever you want following the guide of deployment on premise Kubernetes support will also be available soon. Stay tuned! Set the number of Media Nodes on startup When deploying your OpenVidu Pro cluster, you can set the initial desired number of Media Nodes. Each type of deployment has a way of setting this number. Visit your specific OpenVidu Pro cluster deployment instructions to learn more: AWS On premise Change the number of Media Nodes on the fly You can launch and drop Media Nodes dynamically in two different ways: From OpenVidu Inspector In Cluster page you can launch and drop Media Nodes just by pressing buttons. With OpenVidu Pro REST API You can programmatically launch and drop Media Nodes from your application by consuming OpenVidu Pro REST API. Launch a Media Node : POST /pro/media-nodes Drop a Media Node : DELETE /pro/media-nodes WARNING : depending on the environment where your OpenVidu Pro cluster is deployed, you must take into account some important aspects regarding the launch and drop of Media Nodes. Visit the specific documentation page for your environment to learn more: AWS On premise OpenVidu Pro cluster events OpenVidu Pro provides an specific server-side event that will inform you every time there is a change in the status of the cluster. You can listen to this event by using OpenVidu Webhook (it will also be registered in OpenVidu CDR ). This event is mediaNodeStatusChanged . By listening to it you will have a complete record of your OpenVidu Pro cluster behavior in real time. And of course you can always use OpenVidu Pro REST API to retrieve the status of the whole cluster at any time. Media Node statuses Here are all the possible statuses of a Media Node within an OpenVidu Pro cluster. launching : the Media Node is launching failed : the Media Node failed to launch. This status can be reached from launching status. running : the Media Node is up and running. New sessions can now be established in this Media Node. This status can be reached from launching and waiting-idle-to-terminate statuses. waiting-idle-to-terminate : the Media Node is waiting until the last of its sessions is closed. Once this happens, it will automatically enter terminating status. The Media Node won't accept new sessions during this status. This status can be reached from running status. terminating : the Media Node is shutting down. This status can be reached from running and waiting-idle-to-terminate statuses. terminated : the Media Node is shut down. This status can be reached from terminating status. For OpenVidu Pro clusters running in manual mode ( property openvidu.pro.cluster.mode set to manual ), this status means that the Media Node instance can be safely shut down. How many users can an OpenVidu Pro cluster handle This is probably one of the most important questions when using OpenVidu Pro. The number of Media Nodes you need and the size of each Media Node depends on the answer. Therefore, the price of your OpenVidu Pro cluster also depends on the answer. That being said, there is no single answer to this question. The load each Media Node can handle depends on many factors: The topology of each OpenVidu Session (1:1, 1:N, N:M) The type of media streams being published to the Session (only audio, only video, audio + video) Whether your Sessions are using advanced features such as recording or audio/video filters You will need to perform some tests for your specific use case, and adapt the size of your cluster accordingly. OpenVidu team can perform these tests for you as part of their commercial services (contact us through Commercial page to ask for an estimate). For a quick reference, these are the results of some load tests performed in an OpenVidu Pro cluster deployed on Amazon Web Services with just 1 Media Node. These particular scenario is testing 7-to-7 sessions where every participant sends one audio-video stream (540x360, 30 fps) and receives 6 remote streams (same video). The table states the maximum number of entities that can be established until the Media Node CPU reaches 100% use. Take into account from a pricing point that the number of cores in each column header does not sum up the total number of cores of the cluster (OpenVidu Server Pro Node cores should also be counted). Here you can find the full article presenting these results. Current limitations of OpenVidu Pro scalability Below are stated the current limitations regarding the scalability of an OpenVidu Pro cluster. All of them are currently in our roadmap, and will be for sure addressed in future releases. Composed video recording is not scalable Right now composed recordings with video are hosted in OpenVidu Server Pro node, which means that launching multiple simultaneous composed recordings may increase the load on this node to a dangerous point. So a necessary change to improve scalability for this particular use case is to get this module out of OpenVidu Server Pro Node. For the moment, we recommend limiting the number of simultaneous composed recordings with video and using a more powerful machine in OpenVidu Server Pro Node if required. This doesn't affect either individual recordings or composed recordings with audio-only. Sessions cannot be moved between Media Nodes Current scalability features doesn't support dynamic migration of OpenVidu Sessions between Media Nodes. Once a Session is initialized inside a Media Node, it will remain there until it is closed. We will work to support Session migration between Media Nodes to A) improve fault tolerance upon the possibility of a Media Node crashing and B) make easier the scale-down process of your OpenVidu Pro cluster, so you don't have to wait until all Sessions inside a Media Node are closed to drop that Media Node from the cluster. There is no automatic elasticity yet The automated scale-in and scale-out of Media Nodes according to server load is an important feature that OpenVidu Pro will provide in the future. This way you will be able to configure your OpenVidu Pro cluster to automatically launch new Media Nodes when the CPU load of the existing ones reaches certain point, and drop Media Nodes when CPU load decreases. $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Scalability"},{"location":"openvidu-pro/scalability/#openvidu-pro-architecture","text":"OpenVidu Pro consists of different nodes that work together to offer OpenVidu services in a distributed and scalable way. Currently, OpenVidu Pro has two types of nodes, following a Master-Slave model: OpenVidu Server Pro Node : this is the master node. It takes care of the signaling plane . Manages OpenVidu sessions, forwarding events and messages to clients and distributing the load across the available Media Nodes. Media Nodes : these are the slave nodes, in charge of managing the media plane . For that reason, Media Nodes are the actual bottleneck of the OpenVidu cluster and the ones that determine its capacity: more Media Nodes means more concurrent OpenVidu sessions. Two important aspects of Media Nodes: Each OpenVidu session is currently hosted in one Media Node. Each Media Node can manage multiple OpenVidu sessions.","title":"OpenVidu Pro architecture"},{"location":"openvidu-pro/scalability/#pricing-of-an-openvidu-pro-cluster","text":"The price of an OpenVidu Pro cluster is rather simple: You pay 0.0006$ per core per minute in your OpenVidu Pro cluster There are 3 important aspects to consider: You only pay for your OpenVidu Pro cluster for the time it is running. Usage will be registered the moment you start your cluster and will stop as soon as you shut your cluster down. You pay for every available core at any given time: if you cluster grows for one hour, that hour you will pay more. If your cluster decreases the next hour, next hour will be cheaper. Currently all Nodes have the same core per minute price. Your cluster (specifically your OpenVidu Server Pro Node) needs Internet access at all times. If your specific use case doesn't allow your cluster to have Internet access, please contact us through Commercial page . In Pricing section you will find a detailed with different use cases of OpenVidu Pro clusters and their associated cost depending on their size and running time","title":"Pricing of an OpenVidu Pro cluster"},{"location":"openvidu-pro/scalability/#how-to-deploy-your-openvidu-pro-cluster","text":"Different environments are supported when deploying an OpenVidu Pro cluster. At the current moment you can: Deploy your OpenVidu Pro cluster in AWS Deploy your OpenVidu Pro cluster on premises in your own infrastructure We are currently working to natively support other cloud providers such as Azure , Google Cloud and Digital Ocean the same way we support Amazon. But remember you are still able to deploy OpenVidu Pro wherever you want following the guide of deployment on premise Kubernetes support will also be available soon. Stay tuned!","title":"How to deploy your OpenVidu Pro cluster"},{"location":"openvidu-pro/scalability/#set-the-number-of-media-nodes-on-startup","text":"When deploying your OpenVidu Pro cluster, you can set the initial desired number of Media Nodes. Each type of deployment has a way of setting this number. Visit your specific OpenVidu Pro cluster deployment instructions to learn more: AWS On premise","title":"Set the number of Media Nodes on startup"},{"location":"openvidu-pro/scalability/#change-the-number-of-media-nodes-on-the-fly","text":"You can launch and drop Media Nodes dynamically in two different ways:","title":"Change the number of Media Nodes on the fly"},{"location":"openvidu-pro/scalability/#from-openvidu-inspector","text":"In Cluster page you can launch and drop Media Nodes just by pressing buttons.","title":"From OpenVidu Inspector"},{"location":"openvidu-pro/scalability/#with-openvidu-pro-rest-api","text":"You can programmatically launch and drop Media Nodes from your application by consuming OpenVidu Pro REST API. Launch a Media Node : POST /pro/media-nodes Drop a Media Node : DELETE /pro/media-nodes WARNING : depending on the environment where your OpenVidu Pro cluster is deployed, you must take into account some important aspects regarding the launch and drop of Media Nodes. Visit the specific documentation page for your environment to learn more: AWS On premise","title":"With OpenVidu Pro REST API"},{"location":"openvidu-pro/scalability/#openvidu-pro-cluster-events","text":"OpenVidu Pro provides an specific server-side event that will inform you every time there is a change in the status of the cluster. You can listen to this event by using OpenVidu Webhook (it will also be registered in OpenVidu CDR ). This event is mediaNodeStatusChanged . By listening to it you will have a complete record of your OpenVidu Pro cluster behavior in real time. And of course you can always use OpenVidu Pro REST API to retrieve the status of the whole cluster at any time.","title":"OpenVidu Pro cluster events"},{"location":"openvidu-pro/scalability/#media-node-statuses","text":"Here are all the possible statuses of a Media Node within an OpenVidu Pro cluster. launching : the Media Node is launching failed : the Media Node failed to launch. This status can be reached from launching status. running : the Media Node is up and running. New sessions can now be established in this Media Node. This status can be reached from launching and waiting-idle-to-terminate statuses. waiting-idle-to-terminate : the Media Node is waiting until the last of its sessions is closed. Once this happens, it will automatically enter terminating status. The Media Node won't accept new sessions during this status. This status can be reached from running status. terminating : the Media Node is shutting down. This status can be reached from running and waiting-idle-to-terminate statuses. terminated : the Media Node is shut down. This status can be reached from terminating status. For OpenVidu Pro clusters running in manual mode ( property openvidu.pro.cluster.mode set to manual ), this status means that the Media Node instance can be safely shut down.","title":"Media Node statuses"},{"location":"openvidu-pro/scalability/#how-many-users-can-an-openvidu-pro-cluster-handle","text":"This is probably one of the most important questions when using OpenVidu Pro. The number of Media Nodes you need and the size of each Media Node depends on the answer. Therefore, the price of your OpenVidu Pro cluster also depends on the answer. That being said, there is no single answer to this question. The load each Media Node can handle depends on many factors: The topology of each OpenVidu Session (1:1, 1:N, N:M) The type of media streams being published to the Session (only audio, only video, audio + video) Whether your Sessions are using advanced features such as recording or audio/video filters You will need to perform some tests for your specific use case, and adapt the size of your cluster accordingly. OpenVidu team can perform these tests for you as part of their commercial services (contact us through Commercial page to ask for an estimate). For a quick reference, these are the results of some load tests performed in an OpenVidu Pro cluster deployed on Amazon Web Services with just 1 Media Node. These particular scenario is testing 7-to-7 sessions where every participant sends one audio-video stream (540x360, 30 fps) and receives 6 remote streams (same video). The table states the maximum number of entities that can be established until the Media Node CPU reaches 100% use. Take into account from a pricing point that the number of cores in each column header does not sum up the total number of cores of the cluster (OpenVidu Server Pro Node cores should also be counted). Here you can find the full article presenting these results.","title":"How many users can an OpenVidu Pro cluster handle"},{"location":"openvidu-pro/scalability/#current-limitations-of-openvidu-pro-scalability","text":"Below are stated the current limitations regarding the scalability of an OpenVidu Pro cluster. All of them are currently in our roadmap, and will be for sure addressed in future releases.","title":"Current limitations of OpenVidu Pro scalability"},{"location":"openvidu-pro/scalability/#composed-video-recording-is-not-scalable","text":"Right now composed recordings with video are hosted in OpenVidu Server Pro node, which means that launching multiple simultaneous composed recordings may increase the load on this node to a dangerous point. So a necessary change to improve scalability for this particular use case is to get this module out of OpenVidu Server Pro Node. For the moment, we recommend limiting the number of simultaneous composed recordings with video and using a more powerful machine in OpenVidu Server Pro Node if required. This doesn't affect either individual recordings or composed recordings with audio-only.","title":"Composed video recording is not scalable"},{"location":"openvidu-pro/scalability/#sessions-cannot-be-moved-between-media-nodes","text":"Current scalability features doesn't support dynamic migration of OpenVidu Sessions between Media Nodes. Once a Session is initialized inside a Media Node, it will remain there until it is closed. We will work to support Session migration between Media Nodes to A) improve fault tolerance upon the possibility of a Media Node crashing and B) make easier the scale-down process of your OpenVidu Pro cluster, so you don't have to wait until all Sessions inside a Media Node are closed to drop that Media Node from the cluster.","title":"Sessions cannot be moved between Media Nodes"},{"location":"openvidu-pro/scalability/#there-is-no-automatic-elasticity-yet","text":"The automated scale-in and scale-out of Media Nodes according to server load is an important feature that OpenVidu Pro will provide in the future. This way you will be able to configure your OpenVidu Pro cluster to automatically launch new Media Nodes when the CPU load of the existing ones reaches certain point, and drop Media Nodes when CPU load decreases. $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"There is no automatic elasticity yet"},{"location":"openvidu-pro/deployment/aws/","text":"Deploying OpenVidu Pro on AWS Deployment instructions 1) Access to the console of AWS Cloud Formation 2) Select 'Create Stack' \ud83e\udc1a 'With new resources' 3) Option 'Specify template' \ud83e\udc1a 'Amazon S3 URL' with the following URL 4) Specify stack details 5) Create your stack Scalability Set the number of Media Nodes on startup Change the number of Media Nodes on the fly Updating OpenVidu Pro configuration Troubleshooting OpenVidu Pro in AWS Marketplace Before deploying OpenVidu Pro you need to create an OpenVidu account to get your license key. There's a 15 day free trial waiting for you! Deployment instructions 1) Access to the console of AWS Cloud Formation Go to CloudFormation 2) Select Create Stack \ud83e\udc1a With new resources 3) Option Specify template \ud83e\udc1a Amazon S3 URL with the following URL https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-Pro-latest.yaml Copy 4. Specify stack details First of all, indicate a name for your deployment. Next fill each section of the Parameters formulary: OpenVidu Pro License Your OpenVidu Pro License key. You need an OpenVidu account to purchase it. There's a 15 day free trial waiting for you! SSL certificate configuration Configuration for your CloudFormation stack certificate. We provide 3 different scenarios: you can use the default SELF-SIGNED CERTIFICATE stored in the application (users will need to accept the browser security alert) or if you have a custom domain, either allow LET'S ENCRYPT to automatically generate a valid and free certificate for your domain or use your own CUSTOM CERTIFICATE if you already have one. Self-Signed certificate Let's Encrypt certificate Custom certificate Choose the certificate selfsigned letsencrypt owncert Email for Let's Encrypt certification authority Your choice My domain name Your fully qualified domain For example: if your full URL is https://openvidu.io/ then this is openvidu.io Your fully qualified domain For example: if your full URL is https://openvidu.io/ then this is openvidu.io Public elastic IP (EIP) One AWS Elastic IP you generated (check AWS Docs to generate a new one) One AWS Elastic IP you generated (check AWS Docs to generate a new one) URL to the CRT file URL to your public key file The CloudFormation stack must have access to this URL, at least temporarily URL to the key file URL to your private key file The CloudFormation stack must have access to this URL, at least temporarily If you are using LET'S ENCRYPT CERTIFICATE , of course you will need to register your ElasticIP in your DNS hosting service and associate it with the fully qualified domain name. Until your domain name is not accessible through the public IP you chose, this deployment won't work OpenVidu CE configuration Configuration properties specific for OpenVidu Server CE . You have a complete description of all available properties here . OpenVidu Pro configuration Configuration properties specific for OpenVidu Server Pro . You have a complete description of all available properties here . Kibana configuration Username and password for the Kibana service deployed with OpenVidu Pro. You will need these credentials for later access to the Kibana dashboard of your OpenVidu Pro deployment. Visit section Detailed session monitoring for further information. Networking configuration OpenVidu VPC Dedicated VPC for the OpenVidu Pro cluster All of the EC2 instances of the cluster will connect to this VPC Choose from the drop-down button OpenVidu Subnet Subnet of the VPC where to deploy the OpenVidu Pro cluster Choose from the drop-down button Other configuration These properties configure specific details of the CloudFormation stack. Instance type for Openvidu Server Pro Node Type of EC2 Instance where to deploy the OpenVidu Server Pro Node Choose from the drop-down button Instance type for Media Nodes Type of EC2 Instance where to deploy the Media Nodes Choose from the drop-down button Key name SSH key the EC2 Instances of the cluster Choose from the drop-down button (check AWS Docs to create a new one) 5. Create your stack No extra options are necessary. Click on Next \u279e Next \u279e Create stack CREATE_IN_PROGRESS status will show up. You will now have to wait for a few minutes (about 10) until it shows CREATE_COMPLETE . To connect to OpenVidu Inspector and the Kibana dashboard , simply access Outputs tab after CREATE_COMPLETE status is reached. There you will have both URLs to access both services. To consume OpenVidu REST API , use URL https://OPENVIDUPRO_PUBLIC_IP:4443 . For example, in the image above that would be https://ec2-34-244-193-135.eu-west-1.compute.amazonaws.com:4443 using AWS domain. When deploying with a custom domain name (which you should do for a production environment), of course you must use your domain name instead. Scalability Set the number of Media Nodes on startup When filling the CloudFormation form, simply set the desired number in section OpenVidu Pro configuration . In section Other configuration you can choose the size of your OpenVidu Server Pro Node and your Media Nodes. Change the number of Media Nodes on the fly You can launch and drop Media Nodes dynamically in two different ways: From OpenVidu Inspector In Cluster page you can launch and drop Media Nodes just by pressing buttons. With OpenVidu Pro REST API You can programmatically launch and drop Media Nodes from your application by consuming OpenVidu Pro REST API. Launch a Media Node : POST /pro/media-nodes Drop a Media Node : DELETE /pro/media-nodes WARNING : there are some important aspects to keep in mind when launching and dropping Media Nodes in AWS deployemnts, specially through OpenVidu Pro REST API (OpenVidu Inspector UI is quite self-descriptive): Trying to drop a Media Node which is currently hosting an OpenVidu Session will fail by default. You can manage the drop policy when calling DELETE /pro/media-nodes through parameter deletion-strategy . Updating OpenVidu Pro configuration You may want to change the current configuration of an existing OpenVidu Pro cluster. This configuration includes all of the parameters listed in these pages: OpenVidu Server CE configuration OpenVidu Server Pro configuration When deploying an OpenVidu Pro cluster you give value to these parameters directly or indirectly, depending on the deployment environment . Once the cluster is running, there are different ways you can update the value of the configuration parameters. Take into account that all of them require restarting your OpenVidu Server Pro process, so any active OpenVidu Session will be terminated . 1) With OpenVidu Inspector OpenVidu Inspector allows you to restart the OpenVidu Server Pro process from Config page just by filling a formulary. More information here . NOTE 1 : take into account that not all configuration properties are able to be updated this way NOTE 2 : new values will be stored and remembered, so they will be used when OpenVidu Server Pro is restarted in the future 2) With OpenVidu Pro REST API You can consume REST API method POST /pro/restart to programmatically restart the OpenVidu Server Pro process and update its configuration values. NOTE 1 : take into account that not all configuration properties are able to be updated this way NOTE 2 : new values will be stored and remembered, so they will be used when OpenVidu Server Pro is restarted in the future 3) Manually connecting through SSH The ultimate and most definitive way of updating the configuration parameters of an OpenVidu Pro cluster is connecting to the OpenVidu Server Pro Node through SSH and changing the desired values: SSH to the OpenVidu Server Pro machine using your private rsa key Update file /opt/openvidu/application.properties with the new configuration values Restart OpenVidu Server Pro with sudo systemctl restart openvidu To validate your changes and check that everything went well, you should take a look to OpenVidu Server Pro logs. If there were any errors with any configuration parameter, OpenVidu Server Pro log should help you fix the issue. You can show last 200 lines of the logs with command journalctl -n 200 -u openvidu | cat Troubleshooting First of all, an AWS CloudFormation stack may reach CREATE_FAILED status for missing a default VPC. Check out this FAQ to learn how to fix it. If that is not the problem, then follow these steps: 1) Try to deploy again, but this time disabling option Rollback on failure (Configure stack options \ud83e\udc46 Advanced Options \ud83e\udc46 Stack creation options). This will prevent the instance to be terminated in case of failure so logs can be gathered. Once you re-deploy with this option, the stack will still fail but you\u2019ll be able to access instances through SSH and retrieve some files to debug the problem. 2) We will also need the parameters you've used to deploy, to check possible problems in their values 3) Once you have performed step 1) and the stack creation has failed, please SSH into the instances created and share with us Cloudformation logs /var/log/cloud-init.log /var/log/cloud-init-output.log 4) Get also the log output of openvidu with this command and share with us the output file: journalctl -u openvidu > openvidu.log Regarding the compatibility of openvidu-browser and server SDKs (REST API, openvidu-java-client, openvidu-node-client), use the same version numbers as stated for openvidu-server in Releases page . For example, for OpenVidu Pro 2.10.0, use the artifact versions indicated in 2.10.0 release table OpenVidu Pro in AWS Marketplace The recommended way of deploying OpenVidu Pro in AWS is by directly using CloudFormation . Latest available version of OpenVidu Pro in AWS Marketplace is 2.11.0 , but we are working on 2.12.0 support Before deploying OpenVidu Pro in AWS Marketplace you need to contact us through Commercial page to get the credentials you will need during the deployment process. For this outdated way of deploying an OpenVidu Pro cluster you don't need an OpenVidu account, but you will need some special credentials we need to provide to you. 1) Steps towards configuration Go to marketplace 2) Configure your OpenVidu Server Pro Fill each section of the form with the appropriate values as stated below. Stack name The name of your deployment SSL Certificate Configuration This is the kind of certificate you will be using in your deployment. Three different options are offered: selfsigned : use a selfsigned certificate. This options is meant for testing and developing environments. Leave the rest of the fields with their default value letsencrypt : use an automatic certificate by Let's Encrypt. This way you don't have to worry about providing your own certificate. You simply have to enter an email account where Let's Encrypt will send its messages, your fully qualified domain name and one AWS Elastic IP for the same region you selected before ( allocate one if you don't have it ). Of course, you will need to register this Elastic IP in your DNS hosting service and associate it with your fully qualified domain name . Only after this association between the Elastic IP and your domain name is effective your deployment with Let's Encrypt will work fine. owncert : use your own certificate. You must provide one AWS Elastic IP for the same region you selected before ( allocate one if you don't have it ), and your public certificate and private key, both accessible through uris (an Amazon S3 bucket is the best way to do it). Leave the default values for Email and Fully qualified domain name fields. OpenVidu Configuration These fields respectively configure different system properties of OpenVidu Server. Besides, you'll find two fields for OpenVidu Pro credentials ( OpenViduProUsername and OpenViduProPassword ). We provide those credentials for you and with them you'll be able to access the OpenVidu Pro artifact (contact us through Commercial page to get them). If you want to enable OpenVidu Webhook module by setting OpenViduWebhook field to true, your endpoint defined in field OpenViduWebhookEndpoint will probably be secured in some way. The syntax for the webhook header (field OpenViduWebhookHeaders ) should be used to provide the security credentials. For example: Authorization: Basic T1BFTlZJRFVBUFA6TVlfU0VDUkVU for a basic auth token. Openvidu Security Group These fields allow you to limit the IPs that will be able to connect to OpenVidu Server Pro. WARNING : be careful when limiting these IP ranges Port 4443 access Range : OpenVidu Server Pro REST API and client access point. This should be set to 0.0.0.0/0 if you want any client to be able to use your deployment Port 3478 access Range : TURN server port. This should be set to 0.0.0.0/0 if you want any client to be able to use your deployment, as you never know which user might need a TURN connection to be able to send and receive media SSH Port access Range can be limited as you want, as it provides SSH access to the server with the proper private key through port 22 HTTPS and HTTP (ports 443 and 80) access Range : HTTPS access range will determine the directions able to connect to Kibana dashboard. If you are using Let's Encrypt SSL configuration, set HTTP access range to 0.0.0.0/0 , as Let's Encrypt will need to access your server through port 80. UDP Port access Range and TCP Port access Range : limits the clients that will be able to establish TCP and UDP connections to your OpenVidu Server Pro. So again, if you want to provide service to any client these should be set to 0.0.0.0/0 MinOpenPort and MaxOpenPort : determine what ports will be available to establish the media connections, so the generous default value is a good choice. If you change the values leaving out any of the previously stated ports, the deployment may fail Kibana Dashboard Set the user and password for accessing Kibana dashboard. Networking info Because Kurento Media Server cluster runs in an Autoscaling Group this CloudFormation template will create a VPC and a Subnet with all they need to provide internet access to the instances and public IPs. Then all the instances will be connected to this VPC. Clustering Options How many Kurento Media Servers do you want to deploy? Default to 1. Keep in mind AWS has limits to the amount of instances you can launch in EC2. Also, you will pay for every instance individually. Other parameters Choose the size of your instance (see OpenVidu performance FAQ ) and a Key Pair ( create one if you don't have any ). You can choose different sizes for OpenVidu Server machine and KMS machines. You are ready to go. Click on Next \ud83e\udc46 Next and complete the following point to deploy OpenVidu Pro cluster. Roles Before you can deploy the stack, you have to agree that this template will create Roles which will perform request to AWS API in you behalf from the instances. The Role's policy is only ec2:DescribeInstances , is the minimum required permission and it's needed to discover other cluster members. Every instance is tagged and the query to the API will simply filter by this tag. After clicking the checkbox, you can now finally press Create stack button and deploy OpenVidu Pro cluster. 3) Connecting to your OpenVidu Server Pro Now you just have to wait until Stack status is set to CREATE_COMPLETE . Then you will have a production-ready setup with all the advanced features provided by OpenVidu Pro. To connect to OpenVidu Inspector and the Kibana dashboard , simply access Outputs tab. There you will have both URLs to access both services. To consume OpenVidu REST API , use URL https://OPENVIDUPRO_PUBLIC_IP:4443 . For example, in the image above that would be https://ec2-34-244-193-135.eu-west-1.compute.amazonaws.com:4443 $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.pro-gallery').slick({ autoplay: true, arrows: false, autoplaySpeed: 3000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] }); $('.pro-gallery-steps').slick({ autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', dots: true, infinite: false, responsive: [ { breakpoint: 768, settings: { arrows: true, slidesToShow: 1 } }, ] });","title":"AWS"},{"location":"openvidu-pro/deployment/aws/#deployment-instructions","text":"","title":"Deployment instructions"},{"location":"openvidu-pro/deployment/aws/#1-access-to-the-console-of-aws-cloud-formation","text":"Go to CloudFormation","title":"1) Access to the console of AWS Cloud Formation"},{"location":"openvidu-pro/deployment/aws/#2-select-create-stack-with-new-resources","text":"","title":"2) Select Create Stack \ud83e\udc1a With new resources"},{"location":"openvidu-pro/deployment/aws/#3-option-specify-template-amazon-s3-url-with-the-following-url","text":"https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-Pro-latest.yaml Copy","title":"3) Option Specify template \ud83e\udc1a Amazon S3 URL with the following URL"},{"location":"openvidu-pro/deployment/aws/#4-specify-stack-details","text":"First of all, indicate a name for your deployment. Next fill each section of the Parameters formulary:","title":"4. Specify stack details"},{"location":"openvidu-pro/deployment/aws/#openvidu-pro-license","text":"Your OpenVidu Pro License key. You need an OpenVidu account to purchase it. There's a 15 day free trial waiting for you!","title":"OpenVidu Pro License"},{"location":"openvidu-pro/deployment/aws/#ssl-certificate-configuration","text":"Configuration for your CloudFormation stack certificate. We provide 3 different scenarios: you can use the default SELF-SIGNED CERTIFICATE stored in the application (users will need to accept the browser security alert) or if you have a custom domain, either allow LET'S ENCRYPT to automatically generate a valid and free certificate for your domain or use your own CUSTOM CERTIFICATE if you already have one. Self-Signed certificate Let's Encrypt certificate Custom certificate Choose the certificate selfsigned letsencrypt owncert Email for Let's Encrypt certification authority Your choice My domain name Your fully qualified domain For example: if your full URL is https://openvidu.io/ then this is openvidu.io Your fully qualified domain For example: if your full URL is https://openvidu.io/ then this is openvidu.io Public elastic IP (EIP) One AWS Elastic IP you generated (check AWS Docs to generate a new one) One AWS Elastic IP you generated (check AWS Docs to generate a new one) URL to the CRT file URL to your public key file The CloudFormation stack must have access to this URL, at least temporarily URL to the key file URL to your private key file The CloudFormation stack must have access to this URL, at least temporarily If you are using LET'S ENCRYPT CERTIFICATE , of course you will need to register your ElasticIP in your DNS hosting service and associate it with the fully qualified domain name. Until your domain name is not accessible through the public IP you chose, this deployment won't work","title":"SSL certificate configuration"},{"location":"openvidu-pro/deployment/aws/#openvidu-ce-configuration","text":"Configuration properties specific for OpenVidu Server CE . You have a complete description of all available properties here .","title":"OpenVidu CE configuration"},{"location":"openvidu-pro/deployment/aws/#openvidu-pro-configuration","text":"Configuration properties specific for OpenVidu Server Pro . You have a complete description of all available properties here .","title":"OpenVidu Pro configuration"},{"location":"openvidu-pro/deployment/aws/#kibana-configuration","text":"Username and password for the Kibana service deployed with OpenVidu Pro. You will need these credentials for later access to the Kibana dashboard of your OpenVidu Pro deployment. Visit section Detailed session monitoring for further information.","title":"Kibana configuration"},{"location":"openvidu-pro/deployment/aws/#networking-configuration","text":"OpenVidu VPC Dedicated VPC for the OpenVidu Pro cluster All of the EC2 instances of the cluster will connect to this VPC Choose from the drop-down button OpenVidu Subnet Subnet of the VPC where to deploy the OpenVidu Pro cluster Choose from the drop-down button","title":"Networking configuration"},{"location":"openvidu-pro/deployment/aws/#other-configuration","text":"These properties configure specific details of the CloudFormation stack. Instance type for Openvidu Server Pro Node Type of EC2 Instance where to deploy the OpenVidu Server Pro Node Choose from the drop-down button Instance type for Media Nodes Type of EC2 Instance where to deploy the Media Nodes Choose from the drop-down button Key name SSH key the EC2 Instances of the cluster Choose from the drop-down button (check AWS Docs to create a new one)","title":"Other configuration"},{"location":"openvidu-pro/deployment/aws/#5-create-your-stack","text":"No extra options are necessary. Click on Next \u279e Next \u279e Create stack CREATE_IN_PROGRESS status will show up. You will now have to wait for a few minutes (about 10) until it shows CREATE_COMPLETE . To connect to OpenVidu Inspector and the Kibana dashboard , simply access Outputs tab after CREATE_COMPLETE status is reached. There you will have both URLs to access both services. To consume OpenVidu REST API , use URL https://OPENVIDUPRO_PUBLIC_IP:4443 . For example, in the image above that would be https://ec2-34-244-193-135.eu-west-1.compute.amazonaws.com:4443 using AWS domain. When deploying with a custom domain name (which you should do for a production environment), of course you must use your domain name instead.","title":"5. Create your stack"},{"location":"openvidu-pro/deployment/aws/#scalability","text":"","title":"Scalability"},{"location":"openvidu-pro/deployment/aws/#set-the-number-of-media-nodes-on-startup","text":"When filling the CloudFormation form, simply set the desired number in section OpenVidu Pro configuration . In section Other configuration you can choose the size of your OpenVidu Server Pro Node and your Media Nodes.","title":"Set the number of Media Nodes on startup"},{"location":"openvidu-pro/deployment/aws/#change-the-number-of-media-nodes-on-the-fly","text":"You can launch and drop Media Nodes dynamically in two different ways:","title":"Change the number of Media Nodes on the fly"},{"location":"openvidu-pro/deployment/aws/#from-openvidu-inspector","text":"In Cluster page you can launch and drop Media Nodes just by pressing buttons.","title":"From OpenVidu Inspector"},{"location":"openvidu-pro/deployment/aws/#with-openvidu-pro-rest-api","text":"You can programmatically launch and drop Media Nodes from your application by consuming OpenVidu Pro REST API. Launch a Media Node : POST /pro/media-nodes Drop a Media Node : DELETE /pro/media-nodes WARNING : there are some important aspects to keep in mind when launching and dropping Media Nodes in AWS deployemnts, specially through OpenVidu Pro REST API (OpenVidu Inspector UI is quite self-descriptive): Trying to drop a Media Node which is currently hosting an OpenVidu Session will fail by default. You can manage the drop policy when calling DELETE /pro/media-nodes through parameter deletion-strategy .","title":"With OpenVidu Pro REST API"},{"location":"openvidu-pro/deployment/aws/#updating-openvidu-pro-configuration","text":"You may want to change the current configuration of an existing OpenVidu Pro cluster. This configuration includes all of the parameters listed in these pages: OpenVidu Server CE configuration OpenVidu Server Pro configuration When deploying an OpenVidu Pro cluster you give value to these parameters directly or indirectly, depending on the deployment environment . Once the cluster is running, there are different ways you can update the value of the configuration parameters. Take into account that all of them require restarting your OpenVidu Server Pro process, so any active OpenVidu Session will be terminated .","title":"Updating OpenVidu Pro configuration"},{"location":"openvidu-pro/deployment/aws/#1-with-openvidu-inspector","text":"OpenVidu Inspector allows you to restart the OpenVidu Server Pro process from Config page just by filling a formulary. More information here . NOTE 1 : take into account that not all configuration properties are able to be updated this way NOTE 2 : new values will be stored and remembered, so they will be used when OpenVidu Server Pro is restarted in the future","title":"1) With OpenVidu Inspector"},{"location":"openvidu-pro/deployment/aws/#2-with-openvidu-pro-rest-api","text":"You can consume REST API method POST /pro/restart to programmatically restart the OpenVidu Server Pro process and update its configuration values. NOTE 1 : take into account that not all configuration properties are able to be updated this way NOTE 2 : new values will be stored and remembered, so they will be used when OpenVidu Server Pro is restarted in the future","title":"2) With OpenVidu Pro REST API"},{"location":"openvidu-pro/deployment/aws/#3-manually-connecting-through-ssh","text":"The ultimate and most definitive way of updating the configuration parameters of an OpenVidu Pro cluster is connecting to the OpenVidu Server Pro Node through SSH and changing the desired values: SSH to the OpenVidu Server Pro machine using your private rsa key Update file /opt/openvidu/application.properties with the new configuration values Restart OpenVidu Server Pro with sudo systemctl restart openvidu To validate your changes and check that everything went well, you should take a look to OpenVidu Server Pro logs. If there were any errors with any configuration parameter, OpenVidu Server Pro log should help you fix the issue. You can show last 200 lines of the logs with command journalctl -n 200 -u openvidu | cat","title":"3) Manually connecting through SSH"},{"location":"openvidu-pro/deployment/aws/#troubleshooting","text":"First of all, an AWS CloudFormation stack may reach CREATE_FAILED status for missing a default VPC. Check out this FAQ to learn how to fix it. If that is not the problem, then follow these steps: 1) Try to deploy again, but this time disabling option Rollback on failure (Configure stack options \ud83e\udc46 Advanced Options \ud83e\udc46 Stack creation options). This will prevent the instance to be terminated in case of failure so logs can be gathered. Once you re-deploy with this option, the stack will still fail but you\u2019ll be able to access instances through SSH and retrieve some files to debug the problem. 2) We will also need the parameters you've used to deploy, to check possible problems in their values 3) Once you have performed step 1) and the stack creation has failed, please SSH into the instances created and share with us Cloudformation logs /var/log/cloud-init.log /var/log/cloud-init-output.log 4) Get also the log output of openvidu with this command and share with us the output file: journalctl -u openvidu > openvidu.log Regarding the compatibility of openvidu-browser and server SDKs (REST API, openvidu-java-client, openvidu-node-client), use the same version numbers as stated for openvidu-server in Releases page . For example, for OpenVidu Pro 2.10.0, use the artifact versions indicated in 2.10.0 release table","title":"Troubleshooting"},{"location":"openvidu-pro/deployment/aws/#openvidu-pro-in-aws-marketplace","text":"The recommended way of deploying OpenVidu Pro in AWS is by directly using CloudFormation . Latest available version of OpenVidu Pro in AWS Marketplace is 2.11.0 , but we are working on 2.12.0 support Before deploying OpenVidu Pro in AWS Marketplace you need to contact us through Commercial page to get the credentials you will need during the deployment process. For this outdated way of deploying an OpenVidu Pro cluster you don't need an OpenVidu account, but you will need some special credentials we need to provide to you.","title":"OpenVidu Pro in AWS Marketplace"},{"location":"openvidu-pro/deployment/aws/#1-steps-towards-configuration","text":"Go to marketplace","title":"1) Steps towards configuration"},{"location":"openvidu-pro/deployment/aws/#2-configure-your-openvidu-server-pro","text":"Fill each section of the form with the appropriate values as stated below.","title":"2) Configure your OpenVidu Server Pro"},{"location":"openvidu-pro/deployment/aws/#stack-name","text":"The name of your deployment","title":"Stack name"},{"location":"openvidu-pro/deployment/aws/#ssl-certificate-configuration_1","text":"This is the kind of certificate you will be using in your deployment. Three different options are offered: selfsigned : use a selfsigned certificate. This options is meant for testing and developing environments. Leave the rest of the fields with their default value letsencrypt : use an automatic certificate by Let's Encrypt. This way you don't have to worry about providing your own certificate. You simply have to enter an email account where Let's Encrypt will send its messages, your fully qualified domain name and one AWS Elastic IP for the same region you selected before ( allocate one if you don't have it ). Of course, you will need to register this Elastic IP in your DNS hosting service and associate it with your fully qualified domain name . Only after this association between the Elastic IP and your domain name is effective your deployment with Let's Encrypt will work fine. owncert : use your own certificate. You must provide one AWS Elastic IP for the same region you selected before ( allocate one if you don't have it ), and your public certificate and private key, both accessible through uris (an Amazon S3 bucket is the best way to do it). Leave the default values for Email and Fully qualified domain name fields.","title":"SSL Certificate Configuration"},{"location":"openvidu-pro/deployment/aws/#openvidu-configuration","text":"These fields respectively configure different system properties of OpenVidu Server. Besides, you'll find two fields for OpenVidu Pro credentials ( OpenViduProUsername and OpenViduProPassword ). We provide those credentials for you and with them you'll be able to access the OpenVidu Pro artifact (contact us through Commercial page to get them). If you want to enable OpenVidu Webhook module by setting OpenViduWebhook field to true, your endpoint defined in field OpenViduWebhookEndpoint will probably be secured in some way. The syntax for the webhook header (field OpenViduWebhookHeaders ) should be used to provide the security credentials. For example: Authorization: Basic T1BFTlZJRFVBUFA6TVlfU0VDUkVU for a basic auth token.","title":"OpenVidu Configuration"},{"location":"openvidu-pro/deployment/aws/#openvidu-security-group","text":"These fields allow you to limit the IPs that will be able to connect to OpenVidu Server Pro. WARNING : be careful when limiting these IP ranges Port 4443 access Range : OpenVidu Server Pro REST API and client access point. This should be set to 0.0.0.0/0 if you want any client to be able to use your deployment Port 3478 access Range : TURN server port. This should be set to 0.0.0.0/0 if you want any client to be able to use your deployment, as you never know which user might need a TURN connection to be able to send and receive media SSH Port access Range can be limited as you want, as it provides SSH access to the server with the proper private key through port 22 HTTPS and HTTP (ports 443 and 80) access Range : HTTPS access range will determine the directions able to connect to Kibana dashboard. If you are using Let's Encrypt SSL configuration, set HTTP access range to 0.0.0.0/0 , as Let's Encrypt will need to access your server through port 80. UDP Port access Range and TCP Port access Range : limits the clients that will be able to establish TCP and UDP connections to your OpenVidu Server Pro. So again, if you want to provide service to any client these should be set to 0.0.0.0/0 MinOpenPort and MaxOpenPort : determine what ports will be available to establish the media connections, so the generous default value is a good choice. If you change the values leaving out any of the previously stated ports, the deployment may fail","title":"Openvidu Security Group"},{"location":"openvidu-pro/deployment/aws/#kibana-dashboard","text":"Set the user and password for accessing Kibana dashboard.","title":"Kibana Dashboard"},{"location":"openvidu-pro/deployment/aws/#networking-info","text":"Because Kurento Media Server cluster runs in an Autoscaling Group this CloudFormation template will create a VPC and a Subnet with all they need to provide internet access to the instances and public IPs. Then all the instances will be connected to this VPC.","title":"Networking info"},{"location":"openvidu-pro/deployment/aws/#clustering-options","text":"How many Kurento Media Servers do you want to deploy? Default to 1. Keep in mind AWS has limits to the amount of instances you can launch in EC2. Also, you will pay for every instance individually.","title":"Clustering Options"},{"location":"openvidu-pro/deployment/aws/#other-parameters","text":"Choose the size of your instance (see OpenVidu performance FAQ ) and a Key Pair ( create one if you don't have any ). You can choose different sizes for OpenVidu Server machine and KMS machines. You are ready to go. Click on Next \ud83e\udc46 Next and complete the following point to deploy OpenVidu Pro cluster.","title":"Other parameters"},{"location":"openvidu-pro/deployment/aws/#roles","text":"Before you can deploy the stack, you have to agree that this template will create Roles which will perform request to AWS API in you behalf from the instances. The Role's policy is only ec2:DescribeInstances , is the minimum required permission and it's needed to discover other cluster members. Every instance is tagged and the query to the API will simply filter by this tag. After clicking the checkbox, you can now finally press Create stack button and deploy OpenVidu Pro cluster.","title":"Roles"},{"location":"openvidu-pro/deployment/aws/#3-connecting-to-your-openvidu-server-pro","text":"Now you just have to wait until Stack status is set to CREATE_COMPLETE . Then you will have a production-ready setup with all the advanced features provided by OpenVidu Pro. To connect to OpenVidu Inspector and the Kibana dashboard , simply access Outputs tab. There you will have both URLs to access both services. To consume OpenVidu REST API , use URL https://OPENVIDUPRO_PUBLIC_IP:4443 . For example, in the image above that would be https://ec2-34-244-193-135.eu-west-1.compute.amazonaws.com:4443 $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.pro-gallery').slick({ autoplay: true, arrows: false, autoplaySpeed: 3000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] }); $('.pro-gallery-steps').slick({ autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', dots: true, infinite: false, responsive: [ { breakpoint: 768, settings: { arrows: true, slidesToShow: 1 } }, ] });","title":"3) Connecting to your OpenVidu Server Pro"},{"location":"openvidu-pro/deployment/kubernetes/","text":"Deploying OpenVidu Pro on Kubernetes Coming soon...","title":"Kubernetes"},{"location":"openvidu-pro/deployment/on-premise/","text":"Deploy OpenVidu Pro on premise Deployment instructions 1) Prerequisites 2) Network requirements 3) Ansible inventory 4) Ansible variables 5) Deployment command Scalability Set the number of Media Nodes on startup Change the number of Media Nodes on the fly Updating OpenVidu Pro configuration Troubleshooting Before deploying OpenVidu Pro you need to create an OpenVidu account to get your license key. There's a 15 day free trial waiting for you! Deployment instructions 1) Prerequisites In your local machine You need Ansible installed on your laptop or wherever you are running this playbook. You can install Ansible with: sudo apt-add-repository -y ppa:ansible/ansible sudo apt-get update sudo apt-get install -y ansible Besides you need to install this role for Docker: sudo ansible-galaxy install -p /etc/ansible/roles geerlingguy.docker In your cluster machines You must have at least 2 different instances with a clean installation of Ubuntu 16.04 One instance for the OpenVidu Server Pro Node One instance for a Media Node You can actually have as many instances as you want for Media Nodes. The number of Media Nodes determines the size of your cluster: the more Media Nodes, the more video sessions your cluster will be able to handle. Check out Scalability section for further details. Besides, be sure to meet the following criteria in your cluster instances: Have at least a minimum of 2 CPUs and 8GB of RAM , and a generous network bandwidth Have Python 3 installed (check version with python3 --version ) 2) Network requirements These ports need to be opened and publicly accessible for each type of instance in your cluster: OpenVidu Server Pro instance 4443 TCP (OpenVidu Server listens on port 4443 by default) 3478 TCP (coturn listens on port 3478 by default) 3478 UDP (opening also UDP port has been proved to facilitate connections with certain type of clients) Media Node instances 40000 - 65535 UDP (WebRTC connections with clients may be established using a random port inside this range) 40000 - 65535 TCP (WebRTC connections with clients may be established using a random port inside this range, if UDP can't be used because client network is blocking it) 8888 TCP (must only be accessible for OpenVidu Server Pro instance) (Kurento Media Server listens on port 8888 by default) NOTE : in production environments you will have to configure a fully qualified domain name in your OpenVidu Server Pro instance . You can register a FQDN for the OpenVidu Server Pro instance using a DNS server, pairing the OpenVidu Server Pro instance public IP with your domain name. This is the only way to later set up a valid certificate in OpenVidu Server Pro instance, so clients don't get a warning when connecting to a video session 3) Ansible inventory Ansible uses an inventory file to know which instances connect to and how to configure them. Let's clone OpenVidu's Ansible repository to modify this file and prepare the cluster deployment: git clone https://github.com/OpenVidu/openvidu-pro-clustering git checkout 2.12.0-on-premise cd openvidu-pro-clustering # This will be our working directory from now on File ./inventory.yaml defines our cluster instances. By default it is ready to use a single Media Node, but you can add as many kurento-server hosts as you want, as you can see in the commented lines. The IPs in the inventory file should be the addresses which can be reached from the Ansible host. In example, if your Ansible host is on the 192.168.x.x network should be ok to use that address range in your inventory file. --- all: hosts: openvidu-server: ansible_host: OPENVIDU_SERVER_IP media-node-1: ansible_host: MEDIA_NODE_1_IP # media-node-2: # ansible_host: MEDIA_NODE_2_IP # ... # media-node-N: # ansible_host: MEDIA_NODE_N_IP vars: ansible_become: true ansible_user: USER ansible_ssh_private_key_file: /PATH/TO/SSH_public_key children: media-nodes: hosts: media-node-1: # media-node-2: # ... # media-node-N: openvidu: hosts: openvidu-server: You need to change: Variable ansible_user : the user you use to connect to the instances, i.e. Ubuntu Server Cloud uses ubuntu . If you've deployed those instances in OpenStack using Ubuntu Official Image, ubuntu will be the user. Variable ansible_ssh_private_key_file : path to the RSA private key you use to connect to your instances. Value OPENVIDU_SERVER_IP : public IP to connect to the OpenVidu Server Pro instance. Value MEDIA_NODE_X_IP : public IP to connect to the Kurento Media Server instance(s). 4) Ansible variables In ./group_vars/all file you will find all the parameters used to configure the infrastructure. One of them is your OpenVidu Pro license key . You need an OpenVidu account to purchase it. There's a 15 day free trial waiting for you! WARNING : when giving value to the variables in ./group_vars/all file, go through all of them very carefully. Some of them do not have default values, as they are dependant on your infrastructure. Be also very careful to not delete any of them, as the deployment will fail if any variable is missing. For further information about them check out OpenVidu Server CE configuration and OpenVidu Server Pro configuration 5) Deployment command First time you connect to an instance through SSH, it will ask you to confirm the instance's fingerprint, so try to login into all the instances to accept the fingerprint so Ansible can automatically do the job. ssh -i /PATH/TO/SSH_public_key USER@INSTANCE_IP Check that Ansible can access the instances. The following command (run it in the repository root folder) will perform a ping to all the instances declared in ./inventory.yaml file. You should see a successful log message for each one of them if everything is correct. ansible -i inventory.yaml -m ping all Finally, launch the Ansible's playbook to deploy your cluster: ansible-playbook -i inventory.yaml play.yaml The playbook command will end with the following log: ********************************************************* TASK [check-app-ready : check every 60 seconds for 10 attempts if openvidu is up and ready] ********************************************************* FAILED - RETRYING: check every 60 seconds for 10 attempts if openvidu is up and ready (10 retries left). FAILED - RETRYING: check every 60 seconds for 10 attempts if openvidu is up and ready ( 9 retries left). ok: [openvidu-server] ********************************************************* PLAY RECAP ********************************************************* kurento-server-1 : ok=21 changed=18 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 kurento-server-2 : ok=21 changed=18 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 openvidu-server : ok=53 changed=43 unreachable=0 failed=0 skipped=14 rescued=0 ignored=0 Once the playbook command has successfully finished, you will have OpenVidu Pro services accessible through the following URLs: OpenVidu Pro Inspector ( more info ) : https://YOUR_DNS_NAME/inspector OpenVidu Pro Kibana dashboard ( more info ) : https://YOUR_DNS_NAME/kibana OpenVidu Pro REST endpoint ( more info ) : https://YOUR_DNS_NAME:4443 (or the port you defined in property openvidu_server_port in file ./group_vars/all ) Regarding the compatibility of openvidu-browser and server SDKs (REST API, openvidu-java-client, openvidu-node-client), use the same version numbers as stated for openvidu-server in Releases page . For example, for OpenVidu Pro 2.10.0, use the artifact versions indicated in 2.10.0 release table Scalability Set the number of Media Nodes on startup Deployment instructions inherently contain all the requirements needed to deploy your OpenVidu Pro cluster with a specific initial number of Media Nodes. You first have to prepare the maximum number of Media Nodes you want. For example, if you want your cluster to be able to grow up to 3 Media Nodes, then you will need 4 hosts in your infrastructure: one for the OpenVidu Server Pro Node and three for each Media Node. Check out the Cluster machines prerequisites . Then you just need to properly configure the inventory.yml file with each instance IP before running Ansible's playbook. This way your cluster will start with the desired number of Media Nodes. Change the number of Media Nodes on the fly You can launch and drop Media Nodes dynamically in two different ways: From OpenVidu Inspector In Cluster page you can launch and drop Media Nodes just by pressing buttons. With OpenVidu Pro REST API You can programmatically launch and drop Media Nodes from your application by consuming OpenVidu Pro REST API. Launch a Media Node : POST /pro/media-nodes Drop a Media Node : DELETE /pro/media-nodes WARNING : there are some important aspects to keep in mind when launching and dropping Media Nodes in on premises OpenVidu Pro clusters: Trying to drop a Media Node which is currently hosting an OpenVidu Session will fail by default. You can manage the drop policy when calling DELETE /pro/media-nodes through parameter deletion-strategy . Launching and dropping Media Nodes in on premise deployments will not automatically start and terminate your instances. So to launch a new Media Node in on premise deployments you are required to have the Media Node already running and to provide the Media Node's URI when calling POST /pro/media-nodes (using uri query parameter). When dropping it you will have to terminate the instance yourself after successfully calling DELETE /pro/media-nodes , if that's what you want. You can listen to mediaNodeStatusChanged event through OpenVidu Webhook to know when you can safely terminate your instances (listen to terminated status). Updating OpenVidu Pro configuration You may want to change the current configuration of an existing OpenVidu Pro cluster. This configuration includes all of the parameters listed in these pages: OpenVidu Server CE configuration OpenVidu Server Pro configuration When deploying an OpenVidu Pro cluster you give value to these parameters directly or indirectly, depending on the deployment environment . Once the cluster is running, there are different ways you can update the value of the configuration parameters. Take into account that all of them require restarting your OpenVidu Server Pro process, so any active OpenVidu Session will be terminated . 1) With OpenVidu Inspector OpenVidu Inspector allows you to restart the OpenVidu Server Pro process from Config page just by filling a formulary. More information here . NOTE 1 : take into account that not all configuration properties are able to be updated this way NOTE 2 : new values will be stored and remembered, so they will be used when OpenVidu Server Pro is restarted in the future 2) With OpenVidu Pro REST API You can consume REST API method POST /pro/restart to programmatically restart the OpenVidu Server Pro process and update its configuration values. NOTE 1 : take into account that not all configuration properties are able to be updated this way NOTE 2 : new values will be stored and remembered, so they will be used when OpenVidu Server Pro is restarted in the future 3) Manually connecting through SSH The ultimate and most definitive way of updating the configuration parameters of an OpenVidu Pro cluster is connecting to the OpenVidu Server Pro Node through SSH and changing the desired values: SSH to the OpenVidu Server Pro machine using your private rsa key Update file /opt/openvidu/application.properties with the new configuration values Restart OpenVidu Server Pro with sudo systemctl restart openvidu To validate your changes and check that everything went well, you should take a look to OpenVidu Server Pro logs. If there were any errors with any configuration parameter, OpenVidu Server Pro log should help you fix the issue. You can show last 200 lines of the logs with command journalctl -n 200 -u openvidu | cat Troubleshooting To troubleshoot problems with OpenVidu Pro on premises deployments follow these steps: 1) Provide to us ansible-playbook logs (the output of the ansible-playbook command) 2) SSH in to the OpenVidu Server Pro Node and provide to us Openvidu logs: journalctl -u openvidu > openvidu.log $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.pro-gallery').slick({ autoplay: true, arrows: false, autoplaySpeed: 3000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] }); $('.pro-gallery-steps').slick({ autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', dots: true, infinite: false, responsive: [ { breakpoint: 768, settings: { arrows: true, slidesToShow: 1 } }, ] });","title":"On premise"},{"location":"openvidu-pro/deployment/on-premise/#deployment-instructions","text":"","title":"Deployment instructions"},{"location":"openvidu-pro/deployment/on-premise/#1-prerequisites","text":"","title":"1) Prerequisites"},{"location":"openvidu-pro/deployment/on-premise/#in-your-local-machine","text":"You need Ansible installed on your laptop or wherever you are running this playbook. You can install Ansible with: sudo apt-add-repository -y ppa:ansible/ansible sudo apt-get update sudo apt-get install -y ansible Besides you need to install this role for Docker: sudo ansible-galaxy install -p /etc/ansible/roles geerlingguy.docker","title":"In your local machine"},{"location":"openvidu-pro/deployment/on-premise/#in-your-cluster-machines","text":"You must have at least 2 different instances with a clean installation of Ubuntu 16.04 One instance for the OpenVidu Server Pro Node One instance for a Media Node You can actually have as many instances as you want for Media Nodes. The number of Media Nodes determines the size of your cluster: the more Media Nodes, the more video sessions your cluster will be able to handle. Check out Scalability section for further details. Besides, be sure to meet the following criteria in your cluster instances: Have at least a minimum of 2 CPUs and 8GB of RAM , and a generous network bandwidth Have Python 3 installed (check version with python3 --version )","title":"In your cluster machines"},{"location":"openvidu-pro/deployment/on-premise/#2-network-requirements","text":"These ports need to be opened and publicly accessible for each type of instance in your cluster:","title":"2) Network requirements"},{"location":"openvidu-pro/deployment/on-premise/#openvidu-server-pro-instance","text":"4443 TCP (OpenVidu Server listens on port 4443 by default) 3478 TCP (coturn listens on port 3478 by default) 3478 UDP (opening also UDP port has been proved to facilitate connections with certain type of clients)","title":"OpenVidu Server Pro instance"},{"location":"openvidu-pro/deployment/on-premise/#media-node-instances","text":"40000 - 65535 UDP (WebRTC connections with clients may be established using a random port inside this range) 40000 - 65535 TCP (WebRTC connections with clients may be established using a random port inside this range, if UDP can't be used because client network is blocking it) 8888 TCP (must only be accessible for OpenVidu Server Pro instance) (Kurento Media Server listens on port 8888 by default) NOTE : in production environments you will have to configure a fully qualified domain name in your OpenVidu Server Pro instance . You can register a FQDN for the OpenVidu Server Pro instance using a DNS server, pairing the OpenVidu Server Pro instance public IP with your domain name. This is the only way to later set up a valid certificate in OpenVidu Server Pro instance, so clients don't get a warning when connecting to a video session","title":"Media Node instances"},{"location":"openvidu-pro/deployment/on-premise/#3-ansible-inventory","text":"Ansible uses an inventory file to know which instances connect to and how to configure them. Let's clone OpenVidu's Ansible repository to modify this file and prepare the cluster deployment: git clone https://github.com/OpenVidu/openvidu-pro-clustering git checkout 2.12.0-on-premise cd openvidu-pro-clustering # This will be our working directory from now on File ./inventory.yaml defines our cluster instances. By default it is ready to use a single Media Node, but you can add as many kurento-server hosts as you want, as you can see in the commented lines. The IPs in the inventory file should be the addresses which can be reached from the Ansible host. In example, if your Ansible host is on the 192.168.x.x network should be ok to use that address range in your inventory file. --- all: hosts: openvidu-server: ansible_host: OPENVIDU_SERVER_IP media-node-1: ansible_host: MEDIA_NODE_1_IP # media-node-2: # ansible_host: MEDIA_NODE_2_IP # ... # media-node-N: # ansible_host: MEDIA_NODE_N_IP vars: ansible_become: true ansible_user: USER ansible_ssh_private_key_file: /PATH/TO/SSH_public_key children: media-nodes: hosts: media-node-1: # media-node-2: # ... # media-node-N: openvidu: hosts: openvidu-server: You need to change: Variable ansible_user : the user you use to connect to the instances, i.e. Ubuntu Server Cloud uses ubuntu . If you've deployed those instances in OpenStack using Ubuntu Official Image, ubuntu will be the user. Variable ansible_ssh_private_key_file : path to the RSA private key you use to connect to your instances. Value OPENVIDU_SERVER_IP : public IP to connect to the OpenVidu Server Pro instance. Value MEDIA_NODE_X_IP : public IP to connect to the Kurento Media Server instance(s).","title":"3) Ansible inventory"},{"location":"openvidu-pro/deployment/on-premise/#4-ansible-variables","text":"In ./group_vars/all file you will find all the parameters used to configure the infrastructure. One of them is your OpenVidu Pro license key . You need an OpenVidu account to purchase it. There's a 15 day free trial waiting for you! WARNING : when giving value to the variables in ./group_vars/all file, go through all of them very carefully. Some of them do not have default values, as they are dependant on your infrastructure. Be also very careful to not delete any of them, as the deployment will fail if any variable is missing. For further information about them check out OpenVidu Server CE configuration and OpenVidu Server Pro configuration","title":"4) Ansible variables"},{"location":"openvidu-pro/deployment/on-premise/#5-deployment-command","text":"First time you connect to an instance through SSH, it will ask you to confirm the instance's fingerprint, so try to login into all the instances to accept the fingerprint so Ansible can automatically do the job. ssh -i /PATH/TO/SSH_public_key USER@INSTANCE_IP Check that Ansible can access the instances. The following command (run it in the repository root folder) will perform a ping to all the instances declared in ./inventory.yaml file. You should see a successful log message for each one of them if everything is correct. ansible -i inventory.yaml -m ping all Finally, launch the Ansible's playbook to deploy your cluster: ansible-playbook -i inventory.yaml play.yaml The playbook command will end with the following log: ********************************************************* TASK [check-app-ready : check every 60 seconds for 10 attempts if openvidu is up and ready] ********************************************************* FAILED - RETRYING: check every 60 seconds for 10 attempts if openvidu is up and ready (10 retries left). FAILED - RETRYING: check every 60 seconds for 10 attempts if openvidu is up and ready ( 9 retries left). ok: [openvidu-server] ********************************************************* PLAY RECAP ********************************************************* kurento-server-1 : ok=21 changed=18 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 kurento-server-2 : ok=21 changed=18 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 openvidu-server : ok=53 changed=43 unreachable=0 failed=0 skipped=14 rescued=0 ignored=0 Once the playbook command has successfully finished, you will have OpenVidu Pro services accessible through the following URLs: OpenVidu Pro Inspector ( more info ) : https://YOUR_DNS_NAME/inspector OpenVidu Pro Kibana dashboard ( more info ) : https://YOUR_DNS_NAME/kibana OpenVidu Pro REST endpoint ( more info ) : https://YOUR_DNS_NAME:4443 (or the port you defined in property openvidu_server_port in file ./group_vars/all ) Regarding the compatibility of openvidu-browser and server SDKs (REST API, openvidu-java-client, openvidu-node-client), use the same version numbers as stated for openvidu-server in Releases page . For example, for OpenVidu Pro 2.10.0, use the artifact versions indicated in 2.10.0 release table","title":"5) Deployment command"},{"location":"openvidu-pro/deployment/on-premise/#scalability","text":"","title":"Scalability"},{"location":"openvidu-pro/deployment/on-premise/#set-the-number-of-media-nodes-on-startup","text":"Deployment instructions inherently contain all the requirements needed to deploy your OpenVidu Pro cluster with a specific initial number of Media Nodes. You first have to prepare the maximum number of Media Nodes you want. For example, if you want your cluster to be able to grow up to 3 Media Nodes, then you will need 4 hosts in your infrastructure: one for the OpenVidu Server Pro Node and three for each Media Node. Check out the Cluster machines prerequisites . Then you just need to properly configure the inventory.yml file with each instance IP before running Ansible's playbook. This way your cluster will start with the desired number of Media Nodes.","title":"Set the number of Media Nodes on startup"},{"location":"openvidu-pro/deployment/on-premise/#change-the-number-of-media-nodes-on-the-fly","text":"You can launch and drop Media Nodes dynamically in two different ways:","title":"Change the number of Media Nodes on the fly"},{"location":"openvidu-pro/deployment/on-premise/#from-openvidu-inspector","text":"In Cluster page you can launch and drop Media Nodes just by pressing buttons.","title":"From OpenVidu Inspector"},{"location":"openvidu-pro/deployment/on-premise/#with-openvidu-pro-rest-api","text":"You can programmatically launch and drop Media Nodes from your application by consuming OpenVidu Pro REST API. Launch a Media Node : POST /pro/media-nodes Drop a Media Node : DELETE /pro/media-nodes WARNING : there are some important aspects to keep in mind when launching and dropping Media Nodes in on premises OpenVidu Pro clusters: Trying to drop a Media Node which is currently hosting an OpenVidu Session will fail by default. You can manage the drop policy when calling DELETE /pro/media-nodes through parameter deletion-strategy . Launching and dropping Media Nodes in on premise deployments will not automatically start and terminate your instances. So to launch a new Media Node in on premise deployments you are required to have the Media Node already running and to provide the Media Node's URI when calling POST /pro/media-nodes (using uri query parameter). When dropping it you will have to terminate the instance yourself after successfully calling DELETE /pro/media-nodes , if that's what you want. You can listen to mediaNodeStatusChanged event through OpenVidu Webhook to know when you can safely terminate your instances (listen to terminated status).","title":"With OpenVidu Pro REST API"},{"location":"openvidu-pro/deployment/on-premise/#updating-openvidu-pro-configuration","text":"You may want to change the current configuration of an existing OpenVidu Pro cluster. This configuration includes all of the parameters listed in these pages: OpenVidu Server CE configuration OpenVidu Server Pro configuration When deploying an OpenVidu Pro cluster you give value to these parameters directly or indirectly, depending on the deployment environment . Once the cluster is running, there are different ways you can update the value of the configuration parameters. Take into account that all of them require restarting your OpenVidu Server Pro process, so any active OpenVidu Session will be terminated .","title":"Updating OpenVidu Pro configuration"},{"location":"openvidu-pro/deployment/on-premise/#1-with-openvidu-inspector","text":"OpenVidu Inspector allows you to restart the OpenVidu Server Pro process from Config page just by filling a formulary. More information here . NOTE 1 : take into account that not all configuration properties are able to be updated this way NOTE 2 : new values will be stored and remembered, so they will be used when OpenVidu Server Pro is restarted in the future","title":"1) With OpenVidu Inspector"},{"location":"openvidu-pro/deployment/on-premise/#2-with-openvidu-pro-rest-api","text":"You can consume REST API method POST /pro/restart to programmatically restart the OpenVidu Server Pro process and update its configuration values. NOTE 1 : take into account that not all configuration properties are able to be updated this way NOTE 2 : new values will be stored and remembered, so they will be used when OpenVidu Server Pro is restarted in the future","title":"2) With OpenVidu Pro REST API"},{"location":"openvidu-pro/deployment/on-premise/#3-manually-connecting-through-ssh","text":"The ultimate and most definitive way of updating the configuration parameters of an OpenVidu Pro cluster is connecting to the OpenVidu Server Pro Node through SSH and changing the desired values: SSH to the OpenVidu Server Pro machine using your private rsa key Update file /opt/openvidu/application.properties with the new configuration values Restart OpenVidu Server Pro with sudo systemctl restart openvidu To validate your changes and check that everything went well, you should take a look to OpenVidu Server Pro logs. If there were any errors with any configuration parameter, OpenVidu Server Pro log should help you fix the issue. You can show last 200 lines of the logs with command journalctl -n 200 -u openvidu | cat","title":"3) Manually connecting through SSH"},{"location":"openvidu-pro/deployment/on-premise/#troubleshooting","text":"To troubleshoot problems with OpenVidu Pro on premises deployments follow these steps: 1) Provide to us ansible-playbook logs (the output of the ansible-playbook command) 2) SSH in to the OpenVidu Server Pro Node and provide to us Openvidu logs: journalctl -u openvidu > openvidu.log $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', }); $('.pro-gallery').slick({ autoplay: true, arrows: false, autoplaySpeed: 3000, dots: true, infinite: true, pauseOnHover: false, pauseOnFocus: false, responsive: [ { breakpoint: 768, settings: { arrows: false, slidesToShow: 1 } }, ] }); $('.pro-gallery-steps').slick({ autoplay: false, arrows: true, prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>', nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>', dots: true, infinite: false, responsive: [ { breakpoint: 768, settings: { arrows: true, slidesToShow: 1 } }, ] });","title":"Troubleshooting"},{"location":"openvidu-pro/reference-docs/REST-API-pro/","text":"REST API Pro OpenVidu Pro provides all of OpenVidu CE REST operations , but also includes some extra REST operations of its own. All REST operations have in common the header referred to authorization. It is implemented via Basic Auth, and it is as simple as applying Base64 encoding to the username (always \"OPENVIDUAPP\") and the password (your secret shared with openvidu-server). If authorization header is wrong, every call to any REST API operation will return HTTP status 401 . For example, for secret \"MY_SECRET\", the final valid HTTP header would be Authorization: Basic T1BFTlZJRFVBUFA6TVlfU0VDUkVU List of available operations Get Media Node info: GET /pro/media-nodes/<MEDIA_NODE_ID> Get all Media Nodes info: GET /pro/media-nodes Add new Media Node: POST /pro/media-nodes Remove Media Node: DELETE /pro/media-nodes/<MEDIA_NODE_ID> Modify Media Node: PATCH /pro/media-nodes/<MEDIA_NODE_ID> Force Media Nodes autodiscovery: PUT /pro/media-nodes Restart OpenVidu Pro: POST /pro/restart Get OpenVidu Pro active configuration: GET /pro/config GET /pro/media-nodes/<MEDIA_NODE_ID> GET MEDIA NODE INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes/<MEDIA_NODE_ID> Query params load , sessions , extra-info Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"id\": \"kms_RicdrF9x\", \"environmentId\": \"5372e1c954fd54c13706f476236\", \"ip\": \"172.17.0.4\", \"uri\": \"ws://172.17.0.4:8888/kurento\", \"connected\": true, \"connectionTime\": 1583753233620, \"sessions\": [], \"load\": 0.0, \"status\": \"running\"} Query params load (optional boolean, default to false) : whether to return Media Node load or not. The value will depend on configuration property openvidu.pro.cluster.load-strategy sessions (optional boolean, default to false) : whether to return session information along Media Node information or not. Only sessions hosted in this Media Node will be retrieved. Session information has same format as returned by method GET /api/sessions/<SESSION_ID> extra-info (optional boolean, default to false) : whether to return extra information about the Media Node or not. Only for advanced users Encode query params in the url like this: https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes ?load=true&sessions=false&extra-info=false Returned JSON id : Media Node unique identifier. Use it to perform other REST operations on this Media Node environmentId : Media Node identifier dependent on the deployment environment. For example, an AWS EC2 machine id if the cluster is deployed in AWS ip : Media Node IP uri : Media Node URI endpoint. This is the URI where OpenVidu Server will establish a connection with the Media Node connected : whether OpenVidu Server Pro is connected to this Media Node or not. This property may be set to false if there's an unexpected disconnection of the Media Node connectionTime : when did OpenVidu Server establish the connection with the Media Node (in UTC milliseconds) disconnectionTime : when did OpenVidu Server lose its connection to the Media Node (in UTC milliseconds). Only defined if connected is false sessions : session information of this Media Node. This property is an array of objects with the exact same format as the response returned by method GET /api/sessions/<SESSION_ID> . Only available if query param sessions is set to true load : load of the Media Node. Only available if query param load is set to true status : status of the Media Node (see Media Node statuses ) kurentoInfo : object with extra advanced information about this instance of Kurento Media Server (version, modules, memory usage...). Only available if query param extra-info is set to true (for advanced users, subject to change) HTTP responses 200 : the Media Node information has been successfully retrieved 404 : no Media Node exists for the passed MEDIA_NODE_ID 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes GET /pro/media-nodes LIST MEDIA NODES INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes Query params load , sessions , extra-info Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"numberOfElements\": 1, \"content\": [ {\"id\": \"KMS-XU5ZRM\", \"uri\": \"ws://localhost:8888/kurento\", \"ip\": \"localhost\", \"connected\": true, \"connectionTime\": 1562744478463, \"load\": 0} ]} Query params load (optional boolean, default to false) : whether to return Media Nodes load or not. The value will depend on configuration property openvidu.pro.cluster.load-strategy sessions (optional boolean, default to false) : whether to return session information along Media Nodes information or not. Media Node will be retrieved. Session information has same format as returned by method GET /api/sessions/<SESSION_ID> extra-info (optional boolean, default to false) : whether to return extra information about the Media Nodes or not. Only for advanced users Encode query params in the url like this: https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes ?load=true&sessions=false&extra-info=false Returned JSON numberOfElements : total number of registered Media Nodes content : array of Media Nodes. Each object has the same structure as defined in the returned JSON of GET /pro/media-nodes/<MEDIA_NODE_ID> HTTP responses 200 : Media Nodes information has been successfully retrieved 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes POST /pro/media-nodes NEW MEDIA NODE PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes Query params wait Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"uri\": \"MEDIA_NODE_URI\"} Sample return { \"id\": \"kms_LrMRlL42\", \"ip\": \"172.17.0.5\", \"uri\": \"ws://172.17.0.5:8888/kurento\", \"connected\": true, \"connectionTime\": 1583769116854, \"environmentId\": \"489ed9c4b4d761699dc93\", \"status\": \"running\" } Query params wait (optional boolean, default to false) : whether to wait until the new Media Node reaches running status or not. Setting this property to true basically makes this method synchronized. You will not receive an answer until the Media Node is properly running or an error is thrown. Encode query params in the url like this: https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes ?wait=true Body parameters uri (mandatory string only if openvidu.pro.cluster.mode is manual ) : the websocket endpoint of a running Media Node. For a Kurento Media Server, it should be something similar to ws://media.server.ip:8888/kurento . This property is only necessary and is only taken into account if openvidu.pro.cluster.mode is set to manual . For mode auto a new Media Node will be automatically launched ignoring parameter uri Returned JSON Same JSON response as defined for GET /pro/media-nodes/<MEDIA_NODE_ID> (with all its query params to their default value). If query param wait is set to false, most of its properties will be null. All properties will be defined only after the Media Node reaches running status. HTTP responses 200 : the Media Node has been successfully added 400 : problem with some body parameter 404 : the Media Node is not within reach of OpenVidu Server. This simply means that OpenVidu cannot establish a connection with it. This may be caused by multiple reasons: wrong IP, port or path, a network problem, too strict a proxy configuration... 409 : the Media Node was already registered in OpenVidu Server 501 : configuration property openvidu.pro.cluster is set to false, or is true but property openvidu.pro.cluster.mode is set to manual and no uri parameter was passed in the body request. 502 : the process of launching a new Media Node instance failed. Only possible if property openvidu.pro.cluster.mode is set to auto DELETE /pro/media-nodes/<MEDIA_NODE_ID> REMOVE MEDIA NODE PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes/<MEDIA_NODE_ID> Query params deletion-strategy Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing Query params wait (optional boolean, default to false) : whether to wait until the new Media Node reaches terminated status or not. Setting this property to true basically makes this method synchronized. You will not receive an answer until the Media Node is fully terminated or an error is thrown. deletion-strategy (optional string, default to \"if-no-sessions\") : how should OpenVidu Pro proceed with the Media Node deletion. Can be: now : OpenVidu Pro will remove the Media Node immediately. All OpenVidu sessions hosted by this Media Node will be closed with reason mediaServerDisconnect (all streams, participants and recordings of all these sessions will be stopped with this same reason) if-no-sessions (default value) : if there's any OpenVidu session initialized inside of this Media Node, then this operation will fail with HTTP status 409 . If the Media Node has no ongoing sessions, then OpenVidu Pro will remove it immediately, returning status 204 when-no-sessions : if there's any OpenVidu session initialized inside this Media Node, then it will not be immediately deleted, but instead will be set to waiting-idle-to-terminate status. This status means the Media Node is under quarantine and no more sessions will be initialized inside of it. Whenever the last session of this Media Node is destroyed (no matter the reason), then it will be automatically deleted. The response status will be 202 if this operation changed the Media Node to waiting-idle-to-terminate status and 204 if there were no ongoing sessions inside the Media Node and therefore OpenVidu Pro has deleted it. Encode query params in the url like this: https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes/<MEDIA_NODE_ID> ?wait=false&deletion-strategy=now HTTP responses 202 : if query parameter deletion-strategy is set to when-no-sessions , then it means that the Media Node to be deleted has ongoing sessions inside of it. Media Node status has been set to waiting-idle-to-terminate 204 : the Media Node was successfully removed 404 : no Media Node exists for the passed MEDIA_NODE_ID 409 : if query parameter deletion-strategy is set to if-no-sessions , then it means that the Media Node to be deleted has ongoing sessions inside of it. No Media Node deletion will take place at all. 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes 502 : error while terminating the Media Node instance. Only possible if property openvidu.pro.cluster.mode is set to auto PATCH /pro/media-nodes/<MEDIA_NODE_ID> MODIFY MEDIA NODE PARAMETERS Operation PATCH URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes/<MEDIA_NODE_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"status\": \"MEDIA_NODE_STATUS\"} Sample return {\"id\": \"KMS-GVM2CW\", \"uri\": \"ws://localhost:8888/kurento\", \"ip\": \"localhost\", \"connected\": true, \"connectionTime\": 1562746120857, \"quarantined\": false} Body parameters status (mandatory string) : new desired status of the Media Node. Valid values are waiting-idle-to-terminate (from running status), running (from waiting-idle-to-terminate ) and terminating (from both running and waiting-idle-to-terminate ) Returned JSON The modified Media Node. Same JSON response as defined for GET /pro/media-nodes/<MEDIA_NODE_ID> (with all its query params to their default value) HTTP responses 200 : the Media Node has been successfully modified 204 : the Media Node has not been modified because its status was the same as the provided through body parameters 400 : problem with some body parameter. This will also be the status if you try to set property status to an invalid one ( launching , failed , terminated ) 404 : no Media Node exists for the passed MEDIA_NODE_ID 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes PUT /pro/media-nodes AUTODISCOVER MEDIA NODES PARAMETERS Operation PUT URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"numberOfElements\": 1, \"content\": [ \"id\": \"kms_LrMRlL42\", \"ip\": \"172.17.0.5\", \"uri\": \"ws://172.17.0.5:8888/kurento\", \"connected\": true, \"connectionTime\": 1583769116854, \"environmentId\": \"489ed9c4b4d761699dc93\", \"status\": \"running\" ]} Returned JSON numberOfElements : total number of newly autodiscovered Media Nodes content : array of newly autodiscovered Media Nodes. Each object has the same structure as defined in the returned JSON of GET /pro/media-nodes/<MEDIA_NODE_ID> (with all its query params to their default value) HTTP responses 200 : autodiscovery process has completed 405 : autodiscovery process is not possible. This may happen if OpenVidu Pro cluster environment is set to on_premise and no autodiscover script is available. 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes POST /pro/restart RESTART OPENVIDU PRO PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/pro/restart/ Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"openvidu.secret\": \"MY_SECRET\", \"openvidu.cdr\": true, \"openvidu.recording\": true, \"openvidu.recording.public-access\": true, \"openvidu.recording.notification\": \"publisher_moderator\", \"openvidu.recording.path\": \"/opt/openvidu/recordings\", \"openvidu.recording.custom-layout\": \"/opt/openvidu/custom-layout\", \"openvidu.recording.autostop-timeout\": 120, \"openvidu.webhook\": true, \"openvidu.webhook.endpoint\": \"http://localhost:7777/webhook/\", \"openvidu.webhook.headers\": [\\\"Authorization:\\ Basic\\ T1BFTlZJRFVBUFA6TVlfU0VDUkVU\\\"], \"openvidu.webhook.events\": [\"recordingStatusChanged\"], \"openvidu.streams.video.max-recv-bandwidth\": 1000, \"openvidu.streams.video.min-recv-bandwidth\": 300, \"openvidu.streams.video.max-send-bandwidth\": 1000, \"openvidu.streams.video.min-send-bandwidth\": 300, \"openvidu.pro.stats.monitoring-interval\": 30, \"openvidu.pro.stats.webrtc-interval\": 20} Body parameters The body of the POST request is a JSON object with the new OpenVidu system properties to be applied on the restart process. Not all of them are available, and a few are exclusive to OpenVidu Pro . The complete list of available properties is listed below openvidu.secret (optional string) : new secret to secure OpenVidu Pro openvidu.cdr (optional boolean) : whether to enable OpenVidu Call Detail Record or not openvidu.recording (optional boolean) : whether to enable OpenVidu recording module or not openvidu.recording.public-access (optional boolean) : whether to allow free http access to recorded sessions or not openvidu.recording.notification (optional string) : which users should receive the recording events in the client side ( \"all\" , \"publisher_moderator\" , \"moderator\" or \"none\" ) openvidu.recording.path (optional string) : system path where to store the video files of recorded session openvidu.recording.custom-layout (optional string) : sytem path where OpenVidu Server should look for custom recording layouts openvidu.recording.autostop-timeout (optional number) : timeout in seconds for recordings to automatically stop openvidu.webhook (optional boolean) : whether to enable webhook service or not openvidu.webhook.endpoint (optional string) : endpoint where OpenVidu Server should sent webhook events. Mandatory if openvidu.webhook is true openvidu.webhook.headers : (optional array of strings) : HTTP headers OpenVidu Server should attach to each POST message of webhook events openvidu.webhook.events (optional array of strings) : events for which a POST message will be sent by OpenVidu Server webhook service openvidu.streams.video.max-recv-bandwidth (optional number) : maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained openvidu.streams.video.min-recv-bandwidth (optional number) : minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained openvidu.streams.video.max-send-bandwidth (optional number) : maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained openvidu.streams.video.min-send-bandwidth (optional number) : minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained openvidu.pro.stats.monitoring-interval (optional number) : interval in seconds for CPU, memory and net usage stats gathering in OpenVidu Server Pro host machine. 0 means no gathering at all openvidu.pro.stats.webrtc-interval (optional number) : interval in seconds for WebRTC stats gathering from Kurento Media Server WebRTC endpoints. 0 means no gathering at all HTTP responses 200 : the restarting process has been initialized. All properties are valid and OpenVidu Server should restart properly 400 : there's some problem with a body parameter. The response message will provide further details NOTES This method will restart OpenVidu Server Pro with the new provided configuration parameters. If your have externalized OpenVidu Server Pro configuration , the new variables will be stored in the configuration file, so you will be able to restart the host without losing your new configuration GET /pro/config GET OPENVIDU PRO CONFIGURATION PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/pro/config Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"version\": \"2.10.0\", \"openviduPublicurl\": \"https://localhost:4443/\", \"openviduCdr\": false, \"maxRecvBandwidth\": 1000, \"minRecvBandwidth\": 300, \"maxSendBandwidth\": 1000, \"minSendBandwidth\": 300, \"openviduRecording\": true, \"openviduRecordingVersion\": \"2.9.0\", \"openviduRecordingPath\": \"/opt/openvidu/recordings/\", \"openviduRecordingPublicAccess\": false, \"openviduRecordingNotification\": \"publisher_moderator\", \"openviduRecordingCustomLayout\": \"/opt/openvidu/custom-layout/\", \"openviduRecordingAutostopTimeout\": 120, \"openviduWebhook\": true, \"openviduWebhookEndpoint\": \"http://localhost:7777/webhook/\", \"openviduWebhookHeaders\": [\"Authorization: Basic YWJjZDphYmNk\"], \"openviduWebhookEvents\": [\"recordingStatusChanged\"], \"openviduServerDependencyVersion\": \"2.10.0\", \"openviduProStatsMonitoringInterval\": 30, \"openviduProStatsWebrtcInterval\": 30, \"openviduProCluster\": false, \"openviduProClusterLoadStrategy\": \"streams\", \"kmsUris\": [\"ws://localhost:8888/kurento\"]} Returned JSON version : version of OpenVidu Server Pro openviduServerDependencyVersion : version of OpenVidu Server Community Edition upon which this version of OpenVidu Server Pro is built on Rest of properties : values given to system properties on OpenVidu Server Pro launch. These properties are mostly common to method GET /config of OpenVidu Server Community Edition. Some of them are unique for OpenVidu Server Pro","title":"REST API Pro"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#list-of-available-operations","text":"Get Media Node info: GET /pro/media-nodes/<MEDIA_NODE_ID> Get all Media Nodes info: GET /pro/media-nodes Add new Media Node: POST /pro/media-nodes Remove Media Node: DELETE /pro/media-nodes/<MEDIA_NODE_ID> Modify Media Node: PATCH /pro/media-nodes/<MEDIA_NODE_ID> Force Media Nodes autodiscovery: PUT /pro/media-nodes Restart OpenVidu Pro: POST /pro/restart Get OpenVidu Pro active configuration: GET /pro/config","title":"List of available operations"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#get-promedia-nodesltmedia_node_idgt","text":"GET MEDIA NODE INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes/<MEDIA_NODE_ID> Query params load , sessions , extra-info Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"id\": \"kms_RicdrF9x\", \"environmentId\": \"5372e1c954fd54c13706f476236\", \"ip\": \"172.17.0.4\", \"uri\": \"ws://172.17.0.4:8888/kurento\", \"connected\": true, \"connectionTime\": 1583753233620, \"sessions\": [], \"load\": 0.0, \"status\": \"running\"} Query params load (optional boolean, default to false) : whether to return Media Node load or not. The value will depend on configuration property openvidu.pro.cluster.load-strategy sessions (optional boolean, default to false) : whether to return session information along Media Node information or not. Only sessions hosted in this Media Node will be retrieved. Session information has same format as returned by method GET /api/sessions/<SESSION_ID> extra-info (optional boolean, default to false) : whether to return extra information about the Media Node or not. Only for advanced users Encode query params in the url like this: https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes ?load=true&sessions=false&extra-info=false Returned JSON id : Media Node unique identifier. Use it to perform other REST operations on this Media Node environmentId : Media Node identifier dependent on the deployment environment. For example, an AWS EC2 machine id if the cluster is deployed in AWS ip : Media Node IP uri : Media Node URI endpoint. This is the URI where OpenVidu Server will establish a connection with the Media Node connected : whether OpenVidu Server Pro is connected to this Media Node or not. This property may be set to false if there's an unexpected disconnection of the Media Node connectionTime : when did OpenVidu Server establish the connection with the Media Node (in UTC milliseconds) disconnectionTime : when did OpenVidu Server lose its connection to the Media Node (in UTC milliseconds). Only defined if connected is false sessions : session information of this Media Node. This property is an array of objects with the exact same format as the response returned by method GET /api/sessions/<SESSION_ID> . Only available if query param sessions is set to true load : load of the Media Node. Only available if query param load is set to true status : status of the Media Node (see Media Node statuses ) kurentoInfo : object with extra advanced information about this instance of Kurento Media Server (version, modules, memory usage...). Only available if query param extra-info is set to true (for advanced users, subject to change) HTTP responses 200 : the Media Node information has been successfully retrieved 404 : no Media Node exists for the passed MEDIA_NODE_ID 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes","title":"GET /pro/media-nodes/&amp;lt;MEDIA_NODE_ID&amp;gt;"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#get-promedia-nodes","text":"LIST MEDIA NODES INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes Query params load , sessions , extra-info Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"numberOfElements\": 1, \"content\": [ {\"id\": \"KMS-XU5ZRM\", \"uri\": \"ws://localhost:8888/kurento\", \"ip\": \"localhost\", \"connected\": true, \"connectionTime\": 1562744478463, \"load\": 0} ]} Query params load (optional boolean, default to false) : whether to return Media Nodes load or not. The value will depend on configuration property openvidu.pro.cluster.load-strategy sessions (optional boolean, default to false) : whether to return session information along Media Nodes information or not. Media Node will be retrieved. Session information has same format as returned by method GET /api/sessions/<SESSION_ID> extra-info (optional boolean, default to false) : whether to return extra information about the Media Nodes or not. Only for advanced users Encode query params in the url like this: https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes ?load=true&sessions=false&extra-info=false Returned JSON numberOfElements : total number of registered Media Nodes content : array of Media Nodes. Each object has the same structure as defined in the returned JSON of GET /pro/media-nodes/<MEDIA_NODE_ID> HTTP responses 200 : Media Nodes information has been successfully retrieved 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes","title":"GET /pro/media-nodes"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#post-promedia-nodes","text":"NEW MEDIA NODE PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes Query params wait Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"uri\": \"MEDIA_NODE_URI\"} Sample return { \"id\": \"kms_LrMRlL42\", \"ip\": \"172.17.0.5\", \"uri\": \"ws://172.17.0.5:8888/kurento\", \"connected\": true, \"connectionTime\": 1583769116854, \"environmentId\": \"489ed9c4b4d761699dc93\", \"status\": \"running\" } Query params wait (optional boolean, default to false) : whether to wait until the new Media Node reaches running status or not. Setting this property to true basically makes this method synchronized. You will not receive an answer until the Media Node is properly running or an error is thrown. Encode query params in the url like this: https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes ?wait=true Body parameters uri (mandatory string only if openvidu.pro.cluster.mode is manual ) : the websocket endpoint of a running Media Node. For a Kurento Media Server, it should be something similar to ws://media.server.ip:8888/kurento . This property is only necessary and is only taken into account if openvidu.pro.cluster.mode is set to manual . For mode auto a new Media Node will be automatically launched ignoring parameter uri Returned JSON Same JSON response as defined for GET /pro/media-nodes/<MEDIA_NODE_ID> (with all its query params to their default value). If query param wait is set to false, most of its properties will be null. All properties will be defined only after the Media Node reaches running status. HTTP responses 200 : the Media Node has been successfully added 400 : problem with some body parameter 404 : the Media Node is not within reach of OpenVidu Server. This simply means that OpenVidu cannot establish a connection with it. This may be caused by multiple reasons: wrong IP, port or path, a network problem, too strict a proxy configuration... 409 : the Media Node was already registered in OpenVidu Server 501 : configuration property openvidu.pro.cluster is set to false, or is true but property openvidu.pro.cluster.mode is set to manual and no uri parameter was passed in the body request. 502 : the process of launching a new Media Node instance failed. Only possible if property openvidu.pro.cluster.mode is set to auto","title":"POST /pro/media-nodes"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#delete-promedia-nodesltmedia_node_idgt","text":"REMOVE MEDIA NODE PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes/<MEDIA_NODE_ID> Query params deletion-strategy Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing Query params wait (optional boolean, default to false) : whether to wait until the new Media Node reaches terminated status or not. Setting this property to true basically makes this method synchronized. You will not receive an answer until the Media Node is fully terminated or an error is thrown. deletion-strategy (optional string, default to \"if-no-sessions\") : how should OpenVidu Pro proceed with the Media Node deletion. Can be: now : OpenVidu Pro will remove the Media Node immediately. All OpenVidu sessions hosted by this Media Node will be closed with reason mediaServerDisconnect (all streams, participants and recordings of all these sessions will be stopped with this same reason) if-no-sessions (default value) : if there's any OpenVidu session initialized inside of this Media Node, then this operation will fail with HTTP status 409 . If the Media Node has no ongoing sessions, then OpenVidu Pro will remove it immediately, returning status 204 when-no-sessions : if there's any OpenVidu session initialized inside this Media Node, then it will not be immediately deleted, but instead will be set to waiting-idle-to-terminate status. This status means the Media Node is under quarantine and no more sessions will be initialized inside of it. Whenever the last session of this Media Node is destroyed (no matter the reason), then it will be automatically deleted. The response status will be 202 if this operation changed the Media Node to waiting-idle-to-terminate status and 204 if there were no ongoing sessions inside the Media Node and therefore OpenVidu Pro has deleted it. Encode query params in the url like this: https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes/<MEDIA_NODE_ID> ?wait=false&deletion-strategy=now HTTP responses 202 : if query parameter deletion-strategy is set to when-no-sessions , then it means that the Media Node to be deleted has ongoing sessions inside of it. Media Node status has been set to waiting-idle-to-terminate 204 : the Media Node was successfully removed 404 : no Media Node exists for the passed MEDIA_NODE_ID 409 : if query parameter deletion-strategy is set to if-no-sessions , then it means that the Media Node to be deleted has ongoing sessions inside of it. No Media Node deletion will take place at all. 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes 502 : error while terminating the Media Node instance. Only possible if property openvidu.pro.cluster.mode is set to auto","title":"DELETE /pro/media-nodes/&amp;lt;MEDIA_NODE_ID&amp;gt;"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#patch-promedia-nodesltmedia_node_idgt","text":"MODIFY MEDIA NODE PARAMETERS Operation PATCH URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes/<MEDIA_NODE_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"status\": \"MEDIA_NODE_STATUS\"} Sample return {\"id\": \"KMS-GVM2CW\", \"uri\": \"ws://localhost:8888/kurento\", \"ip\": \"localhost\", \"connected\": true, \"connectionTime\": 1562746120857, \"quarantined\": false} Body parameters status (mandatory string) : new desired status of the Media Node. Valid values are waiting-idle-to-terminate (from running status), running (from waiting-idle-to-terminate ) and terminating (from both running and waiting-idle-to-terminate ) Returned JSON The modified Media Node. Same JSON response as defined for GET /pro/media-nodes/<MEDIA_NODE_ID> (with all its query params to their default value) HTTP responses 200 : the Media Node has been successfully modified 204 : the Media Node has not been modified because its status was the same as the provided through body parameters 400 : problem with some body parameter. This will also be the status if you try to set property status to an invalid one ( launching , failed , terminated ) 404 : no Media Node exists for the passed MEDIA_NODE_ID 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes","title":"PATCH /pro/media-nodes/&amp;lt;MEDIA_NODE_ID&amp;gt;"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#put-promedia-nodes","text":"AUTODISCOVER MEDIA NODES PARAMETERS Operation PUT URL https://<YOUR_OPENVIDUSERVER_IP>/pro/media-nodes Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"numberOfElements\": 1, \"content\": [ \"id\": \"kms_LrMRlL42\", \"ip\": \"172.17.0.5\", \"uri\": \"ws://172.17.0.5:8888/kurento\", \"connected\": true, \"connectionTime\": 1583769116854, \"environmentId\": \"489ed9c4b4d761699dc93\", \"status\": \"running\" ]} Returned JSON numberOfElements : total number of newly autodiscovered Media Nodes content : array of newly autodiscovered Media Nodes. Each object has the same structure as defined in the returned JSON of GET /pro/media-nodes/<MEDIA_NODE_ID> (with all its query params to their default value) HTTP responses 200 : autodiscovery process has completed 405 : autodiscovery process is not possible. This may happen if OpenVidu Pro cluster environment is set to on_premise and no autodiscover script is available. 501 : configuration property openvidu.pro.cluster is set to false. You need to enable cluster mode to be able to manage Media Nodes","title":"PUT /pro/media-nodes"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#post-prorestart","text":"RESTART OPENVIDU PRO PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/pro/restart/ Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"openvidu.secret\": \"MY_SECRET\", \"openvidu.cdr\": true, \"openvidu.recording\": true, \"openvidu.recording.public-access\": true, \"openvidu.recording.notification\": \"publisher_moderator\", \"openvidu.recording.path\": \"/opt/openvidu/recordings\", \"openvidu.recording.custom-layout\": \"/opt/openvidu/custom-layout\", \"openvidu.recording.autostop-timeout\": 120, \"openvidu.webhook\": true, \"openvidu.webhook.endpoint\": \"http://localhost:7777/webhook/\", \"openvidu.webhook.headers\": [\\\"Authorization:\\ Basic\\ T1BFTlZJRFVBUFA6TVlfU0VDUkVU\\\"], \"openvidu.webhook.events\": [\"recordingStatusChanged\"], \"openvidu.streams.video.max-recv-bandwidth\": 1000, \"openvidu.streams.video.min-recv-bandwidth\": 300, \"openvidu.streams.video.max-send-bandwidth\": 1000, \"openvidu.streams.video.min-send-bandwidth\": 300, \"openvidu.pro.stats.monitoring-interval\": 30, \"openvidu.pro.stats.webrtc-interval\": 20} Body parameters The body of the POST request is a JSON object with the new OpenVidu system properties to be applied on the restart process. Not all of them are available, and a few are exclusive to OpenVidu Pro . The complete list of available properties is listed below openvidu.secret (optional string) : new secret to secure OpenVidu Pro openvidu.cdr (optional boolean) : whether to enable OpenVidu Call Detail Record or not openvidu.recording (optional boolean) : whether to enable OpenVidu recording module or not openvidu.recording.public-access (optional boolean) : whether to allow free http access to recorded sessions or not openvidu.recording.notification (optional string) : which users should receive the recording events in the client side ( \"all\" , \"publisher_moderator\" , \"moderator\" or \"none\" ) openvidu.recording.path (optional string) : system path where to store the video files of recorded session openvidu.recording.custom-layout (optional string) : sytem path where OpenVidu Server should look for custom recording layouts openvidu.recording.autostop-timeout (optional number) : timeout in seconds for recordings to automatically stop openvidu.webhook (optional boolean) : whether to enable webhook service or not openvidu.webhook.endpoint (optional string) : endpoint where OpenVidu Server should sent webhook events. Mandatory if openvidu.webhook is true openvidu.webhook.headers : (optional array of strings) : HTTP headers OpenVidu Server should attach to each POST message of webhook events openvidu.webhook.events (optional array of strings) : events for which a POST message will be sent by OpenVidu Server webhook service openvidu.streams.video.max-recv-bandwidth (optional number) : maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained openvidu.streams.video.min-recv-bandwidth (optional number) : minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained openvidu.streams.video.max-send-bandwidth (optional number) : maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained openvidu.streams.video.min-send-bandwidth (optional number) : minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained openvidu.pro.stats.monitoring-interval (optional number) : interval in seconds for CPU, memory and net usage stats gathering in OpenVidu Server Pro host machine. 0 means no gathering at all openvidu.pro.stats.webrtc-interval (optional number) : interval in seconds for WebRTC stats gathering from Kurento Media Server WebRTC endpoints. 0 means no gathering at all HTTP responses 200 : the restarting process has been initialized. All properties are valid and OpenVidu Server should restart properly 400 : there's some problem with a body parameter. The response message will provide further details NOTES This method will restart OpenVidu Server Pro with the new provided configuration parameters. If your have externalized OpenVidu Server Pro configuration , the new variables will be stored in the configuration file, so you will be able to restart the host without losing your new configuration","title":"POST /pro/restart"},{"location":"openvidu-pro/reference-docs/REST-API-pro/#get-proconfig","text":"GET OPENVIDU PRO CONFIGURATION PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/pro/config Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"version\": \"2.10.0\", \"openviduPublicurl\": \"https://localhost:4443/\", \"openviduCdr\": false, \"maxRecvBandwidth\": 1000, \"minRecvBandwidth\": 300, \"maxSendBandwidth\": 1000, \"minSendBandwidth\": 300, \"openviduRecording\": true, \"openviduRecordingVersion\": \"2.9.0\", \"openviduRecordingPath\": \"/opt/openvidu/recordings/\", \"openviduRecordingPublicAccess\": false, \"openviduRecordingNotification\": \"publisher_moderator\", \"openviduRecordingCustomLayout\": \"/opt/openvidu/custom-layout/\", \"openviduRecordingAutostopTimeout\": 120, \"openviduWebhook\": true, \"openviduWebhookEndpoint\": \"http://localhost:7777/webhook/\", \"openviduWebhookHeaders\": [\"Authorization: Basic YWJjZDphYmNk\"], \"openviduWebhookEvents\": [\"recordingStatusChanged\"], \"openviduServerDependencyVersion\": \"2.10.0\", \"openviduProStatsMonitoringInterval\": 30, \"openviduProStatsWebrtcInterval\": 30, \"openviduProCluster\": false, \"openviduProClusterLoadStrategy\": \"streams\", \"kmsUris\": [\"ws://localhost:8888/kurento\"]} Returned JSON version : version of OpenVidu Server Pro openviduServerDependencyVersion : version of OpenVidu Server Community Edition upon which this version of OpenVidu Server Pro is built on Rest of properties : values given to system properties on OpenVidu Server Pro launch. These properties are mostly common to method GET /config of OpenVidu Server Community Edition. Some of them are unique for OpenVidu Server Pro","title":"GET /pro/config"},{"location":"openvidu-pro/reference-docs/openvidu-server-pro-cdr/","text":"OpenVidu Server Pro CDR OpenVidu Pro provides all of OpenVidu CE CDR events , but also includes some extra events of its own. Also remember that all OpenVidu Pro CDR events are also dispatched by OpenVidu Webhook, just as stated in OpenVidu CE documentation . Events in OpenVidu Pro CDR mediaNodeStatusChanged mediaNodeStatusChanged Recorded when the status of a Media Node of an OpenVidu Pro cluster has changed. This event is only triggered when OpenVidu Pro is running in cluster mode. See Scalability section to learn more. Property Description Value id Unique identifier of the Media Node A string with the Media Node unique identifier environmentId Unique identifier of the Media Node, dependent on the deployment environment. For example, an AWS EC2 machine id if the cluster is deployed in AWS A string with the Media Node environment unique identifier ip IP of the Media Node A string with the Media Node IP uri URI of the Media Node. This is the actual direction where OpenVidu Server Pro Media Node connects to this Media Node A string with the Media Node URI clusterId OpenVidu Pro cluster identifier. This allows you to identify the specific cluster to which the Media Node triggering this event belongs, specially if you have more than one OpenVidu Pro cluster running (see ) A string with the cluster identifier oldStatus Old status of the Media Node. See Media Node statuses A string with the Media Node old status. null if newStatus is launching newStatus New status of the Media Node. See Media Node statuses A string with the Media Node new status timestamp Time when the event was triggered UTC milliseconds Example: {\"mediaNodeStatusChanged\":{\"timestamp\":1583750581667,\"id\":\"kms_V3B5OxT7\",\"environmentId\":\"c76535087c5767b83a211036197115d071daf897bfd951bc18f834fc535d9fa9\",\"ip\":\"172.17.0.3\",\"uri\":\"ws://172.17.0.3:8888/kurento\",\"newStatus\":\"running\",\"oldStatus\":\"launching\",\"clusterId\":\"CLUSTER1\"}}","title":"OpenVidu Server Pro CDR"},{"location":"openvidu-pro/reference-docs/openvidu-server-pro-cdr/#events-in-openvidu-pro-cdr","text":"mediaNodeStatusChanged","title":"Events in OpenVidu Pro CDR"},{"location":"openvidu-pro/reference-docs/openvidu-server-pro-cdr/#medianodestatuschanged","text":"Recorded when the status of a Media Node of an OpenVidu Pro cluster has changed. This event is only triggered when OpenVidu Pro is running in cluster mode. See Scalability section to learn more. Property Description Value id Unique identifier of the Media Node A string with the Media Node unique identifier environmentId Unique identifier of the Media Node, dependent on the deployment environment. For example, an AWS EC2 machine id if the cluster is deployed in AWS A string with the Media Node environment unique identifier ip IP of the Media Node A string with the Media Node IP uri URI of the Media Node. This is the actual direction where OpenVidu Server Pro Media Node connects to this Media Node A string with the Media Node URI clusterId OpenVidu Pro cluster identifier. This allows you to identify the specific cluster to which the Media Node triggering this event belongs, specially if you have more than one OpenVidu Pro cluster running (see ) A string with the cluster identifier oldStatus Old status of the Media Node. See Media Node statuses A string with the Media Node old status. null if newStatus is launching newStatus New status of the Media Node. See Media Node statuses A string with the Media Node new status timestamp Time when the event was triggered UTC milliseconds Example: {\"mediaNodeStatusChanged\":{\"timestamp\":1583750581667,\"id\":\"kms_V3B5OxT7\",\"environmentId\":\"c76535087c5767b83a211036197115d071daf897bfd951bc18f834fc535d9fa9\",\"ip\":\"172.17.0.3\",\"uri\":\"ws://172.17.0.3:8888/kurento\",\"newStatus\":\"running\",\"oldStatus\":\"launching\",\"clusterId\":\"CLUSTER1\"}}","title":"mediaNodeStatusChanged"},{"location":"openvidu-pro/reference-docs/openvidu-server-pro-params/","text":"OpenVidu Server Pro configuration parameters OpenVidu Pro provides all of OpenVidu CE configuration parameters , but also includes some extra parameters of its own. Parameter Description Default value openvidu.pro.license License key of your OpenVidu Pro account. This parameter is mandatory to launch OpenVidu Pro clusters. Sign up now to get your free trial! openvidu.pro.cluster Whether to launch OpenVidu in cluster mode or not. See Scalability section to learn more false openvidu.pro.cluster.id Unique identifier of your cluster. Each OpenVidu Server Pro instance corresponds to one cluster. You can launch as many clusters as you want with your license key. Cluster ID will always be stored to disk so restarting OpenVidu Server Pro will keep the same previous cluster ID if this configuration parameter is not given a distinct value A random string openvidu.pro.cluster.environment Where is OpenVidu Pro cluster deployed. This way OpenVidu Pro will be able to manage the infrastructure on its own. Can be: [ docker , aws , on_premise ]. See Scalability section to learn more docker (suitable for development environments) openvidu.pro.cluster.mode Mode of cluster management. Can be auto (OpenVidu manages Media Nodes on its own. Parameter kms.uris is ignored) or manual (user must manage Media Nodes. Parameter kms.uris is used: if any uri is provided it must be valid) auto openvidu.pro.cluster.autodiscovery Whether to automatically add all running Media Nodes in reach of OpenVidu Pro or not. This is openvidu.pro.cluster.environment dependant and only enabled if openvidu.pro.cluster.mode is set to auto true openvidu.pro.cluster.media-nodes The desired number of Media Nodes on startup. First the autodiscovery process is performed. If there are too many Media Nodes after that, they will be dropped until this number is reached. If there are not enough, more will be launched. This only takes place if openvidu.pro.cluster.mode is set to auto 1 openvidu.pro.cluster.load-strategy What parameter should be used to distribute the creation of new sessions (and therefore distribution of load) among all available Media Nodes. Can be: \u2022 streams : load calculated counting the number of media streams flowing through the Media Node \u2022 sessions : load calculated counting the number of OpenVidu sessions hosted by the Media Node \u2022 mediaObjects : load calculated counting the number of low-level media objects inside the Media Node (WebRtc streams, RTSP streams, recorder endpoints... any low-level media processing element). This is the most accurate measure, but it also requires asking each Media Node to return their internal information each time load is calculated streams openvidu.pro.cluster.path Path where OpenVidu Server Pro will manage cluster-related files. This includes: looking for custom infrastructure management scripts and storing temporal output files with instances information /opt/openvidu/cluster openvidu.pro.cluster.test If true, OpenVidu Server Pro will perform a quick test on startup to check the clustering features: it will launch a Media Node, connect to it and finally drop it. OpenVidu Server Pro logs will inform about the test execution in detail. Immediately after finishing the test, OpenVidu Server Pro process will terminate with an exit code of 0 if the test was successful and 1 if it failed. This property is extremely useful to test that your OpenVidu Pro deployment is working fine false openvidu.pro.elasticsearch.host URL where the Elasticsearch service of OpenVidu Pro stack is listening. OpenVidu Pro will send to that URL useful statistics of your sessions. If this parameter is explicitly set to an empty string, OpenVidu Pro will not send any data to Elasticsearch. If it is defined, then it is mandatory that OpenVidu Pro is able to establish a connection to it or start up process will fail. By default OpenVidu Pro deployments have an Elasticsearch installation in localhost http://localhost:9200 openvidu.pro.elasticsearch.host URL where the Kibana service of OpenVidu Pro stack is listening. You can visualize Elasticsearch data in Kibana with the default dashboards provided by OpenVidu Pro, or you can create your own dashboards to better fit your necessities. If this parameter is explicitly set to an empty string, OpenVidu Pro will not connect to Kibana. If it is defined, then it is mandatory that OpenVidu Pro is able to establish a connection to it or start up process will fail. By default OpenVidu Pro deployments have a Kibana installation in localhost http://localhost:5601 openvidu.pro.stats.monitoring-interval Interval in seconds for CPU, memory and net usage stats gathering in OpenVidu Server Pro host. Set it to 0 for no gathering at all 30 openvidu.pro.stats.webrtc-interval Interval in seconds for WebRTC stats gathering from Media Nodes WebRTC endpoints. Set it to 0 for no gathering at all 30 Example: java -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://my.openvidu.server.ip:4443/ -Dopenvidu.cdr=true -Dopenvidu.pro.cluster=true -Dopenvidu.pro.cluster.load-strategy=streams -Dopenvidu.pro.cluster.mode=auto -Dopenvidu.pro.cluster.media-nodes=3 -Dopenvidu.pro.stats.webrtc-interval=0 -jar openvidu-server-pro.jar","title":"OpenVidu Server Pro configuration"},{"location":"reference-docs/REST-API/","text":"REST API All REST operations have in common the header referred to authorization. It is implemented via Basic Auth, and it is as simple as applying Base64 encoding to the username (always \"OPENVIDUAPP\") and the password (your secret shared with openvidu-server). If authorization header is wrong, every call to any REST API operation will return HTTP status 401 . For example, for secret \"MY_SECRET\", the final valid HTTP header would be Authorization: Basic T1BFTlZJRFVBUFA6TVlfU0VDUkVU List of available operations Initialize a session: POST /api/sessions Generate a token: POST /api/tokens Retrieve active session info: GET /api/sessions/<SESSION_ID> Retrieve all active sessions info: GET /api/sessions Send a signal to a session: POST /api/signal Close a session: DELETE /api/sessions/<SESSION_ID> Force the disconnection of a user from a session: DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> Force the unpublishing of a user's stream from a session: DELETE /api/sessions/<SESSION_ID>/stream/<STREAM_ID> Publish a stream from an IP camera: POST /api/sessions/<SESSION_ID>/connection Start the recording of a session: POST /api/recordings/start Stop the recording of a session: POST/api/recordings/stop/<RECORDING_ID> Get recording info: GET /api/recordings/<RECORDING_ID> Get all recordings info: GET /api/recordings Delete a recording: DELETE /api/recordings/<RECORDING_ID> Get OpenVidu active configuration: GET /config POST /api/sessions NEW SESSIONID PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"mediaMode\": \"MEDIA_MODE\", \"recordingMode\": \"RECORDING_MODE\", \"customSessionId\": \"CUSTOM_SESSION_ID\", \"defaultOutputMode\": \"OUTPUT_MODE\", \"defaultRecordingLayout\": \"RECORDING_LAYOUT\", \"defaultCustomLayout\": \"CUSTOM_LAYOUT\"} Sample return {\"id\": \"zfgmthb8jl9uellk\", \"createdAt\": 1538481996019} Body parameters mediaMode (optional string) ROUTED (default) : Media streams will be routed through OpenVidu Server. This Media Mode is mandatory for session recording Not available yet: RELAYED recordingMode (optional string) ALWAYS : Automatic recording from the first user publishing until the last participant leaves the session MANUAL (default) : If you want to manage when start and stop the recording customSessionId (optional string) You can fix the sessionId that will be assigned to the session with this parameter. If you make another request with the exact same customSessionId while previous session already exists, no session will be created and a 409 http response will be returned. If this parameter is an empty string or not sent at all, OpenVidu Server will generate a random sessionId for you. If set, it must be an alphanumeric string: allowed numbers [ 0-9 ], letters [ a-zA-Z ], dashes ( - ) and underscores ( _ ) defaultOutputMode (optional string) COMPOSED (default) : when recording the session, all streams will be composed in the same file in a grid layout INDIVIDUAL : when recording the session, every stream is recorded in its own file defaultRecordingLayout (optional string. Only applies if defaultOutputMode is set to COMPOSED ) BEST_FIT (default) : A grid layout where all the videos are evenly distributed CUSTOM : Use your own custom layout. See Custom recording layouts section to learn how Not available yet: PICTURE_IN_PICTURE , VERTICAL_PRESENTATION , HORIZONTAL_PRESENTATION defaultCustomLayout (optional string. Only applies if defaultRecordingLayout is set to CUSTOM ) A relative path indicating the custom recording layout to be used if more than one is available. Default to empty string (if so custom layout expected under path set with openvidu-server configuration property openvidu.recording.custom-layout ) Returned JSON id : session identifier. Store it for performing future operations onto this session createdAt : time when the session was created in UTC milliseconds HTTP responses 200 : session successfully created and sessionId ready to be used 400 : problem with some body parameter 409 : parameter customSessionId corresponds to an existing session. There has been no change at all in the state of OpenVidu Server. You can proceed to use the rejected custom sessionId as usual without a problem POST /api/tokens NEW TOKEN PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/tokens Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"session\": \"SESSION_ID\", \"role\": \"ROLE\", \"data\": \"DATA\", \"kurentoOptions\": KURENTO_OPTIONS} Sample return {\"id\":\"wss://localhost:4443?sessionId=zfgmthb8jl9uellk&token=lnlrtnkwm4v8l7uc&role=PUBLISHER&turnUsername=FYYNRC&turnCredential=yfxxs3\", \"session\": \"zfgmthb8jl9uellk\", \"role\": \"PUBLISHER\", \"data\": \"User Data\", \"token\":\"wss://localhost:4443?sessionId=zfgmthb8jl9uellk&token=lnlrtnkwm4v8l7uc&role=PUBLISHER&turnUsername=FYYNRC&turnCredential=yfxxs3\", \"kurentoOptions\": {\"videoMaxSendBandwidth\": 700, \"allowedFilters\": [\"GStreamerFilter\", \"ZBarFilter\"]}} Body parameters session (mandatory string) : the sessionId for which the token should be associated role (optional string. Check OpenViduRole section of OpenVidu Node Client for a complete description) SUBSCRIBER PUBLISHER (default) MODERATOR data (optional string) : metadata associated to this token (usually participant's information) kurentoOptions (optional JSON object) : you can set some configuration properties for the participant owning this token regarding Kurento. This is a JSON object with the following optional properties: videoMaxRecvBandwidth : maximum number of Kbps that the client owning the token will be able to receive from Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in OpenVidu Server configuration (parameter openvidu.streams.video.max-recv-bandwidth ) for every incoming stream of the user owning the token. WARNING : the lower value set to this property limits every other bandwidth of the WebRTC pipeline this server-to-client stream belongs to. This includes the user publishing the stream and every other user subscribed to the same stream. videoMinRecvBandwidth : minimum number of Kbps that the client owning the token will try to receive from Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in OpenVidu Server configuration (parameter openvidu.streams.video.min-recv-bandwidth ) for every incoming stream of the user owning the token. videoMaxSendBandwidth : maximum number of Kbps that the client owning the token will be able to send to Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in OpenVidu Server configuration (parameter openvidu.streams.video.max-send-bandwidth ) for every outgoing stream of the user owning the token. WARNING : this value limits every other bandwidth of the WebRTC pipeline this client-to-server stream belongs to. This includes every other user subscribed to the stream. videoMinSendBandwidth : minimum number of Kbps that the client owning the token will try to send to Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in OpenVidu Server configuration (parameter openvidu.streams.video.min-send-bandwidth ) for every outgoing stream of the user owning the token. allowedFilters : array of strings containing the names of the filters the user owning the token will be able to apply (see Voice and video filters ) Returned JSON token : token value. Send it to one client to pass it as a parameter in openvidu-browser method Session.connect session : same as in the body request role : same as in the body request data : same as in the body request id : same value as token kurentoOptions : object with Kurento configuration if provided, same as in the body request HTTP responses 200 : token successfully created and ready to be used by one client to connect to the associated session 400 : problem with some body parameter 404 : provided value for session parameter was not found in OpenVidu Server. You must first call POST /api/sessions to get a session id GET /api/sessions/<SESSION_ID> GET SESSION INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"sessionId\":\"TestSession\",\"createdAt\":1538482606338,\"mediaMode\":\"ROUTED\",\"recordingMode\":\"MANUAL\",\"defaultOutputMode\":\"COMPOSED\",\"defaultRecordingLayout\":\"BEST_FIT\",\"customSessionId\":\"TestSession\",\"connections\":{\"numberOfElements\":2,\"content\":[{\"connectionId\":\"vhdxz7abbfirh2lh\",\"createdAt\":1538482606412,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession&token=2ezkertrimk6nttk&role=PUBLISHER&turnUsername=H0EQLL&turnCredential=kjh48u\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient1\",\"publishers\":[{\"createdAt\":1538482606976,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"mediaOptions\":{\"hasAudio\":true,\"audioActive\":true,\"hasVideo\":true,\"videoActive\":true,\"typeOfVideo\":\"CAMERA\",\"frameRate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"filter\":{}}}],\"subscribers\":[]},{\"connectionId\":\"maxawd3ysuj1rxvq\",\"createdAt\":1538482607659,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession&token=ovj1b4ysuqmcirti&role=PUBLISHER&turnUsername=INOAHN&turnCredential=oujrqd\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient2\",\"publishers\":[],\"subscribers\":[{\"createdAt\":1538482607799,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"publisher\":\"vhdxz7abbfirh2lh\"}]}]},\"recording\":false} Returned JSON sessionId : identifier of the session (identical to SESSION_ID url parameter) createdAt : time when the session was created in UTC milliseconds mediaMode : media mode configured for the session ( ROUTED or RELAYED ) recording : whether the session is being recorded or not at this moment recordingMode : recording mode configured for the session ( ALWAYS or MANUAL ) defaultOutputMode : the default output mode for the recordings of the session ( COMPOSED or INDIVIDUAL ) defaultRecordingLayout : the default recording layout configured for the recordings of the session. Only defined if field defaultOutputMode is set to COMPOSED defaultCustomLayout : the default custom layout configured for the recordings of the session. Its format is a relative path. Only defined if field defaultRecordingLayout is set to CUSTOM customSessionId : custom session identifier. Only defined if the session was initialized passing a customSessionId field (see POST /api/sessions ) connections : collection of active connections in the session. This object is defined by a numberOfElements property counting the total number of active connections and a content array with the actual connections. Each object of this array has this structure: connectionId : identifier of the user's connection createdAt : time when the connection was established in UTC milliseconds location : geo location of the participant PRO platform : complete description of the platform used by the participant to connect to the session role : role of the connection clientData : data defined in OpenVidu Browser when calling Session.connect ( metadata parameter) serverData : data assigned to the user's token when generating the token in OpenVidu Server token : user's token publishers : array of Publisher objects (streams the user is publishing). Each one is defined by the unique streamId property, has a createdAt property indicating the time it was created in UTC milliseconds and has a mediaOptions object with the current properties of the published stream (\"hasVideo\",\"hasAudio\",\"videoActive\",\"audioActive\",\"frameRate\",\"videoDimensions\",\"typeOfVideo\", \"filter\") subscribers : array of Subscriber objects (streams the user is subscribed to). Each on is defined by the unique streamId and a publisher property with the connectionId to identify the connection publishing the stream (must be present inside the connections.content array of the session) HTTP responses 200 : the session information has been successfully retrieved 404 : no session exists for the passed SESSION_ID GET /api/sessions GET ALL SESSION INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"numberOfElements\":1,\"content\":[{\"sessionId\":\"TestSession\",\"createdAt\":1538482606338,\"mediaMode\":\"ROUTED\",\"recordingMode\":\"MANUAL\",\"defaultOutputMode\":\"COMPOSED\",\"defaultRecordingLayout\":\"BEST_FIT\",\"customSessionId\":\"TestSession\",\"connections\":{\"numberOfElements\":2,\"content\":[{\"connectionId\":\"vhdxz7abbfirh2lh\",\"createdAt\":1538482606412,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession&token=2ezkertrimk6nttk&role=PUBLISHER&turnUsername=H0EQLL&turnCredential=kjh48u\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient1\",\"publishers\":[{\"createdAt\":1538482606976,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"mediaOptions\":{\"hasAudio\":true,\"audioActive\":true,\"hasVideo\":true,\"videoActive\":true,\"typeOfVideo\":\"CAMERA\",\"frameRate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"filter\":{}}}],\"subscribers\":[]},{\"connectionId\":\"maxawd3ysuj1rxvq\",\"createdAt\":1538482607659,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession&token=ovj1b4ysuqmcirti&role=PUBLISHER&turnUsername=INOAHN&turnCredential=oujrqd\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient2\",\"publishers\":[],\"subscribers\":[{\"createdAt\":1538482607799,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"publisher\":\"vhdxz7abbfirh2lh\"}]}]},\"recording\":false}]} Returned JSON numberOfElements : total number of active sessions content : array of sessions. Each object has the same structure as defined in the returned JSON of GET /api/sessions/<SESSION_ID> HTTP responses 200 : all the session information has been successfully retrieved POST /api/signal SEND A SIGNAL PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/signal Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"session\": \"SESSION_ID\", \"to\": [\"connectionId1\", \"connectionId2\"], \"type\": \"MY_TYPE\", \"data\": \"This is my signal data\"} Sample return Returns nothing Body parameters session (mandatory string) : the sessionId of the session you want to send the signal to to (optional array of strings) : list of connection identifiers to which you want to send the signal. If this property is not included or is an empty array, the signal will be sent to all participants of the session type (optional string) : type of the signal. In the body example of the table above, only users subscribed to Session.on('signal:MY_TYPE') will trigger that signal. Users subscribed to Session.on('signal') will trigger signals of any type data (optional string) : actual data of the signal HTTP responses 200 : signal successfully sent. This doesn't necessary mean that all the intended recipients will have received it correctly. If any user has lost its connection to OpenVidu Server during this process, it may not receive the signal 400 : there is a problem with some body parameter 404 : no session exists for the passed SESSION_ID 406 : no connection exists for the passed to array. This error may be triggered if the session has no connected participants or if you provide some string value that does not correspond to a valid connectionId of the session (even though others may be correct) DELETE /api/sessions/<SESSION_ID> CLOSE SESSION PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing HTTP responses 204 : the session has been successfully closed. Every participant will have received the proper events in OpenVidu Browser: streamDestroyed , connectionDestroyed and sessionDisconnected , all of them with \"reason\" property set to \"sessionClosedByServer\". Depending on the order of eviction of the users, some of them will receive more events than the others (the first one will only receive the events related to himself, last one will receive every possible event) 404 : no session exists for the passed SESSION_ID DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> FORCE DISCONNECTION PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing HTTP responses 204 : the user has been successfully evicted from the session. Every participant will have received the proper events in OpenVidu Browser: streamDestroyed if the user was publishing, connectionDestroyed for the remaining users and sessionDisconnected for the evicted user. All of them with \"reason\" property set to \"forceDisconnectByServer\" 400 : no session exists for the passed SESSION_ID 404 : no connection exists for the passed CONNECTION_ID DELETE /api/sessions/<SESSION_ID>/stream/<STREAM_ID> FORCE UNPUBLISHING PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID>/stream/<STREAM_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing HTTP responses 204 : the stream has been successfully unpublished. Every participant will have received the proper streamDestroyed event in OpenVidu Browser with \"reason\" property set to \"forceUnpublishByServer\" 400 : no session exists for the passed SESSION_ID 404 : no stream exists for the passed STREAM_ID 405 : you cannot directly delete the stream of an IPCAM participant (any participant created with method POST /api/sessions/<SESSION_ID>/connection ). Instead you must delete the connection object with DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> POST /api/sessions/<SESSION_ID>/connection Available from OpenVidu >= 2.12.0 PUBLISH IP CAMERA PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID>/connection Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"type\": \"IPCAM\", \"rtspUri\": \"rtsp://b1.dnsdojo.com:1935/live/sys3.stream\", \"adaptativeBitrate\": true, \"onlyPlayWithSubscribers\": true, \"data\": \"Office security camera\"} Sample return {\"connectionId\": \"ipc_IPCAM_rtsp_A8MJ_91_191_213_49_554_live_mpeg4_sdp\", \"createdAt\": 1582121476379, \"location\": \"unknown\", \"platform\": \"IPCAM\", \"role\": \"PUBLISHER\", \"serverData\": \"MY_IP_CAMERA\", \"publishers\": [{\"createdAt\": 1582121476439, \"streamId\": \"str_IPC_XC1W_ipc_IPCAM_rtsp_A8MJ_91_191_213_49_554_live_mpeg4_sdp\", \"rtspUri\": \"rtsp://91.191.213.49:554/live_mpeg4.sdp\", \"mediaOptions\": {\"hasAudio\": true, \"audioActive\": true, \"hasVideo\": true, \"videoActive\": true, \"typeOfVideo\": \"IPCAM\", \"frameRate\": null, \"videoDimensions\": null, \"filter\": {}, \"adaptativeBitrate\": true, \"onlyPlayWithSubscribers\": true}} ], \"subscribers\": []} Body parameters type (optional string) : which type of stream will be published. For now can only be IPCAM . Default to IPCAM rtspUri (mandatory string) : RTSP URI of the IP camera. For example: rtsp://your.camera.ip:7777/path adaptativeBitrate (optional boolean) : whether to use adaptative bitrate (and therefore adaptative quality) or not. For local network connections that do not require media transcoding this can be disabled to save CPU power. If you are not sure if transcoding might be necessary, setting this property to false may result in media connections not being established . Default to true onlyPlayWithSubscribers (optional boolean) : enable the IP camera stream only when some user is subscribed to it. This allows you to reduce power consumption and network bandwidth in your server while nobody is asking to receive the camera's video. On the counterpart, first user subscribing to the IP camera stream will take a little longer to receive its video. Default to true data (optional string) : metadata you want to associate to the camera's participant. This will be included as Connection.data property received by your clients on connectionCreated event, and will also be available in backend events ( CDR and Webhook ) Returned JSON Returns the new Connection object. This object is the same as each JSON object in the connections.content array returned by method GET /api/sessions/<SESSION_ID> connectionId : identifier of the camera's connection. Store it to perform other operations such as unpublish the IP camera from the session createdAt : time when the connection was established in UTC milliseconds location : geo location of the IP camera PRO platform : \"IPCAM\" role : \"PUBLISHER\" clientData : \"\" (IP camera connections cannot be initialized from the client-side) serverData : data associated to the IP camera connection with query parameter data token : undefined (IP camera connections do not have a token associated) publishers : array of Publisher objects (streams the camera is publishing. There will only be one object). Each one is defined by the unique streamId property, has a createdAt property indicating the time it was created in UTC milliseconds and has a mediaOptions object with the current properties of the published stream (\"hasVideo\", \"hasAudio\", \"videoActive\", \"audioActive\", \"frameRate\", \"videoDimensions\", \"typeOfVideo\", \"filter\") subscribers : [] (camera is always a send-only connection, so it won't have any subscriber object) HTTP responses 200 : the IP camera has been successfully published to the session. Every participant will have received the proper events in OpenVidu Browser: connectionCreated identifying the new camera participant and streamCreated so they can subscribe to the IP camera stream. 400 : problem with some body parameter 404 : no session exists for the passed SESSION_ID 500 : unexpected error when publishing the IP camera stream into the session. See the error message for further information POST /api/recordings/start START SESSION RECORDING PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings/start Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"session\": \"SESSION_ID\", \"name\": \"NAME\", \"outputMode\": \"OUTPUT_MODE\", \"hasAudio\": \"HAS_AUDIO\", \"hasVideo\": \"HAS_VIDEO\", \"resolution\": \"RESOLUTION\", \"recordingLayout\": \"RECORDING_LAYOUT\", \"customLayout\": \"CUSTOM_LAYOUT\"} Sample return {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\":true, \"hasVideo\":false,\"createdAt\":1538483606521, \"size\":3205004, \"duration\":12.92, \"url\":null, \"status\": \"started\"} Body parameters session (mandatory string) : the sessionId belonging to the session you want to start recording name (optional string) : the name you want to give to the video file. You can access this same property in openvidu-browser on recordingEvents. If no name is provided, the video file will be named after id property of the recording outputMode (optional string) : record all streams in a single file in a grid layout or record each stream in its own separate file. This property will override the defaultOutputMode property set on POST /api/sessions for this particular recording COMPOSED (default) : when recording the session, all streams will be composed in the same file in a grid layout INDIVIDUAL : when recording the session, every stream is recorded in its own file hasAudio (optional boolean) : whether to record audio or not. Default to true hasVideo (optional boolean) : whether to record video or not. Default to true recordingLayout (optional string. Only applies if outputMode is set to COMPOSED and hasVideo to true) : the layout to be used in this recording. This property will override the defaultRecordingLayout property set on POST /api/sessions for this particular recording. BEST_FIT (default) : A grid layout where all the videos are evenly distributed CUSTOM : Use your own custom layout. See Custom recording layouts section to learn how Not available yet: PICTURE_IN_PICTURE , VERTICAL_PRESENTATION , HORIZONTAL_PRESENTATION customLayout (optional string. Only applies if recordingLayout is set to CUSTOM ) : a relative path indicating the custom recording layout to be used if more than one is available. Default to empty string (if so custom layout expected under path set with openvidu-server system property openvidu.recording.custom-layout ) . This property will override the defaultCustomLayout property set on POST /api/sessions for this particular recording resolution (optional string. Only applies if outputMode is set to COMPOSED and hasVideo to true) : the resolution of the recorded video file. It is a string indicating the width and height in pixels like this: \"1920x1080\" . Values for both width and height must be between 100 and 1999 Returned JSON id : recording identifier. Store it to perform other operations such as stop, get or delete the recording sessionId : session associated to the recording (same value as session in the body request) name : name of the recording. If no name parameter is passed in the POST operation, will be equal to id field outputMode : output mode of the recording hasAudio : true if the recording has an audio track, false otherwise hasVideo : true if the recording has a video track, false otherwise recordingLayout : the recording layout that is being used. Only defined if outputMode is set to COMPOSED and hasVideo to true customLayout : the custom layout that is being used. Only defined if recordingLayout is set to CUSTOM resolution : resolution of the video file. Only defined if outputMode is set to COMPOSED and hasVideo to true createdAt : time when the recording started in UTC milliseconds size : size in bytes of the video file (0 until stop operation is called) duration : duration of the video file in seconds (0 until stop operation is called) url : set to null status : set to \"started\" HTTP responses 200 : the session has started to be recorded. The moment this response is retrieved, it means that the video file is already created and contains proper data, and that the recording can be stopped with guarantees 400 : problem with some body parameter 422 : resolution parameter exceeds acceptable values (for both width and height, min 100px and max 1999px) or trying to start a recording with both hasAudio and hasVideo to false 404 : no session exists for the passed sessionId parameter 406 : the session has no connected participants 409 : the session is not configured for using MediaMode ROUTED or it is already being recorded 501 : OpenVidu Server recording module is disabled ( openvidu.recording property set to false ) POST /api/recordings/stop/<RECORDING_ID> STOP SESSION RECORDING PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings/stop/<RECORDING_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": null, \"status\": \"stopped\"} Returned JSON id : recording identifier sessionId : session associated to the recording name : name of the recording. If no name parameter is passed when starting the recording, will be equal to id field outputMode : output mode of the recording hasAudio : true if the recording has an audio track, false otherwise hasVideo : true if the recording has a video track, false otherwise recordingLayout : the recording layout used in the recording. Only defined if outputMode is set to COMPOSED and hasVideo to true customLayout : the custom layout used in the recording. Only defined if recordingLayout is set to CUSTOM resolution : resolution of the video file. Only defined if outputMode is set to COMPOSED and hasVideo to true createdAt : time when the recording started in UTC milliseconds size : size in bytes of the video file duration : duration of the video file in seconds url : set to \"https://YOUR_OPENVIDUSERVER_IP/recordings/<RECORDING_ID>/<RECORDING_NAME>.<EXTENSION>\" . This path will be protected with OpenVidu credentials depending on whether openvidu-server system property openvidu.recording.public-access is false or true status : set to \"stopped\" or \"available\" depending on whether openvidu-server system property openvidu.recording.public-access is false or true HTTP responses 200 : the session has successfully stopped from being recorded. The video file is ready to be reproduced 404 : no recording exists for the passed RECORDING_ID 406 : recording has starting status. Wait until started status before stopping the recording GET /api/recordings/<RECORDING_ID> GET RECORDING INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings/<RECORDING_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": null, \"status\": \"stopped\"} Returned JSON id : recording identifier sessionId : session associated to the recording name : name of the recording. If no name parameter is passed when starting the recording, will be equal to id field outputMode : output mode of the recording hasAudio : true if the recording has an audio track, false otherwise hasVideo : true if the recording has a video track, false otherwise recordingLayout : the recording layout used in the recording. Only defined if outputMode is set to COMPOSED and hasVideo to true customLayout : the custom layout used in the recording. Only defined if recordingLayout is set to CUSTOM resolution : resolution of the video file. Only defined if outputMode is set to COMPOSED and hasVideo to true createdAt : time when the recording started in UTC milliseconds size : size in bytes of the video file (0 until stop operation is called) duration : duration of the video file in seconds (0 until stop operation is called) url : set to null until stop operation is called. Then it will be \"https://YOUR_OPENVIDUSERVER_IP/recordings/<RECORDING_ID>/<RECORDING_NAME>.<EXTENSION>\" , path that may be protected with OpenVidu credentials depending on whether openvidu-server system property openvidu.recording.public-access is false or true. status : status of the recording ( \"starting\" , \"started\" , \"stopped\" , \"available\" , \"failed\" ) HTTP responses 200 : the recording information has been successfully retrieved 404 : no recording exists for the passed RECORDING_ID GET /api/recordings LIST RECORDINGS INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"count\": 2, \"items\": [{\"id\": \"n0kcws1evvn3esmo\", \"sessionId\": \"n0kcws1evvn3esmo\", \"name\": \"n0kcws1evvn3esmo\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": true, \"recordingLayout\": \"BEST_FIT\", \"resolution\": \"1920x1080\", \"createdAt\": 1521202349460, \"size\": 22887561, \"duration\": 132.08, \"url\": \"https://localhost:4443/recordings/n0kcws1evvn3esmo/n0kcws1evvn3esmo.mp4\", \"status\": \"available\"}, {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": \"https://localhost:4443/recordings/fds4e07mdug1ga3h/MyRecording.webm\", \"status\": \"available\"}]} Returned JSON count : number of total recordings items : array of recording information in JSON format. Each item has the same properties as stated in the return value of method GET /api/recordings/<RECORDING_ID> HTTP responses 200 : all of the available recording information has been successfully retrieved DELETE /api/recordings/<RECORDING_ID> DELETE RECORDING PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings/<RECORDING_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing HTTP responses 204 : the video file and all of its metadata has been successfully deleted from the host 404 : no recording exists for the passed RECORDING_ID 409 : the recording has \"started\" status. Stop it before deletion GET /config GET OPENVIDU CONFIGURATION PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/config Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"version\": \"2.9.0\", \"openviduPublicurl\": \"https://localhost:4443/\", \"openviduCdr\": false, \"maxRecvBandwidth\": 1000, \"minRecvBandwidth\": 300, \"maxSendBandwidth\": 1000, \"minSendBandwidth\": 300, \"openviduRecording\": true, \"openviduRecordingVersion\": \"2.8.0\", \"openviduRecordingPath\": \"/opt/openvidu/recordings/\", \"openviduRecordingPublicAccess\": true, \"openviduRecordingNotification\": \"publisher_moderator\", \"openviduRecordingCustomLayout\": \"/opt/openvidu/custom-layout/\", \"openviduRecordingAutostopTimeout\": 120, \"openviduWebhook\": true, \"openviduWebhookEndpoint\": \"http://localhost:7777/webhook/\", \"openviduWebhookHeaders\": [\"Authorization: Basic YWJjZDphYmNk\"], \"openviduWebhookEvents\": [\"recordingStatusChanged\"]} Returned JSON version : version of OpenVidu Server Rest of properties : values given to system properties on OpenVidu Server launch","title":"REST API"},{"location":"reference-docs/REST-API/#list-of-available-operations","text":"Initialize a session: POST /api/sessions Generate a token: POST /api/tokens Retrieve active session info: GET /api/sessions/<SESSION_ID> Retrieve all active sessions info: GET /api/sessions Send a signal to a session: POST /api/signal Close a session: DELETE /api/sessions/<SESSION_ID> Force the disconnection of a user from a session: DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> Force the unpublishing of a user's stream from a session: DELETE /api/sessions/<SESSION_ID>/stream/<STREAM_ID> Publish a stream from an IP camera: POST /api/sessions/<SESSION_ID>/connection Start the recording of a session: POST /api/recordings/start Stop the recording of a session: POST/api/recordings/stop/<RECORDING_ID> Get recording info: GET /api/recordings/<RECORDING_ID> Get all recordings info: GET /api/recordings Delete a recording: DELETE /api/recordings/<RECORDING_ID> Get OpenVidu active configuration: GET /config","title":"List of available operations"},{"location":"reference-docs/REST-API/#post-apisessions","text":"NEW SESSIONID PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"mediaMode\": \"MEDIA_MODE\", \"recordingMode\": \"RECORDING_MODE\", \"customSessionId\": \"CUSTOM_SESSION_ID\", \"defaultOutputMode\": \"OUTPUT_MODE\", \"defaultRecordingLayout\": \"RECORDING_LAYOUT\", \"defaultCustomLayout\": \"CUSTOM_LAYOUT\"} Sample return {\"id\": \"zfgmthb8jl9uellk\", \"createdAt\": 1538481996019} Body parameters mediaMode (optional string) ROUTED (default) : Media streams will be routed through OpenVidu Server. This Media Mode is mandatory for session recording Not available yet: RELAYED recordingMode (optional string) ALWAYS : Automatic recording from the first user publishing until the last participant leaves the session MANUAL (default) : If you want to manage when start and stop the recording customSessionId (optional string) You can fix the sessionId that will be assigned to the session with this parameter. If you make another request with the exact same customSessionId while previous session already exists, no session will be created and a 409 http response will be returned. If this parameter is an empty string or not sent at all, OpenVidu Server will generate a random sessionId for you. If set, it must be an alphanumeric string: allowed numbers [ 0-9 ], letters [ a-zA-Z ], dashes ( - ) and underscores ( _ ) defaultOutputMode (optional string) COMPOSED (default) : when recording the session, all streams will be composed in the same file in a grid layout INDIVIDUAL : when recording the session, every stream is recorded in its own file defaultRecordingLayout (optional string. Only applies if defaultOutputMode is set to COMPOSED ) BEST_FIT (default) : A grid layout where all the videos are evenly distributed CUSTOM : Use your own custom layout. See Custom recording layouts section to learn how Not available yet: PICTURE_IN_PICTURE , VERTICAL_PRESENTATION , HORIZONTAL_PRESENTATION defaultCustomLayout (optional string. Only applies if defaultRecordingLayout is set to CUSTOM ) A relative path indicating the custom recording layout to be used if more than one is available. Default to empty string (if so custom layout expected under path set with openvidu-server configuration property openvidu.recording.custom-layout ) Returned JSON id : session identifier. Store it for performing future operations onto this session createdAt : time when the session was created in UTC milliseconds HTTP responses 200 : session successfully created and sessionId ready to be used 400 : problem with some body parameter 409 : parameter customSessionId corresponds to an existing session. There has been no change at all in the state of OpenVidu Server. You can proceed to use the rejected custom sessionId as usual without a problem","title":"POST /api/sessions"},{"location":"reference-docs/REST-API/#post-apitokens","text":"NEW TOKEN PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/tokens Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"session\": \"SESSION_ID\", \"role\": \"ROLE\", \"data\": \"DATA\", \"kurentoOptions\": KURENTO_OPTIONS} Sample return {\"id\":\"wss://localhost:4443?sessionId=zfgmthb8jl9uellk&token=lnlrtnkwm4v8l7uc&role=PUBLISHER&turnUsername=FYYNRC&turnCredential=yfxxs3\", \"session\": \"zfgmthb8jl9uellk\", \"role\": \"PUBLISHER\", \"data\": \"User Data\", \"token\":\"wss://localhost:4443?sessionId=zfgmthb8jl9uellk&token=lnlrtnkwm4v8l7uc&role=PUBLISHER&turnUsername=FYYNRC&turnCredential=yfxxs3\", \"kurentoOptions\": {\"videoMaxSendBandwidth\": 700, \"allowedFilters\": [\"GStreamerFilter\", \"ZBarFilter\"]}} Body parameters session (mandatory string) : the sessionId for which the token should be associated role (optional string. Check OpenViduRole section of OpenVidu Node Client for a complete description) SUBSCRIBER PUBLISHER (default) MODERATOR data (optional string) : metadata associated to this token (usually participant's information) kurentoOptions (optional JSON object) : you can set some configuration properties for the participant owning this token regarding Kurento. This is a JSON object with the following optional properties: videoMaxRecvBandwidth : maximum number of Kbps that the client owning the token will be able to receive from Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in OpenVidu Server configuration (parameter openvidu.streams.video.max-recv-bandwidth ) for every incoming stream of the user owning the token. WARNING : the lower value set to this property limits every other bandwidth of the WebRTC pipeline this server-to-client stream belongs to. This includes the user publishing the stream and every other user subscribed to the same stream. videoMinRecvBandwidth : minimum number of Kbps that the client owning the token will try to receive from Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in OpenVidu Server configuration (parameter openvidu.streams.video.min-recv-bandwidth ) for every incoming stream of the user owning the token. videoMaxSendBandwidth : maximum number of Kbps that the client owning the token will be able to send to Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in OpenVidu Server configuration (parameter openvidu.streams.video.max-send-bandwidth ) for every outgoing stream of the user owning the token. WARNING : this value limits every other bandwidth of the WebRTC pipeline this client-to-server stream belongs to. This includes every other user subscribed to the stream. videoMinSendBandwidth : minimum number of Kbps that the client owning the token will try to send to Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in OpenVidu Server configuration (parameter openvidu.streams.video.min-send-bandwidth ) for every outgoing stream of the user owning the token. allowedFilters : array of strings containing the names of the filters the user owning the token will be able to apply (see Voice and video filters ) Returned JSON token : token value. Send it to one client to pass it as a parameter in openvidu-browser method Session.connect session : same as in the body request role : same as in the body request data : same as in the body request id : same value as token kurentoOptions : object with Kurento configuration if provided, same as in the body request HTTP responses 200 : token successfully created and ready to be used by one client to connect to the associated session 400 : problem with some body parameter 404 : provided value for session parameter was not found in OpenVidu Server. You must first call POST /api/sessions to get a session id","title":"POST /api/tokens"},{"location":"reference-docs/REST-API/#get-apisessionsltsession_idgt","text":"GET SESSION INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"sessionId\":\"TestSession\",\"createdAt\":1538482606338,\"mediaMode\":\"ROUTED\",\"recordingMode\":\"MANUAL\",\"defaultOutputMode\":\"COMPOSED\",\"defaultRecordingLayout\":\"BEST_FIT\",\"customSessionId\":\"TestSession\",\"connections\":{\"numberOfElements\":2,\"content\":[{\"connectionId\":\"vhdxz7abbfirh2lh\",\"createdAt\":1538482606412,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession&token=2ezkertrimk6nttk&role=PUBLISHER&turnUsername=H0EQLL&turnCredential=kjh48u\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient1\",\"publishers\":[{\"createdAt\":1538482606976,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"mediaOptions\":{\"hasAudio\":true,\"audioActive\":true,\"hasVideo\":true,\"videoActive\":true,\"typeOfVideo\":\"CAMERA\",\"frameRate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"filter\":{}}}],\"subscribers\":[]},{\"connectionId\":\"maxawd3ysuj1rxvq\",\"createdAt\":1538482607659,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession&token=ovj1b4ysuqmcirti&role=PUBLISHER&turnUsername=INOAHN&turnCredential=oujrqd\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient2\",\"publishers\":[],\"subscribers\":[{\"createdAt\":1538482607799,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"publisher\":\"vhdxz7abbfirh2lh\"}]}]},\"recording\":false} Returned JSON sessionId : identifier of the session (identical to SESSION_ID url parameter) createdAt : time when the session was created in UTC milliseconds mediaMode : media mode configured for the session ( ROUTED or RELAYED ) recording : whether the session is being recorded or not at this moment recordingMode : recording mode configured for the session ( ALWAYS or MANUAL ) defaultOutputMode : the default output mode for the recordings of the session ( COMPOSED or INDIVIDUAL ) defaultRecordingLayout : the default recording layout configured for the recordings of the session. Only defined if field defaultOutputMode is set to COMPOSED defaultCustomLayout : the default custom layout configured for the recordings of the session. Its format is a relative path. Only defined if field defaultRecordingLayout is set to CUSTOM customSessionId : custom session identifier. Only defined if the session was initialized passing a customSessionId field (see POST /api/sessions ) connections : collection of active connections in the session. This object is defined by a numberOfElements property counting the total number of active connections and a content array with the actual connections. Each object of this array has this structure: connectionId : identifier of the user's connection createdAt : time when the connection was established in UTC milliseconds location : geo location of the participant PRO platform : complete description of the platform used by the participant to connect to the session role : role of the connection clientData : data defined in OpenVidu Browser when calling Session.connect ( metadata parameter) serverData : data assigned to the user's token when generating the token in OpenVidu Server token : user's token publishers : array of Publisher objects (streams the user is publishing). Each one is defined by the unique streamId property, has a createdAt property indicating the time it was created in UTC milliseconds and has a mediaOptions object with the current properties of the published stream (\"hasVideo\",\"hasAudio\",\"videoActive\",\"audioActive\",\"frameRate\",\"videoDimensions\",\"typeOfVideo\", \"filter\") subscribers : array of Subscriber objects (streams the user is subscribed to). Each on is defined by the unique streamId and a publisher property with the connectionId to identify the connection publishing the stream (must be present inside the connections.content array of the session) HTTP responses 200 : the session information has been successfully retrieved 404 : no session exists for the passed SESSION_ID","title":"GET /api/sessions/&amp;lt;SESSION_ID&amp;gt;"},{"location":"reference-docs/REST-API/#get-apisessions","text":"GET ALL SESSION INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"numberOfElements\":1,\"content\":[{\"sessionId\":\"TestSession\",\"createdAt\":1538482606338,\"mediaMode\":\"ROUTED\",\"recordingMode\":\"MANUAL\",\"defaultOutputMode\":\"COMPOSED\",\"defaultRecordingLayout\":\"BEST_FIT\",\"customSessionId\":\"TestSession\",\"connections\":{\"numberOfElements\":2,\"content\":[{\"connectionId\":\"vhdxz7abbfirh2lh\",\"createdAt\":1538482606412,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession&token=2ezkertrimk6nttk&role=PUBLISHER&turnUsername=H0EQLL&turnCredential=kjh48u\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient1\",\"publishers\":[{\"createdAt\":1538482606976,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"mediaOptions\":{\"hasAudio\":true,\"audioActive\":true,\"hasVideo\":true,\"videoActive\":true,\"typeOfVideo\":\"CAMERA\",\"frameRate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"filter\":{}}}],\"subscribers\":[]},{\"connectionId\":\"maxawd3ysuj1rxvq\",\"createdAt\":1538482607659,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession&token=ovj1b4ysuqmcirti&role=PUBLISHER&turnUsername=INOAHN&turnCredential=oujrqd\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient2\",\"publishers\":[],\"subscribers\":[{\"createdAt\":1538482607799,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"publisher\":\"vhdxz7abbfirh2lh\"}]}]},\"recording\":false}]} Returned JSON numberOfElements : total number of active sessions content : array of sessions. Each object has the same structure as defined in the returned JSON of GET /api/sessions/<SESSION_ID> HTTP responses 200 : all the session information has been successfully retrieved","title":"GET /api/sessions"},{"location":"reference-docs/REST-API/#post-apisignal","text":"SEND A SIGNAL PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/signal Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"session\": \"SESSION_ID\", \"to\": [\"connectionId1\", \"connectionId2\"], \"type\": \"MY_TYPE\", \"data\": \"This is my signal data\"} Sample return Returns nothing Body parameters session (mandatory string) : the sessionId of the session you want to send the signal to to (optional array of strings) : list of connection identifiers to which you want to send the signal. If this property is not included or is an empty array, the signal will be sent to all participants of the session type (optional string) : type of the signal. In the body example of the table above, only users subscribed to Session.on('signal:MY_TYPE') will trigger that signal. Users subscribed to Session.on('signal') will trigger signals of any type data (optional string) : actual data of the signal HTTP responses 200 : signal successfully sent. This doesn't necessary mean that all the intended recipients will have received it correctly. If any user has lost its connection to OpenVidu Server during this process, it may not receive the signal 400 : there is a problem with some body parameter 404 : no session exists for the passed SESSION_ID 406 : no connection exists for the passed to array. This error may be triggered if the session has no connected participants or if you provide some string value that does not correspond to a valid connectionId of the session (even though others may be correct)","title":"POST /api/signal"},{"location":"reference-docs/REST-API/#delete-apisessionsltsession_idgt","text":"CLOSE SESSION PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing HTTP responses 204 : the session has been successfully closed. Every participant will have received the proper events in OpenVidu Browser: streamDestroyed , connectionDestroyed and sessionDisconnected , all of them with \"reason\" property set to \"sessionClosedByServer\". Depending on the order of eviction of the users, some of them will receive more events than the others (the first one will only receive the events related to himself, last one will receive every possible event) 404 : no session exists for the passed SESSION_ID","title":"DELETE /api/sessions/&amp;lt;SESSION_ID&amp;gt;"},{"location":"reference-docs/REST-API/#delete-apisessionsltsession_idgtconnectionltconnection_idgt","text":"FORCE DISCONNECTION PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing HTTP responses 204 : the user has been successfully evicted from the session. Every participant will have received the proper events in OpenVidu Browser: streamDestroyed if the user was publishing, connectionDestroyed for the remaining users and sessionDisconnected for the evicted user. All of them with \"reason\" property set to \"forceDisconnectByServer\" 400 : no session exists for the passed SESSION_ID 404 : no connection exists for the passed CONNECTION_ID","title":"DELETE /api/sessions/&amp;lt;SESSION_ID&amp;gt;/connection/&amp;lt;CONNECTION_ID&amp;gt;"},{"location":"reference-docs/REST-API/#delete-apisessionsltsession_idgtstreamltstream_idgt","text":"FORCE UNPUBLISHING PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID>/stream/<STREAM_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing HTTP responses 204 : the stream has been successfully unpublished. Every participant will have received the proper streamDestroyed event in OpenVidu Browser with \"reason\" property set to \"forceUnpublishByServer\" 400 : no session exists for the passed SESSION_ID 404 : no stream exists for the passed STREAM_ID 405 : you cannot directly delete the stream of an IPCAM participant (any participant created with method POST /api/sessions/<SESSION_ID>/connection ). Instead you must delete the connection object with DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID>","title":"DELETE /api/sessions/&amp;lt;SESSION_ID&amp;gt;/stream/&amp;lt;STREAM_ID&amp;gt;"},{"location":"reference-docs/REST-API/#post-apisessionsltsession_idgtconnection","text":"Available from OpenVidu >= 2.12.0 PUBLISH IP CAMERA PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/sessions/<SESSION_ID>/connection Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"type\": \"IPCAM\", \"rtspUri\": \"rtsp://b1.dnsdojo.com:1935/live/sys3.stream\", \"adaptativeBitrate\": true, \"onlyPlayWithSubscribers\": true, \"data\": \"Office security camera\"} Sample return {\"connectionId\": \"ipc_IPCAM_rtsp_A8MJ_91_191_213_49_554_live_mpeg4_sdp\", \"createdAt\": 1582121476379, \"location\": \"unknown\", \"platform\": \"IPCAM\", \"role\": \"PUBLISHER\", \"serverData\": \"MY_IP_CAMERA\", \"publishers\": [{\"createdAt\": 1582121476439, \"streamId\": \"str_IPC_XC1W_ipc_IPCAM_rtsp_A8MJ_91_191_213_49_554_live_mpeg4_sdp\", \"rtspUri\": \"rtsp://91.191.213.49:554/live_mpeg4.sdp\", \"mediaOptions\": {\"hasAudio\": true, \"audioActive\": true, \"hasVideo\": true, \"videoActive\": true, \"typeOfVideo\": \"IPCAM\", \"frameRate\": null, \"videoDimensions\": null, \"filter\": {}, \"adaptativeBitrate\": true, \"onlyPlayWithSubscribers\": true}} ], \"subscribers\": []} Body parameters type (optional string) : which type of stream will be published. For now can only be IPCAM . Default to IPCAM rtspUri (mandatory string) : RTSP URI of the IP camera. For example: rtsp://your.camera.ip:7777/path adaptativeBitrate (optional boolean) : whether to use adaptative bitrate (and therefore adaptative quality) or not. For local network connections that do not require media transcoding this can be disabled to save CPU power. If you are not sure if transcoding might be necessary, setting this property to false may result in media connections not being established . Default to true onlyPlayWithSubscribers (optional boolean) : enable the IP camera stream only when some user is subscribed to it. This allows you to reduce power consumption and network bandwidth in your server while nobody is asking to receive the camera's video. On the counterpart, first user subscribing to the IP camera stream will take a little longer to receive its video. Default to true data (optional string) : metadata you want to associate to the camera's participant. This will be included as Connection.data property received by your clients on connectionCreated event, and will also be available in backend events ( CDR and Webhook ) Returned JSON Returns the new Connection object. This object is the same as each JSON object in the connections.content array returned by method GET /api/sessions/<SESSION_ID> connectionId : identifier of the camera's connection. Store it to perform other operations such as unpublish the IP camera from the session createdAt : time when the connection was established in UTC milliseconds location : geo location of the IP camera PRO platform : \"IPCAM\" role : \"PUBLISHER\" clientData : \"\" (IP camera connections cannot be initialized from the client-side) serverData : data associated to the IP camera connection with query parameter data token : undefined (IP camera connections do not have a token associated) publishers : array of Publisher objects (streams the camera is publishing. There will only be one object). Each one is defined by the unique streamId property, has a createdAt property indicating the time it was created in UTC milliseconds and has a mediaOptions object with the current properties of the published stream (\"hasVideo\", \"hasAudio\", \"videoActive\", \"audioActive\", \"frameRate\", \"videoDimensions\", \"typeOfVideo\", \"filter\") subscribers : [] (camera is always a send-only connection, so it won't have any subscriber object) HTTP responses 200 : the IP camera has been successfully published to the session. Every participant will have received the proper events in OpenVidu Browser: connectionCreated identifying the new camera participant and streamCreated so they can subscribe to the IP camera stream. 400 : problem with some body parameter 404 : no session exists for the passed SESSION_ID 500 : unexpected error when publishing the IP camera stream into the session. See the error message for further information","title":"POST /api/sessions/&amp;lt;SESSION_ID&amp;gt;/connection"},{"location":"reference-docs/REST-API/#post-apirecordingsstart","text":"START SESSION RECORDING PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings/start Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/json Body {\"session\": \"SESSION_ID\", \"name\": \"NAME\", \"outputMode\": \"OUTPUT_MODE\", \"hasAudio\": \"HAS_AUDIO\", \"hasVideo\": \"HAS_VIDEO\", \"resolution\": \"RESOLUTION\", \"recordingLayout\": \"RECORDING_LAYOUT\", \"customLayout\": \"CUSTOM_LAYOUT\"} Sample return {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\":true, \"hasVideo\":false,\"createdAt\":1538483606521, \"size\":3205004, \"duration\":12.92, \"url\":null, \"status\": \"started\"} Body parameters session (mandatory string) : the sessionId belonging to the session you want to start recording name (optional string) : the name you want to give to the video file. You can access this same property in openvidu-browser on recordingEvents. If no name is provided, the video file will be named after id property of the recording outputMode (optional string) : record all streams in a single file in a grid layout or record each stream in its own separate file. This property will override the defaultOutputMode property set on POST /api/sessions for this particular recording COMPOSED (default) : when recording the session, all streams will be composed in the same file in a grid layout INDIVIDUAL : when recording the session, every stream is recorded in its own file hasAudio (optional boolean) : whether to record audio or not. Default to true hasVideo (optional boolean) : whether to record video or not. Default to true recordingLayout (optional string. Only applies if outputMode is set to COMPOSED and hasVideo to true) : the layout to be used in this recording. This property will override the defaultRecordingLayout property set on POST /api/sessions for this particular recording. BEST_FIT (default) : A grid layout where all the videos are evenly distributed CUSTOM : Use your own custom layout. See Custom recording layouts section to learn how Not available yet: PICTURE_IN_PICTURE , VERTICAL_PRESENTATION , HORIZONTAL_PRESENTATION customLayout (optional string. Only applies if recordingLayout is set to CUSTOM ) : a relative path indicating the custom recording layout to be used if more than one is available. Default to empty string (if so custom layout expected under path set with openvidu-server system property openvidu.recording.custom-layout ) . This property will override the defaultCustomLayout property set on POST /api/sessions for this particular recording resolution (optional string. Only applies if outputMode is set to COMPOSED and hasVideo to true) : the resolution of the recorded video file. It is a string indicating the width and height in pixels like this: \"1920x1080\" . Values for both width and height must be between 100 and 1999 Returned JSON id : recording identifier. Store it to perform other operations such as stop, get or delete the recording sessionId : session associated to the recording (same value as session in the body request) name : name of the recording. If no name parameter is passed in the POST operation, will be equal to id field outputMode : output mode of the recording hasAudio : true if the recording has an audio track, false otherwise hasVideo : true if the recording has a video track, false otherwise recordingLayout : the recording layout that is being used. Only defined if outputMode is set to COMPOSED and hasVideo to true customLayout : the custom layout that is being used. Only defined if recordingLayout is set to CUSTOM resolution : resolution of the video file. Only defined if outputMode is set to COMPOSED and hasVideo to true createdAt : time when the recording started in UTC milliseconds size : size in bytes of the video file (0 until stop operation is called) duration : duration of the video file in seconds (0 until stop operation is called) url : set to null status : set to \"started\" HTTP responses 200 : the session has started to be recorded. The moment this response is retrieved, it means that the video file is already created and contains proper data, and that the recording can be stopped with guarantees 400 : problem with some body parameter 422 : resolution parameter exceeds acceptable values (for both width and height, min 100px and max 1999px) or trying to start a recording with both hasAudio and hasVideo to false 404 : no session exists for the passed sessionId parameter 406 : the session has no connected participants 409 : the session is not configured for using MediaMode ROUTED or it is already being recorded 501 : OpenVidu Server recording module is disabled ( openvidu.recording property set to false )","title":"POST /api/recordings/start"},{"location":"reference-docs/REST-API/#post-apirecordingsstopltrecording_idgt","text":"STOP SESSION RECORDING PARAMETERS Operation POST URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings/stop/<RECORDING_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": null, \"status\": \"stopped\"} Returned JSON id : recording identifier sessionId : session associated to the recording name : name of the recording. If no name parameter is passed when starting the recording, will be equal to id field outputMode : output mode of the recording hasAudio : true if the recording has an audio track, false otherwise hasVideo : true if the recording has a video track, false otherwise recordingLayout : the recording layout used in the recording. Only defined if outputMode is set to COMPOSED and hasVideo to true customLayout : the custom layout used in the recording. Only defined if recordingLayout is set to CUSTOM resolution : resolution of the video file. Only defined if outputMode is set to COMPOSED and hasVideo to true createdAt : time when the recording started in UTC milliseconds size : size in bytes of the video file duration : duration of the video file in seconds url : set to \"https://YOUR_OPENVIDUSERVER_IP/recordings/<RECORDING_ID>/<RECORDING_NAME>.<EXTENSION>\" . This path will be protected with OpenVidu credentials depending on whether openvidu-server system property openvidu.recording.public-access is false or true status : set to \"stopped\" or \"available\" depending on whether openvidu-server system property openvidu.recording.public-access is false or true HTTP responses 200 : the session has successfully stopped from being recorded. The video file is ready to be reproduced 404 : no recording exists for the passed RECORDING_ID 406 : recording has starting status. Wait until started status before stopping the recording","title":"POST /api/recordings/stop/&amp;lt;RECORDING_ID&amp;gt;"},{"location":"reference-docs/REST-API/#get-apirecordingsltrecording_idgt","text":"GET RECORDING INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings/<RECORDING_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": null, \"status\": \"stopped\"} Returned JSON id : recording identifier sessionId : session associated to the recording name : name of the recording. If no name parameter is passed when starting the recording, will be equal to id field outputMode : output mode of the recording hasAudio : true if the recording has an audio track, false otherwise hasVideo : true if the recording has a video track, false otherwise recordingLayout : the recording layout used in the recording. Only defined if outputMode is set to COMPOSED and hasVideo to true customLayout : the custom layout used in the recording. Only defined if recordingLayout is set to CUSTOM resolution : resolution of the video file. Only defined if outputMode is set to COMPOSED and hasVideo to true createdAt : time when the recording started in UTC milliseconds size : size in bytes of the video file (0 until stop operation is called) duration : duration of the video file in seconds (0 until stop operation is called) url : set to null until stop operation is called. Then it will be \"https://YOUR_OPENVIDUSERVER_IP/recordings/<RECORDING_ID>/<RECORDING_NAME>.<EXTENSION>\" , path that may be protected with OpenVidu credentials depending on whether openvidu-server system property openvidu.recording.public-access is false or true. status : status of the recording ( \"starting\" , \"started\" , \"stopped\" , \"available\" , \"failed\" ) HTTP responses 200 : the recording information has been successfully retrieved 404 : no recording exists for the passed RECORDING_ID","title":"GET /api/recordings/&amp;lt;RECORDING_ID&amp;gt;"},{"location":"reference-docs/REST-API/#get-apirecordings","text":"LIST RECORDINGS INFO PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"count\": 2, \"items\": [{\"id\": \"n0kcws1evvn3esmo\", \"sessionId\": \"n0kcws1evvn3esmo\", \"name\": \"n0kcws1evvn3esmo\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": true, \"recordingLayout\": \"BEST_FIT\", \"resolution\": \"1920x1080\", \"createdAt\": 1521202349460, \"size\": 22887561, \"duration\": 132.08, \"url\": \"https://localhost:4443/recordings/n0kcws1evvn3esmo/n0kcws1evvn3esmo.mp4\", \"status\": \"available\"}, {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": \"https://localhost:4443/recordings/fds4e07mdug1ga3h/MyRecording.webm\", \"status\": \"available\"}]} Returned JSON count : number of total recordings items : array of recording information in JSON format. Each item has the same properties as stated in the return value of method GET /api/recordings/<RECORDING_ID> HTTP responses 200 : all of the available recording information has been successfully retrieved","title":"GET /api/recordings"},{"location":"reference-docs/REST-API/#delete-apirecordingsltrecording_idgt","text":"DELETE RECORDING PARAMETERS Operation DELETE URL https://<YOUR_OPENVIDUSERVER_IP>/api/recordings/<RECORDING_ID> Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Content-Type: application/x-www-form-urlencoded Sample return Returns nothing HTTP responses 204 : the video file and all of its metadata has been successfully deleted from the host 404 : no recording exists for the passed RECORDING_ID 409 : the recording has \"started\" status. Stop it before deletion","title":"DELETE /api/recordings/&amp;lt;RECORDING_ID&amp;gt;"},{"location":"reference-docs/REST-API/#get-config","text":"GET OPENVIDU CONFIGURATION PARAMETERS Operation GET URL https://<YOUR_OPENVIDUSERVER_IP>/config Headers Authorization: Basic EncodeBase64(OPENVIDUAPP:<YOUR_SECRET>) Sample return {\"version\": \"2.9.0\", \"openviduPublicurl\": \"https://localhost:4443/\", \"openviduCdr\": false, \"maxRecvBandwidth\": 1000, \"minRecvBandwidth\": 300, \"maxSendBandwidth\": 1000, \"minSendBandwidth\": 300, \"openviduRecording\": true, \"openviduRecordingVersion\": \"2.8.0\", \"openviduRecordingPath\": \"/opt/openvidu/recordings/\", \"openviduRecordingPublicAccess\": true, \"openviduRecordingNotification\": \"publisher_moderator\", \"openviduRecordingCustomLayout\": \"/opt/openvidu/custom-layout/\", \"openviduRecordingAutostopTimeout\": 120, \"openviduWebhook\": true, \"openviduWebhookEndpoint\": \"http://localhost:7777/webhook/\", \"openviduWebhookHeaders\": [\"Authorization: Basic YWJjZDphYmNk\"], \"openviduWebhookEvents\": [\"recordingStatusChanged\"]} Returned JSON version : version of OpenVidu Server Rest of properties : values given to system properties on OpenVidu Server launch","title":"GET /config"},{"location":"reference-docs/openvidu-artifacts/","text":"OpenVidu Artifacts Main artifacts Artifact Type Stable version Link Info openvidu-browser NPM package 1.8.0 NPM JS file 1.8.0 GitHub openvidu-server JAR 1.8.0 GitHub Docker container 1.8.0 DockerHub Docker container (+KMS) 1.8.0 DockerHub openvidu-java-client MVN package 1.8.0 MVN Repository openvidu-node-client NPM package 1.8.0 NPM openvidu-cloud-devops JSON files 1.7.0 GitHub openvidu-parent POM 1.1.0 MVN Repository Demos and tutorials artifacts Artifact Type Stable version Link openvidu-js-java JAR 1.1.0 GitHub Docker container (basic-webinar-demo) 1.1.0 DockerHub openvidu-mvc-java JAR 1.1.0 GitHub basic-videoconference-demo Docker container 1.1.0 DockerHub classroom-demo Docker container 1.1.0 DockerHub WAR 1.1.0 GitHub Tutorials artifacts without a binary distribution Artifact How to run it openvidu-js-node Go openvidu-mvc-node Go openvidu-insecure-js (basic-videoconference-demo) Go openvidu-insecure-angular Go openvidu-getaroom Go var mobileWidth = 767; var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth; if (width <= mobileWidth) { function changePlacement(tooltip) { tooltip.setAttribute('data-placement', 'left'); } var tooltips = document.getElementsByClassName('ion-information-circled'); for(i = 0; i < tooltips.length; i++) { changePlacement(tooltips[i]); } }","title":"Openvidu artifacts"},{"location":"reference-docs/openvidu-browser/","text":"openvidu-browser API Check TypeDoc documentation","title":"openvidu-browser API"},{"location":"reference-docs/openvidu-java-client/","text":"openvidu-java-client API This is a Java library wrapping OpenVidu Server REST API Check JavaDoc documentation Code samples Create a session OpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); SessionProperties properties = new SessionProperties.Builder().build(); Session session = openVidu.createSession(properties); Generate a token TokenOptions tokenOptions = new TokenOptions.Builder() .role(OpenViduRole.PUBLISHER) .data(\"user_data\") .build(); String token = session.generateToken(tokenOptions); Fetch session status // Fetch all session info from OpenVidu Server openvidu.fetch(): List<Session> activeSessions = openvidu.getActiveSessions(); // Fetch one session info from OpenVidu Server session.fetch(); List<Connection> activeConnections = session.getActiveConnections(); Close a session session.close(); Disconnect a user // Find the desired Connection object in the list returned by Session.getActiveConnections() session.forceDisconnect(connection); Unpublish a user's stream // Find the desired Publisher object in the list returned by Connection.getPublishers() session.forceUnpublish(publisher); Manage recordings // Start recording String sessionId = session.getSessionId(); RecordingProperties properties = new RecordingProperties.Builder().build(); Recording recordingStarted = openVidu.startRecording(sessionId, properties); // Stop recording String recordingId = recordingStarted.getId(); Recording recordingStopped = openvidu.stopRecording(recordingId); // Get recording Recording recordingRetrieved = openvidu.getRecording(recordingId); // List recordings List<Recording> recordingList = openVidu.listRecordings(); // Delete recording openVidu.deleteRecording(recordingId);","title":"openvidu-java-client API"},{"location":"reference-docs/openvidu-java-client/#code-samples","text":"","title":"Code samples"},{"location":"reference-docs/openvidu-java-client/#create-a-session","text":"OpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); SessionProperties properties = new SessionProperties.Builder().build(); Session session = openVidu.createSession(properties);","title":"Create a session"},{"location":"reference-docs/openvidu-java-client/#generate-a-token","text":"TokenOptions tokenOptions = new TokenOptions.Builder() .role(OpenViduRole.PUBLISHER) .data(\"user_data\") .build(); String token = session.generateToken(tokenOptions);","title":"Generate a token"},{"location":"reference-docs/openvidu-java-client/#fetch-session-status","text":"// Fetch all session info from OpenVidu Server openvidu.fetch(): List<Session> activeSessions = openvidu.getActiveSessions(); // Fetch one session info from OpenVidu Server session.fetch(); List<Connection> activeConnections = session.getActiveConnections();","title":"Fetch session status"},{"location":"reference-docs/openvidu-java-client/#close-a-session","text":"session.close();","title":"Close a session"},{"location":"reference-docs/openvidu-java-client/#disconnect-a-user","text":"// Find the desired Connection object in the list returned by Session.getActiveConnections() session.forceDisconnect(connection);","title":"Disconnect a user"},{"location":"reference-docs/openvidu-java-client/#unpublish-a-users-stream","text":"// Find the desired Publisher object in the list returned by Connection.getPublishers() session.forceUnpublish(publisher);","title":"Unpublish a user's stream"},{"location":"reference-docs/openvidu-java-client/#manage-recordings","text":"// Start recording String sessionId = session.getSessionId(); RecordingProperties properties = new RecordingProperties.Builder().build(); Recording recordingStarted = openVidu.startRecording(sessionId, properties); // Stop recording String recordingId = recordingStarted.getId(); Recording recordingStopped = openvidu.stopRecording(recordingId); // Get recording Recording recordingRetrieved = openvidu.getRecording(recordingId); // List recordings List<Recording> recordingList = openVidu.listRecordings(); // Delete recording openVidu.deleteRecording(recordingId);","title":"Manage recordings"},{"location":"reference-docs/openvidu-node-client/","text":"openvidu-node-client API This is a Node library wrapping OpenVidu Server REST API Check TypeDoc documentation Code samples Create a session var openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); var properties = {}; openVidu.createSession(properties).then(session => { ... }); Generate a token var tokenOptions = { role: \"PUBLISHER\", data: \"user_data\" }; session.generateToken(tokenOptions).then(token => { ... }); Fetch session status // Fetch all session info from OpenVidu Server openvidu.fetch() .then(anyChange => { var activeSessions = openvidu.activeSessions; }); // Fetch one session info from OpenVidu Server session.fetch() .then(anyChange => { var activeConnections = session.activeSessions; }); Close a session session.close().then(() => console.log('Session closed')); Disconnect a user // Find the desired Connection object in the array Session.activeConnections session.forceDisconnect(connection); Unpublish a user's stream // Find the desired Publisher object in the array Connection.publishers session.forceUnpublish(publisher); Manage recordings // Start recording var sessionId = session.getSessionId(); openVidu.startRecording(sessionId).then(recordingStarted => ... ); // Stop recording var recordingId = recordingStarted.id; openvidu.stopRecording(recordingId).then(recordingStopped => ... ); // Get recording openvidu.getRecording(recordingId).then(recordingRetrieved => ... ); // List recordings openVidu.listRecordings().then(recordingList => ... ); // Delete recording openVidu.deleteRecording(recordingId);","title":"openvidu-node-client API"},{"location":"reference-docs/openvidu-node-client/#code-samples","text":"","title":"Code samples"},{"location":"reference-docs/openvidu-node-client/#create-a-session","text":"var openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); var properties = {}; openVidu.createSession(properties).then(session => { ... });","title":"Create a session"},{"location":"reference-docs/openvidu-node-client/#generate-a-token","text":"var tokenOptions = { role: \"PUBLISHER\", data: \"user_data\" }; session.generateToken(tokenOptions).then(token => { ... });","title":"Generate a token"},{"location":"reference-docs/openvidu-node-client/#fetch-session-status","text":"// Fetch all session info from OpenVidu Server openvidu.fetch() .then(anyChange => { var activeSessions = openvidu.activeSessions; }); // Fetch one session info from OpenVidu Server session.fetch() .then(anyChange => { var activeConnections = session.activeSessions; });","title":"Fetch session status"},{"location":"reference-docs/openvidu-node-client/#close-a-session","text":"session.close().then(() => console.log('Session closed'));","title":"Close a session"},{"location":"reference-docs/openvidu-node-client/#disconnect-a-user","text":"// Find the desired Connection object in the array Session.activeConnections session.forceDisconnect(connection);","title":"Disconnect a user"},{"location":"reference-docs/openvidu-node-client/#unpublish-a-users-stream","text":"// Find the desired Publisher object in the array Connection.publishers session.forceUnpublish(publisher);","title":"Unpublish a user's stream"},{"location":"reference-docs/openvidu-node-client/#manage-recordings","text":"// Start recording var sessionId = session.getSessionId(); openVidu.startRecording(sessionId).then(recordingStarted => ... ); // Stop recording var recordingId = recordingStarted.id; openvidu.stopRecording(recordingId).then(recordingStopped => ... ); // Get recording openvidu.getRecording(recordingId).then(recordingRetrieved => ... ); // List recordings openVidu.listRecordings().then(recordingList => ... ); // Delete recording openVidu.deleteRecording(recordingId);","title":"Manage recordings"},{"location":"reference-docs/openvidu-server-cdr/","text":"OpenVidu Server CDR OpenVidu Server offers a CDR logging system, so you can easily keep record of every session, every user connecting to them and every media connection established by each one of the users (sending or receiving). To start OpenVidu Server with CDR enabled, launch it with option openvidu.cdr=true . The CDR file will be located under log/ folder in the same path as your Java executable. The record is a plain text file containing one standard JSON entry for each line. All JSON entries have the following structure: {\"EVENT_NAME\": {\"sessionId\": \"SESSION_ID\", \"timestamp\": TIMESTAMP, \"PROP_1\": \"VALUE_1\",\"PROP_2\": \"VALUE_2\", ... }} So every entry is a JSON object identified by a specific event name, and all of them have as properties the sessionId identifying the video-session for which this event was registered and the timestamp . Besides this two common properties, there are custom properties for every specific event with useful information. The complete list of possible JSON entries is available below: Events in OpenVidu CDR sessionCreated sessionDestroyed participantJoined participantLeft webrtcConnectionCreated webrtcConnectionDestroyed recordingStarted (removed in OpenVidu 2.11.0. Use recordingStatusChanged ) recordingStopped (removed in OpenVidu 2.11.0. Use recordingStatusChanged ) recordingStatusChanged (from OpenVidu 2.11.0) filterEventDispatched (from OpenVidu 2.12.0) sessionCreated Recorded when a new session has been created. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds Example: {\"sessionCreated\":{\"sessionId\":\"fds4e07mdug1ga3h\",\"timestamp\":1538481330577}} sessionDestroyed Recorded when a session has finished. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds startTime Time when the session started UTC milliseconds duration Total duration of the session Seconds reason Why the session was destroyed [ \"lastParticipantLeft\" , \"sessionClosedByServer\" , \"openviduServerStopped\" ] Example: {\"sessionDestroyed\":{\"sessionId\":\"fds4e07mdug1ga3h\",\"timestamp\":1538481699154,\"startTime\":1538481330577,\"duration\":368,\"reason\":\"lastParticipantLeft\"}} participantJoined Recorded when a user has connected to a session. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier location Geo location of the participant PRO A string with format \"CITY, COUNTRY\" (or \"unknown\" ) platform Complete description of the platform used by the participant to connect to the session A string with the platform description clientData Metadata associated to this participant from the client side. This corresponds to parameter metadata of openvidu-browser method Session.connect A string with the participant client-side metadata (generated when calling Session.connect method) serverData Metadata associated to this participant from the server side. This corresponds to parameter data of REST API operation POST /api/tokens or its Java/Node server SDKs variants A string with the participant server-side metadata (generated with the token) Example: {\"participantJoined\":{\"sessionId\":\"ses_SuXO99zeb1\",\"timestamp\":1584008771500,\"participantId\":\"con_ZTMYOmVuZB\",\"location\":\"Berlin, Germany\",\"platform\":\"Chrome 80.0.3987.132 on Linux 64-bit\",\"clientData\":\"Mike\",\"serverData\":\"{'user': 'client1'}\"}} participantLeft Recorded when a user has left a session. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier location Geo location of the participant PRO A string with format \"CITY, COUNTRY\" (or \"unknown\" ) platform Complete description of the platform used by the participant to connect to the session A string with the platform description clientData Metadata associated to this participant from the client side. This corresponds to parameter metadata of openvidu-browser method Session.connect A string with the participant client-side metadata (generated when calling Session.connect method) serverData Metadata associated to this participant from the server side. This corresponds to parameter data of REST API operation POST /api/tokens or its Java/Node server SDKs variants A string with the participant server-side metadata (generated with the token) startTime Time when the participant joined the session UTC milliseconds duration Total duration of the participant's connection to the session Seconds reason How the participant left the session [ \"disconnect\" , \"forceDisconnectByUser\" , \"forceDisconnectByServer\" , \"sessionClosedByServer\" , \"networkDisconnect\" , \"openviduServerStopped\" ] Example: {\"participantLeft\":{\"sessionId\":\"ses_SuXO99zeb1\",\"timestamp\":1584009224993,\"startTime\":1584008771500,\"duration\":453,\"reason\":\"disconnect\",\"participantId\":\"con_ZTMYOmVuZB\",\"location\":\"Berlin, Germany\",\"platform\":\"Chrome 80.0.3987.132 on Linux 64-bit\",\"clientData\":\"Mike\",\"serverData\":\"{'user': 'client1'}\"}} webrtcConnectionCreated Recorded when a new media stream has been established. Can be an \"INBOUND\" connection (the user is receiving a stream from a publisher of the session) or an \"OUTBOUND\" connection (the user is a publishing a stream to the session). Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier connection Whether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu) [ \"INBOUND\" , \"OUTBOUND\" ] receivingFrom If connection is \"INBOUND\" , the participant from whom the media stream is being received A string with the participant (sender) unique identifier audioEnabled Whether the media connection has negotiated audio or not [ true , false ] videoEnabled Whether the media connection has negotiated video or not [ true , false ] videoSource If videoEnabled is true , the type of video that is being transmitted [ \"CAMERA\" , \"SCREEN\" ] videoFramerate If videoEnabled is true , the framerate of the transmitted video Number of fps videoDimensions If videoEnabled is true , the dimensions transmitted video String with the dimensions (e.g. \"1920x1080\" ) Example: {\"webrtcConnectionCreated\":{\"sessionId\":\"fds4e07mdug1ga3h\",\"timestamp\":1538481419726,\"participantId\":\"ges2furjsjjmyi0b\",\"connection\":\"INBOUND\",\"receivingFrom\":\"wsalcr1r72goj8sk\",\"videoSource\":\"CAMERA\",\"videoFramerate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"audioEnabled\":true,\"videoEnabled\":true}} webrtcConnectionDestroyed Recorded when any media stream connection is closed. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier connection Whether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu) [ \"INBOUND\" , \"OUTBOUND\" ] receivingFrom If connection is \"INBOUND\" , the participant from whom the media stream is being received A string with the participant (sender) unique identifier audioEnabled Whether the media connection has negotiated audio or not [ true , false ] videoEnabled Whether the media connection has negotiated video or not [ true , false ] videoSource If videoEnabled is true , the type of video that is being transmitted [ \"CAMERA\" , \"SCREEN\" ] videoFramerate If videoEnabled is true , the framerate of the transmitted video Number of fps videoDimensions If videoEnabled is true , the dimensions transmitted video String with the dimensions (e.g. \"1920x1080\" ) startTime Time when the media connection was established UTC milliseconds duration Total duration of the media connection Seconds reason How the WebRTC connection was destroyed [ \"unsubscribe\" , \"unpublish\" , \"disconnect\" , \"forceUnpublishByUser\" , \"forceUnpublishByServer\" , \"forceDisconnectByUser\" , \"forceDisconnectByServer\" , \"sessionClosedByServer\" , \"networkDisconnect\" , \"openviduServerStopped\" , \"mediaServerDisconnect\" ] Example: {\"webrtcConnectionDestroyed\":{\"sessionId\":\"fds4e07mdug1ga3h\",\"timestamp\":1538481449060,\"startTime\":1538481419726,\"duration\":29,\"reason\":\"disconnect\",\"participantId\":\"ges2furjsjjmyi0b\",\"connection\":\"INBOUND\",\"receivingFrom\":\"wsalcr1r72goj8sk\",\"videoSource\":\"CAMERA\",\"videoFramerate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"audioEnabled\":true,\"videoEnabled\":true}} recordingStarted REMOVED IN OPENVIDU 2.11.0. Use recordingStatusChanged Recorded when a new session has started to be recorded Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds id Unique identifier of the recording A string with the recording unique identifier name Name given to the recording file A string with the recording name outputMode Output mode of the recording ( COMPOSED or INDIVIDUAL ) A string with the recording output mode hasAudio Wheter the recording file has audio or not [ true , false ] hasVideo Wheter the recording file has video or not [ true , false ] recordingLayout The type of layout used in the recording. Only defined if outputMode is COMPOSED and hasVideo is true A RecordingLayout value (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...) resolution Resolution of the recorded file. Only defined if outputMode is COMPOSED and hasVideo is true A string with the width and height of the video file in pixels. e.g. \"1280x720\" size The size of the video file 0 duration Duration of the video file 0 Example: {\"recordingStarted\":{\"sessionId\":\"TestSession\",\"timestamp\":1549015630563,\"id\":\"TestSession\",\"name\":\"MyRecording\",\"outputMode\":\"COMPOSED\",\"hasAudio\":false,\"hasVideo\":true,\"recordingLayout\":\"BEST_FIT\",\"resolution\":\"1920x1080\",\"size\":0,\"duration\":0.0}} recordingStopped REMOVED IN OPENVIDU 2.11.0. Use recordingStatusChanged Recorded when a new session has stopped being recorded Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds startTime Time when the stopped recording started UTC milliseconds id Unique identifier of the recording A string with the recording unique identifier name Name given to the recording file A string with the recording name outputMode Output mode of the recording ( COMPOSED or INDIVIDUAL ) A string with the recording output mode hasAudio Wheter the recording file has audio or not [ true , false ] hasVideo Wheter the recording file has video or not [ true , false ] recordingLayout The type of layout used in the recording. Only defined if outputMode is COMPOSED and hasVideo is true A RecordingLayout value (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...) resolution Resolution of the recorded file. Only defined if outputMode is COMPOSED and hasVideo is true A string with the width and height of the video file in pixels. e.g. \"1280x720\" size The size of the video file Bytes duration Duration of the video file Seconds reason Why the recording stopped [ \"recordingStoppedByServer\" , \"lastParticipantLeft\" , \"sessionClosedByServer\" , \"automaticStop\" , \"openviduServerStopped\" , \"mediaServerDisconnect\" ] Example: {\"recordingStopped\":{\"sessionId\":\"TestSession\",\"timestamp\":1549015640859,\"startTime\":1549015630563,\"id\":\"TestSession\",\"name\":\"MyRecording\",\"outputMode\":\"COMPOSED\",\"hasAudio\":false,\"hasVideo\":true,\"recordingLayout\":\"BEST_FIT\",\"resolution\":\"1920x1080\",\"size\":617509,\"duration\":5.967,\"reason\":\"recordingStoppedByServer\"}} recordingStatusChanged Recorded when the status of a recording has changed. The status may be: started : the session is being recorded. This means the associated video(s) already exists and its size is greater than 0. NOTE: when using COMPOSED recording with video, this event does not mean there are publisher's streams being recorded in the video file. It only ensures the video file exists and its size is greater than 0 stopped : the recording process has stopped and files are being processed. The recording entity's duration and size properties will still be set to 0. ready : the recorded file has been successfully processed and is available for download. The recording entity's duration and size properties are properly defined now failed : the recording process has failed. The final state of the recorded file cannot be guaranteed to be stable Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds startTime Time when the recording started UTC milliseconds id Unique identifier of the recording A string with the recording unique identifier name Name given to the recording file A string with the recording name outputMode Output mode of the recording ( COMPOSED or INDIVIDUAL ) A string with the recording output mode hasAudio Wheter the recording file has audio or not [ true , false ] hasVideo Wheter the recording file has video or not [ true , false ] recordingLayout The type of layout used in the recording. Only defined if outputMode is COMPOSED and hasVideo is true A RecordingLayout value (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...) resolution Resolution of the recorded file. Only defined if outputMode is COMPOSED and hasVideo is true A string with the width and height of the video file in pixels. e.g. \"1280x720\" size The size of the video file. 0 until status is stopped Bytes duration Duration of the video file. 0 until status is stopped Seconds status Status of the recording [ \"started\" , \"stopped\" , \"ready\" , \"failed\" ] reason Why the recording stopped. Only defined when status is stopped or ready [ \"recordingStoppedByServer\" , \"lastParticipantLeft\" , \"sessionClosedByServer\" , \"automaticStop\" , \"openviduServerStopped\" , \"mediaServerDisconnect\" ] Example: {\"recordingStatusChanged\":{\"sessionId\":\"TestSession\",\"timestamp\":1549015640859,\"startTime\":1549015630563,\"duration\":5.967,\"id\":\"TestSession\",\"name\":\"MyRecording\",\"outputMode\":\"COMPOSED\",\"hasAudio\":true,\"hasVideo\":true,\"recordingLayout\":\"BEST_FIT\",\"resolution\":\"1920x1080\",\"size\":617509,\"status\":\"stopped\",\"reason\":\"sessionClosedByServer\"}} filterEventDispatched From OpenVidu 2.12.0 Recorded when a filter event has been dispatched. This event can only be triggered if a filter has been applied to a stream and a listener has been added to a specific event offered by the filter. See Voice and video filters to learn more. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier streamId Identifier of the stream for which the filter is applied A string with the stream unique identifier filterType Type of the filter applied to the stream A string with the type of filter eventType Event of the filter that was triggered A string with the type of event data Data of the filter event A string with the data returned by the filter event. Its value will depend on the type of filter and event Example: {\"filterEventDispatched\":{\"sessionId\":\"TestSession\",\"timestamp\":1568645808285,\"participantId\":\"oklnb2wgsisr0sd3\",\"streamId\":\"oklnb2wgsisr0sd3_CAMERA_GXTRU\",\"filterType\":\"ZBarFilter\",\"eventType\":\"CodeFound\",\"data\":\"{timestampMillis=1568645808285, codeType=EAN-13, source=23353-1d3c_kurento.MediaPipeline/1f56f4a5-807c-71a30d40_kurento.ZBarFilter, type=CodeFound, value=0012345678905, tags=[], timestamp=1568645808}\"}}","title":"OpenVidu Server CDR"},{"location":"reference-docs/openvidu-server-cdr/#events-in-openvidu-cdr","text":"sessionCreated sessionDestroyed participantJoined participantLeft webrtcConnectionCreated webrtcConnectionDestroyed recordingStarted (removed in OpenVidu 2.11.0. Use recordingStatusChanged ) recordingStopped (removed in OpenVidu 2.11.0. Use recordingStatusChanged ) recordingStatusChanged (from OpenVidu 2.11.0) filterEventDispatched (from OpenVidu 2.12.0)","title":"Events in OpenVidu CDR"},{"location":"reference-docs/openvidu-server-cdr/#sessioncreated","text":"Recorded when a new session has been created. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds Example: {\"sessionCreated\":{\"sessionId\":\"fds4e07mdug1ga3h\",\"timestamp\":1538481330577}}","title":"sessionCreated"},{"location":"reference-docs/openvidu-server-cdr/#sessiondestroyed","text":"Recorded when a session has finished. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds startTime Time when the session started UTC milliseconds duration Total duration of the session Seconds reason Why the session was destroyed [ \"lastParticipantLeft\" , \"sessionClosedByServer\" , \"openviduServerStopped\" ] Example: {\"sessionDestroyed\":{\"sessionId\":\"fds4e07mdug1ga3h\",\"timestamp\":1538481699154,\"startTime\":1538481330577,\"duration\":368,\"reason\":\"lastParticipantLeft\"}}","title":"sessionDestroyed"},{"location":"reference-docs/openvidu-server-cdr/#participantjoined","text":"Recorded when a user has connected to a session. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier location Geo location of the participant PRO A string with format \"CITY, COUNTRY\" (or \"unknown\" ) platform Complete description of the platform used by the participant to connect to the session A string with the platform description clientData Metadata associated to this participant from the client side. This corresponds to parameter metadata of openvidu-browser method Session.connect A string with the participant client-side metadata (generated when calling Session.connect method) serverData Metadata associated to this participant from the server side. This corresponds to parameter data of REST API operation POST /api/tokens or its Java/Node server SDKs variants A string with the participant server-side metadata (generated with the token) Example: {\"participantJoined\":{\"sessionId\":\"ses_SuXO99zeb1\",\"timestamp\":1584008771500,\"participantId\":\"con_ZTMYOmVuZB\",\"location\":\"Berlin, Germany\",\"platform\":\"Chrome 80.0.3987.132 on Linux 64-bit\",\"clientData\":\"Mike\",\"serverData\":\"{'user': 'client1'}\"}}","title":"participantJoined"},{"location":"reference-docs/openvidu-server-cdr/#participantleft","text":"Recorded when a user has left a session. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier location Geo location of the participant PRO A string with format \"CITY, COUNTRY\" (or \"unknown\" ) platform Complete description of the platform used by the participant to connect to the session A string with the platform description clientData Metadata associated to this participant from the client side. This corresponds to parameter metadata of openvidu-browser method Session.connect A string with the participant client-side metadata (generated when calling Session.connect method) serverData Metadata associated to this participant from the server side. This corresponds to parameter data of REST API operation POST /api/tokens or its Java/Node server SDKs variants A string with the participant server-side metadata (generated with the token) startTime Time when the participant joined the session UTC milliseconds duration Total duration of the participant's connection to the session Seconds reason How the participant left the session [ \"disconnect\" , \"forceDisconnectByUser\" , \"forceDisconnectByServer\" , \"sessionClosedByServer\" , \"networkDisconnect\" , \"openviduServerStopped\" ] Example: {\"participantLeft\":{\"sessionId\":\"ses_SuXO99zeb1\",\"timestamp\":1584009224993,\"startTime\":1584008771500,\"duration\":453,\"reason\":\"disconnect\",\"participantId\":\"con_ZTMYOmVuZB\",\"location\":\"Berlin, Germany\",\"platform\":\"Chrome 80.0.3987.132 on Linux 64-bit\",\"clientData\":\"Mike\",\"serverData\":\"{'user': 'client1'}\"}}","title":"participantLeft"},{"location":"reference-docs/openvidu-server-cdr/#webrtcconnectioncreated","text":"Recorded when a new media stream has been established. Can be an \"INBOUND\" connection (the user is receiving a stream from a publisher of the session) or an \"OUTBOUND\" connection (the user is a publishing a stream to the session). Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier connection Whether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu) [ \"INBOUND\" , \"OUTBOUND\" ] receivingFrom If connection is \"INBOUND\" , the participant from whom the media stream is being received A string with the participant (sender) unique identifier audioEnabled Whether the media connection has negotiated audio or not [ true , false ] videoEnabled Whether the media connection has negotiated video or not [ true , false ] videoSource If videoEnabled is true , the type of video that is being transmitted [ \"CAMERA\" , \"SCREEN\" ] videoFramerate If videoEnabled is true , the framerate of the transmitted video Number of fps videoDimensions If videoEnabled is true , the dimensions transmitted video String with the dimensions (e.g. \"1920x1080\" ) Example: {\"webrtcConnectionCreated\":{\"sessionId\":\"fds4e07mdug1ga3h\",\"timestamp\":1538481419726,\"participantId\":\"ges2furjsjjmyi0b\",\"connection\":\"INBOUND\",\"receivingFrom\":\"wsalcr1r72goj8sk\",\"videoSource\":\"CAMERA\",\"videoFramerate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"audioEnabled\":true,\"videoEnabled\":true}}","title":"webrtcConnectionCreated"},{"location":"reference-docs/openvidu-server-cdr/#webrtcconnectiondestroyed","text":"Recorded when any media stream connection is closed. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier connection Whether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu) [ \"INBOUND\" , \"OUTBOUND\" ] receivingFrom If connection is \"INBOUND\" , the participant from whom the media stream is being received A string with the participant (sender) unique identifier audioEnabled Whether the media connection has negotiated audio or not [ true , false ] videoEnabled Whether the media connection has negotiated video or not [ true , false ] videoSource If videoEnabled is true , the type of video that is being transmitted [ \"CAMERA\" , \"SCREEN\" ] videoFramerate If videoEnabled is true , the framerate of the transmitted video Number of fps videoDimensions If videoEnabled is true , the dimensions transmitted video String with the dimensions (e.g. \"1920x1080\" ) startTime Time when the media connection was established UTC milliseconds duration Total duration of the media connection Seconds reason How the WebRTC connection was destroyed [ \"unsubscribe\" , \"unpublish\" , \"disconnect\" , \"forceUnpublishByUser\" , \"forceUnpublishByServer\" , \"forceDisconnectByUser\" , \"forceDisconnectByServer\" , \"sessionClosedByServer\" , \"networkDisconnect\" , \"openviduServerStopped\" , \"mediaServerDisconnect\" ] Example: {\"webrtcConnectionDestroyed\":{\"sessionId\":\"fds4e07mdug1ga3h\",\"timestamp\":1538481449060,\"startTime\":1538481419726,\"duration\":29,\"reason\":\"disconnect\",\"participantId\":\"ges2furjsjjmyi0b\",\"connection\":\"INBOUND\",\"receivingFrom\":\"wsalcr1r72goj8sk\",\"videoSource\":\"CAMERA\",\"videoFramerate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"audioEnabled\":true,\"videoEnabled\":true}}","title":"webrtcConnectionDestroyed"},{"location":"reference-docs/openvidu-server-cdr/#recordingstarted","text":"REMOVED IN OPENVIDU 2.11.0. Use recordingStatusChanged Recorded when a new session has started to be recorded Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds id Unique identifier of the recording A string with the recording unique identifier name Name given to the recording file A string with the recording name outputMode Output mode of the recording ( COMPOSED or INDIVIDUAL ) A string with the recording output mode hasAudio Wheter the recording file has audio or not [ true , false ] hasVideo Wheter the recording file has video or not [ true , false ] recordingLayout The type of layout used in the recording. Only defined if outputMode is COMPOSED and hasVideo is true A RecordingLayout value (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...) resolution Resolution of the recorded file. Only defined if outputMode is COMPOSED and hasVideo is true A string with the width and height of the video file in pixels. e.g. \"1280x720\" size The size of the video file 0 duration Duration of the video file 0 Example: {\"recordingStarted\":{\"sessionId\":\"TestSession\",\"timestamp\":1549015630563,\"id\":\"TestSession\",\"name\":\"MyRecording\",\"outputMode\":\"COMPOSED\",\"hasAudio\":false,\"hasVideo\":true,\"recordingLayout\":\"BEST_FIT\",\"resolution\":\"1920x1080\",\"size\":0,\"duration\":0.0}}","title":"recordingStarted"},{"location":"reference-docs/openvidu-server-cdr/#recordingstopped","text":"REMOVED IN OPENVIDU 2.11.0. Use recordingStatusChanged Recorded when a new session has stopped being recorded Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds startTime Time when the stopped recording started UTC milliseconds id Unique identifier of the recording A string with the recording unique identifier name Name given to the recording file A string with the recording name outputMode Output mode of the recording ( COMPOSED or INDIVIDUAL ) A string with the recording output mode hasAudio Wheter the recording file has audio or not [ true , false ] hasVideo Wheter the recording file has video or not [ true , false ] recordingLayout The type of layout used in the recording. Only defined if outputMode is COMPOSED and hasVideo is true A RecordingLayout value (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...) resolution Resolution of the recorded file. Only defined if outputMode is COMPOSED and hasVideo is true A string with the width and height of the video file in pixels. e.g. \"1280x720\" size The size of the video file Bytes duration Duration of the video file Seconds reason Why the recording stopped [ \"recordingStoppedByServer\" , \"lastParticipantLeft\" , \"sessionClosedByServer\" , \"automaticStop\" , \"openviduServerStopped\" , \"mediaServerDisconnect\" ] Example: {\"recordingStopped\":{\"sessionId\":\"TestSession\",\"timestamp\":1549015640859,\"startTime\":1549015630563,\"id\":\"TestSession\",\"name\":\"MyRecording\",\"outputMode\":\"COMPOSED\",\"hasAudio\":false,\"hasVideo\":true,\"recordingLayout\":\"BEST_FIT\",\"resolution\":\"1920x1080\",\"size\":617509,\"duration\":5.967,\"reason\":\"recordingStoppedByServer\"}}","title":"recordingStopped"},{"location":"reference-docs/openvidu-server-cdr/#recordingstatuschanged","text":"Recorded when the status of a recording has changed. The status may be: started : the session is being recorded. This means the associated video(s) already exists and its size is greater than 0. NOTE: when using COMPOSED recording with video, this event does not mean there are publisher's streams being recorded in the video file. It only ensures the video file exists and its size is greater than 0 stopped : the recording process has stopped and files are being processed. The recording entity's duration and size properties will still be set to 0. ready : the recorded file has been successfully processed and is available for download. The recording entity's duration and size properties are properly defined now failed : the recording process has failed. The final state of the recorded file cannot be guaranteed to be stable Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds startTime Time when the recording started UTC milliseconds id Unique identifier of the recording A string with the recording unique identifier name Name given to the recording file A string with the recording name outputMode Output mode of the recording ( COMPOSED or INDIVIDUAL ) A string with the recording output mode hasAudio Wheter the recording file has audio or not [ true , false ] hasVideo Wheter the recording file has video or not [ true , false ] recordingLayout The type of layout used in the recording. Only defined if outputMode is COMPOSED and hasVideo is true A RecordingLayout value (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...) resolution Resolution of the recorded file. Only defined if outputMode is COMPOSED and hasVideo is true A string with the width and height of the video file in pixels. e.g. \"1280x720\" size The size of the video file. 0 until status is stopped Bytes duration Duration of the video file. 0 until status is stopped Seconds status Status of the recording [ \"started\" , \"stopped\" , \"ready\" , \"failed\" ] reason Why the recording stopped. Only defined when status is stopped or ready [ \"recordingStoppedByServer\" , \"lastParticipantLeft\" , \"sessionClosedByServer\" , \"automaticStop\" , \"openviduServerStopped\" , \"mediaServerDisconnect\" ] Example: {\"recordingStatusChanged\":{\"sessionId\":\"TestSession\",\"timestamp\":1549015640859,\"startTime\":1549015630563,\"duration\":5.967,\"id\":\"TestSession\",\"name\":\"MyRecording\",\"outputMode\":\"COMPOSED\",\"hasAudio\":true,\"hasVideo\":true,\"recordingLayout\":\"BEST_FIT\",\"resolution\":\"1920x1080\",\"size\":617509,\"status\":\"stopped\",\"reason\":\"sessionClosedByServer\"}}","title":"recordingStatusChanged"},{"location":"reference-docs/openvidu-server-cdr/#filtereventdispatched","text":"From OpenVidu 2.12.0 Recorded when a filter event has been dispatched. This event can only be triggered if a filter has been applied to a stream and a listener has been added to a specific event offered by the filter. See Voice and video filters to learn more. Property Description Value sessionId Session for which the event was triggered A string with the session unique identifier timestamp Time when the event was triggered UTC milliseconds participantId Identifier of the participant A string with the participant unique identifier streamId Identifier of the stream for which the filter is applied A string with the stream unique identifier filterType Type of the filter applied to the stream A string with the type of filter eventType Event of the filter that was triggered A string with the type of event data Data of the filter event A string with the data returned by the filter event. Its value will depend on the type of filter and event Example: {\"filterEventDispatched\":{\"sessionId\":\"TestSession\",\"timestamp\":1568645808285,\"participantId\":\"oklnb2wgsisr0sd3\",\"streamId\":\"oklnb2wgsisr0sd3_CAMERA_GXTRU\",\"filterType\":\"ZBarFilter\",\"eventType\":\"CodeFound\",\"data\":\"{timestampMillis=1568645808285, codeType=EAN-13, source=23353-1d3c_kurento.MediaPipeline/1f56f4a5-807c-71a30d40_kurento.ZBarFilter, type=CodeFound, value=0012345678905, tags=[], timestamp=1568645808}\"}}","title":"filterEventDispatched"},{"location":"reference-docs/openvidu-server-params/","text":"OpenVidu Server configuration parameters Configuration parameters for OpenVidu Server Extra configuration parameters for OpenVidu Server Docker container Externalizing configuration Configuration parameters for OpenVidu Server Parameter Description Default value server.port Port where OpenVidu Server will listen to client's connections 4443 kms.uris KMS URL's to which OpenVidu Server will try to connect. They are tested in order until a valid one is found [\"ws://localhost:8888/kurento\"] (default value for a KMS running in the same machine as OpenVidu Server) openvidu.secret Secret used to connect to OpenVidu Server. This value is required when using the REST API or any server client ( openvidu-java-client , openvidu-node-client ), as well as when connecting to openvidu-server dashboard MY_SECRET openvidu.publicurl URL to connect clients to OpenVidu Server. This can be the full IP (protocol, host and port) or just a domain name if you have configured it. For example: \u2022 https://my.openvidu.server.com \u2022 https://12.34.56.78:4443/ local (with default value local this parameter will be set to localhost:PORT , being PORT the param server.port ) openvidu.cdr Whether to enable Call Detail Record or not (check Call Detail Record ) false openvidu.recording Whether to enable recording module or not (check Recording ) false openvidu.recording.path System path where to store the video files of recorded sessions /opt/openvidu/recordings openvidu.recording.public-access Whether to allow free http access to recorded sessions or not. If true path https://OPENVIDU_IP:[server.port]/[openvidu.recording.path] will be publicly accessible through https://OPENVIDU_IP:[server.port]/recordings path. That means any client can connect to https://OPENVIDU_IP:[server.port]/recordings/<RECORDING_ID>/<RECORDING_NAME>.<EXTENSION> and access the recorded video file. If false this path will be secured with openvidu.secret . For example, for OpenVidu Server launched in my.url.com and configured with server.port=5000 , openvidu.recording=true , openvidu.recording-path=/my/path and openvidu.recording.public-access=true : A session with id foo that has been recorded may generate a video file locally stored in the host machine under /my/path/foo/foo.mp4 and accesible by any client connecting to https://my.url.com:5000/recordings/foo/foo.mp4 false openvidu.recording.notification Which users should receive the recording events in the client side ( recordingStarted , recordingStopped ). Can be all (every user connected to the session), publisher_moderator (users with role 'PUBLISHER' or 'MODERATOR'), moderator (only users with role 'MODERATOR') or none (no user will receive these events) publisher_moderator openvidu.recording.custom-layout System path where OpenVidu Server should look for custom recording layouts /opt/openvidu/custom-layout openvidu.recording.autostop-timeout Timeout in seconds for recordings to automatically stop (and the session involved to be closed) when conditions are met: a session recording is started but no user is publishing to it or a session is being recorded and last user disconnects. If a user publishes within the timeout in either case, the automatic stop of the recording is cancelled 120 openvidu.webhook Whether to enable webhook service or not (check OpenVidu Server Webhook ) false openvidu.webhook.endpoint HTTP endpoint where OpenVidu Server will send the POST messages with webhook events openvidu.webhook.headers Array of strings with the HTTP headers that OpenVidu Server will append to each POST message of webhook events. For example, you may configure a Basic Auth header name:pass setting this property to [\\\"Authorization:\\ Basic\\ bmFtZTpwYXNz\\\"] [ ] openvidu.webhook.events Array of strings with the type of events you want OpenVidu Server to send to your webhook [\"sessionCreated\",\"sessionDestroyed\",\"participantJoined\",\"participantLeft\",\"webrtcConnectionCreated\",\"webrtcConnectionDestroyed\",\"recordingStatusChanged\"] (all available events) openvidu.streams.video.max-recv-bandwidth Maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained 1000 openvidu.streams.video.min-recv-bandwidth Minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained 300 openvidu.streams.video.max-send-bandwidth Maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained 1000 openvidu.streams.video.min-send-bandwidth Minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained 300 server.ssl.key-store Path for using custom JKS certificate (selfsigned OpenVidu key-store) server.ssl.key-store-password Password for the custom JKS (selfsigned OpenVidu password) server.ssl.key-alias Alias for the custom JKS (selfsigned OpenVidu alias) Examples: java -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://my.openvidu.server.ip:3333/ -Dopenvidu.cdr=true -Dserver.port=3333 -Dkms.uris=[\"ws://my.kms.ip:8888/kurento\"] -jar openvidu-server.jar Extra configuration parameters for OpenVidu Server Docker container WARNING: container not suitable for production deployments of OpenVidu. This container lacks some services mandatory for production set ups. To deploy OpenVidu CE in a production environment, you can do it on AWS or on Ubuntu Parameter Description Sample value KMS_STUN_IP IP of STUN server used by KMS stun.l.google.com (free STUN server from Google) KMS_STUN_PORT PORT of STUN server used by KMS 19302 (free STUN server from Google) KMS_TURN_URL Configuration for TURN server used by KMS user:pass@turn_public_ip:turn_port ( user and pass of the TURN server, turn_public_ip its publicly accessible url and turn_port the port the TURN server listens to Example: docker run -d -p 3333:3333 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://my.openvidu.server.ip:3333/ -e openvidu.cdr=true -e server.port=3333 -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e KMS_TURN_URL=myuser:mypass@54.54.54.54:3478 openvidu/openvidu-server-kms:2.12.0 Externalizing configuration You can use an external file to configure OpenVidu Server. Simply write the properties you want in a *.properties file and launch Java process with property spring.config.additional-location setting the path to the file. For example: java -Dspring.config.additional-location=/opt/openvidu/application.properties -jar openvidu-server.jar And having file /opt/openvidu/application.properties one property per line. For example: openvidu.cdr=true openvidu.secret=1234 openvidu.webhook=true openvidu.webhook.endpoint=http://my.webhook.com openvidu.webhook.events=[\"sessionCreated\",\"sessionDestroyed\"] openvidu.recording=false","title":"OpenVidu Server configuration"},{"location":"reference-docs/openvidu-server-params/#configuration-parameters-for-openvidu-server","text":"Parameter Description Default value server.port Port where OpenVidu Server will listen to client's connections 4443 kms.uris KMS URL's to which OpenVidu Server will try to connect. They are tested in order until a valid one is found [\"ws://localhost:8888/kurento\"] (default value for a KMS running in the same machine as OpenVidu Server) openvidu.secret Secret used to connect to OpenVidu Server. This value is required when using the REST API or any server client ( openvidu-java-client , openvidu-node-client ), as well as when connecting to openvidu-server dashboard MY_SECRET openvidu.publicurl URL to connect clients to OpenVidu Server. This can be the full IP (protocol, host and port) or just a domain name if you have configured it. For example: \u2022 https://my.openvidu.server.com \u2022 https://12.34.56.78:4443/ local (with default value local this parameter will be set to localhost:PORT , being PORT the param server.port ) openvidu.cdr Whether to enable Call Detail Record or not (check Call Detail Record ) false openvidu.recording Whether to enable recording module or not (check Recording ) false openvidu.recording.path System path where to store the video files of recorded sessions /opt/openvidu/recordings openvidu.recording.public-access Whether to allow free http access to recorded sessions or not. If true path https://OPENVIDU_IP:[server.port]/[openvidu.recording.path] will be publicly accessible through https://OPENVIDU_IP:[server.port]/recordings path. That means any client can connect to https://OPENVIDU_IP:[server.port]/recordings/<RECORDING_ID>/<RECORDING_NAME>.<EXTENSION> and access the recorded video file. If false this path will be secured with openvidu.secret . For example, for OpenVidu Server launched in my.url.com and configured with server.port=5000 , openvidu.recording=true , openvidu.recording-path=/my/path and openvidu.recording.public-access=true : A session with id foo that has been recorded may generate a video file locally stored in the host machine under /my/path/foo/foo.mp4 and accesible by any client connecting to https://my.url.com:5000/recordings/foo/foo.mp4 false openvidu.recording.notification Which users should receive the recording events in the client side ( recordingStarted , recordingStopped ). Can be all (every user connected to the session), publisher_moderator (users with role 'PUBLISHER' or 'MODERATOR'), moderator (only users with role 'MODERATOR') or none (no user will receive these events) publisher_moderator openvidu.recording.custom-layout System path where OpenVidu Server should look for custom recording layouts /opt/openvidu/custom-layout openvidu.recording.autostop-timeout Timeout in seconds for recordings to automatically stop (and the session involved to be closed) when conditions are met: a session recording is started but no user is publishing to it or a session is being recorded and last user disconnects. If a user publishes within the timeout in either case, the automatic stop of the recording is cancelled 120 openvidu.webhook Whether to enable webhook service or not (check OpenVidu Server Webhook ) false openvidu.webhook.endpoint HTTP endpoint where OpenVidu Server will send the POST messages with webhook events openvidu.webhook.headers Array of strings with the HTTP headers that OpenVidu Server will append to each POST message of webhook events. For example, you may configure a Basic Auth header name:pass setting this property to [\\\"Authorization:\\ Basic\\ bmFtZTpwYXNz\\\"] [ ] openvidu.webhook.events Array of strings with the type of events you want OpenVidu Server to send to your webhook [\"sessionCreated\",\"sessionDestroyed\",\"participantJoined\",\"participantLeft\",\"webrtcConnectionCreated\",\"webrtcConnectionDestroyed\",\"recordingStatusChanged\"] (all available events) openvidu.streams.video.max-recv-bandwidth Maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained 1000 openvidu.streams.video.min-recv-bandwidth Minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained 300 openvidu.streams.video.max-send-bandwidth Maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained 1000 openvidu.streams.video.min-send-bandwidth Minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained 300 server.ssl.key-store Path for using custom JKS certificate (selfsigned OpenVidu key-store) server.ssl.key-store-password Password for the custom JKS (selfsigned OpenVidu password) server.ssl.key-alias Alias for the custom JKS (selfsigned OpenVidu alias) Examples: java -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://my.openvidu.server.ip:3333/ -Dopenvidu.cdr=true -Dserver.port=3333 -Dkms.uris=[\"ws://my.kms.ip:8888/kurento\"] -jar openvidu-server.jar","title":"Configuration parameters for OpenVidu Server"},{"location":"reference-docs/openvidu-server-params/#extra-configuration-parameters-for-openvidu-server-docker-container","text":"WARNING: container not suitable for production deployments of OpenVidu. This container lacks some services mandatory for production set ups. To deploy OpenVidu CE in a production environment, you can do it on AWS or on Ubuntu Parameter Description Sample value KMS_STUN_IP IP of STUN server used by KMS stun.l.google.com (free STUN server from Google) KMS_STUN_PORT PORT of STUN server used by KMS 19302 (free STUN server from Google) KMS_TURN_URL Configuration for TURN server used by KMS user:pass@turn_public_ip:turn_port ( user and pass of the TURN server, turn_public_ip its publicly accessible url and turn_port the port the TURN server listens to Example: docker run -d -p 3333:3333 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://my.openvidu.server.ip:3333/ -e openvidu.cdr=true -e server.port=3333 -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e KMS_TURN_URL=myuser:mypass@54.54.54.54:3478 openvidu/openvidu-server-kms:2.12.0","title":"Extra configuration parameters for OpenVidu Server Docker container"},{"location":"reference-docs/openvidu-server-params/#externalizing-configuration","text":"You can use an external file to configure OpenVidu Server. Simply write the properties you want in a *.properties file and launch Java process with property spring.config.additional-location setting the path to the file. For example: java -Dspring.config.additional-location=/opt/openvidu/application.properties -jar openvidu-server.jar And having file /opt/openvidu/application.properties one property per line. For example: openvidu.cdr=true openvidu.secret=1234 openvidu.webhook=true openvidu.webhook.endpoint=http://my.webhook.com openvidu.webhook.events=[\"sessionCreated\",\"sessionDestroyed\"] openvidu.recording=false","title":"Externalizing configuration"},{"location":"reference-docs/openvidu-server-webhook/","text":"OpenVidu Server Webhook OpenVidu offers a webhook service since release 2.11.0 to receive session events in your app server. Enable Webhook service The following system properties allow enabling and configuring OpenVidu Server Webhook service: openvidu.webhook : set it to true to enable webhook service. openvidu.webhook.endpoint : configure the HTTP endpoint where OpenVidu Server will send the POST messages with session events. This property is mandatory if openvidu.webhook is set to true. openvidu.webhook.headers : an array of HTTP headers that OpenVidu Server will append to each POST message. For example, you may configure HTTP authorization with this property. By default this property is an empty array (no headers) openvidu.webhook.events : an array with the type of events you want OpenVidu Server to send to your webhook. By default all available events are enabled. Check out this sample command. It will launch OpenVidu Server with webhook service enabled, sending session events to HTTP endpoint located at http://12.34.56.78:5000/my_webhook , passing a Basic Auth header and sending only sessionCreated , sessionDestroyed and recordingStatusChanged events. java -jar \\ -Dopenvidu.secret=MY_SECRET \\ -Dopenvidu.publicurl=https://my.domain.com \\ -Dopenvidu.recording=true \\ -Dopenvidu.webhook=true \\ -Dopenvidu.webhook.endpoint=http://12.34.56.78:5000/my_webhook \\ -Dopenvidu.webhook.headers=[\\\"Authorization:\\ Basic\\ T1BFTlZJRFVBUFA6TVlfU0VDUkVU\\\"] \\ -Dopenvidu.webhook.events=[\"sessionCreated\",\"sessionDestroyed\",\"recordingStatusChanged\"] \\ openvidu-server.jar How your webhook endpoint should be The HTTP endpoint you configure in property openvidu.webhook.endpoint must meet two criteria: Should listen to HTTP POST requests Should return a 200 success response If OpenVidu Server cannot successfully send the HTTP POST messages to the endpoint and do not receive a 200 success as response, it will log one error message for each attempt. No further action will be taken. Available events in Webhook service OpenVidu Server Webhook service is able to send the same events as defined for OpenVidu CDR . The structure of each event is slightly different to the CDR ones: instead of having a single key named after the type of event and containing all of the event properties in a single object, webhook events have the type of event defined in an event property at the same level as the rest of properties. For example: {\"sessionId\":\"TestSession\",\"timestamp\":1561969010392,\"event\":\"sessionCreated\"} {\"sessionId\":\"TestSession\",\"timestamp\":1561968541502,\"streamId\":\"d2oomgno0isd9xqq_CAMERA_ILTAU\",\"participantId\":\"d2oomgno0isd9xqq\",\"connection\":\"OUTBOUND\",\"videoSource\":\"CAMERA\",\"videoFramerate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"audioEnabled\":true,\"videoEnabled\":true,\"event\":\"webrtcConnectionCreated\"} You can choose only those events that interest you from the whole set of available events with property openvidu.webhook.events . For example, if you are only interested in recording related events, you should set the property to: openvidu.webhook.events=[\"recordingStatusChanged\"]","title":"OpenVidu Server Webhook"},{"location":"reference-docs/openvidu-server-webhook/#enable-webhook-service","text":"The following system properties allow enabling and configuring OpenVidu Server Webhook service: openvidu.webhook : set it to true to enable webhook service. openvidu.webhook.endpoint : configure the HTTP endpoint where OpenVidu Server will send the POST messages with session events. This property is mandatory if openvidu.webhook is set to true. openvidu.webhook.headers : an array of HTTP headers that OpenVidu Server will append to each POST message. For example, you may configure HTTP authorization with this property. By default this property is an empty array (no headers) openvidu.webhook.events : an array with the type of events you want OpenVidu Server to send to your webhook. By default all available events are enabled. Check out this sample command. It will launch OpenVidu Server with webhook service enabled, sending session events to HTTP endpoint located at http://12.34.56.78:5000/my_webhook , passing a Basic Auth header and sending only sessionCreated , sessionDestroyed and recordingStatusChanged events. java -jar \\ -Dopenvidu.secret=MY_SECRET \\ -Dopenvidu.publicurl=https://my.domain.com \\ -Dopenvidu.recording=true \\ -Dopenvidu.webhook=true \\ -Dopenvidu.webhook.endpoint=http://12.34.56.78:5000/my_webhook \\ -Dopenvidu.webhook.headers=[\\\"Authorization:\\ Basic\\ T1BFTlZJRFVBUFA6TVlfU0VDUkVU\\\"] \\ -Dopenvidu.webhook.events=[\"sessionCreated\",\"sessionDestroyed\",\"recordingStatusChanged\"] \\ openvidu-server.jar","title":"Enable Webhook service"},{"location":"reference-docs/openvidu-server-webhook/#how-your-webhook-endpoint-should-be","text":"The HTTP endpoint you configure in property openvidu.webhook.endpoint must meet two criteria: Should listen to HTTP POST requests Should return a 200 success response If OpenVidu Server cannot successfully send the HTTP POST messages to the endpoint and do not receive a 200 success as response, it will log one error message for each attempt. No further action will be taken.","title":"How your webhook endpoint should be"},{"location":"reference-docs/openvidu-server-webhook/#available-events-in-webhook-service","text":"OpenVidu Server Webhook service is able to send the same events as defined for OpenVidu CDR . The structure of each event is slightly different to the CDR ones: instead of having a single key named after the type of event and containing all of the event properties in a single object, webhook events have the type of event defined in an event property at the same level as the rest of properties. For example: {\"sessionId\":\"TestSession\",\"timestamp\":1561969010392,\"event\":\"sessionCreated\"} {\"sessionId\":\"TestSession\",\"timestamp\":1561968541502,\"streamId\":\"d2oomgno0isd9xqq_CAMERA_ILTAU\",\"participantId\":\"d2oomgno0isd9xqq\",\"connection\":\"OUTBOUND\",\"videoSource\":\"CAMERA\",\"videoFramerate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"audioEnabled\":true,\"videoEnabled\":true,\"event\":\"webrtcConnectionCreated\"} You can choose only those events that interest you from the whole set of available events with property openvidu.webhook.events . For example, if you are only interested in recording related events, you should set the property to: openvidu.webhook.events=[\"recordingStatusChanged\"]","title":"Available events in Webhook service"},{"location":"releases/","text":"Releases 2.12.0 2.11.0 2.10.0 2.9.0 2.8.0 2.7.0 2.6.0 2.5.0 2.4.0 2.3.0 2.2.0 2.1.0 2.0.0 1.9.0-beta-1 2.12.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.12.0 NPM JS file 2.12.0 GitHub openvidu-server JAR 2.12.0 GitHub Docker container 2.12.0 DockerHub Docker container (+KMS) 2.12.0 DockerHub openvidu-java-client MVN package 2.12.1 MVN Repository openvidu-node-client NPM package 2.12.0 NPM openvidu-webcomponent ZIP 2.12.0 GitHub openvidu-angular NPM package 2.12.0 NPM openvidu-react NPM package 2.12.0 NPM Kurento Media Server Ubuntu package 6.13.0 Kurento Docs Release Notes NEW FEATURES IN OPENVIDU CE IP cameras support You can now publish IP cameras into an OpenVidu Session!. You users will be able to receive it as they receive any other regular webcam stream. With this new feature you can for example implement surveillance systems in the blink of an eye. How about receiving your IP camera video in your mobile app? And what about building a web dashboard where you can observe all of your security cameras footage in real-time? So many possibilities\u2026 You can check out IP cameras section of OpenVidu official documentation to learn more Send signals from your backend You are now able to send messages to the participants of an OpenVidu Session from your application\u2019s backend with method POST /api/signal . This feature brings the power of client side messaging to your server side. Record your webapp with COMPOSITE layout You can now use custom recording layouts deployed outside of OpenVidu Server host. Before it was mandatory to build an HTML/CSS layout and upload it to OpenVidu Server host before you could use it as a custom recording layout. But now you can record any webpage hosted anywhere. More information here . New CDR/Webhook event filterEventDispatched You can now register filterEventDispatched events in OpenVidu CDR and OpenVidu Webhook services. This way you can know when a voice or video filter has emitted an event from your application\u2019s server side (once you add an event listener to a filter). New data in CDR/Webhook event participantJoined and participantLeft Both participantJoined and participantLeft CDR/Webhook events include now clientData and serverData properties. This allows you to better identify your users from your application\u2019s server side. Automatic reconnection when connection is lost Now your clients can listen to brand new reconnection events triggered by Session object: reconnecting and reconnected events. reconnecting event is triggered when a client connected to a Session loses its network connection with OpenVidu. Automatically openvidu-browser tries to reconnect to the Session with an endless polling. Once the client recovers its network connection, openvidu-browser will automatically try to reset the user state in the session. If it is too late and OpenVidu has already evicted the user due to inactivity, then a SessionDisconnectedEvent with reason networkDisconnect will be triggered. If the user reconnected on time, everything\u2019s back to normal, event reconnected will be dispatched by the Session object and media connections will be automatically re-established if necessary (see Media freeze bug in BUG FIXES). You can check out Automatic reconnection section of OpenVidu official documentation to learn more Switch from camera to screenshare instantly You can use new Publisher.replaceTrack() method available in openvidu-browser to change the audio or video tracks of a Publisher object on the fly, without unpublishing and re-publishing again (so, no need of WebRTC renegotiation!). This also helps changing the video track (front camera for back camera, webcam for screenshare\u2026) keeping your audio connection at all times. You can check out Switch camera section of OpenVidu official documentation to learn more Change publisherSpeakingEvents configuration on the fly in your clients New method StreamManager.updatePublisherSpeakingEventsOptions() allows you to dynamically change the threshold for audio events in openvidu-browser. Affected events are publisherStartSpeaking , publisherStopSpeaking and streamAudioVolumeChange . This way you can adjust in real time the limits and frequency of audio stream polling in the browser to make better use of these events. All the goodnes from Kurento 6.12.0 and 6.13.0 releases OpenVidu 2.12.0 is now using the latest 6.13.0 version of Kurento . There are lots of improvements in both Kurento 6.12.0 and 6.13.0, including some several critical bug fixes. You can take a look to all of them here: Kurento 6.12.0 Release Notes Kurento 6.13.0 Release Notes NEW FEATURES IN OPENVIDU PRO New payment method This is possibly the biggest change for this release. The number of customers of our OpenVidu Pro tier has increased considerably in recent times, and we needed to facilitate the process of subscribing to OpenVidu Pro. We have introduced a new license key system for deploying OpenVidu Pro. Now anyone can create an OpenVidu account , and in just a few clicks you will be able to purchase an OpenVidu Pro license to launch as many OpenVidu Pro clusters as you want. Visit Pricing section to learn more about the new OpenVidu Pro subscription model. You have a 15-day free trial period when registering as an OpenVidu user! Simplified pricing Related to previous point, we have now removed the minimum 10$ per month fee and users receive a 15-day free trial period when they register as OpenVidu users . Check it out now for free! Dynamic scalability OpenVidu Pro 2.11.0 allowed you to initialize your OpenVidu Pro cluster with a fixed number of Media Nodes. Now you can add and remove as many Media Nodes as you want on the fly from OpenVidu Inspector or through OpenVidu Pro REST API . Visit Scalability section to learn more. OpenVidu Inspector big upgrade OpenVidu Inspector has undergone a major upgrade to support the new clustering features of OpenVidu Pro 2.12.0. You can now manage your cluster directly from OpenVidu Inspector. Besides, it is now built with Angular 9, which makes it even more efficient and less heavy! Detailed session monitoring improved OpenVidu Pro is now using the latest Elasticsearch and Kibana version . And every new event and important piece of information generated by 2.12.0 is of course stored and processed for later use. Visit Detailed session monitoring section to learn more. BUG FIXES Media freeze bug : media connections are now automatically re-negotiated under the hood if they remain freezed after a user is successfully reconnected following a network failure. This happens when a user loses its Internet connection and manages to reconnect to OpenVidu before it was automatically evicted from the Session, but its media streams are broken. This is so because media connections flow through their own plane, separated from Client-OpenViduServer signaling plane. openvidu-server : race condition fixed for same final user establishing more than one connection to a session at the same time. This might be related to some sessions getting stuck even when no participants are connected to it. openvidu-server : concurrency problems when closing a session being recorded in COMPOSED video mode (fix for issue 364 ). Other possible concurrency problems of the same nature have also been addressed, so stability of OpenVidu Server should have improved for these kind of corner cases. openvidu-server : configuration parameter openvidu.recording.public-access could not take effect when set to false. Now it always does. openvidu-browser : LocalRecorder was broken for recent versions of Firefox. Now LocalRecorder.record() method has an optional string parameter to indicate the desired mimeType . If none is provided, then default browser codecs wil be used to record media streams in the browser. openvidu-browser : method OpenVidu.getUserMedia() was broken when requesting screen sharing. Now it works just fine. openvidu-browser : setting a listener for streamAudioVolumeChange event just after initializing a Publisher or Subscriber object could trigger an Exception. Now it doesn\u2019t. openvidu-browser : Session.signal() wrong to array now does not trigger a fatal error. openvidu-node-client : OpenVidu entrypoint object would throw an error if initialized with a URL with no port. Now you can use your openvidu-server domain name without a port (default 443) to initialized it. OpenVidu Inspector : thumbnails of recording files were sometimes asking for the secret in order to be loaded. Now they don\u2019t. 2.11.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.11.0 NPM JS file 2.11.0 GitHub openvidu-server JAR 2.11.0 GitHub Docker container 2.11.0 DockerHub Docker container (+KMS) 2.11.0 DockerHub openvidu-java-client MVN package 2.11.0 MVN Repository openvidu-node-client NPM package 2.11.0 NPM openvidu-webcomponent ZIP 2.11.0 GitHub openvidu-angular NPM package 2.11.0 NPM openvidu-react NPM package 2.11.0 NPM Kurento Media Server Ubuntu package 6.11.0 Kurento Docs Release Notes NEW FEATURES IN OPENVIDU COMMUNITY OpenVidu Webhook service You are now able to receive OpenVidu events in your application server by using the brand new Webhook service. This is a feature that has been requested for a long time, and you can start using it right now. You have all the information in the official documentation: OpenVidu Server Webhook Externalizing configuration of OpenVidu Server Are you tired of having to write all the configuration parameters in openvidu-server launch command? Well, now you can externalize all your configuration into a separate file. You just need to use property spring.config.additional-location like this: java -Dspring.config.additional-location=/path/to/application.properties -jar openvidu-server.jar Then all configuration parameters listed in that file will be used. You have all the information in the official documentation: Externalizing configuration NEW FEATURES IN OPENVIDU PRO First version of scalability Finally OpenVidu brings the possibility of deploying a cluster with multiple Media Nodes. OpenVidu Pro will distribute your sessions among all available Media Nodes based on their current load. Take a look to the official OpenVidu Pro tier documentation to learn more: Scalability Persistent configuration when restarting OpenVidu Server Pro Whenever you restart OpenVidu Server Pro by using the REST API , the new parameters you provide will be saved to disk. This way you will be able to stop the service or even the host without losing the last configuration you provided when restarting OpenVidu Server Pro through REST API. BUG FIXES openvidu-browser : when sharing the entire screen in Electron, no Publisher was being initalized. Now it does. openvidu-browser : mobile devices where sending a streamPropertyChanged event when rotating the phone even when the Publisher wasn't being published to the session (error on the websocket connection). Now they don't. openvidu-server : when KMS crashed and was rebooted, sometimes the first user republishing a Stream would get an error. Now it doesn't. openvidu-pro : restarting OpenVidu Pro from Inspector and enabling CDR failed. Now it doesn't. openvidu-pro : Kibana failed returning documents before running a session. Now it doesn't. openvidu-pro : Inspector loggin process may failed when connecting through Firefox. Now it doesn't. OTHER NOTEWORTHY CHANGES Although this is not a visible feature for OpenVidu final users, we would like to mention that we have updated OpenVidu Server to Spring Boot 2 . OpenVidu Server core has been based on Spring Boot 1 since the beginning of the project, but we decided to invest some time to upgrade it to the latest stable version to take advantage of its many new improvements. This should translate in better performance, stability and security. BREAKING CHANGES OpenVidu CDR events recordingStarted and recordingStopped are now deprecated in favour of recordingStatusChanged event. Check this new event here . Besides, event recordingStopped now won't provide the final values of the recording (specifically its duration and size properties, that will be 0). You will have to listen to recordingStatusChanged with status ready to get them. 2.10.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.10.0 NPM JS file 2.10.0 GitHub openvidu-server JAR 2.10.0 GitHub Docker container 2.10.0 DockerHub Docker container (+KMS) 2.10.0 DockerHub openvidu-java-client MVN package 2.10.0 MVN Repository openvidu-node-client NPM package 2.10.0 NPM openvidu-webcomponent ZIP 2.10.0 GitHub openvidu-angular NPM package 2.10.0 NPM openvidu-react NPM package 2.10.0 NPM Kurento Media Server Ubuntu package 6.10.0 Kurento Docs Release Notes NEW FEATURES This release brings support to more and more clients, so you can expand your OpenVidu client-side range. Of course, they are all compatible with each other and with every other platform already supported. Electron support OpenVidu has supported most popular browsers since its inception, and past releases brought official support to Android and iOS through Ionic . But there was still a gap regarding desktop applications. With 2.10.0 we are happy to announce that you are now able to implement your Windows, OSX and Linux native app with OpenVidu through Electron. What is Electron? It is great framework for building native desktop applications with classic web technologies (simple, good old HTML, CSS and JS). Electron is to desktop operating systems what Ionic is to mobile operating systems. Some examples of great applications built with Electron are Slack, Skype, Atom or Visual Studio Code Using Electron means that the same codebase you are already using for your web and mobile application can be used to build a desktop app that will work on Windows, OSX and Linux. Take a look to our brand new openvidu-electron tutorial, and you will have a desktop OpenVidu app working in minutes. It even brings screen-sharing! React Native support You\u2019re not convinced by Ionic? Now you can choose React Native framework for developing your OpenVidu mobile app. React Native is rather similar to Ionic from the developers perspective, but at the same time its nature is very different. Essentially, it really uses native Android and iOS UI components under the hood while Ionic is based on WebView (in a nutshell, it runs on the browser). React Native support is not part of the open source stack of OpenVidu platform. Please, contact us through Commercial page to ask for React Native support. You can then use openvidu-react-native tutorial to quickly get started Internet Explorer support Yes, it\u2019s 2019. But there\u2019s still a lot of companies out there that provide/require IE support and need videoconferencing systems to work in this browser relic. So that\u2019s why we have brought OpenVidu support to IE through Temasys plugin. Only IE 11 is supported (going further back was too much of a pain). Internet Explorer support is not part of the open source stack of OpenVidu platform. Please, contact us through Commercial page to ask for React Native support. You can then use openvidu-internet-explorer tutorial to quickly get started BUG FIXES openvidu-angular and openvidu-webcomponent were failing when screen sharing. Now they don\u2019t. openvidu-browser : screen-sharing streams are not mirrored in the local videos now by default. openvidu-browser : event streamPlaying was being triggered anormally when calling StreamManager.addVideoElement method. Now it doesn\u2019t. openvidu-node-client and openvidu-java-client : removed static methods and properties from OpenVidu object. Now it is possible to keep a collection of OpenVidu objects from same Node or Java app by using SDK clients, which allows to manage multiple OpenVidu Servers from the same application. openvidu-browser now checks version compatibility with openvidu-server. If version numbers are not equal, an error will be printed in the browser\u2019s console when calling Session.connect method, so developers know they must use same version number on both sides. This gives devs very useful information about a very common mistake that usually leads to bugs that can be very difficult to trace but have a really simple solution, which is simply upgrading openvidu-browser library version. This new verification is not really a bug fix, but for sure will help avoiding future bugs. 2.9.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.9.0 NPM JS file 2.9.0 GitHub openvidu-server JAR 2.9.0 GitHub Docker container 2.9.0 DockerHub Docker container (+KMS) 2.9.0 DockerHub openvidu-java-client MVN package 2.9.0 MVN Repository openvidu-node-client NPM package 2.9.0 NPM openvidu-webcomponent ZIP 2.9.0 GitHub openvidu-angular NPM package 2.9.0 NPM openvidu-react NPM package 2.9.0 NPM Kurento Media Server Ubuntu package 6.10.0 Kurento Docs Release Notes NEW FEATURES Ubuntu 18.04 bionic support Our team has released Kurento 6.10.0 , which can now be installed in Ubuntu 18.04 systems. This is a milestone we've been working on for quite some time, and we finally believe we're ready to launch official support for the newest Ubuntu LTS version. Deployment section in OpenVidu Docs is properly updated to inform about this. We still consider Ubuntu Bionic to be in a preliminary support state, and some bugs may appear. In fact, we know for sure there's one limitation: no OpenCV filters will work in Ubuntu 18.04 at this moment. OpenVidu has supported audio and video filters for a long time now, and it is a cool feature that allows developers to implement some advanced audio and video real-time processing in the server side. But unfortunately Kurento has not been updated yet to support it in Bionic, so no FaceOverlayFilter or ChromaFilter will work in new Ubuntu version. But you can still use GStreamer filters ! OpenVidu Server boot process greatly improved OpenVidu Server now checks all requiered conditions at boot time, which helps solving missconfiguration problems when deploying on Ubuntu . This includes every requirement related to permissions and installed software. If something is missing, wrong or there are not enough permissions in certain path, the OpenVidu Server process immediately exits with a clear description about what happened and a possible solution to fix it. In our experience, this makes the process of installing OpenVidu Server directly in Ubuntu so much easier and manageable. OpenVidu reconnection to Kurento Media Server If OpenVidu Server loses its connection to Kurento Media Server, now it will try to reconnect automatically. When it does so, if it is a new instance of Kurento, every stream of every previously active session will be destroyed with reason mediaServerDisconnect and every active recording will be stopped with same reason, but your users will not be disconnected from your sessions. This way you can directly re-publish and re-subscribe any desired stream right away. This may help in case Kurento crashes: your users will have lost their media connections, but they will still be connected to their OpenVidu sessions and will only have to re-establish streams once OpenVidu Server is connected to a new Kurento instance. OpenVidu upgrade process Do you want to upgrade your OpenVidu deployment? Now you have a section entirely dedicated to it in the documentation . If you have deployed OpenVidu in AWS, it's as easy as launching a single command. If you have chosen Ubuntu deployment, then you will have to manually run some commands. Either way, you have available proper instructions now. Native screen-sharing for Chrome OpenVidu has supported native screen-sharing for Firefox since its inception, but Google decided to have Chrome require an extension to allow screen-sharing. Finally they changed their mind and brought Chrome up to the standard, supporting getDisplayMedia API. So, our client library openvidu-browser now supports native screen-sharing for Chrome\u226572. No extension needed for these browsers! OpenVidu Call improvements Our best demo application has been updated with some exciting new features: Users can now share their webcam and their screen at the same time. The chat is better integrated now. You can enlarge as many videos as you want, not just one. Available space will be automatically managed by the application for best fit. Preview window for camera and mic selection has undergone many necessary fixes. Now it works fine in every OS and client supported by OpenVidu. openvidu-call-ionic (Ionic version of OpenVidu Call for mobile devices) now supports Ionic 4 and works fine in iOS.ready to BUG FIXES For COMPOSED recording with video, when multiple screen sharing streams were being published it crashed. Now it doesn't. For COMPOSED recordings with video, when stopping them immediatley after started, sometimes the generated video file would not be playable. Now in this cases failed status is set to this recordings, so you can take care of them properly. After manually stopping ALWAYS recordings (sessions that are automatically recorded once first publisher starts) in an ongoing session, now publishing a stream when no publishers are active in the session won't start automatically a new recording. Active sessions retrieval now returns sessions created with REST API or server SDKs that have not received any client connection (before this fix they would not be returned until some user had connected to it) Call Detail Record : recordingStopped event for INDIVIDUAL recordings wasn't updating their duration and size values (both properties had value 0) streamPropertyChanged event was firing an exception in the browser for streams for which a user wasn't subscribed to. Avoid 500 error when sending no body on POST operations of the REST API, such as POST /api/sessions Minor bug fixes in openvidu-java-client. OPENVIDU PRO We are excited to announce OpenVidu Pro: a commercial tier for OpenVidu platform. Check it out here . 2.8.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.8.0 NPM JS file 2.8.0 GitHub openvidu-server JAR 2.8.0 GitHub Docker container 2.8.0 DockerHub Docker container (+KMS) 2.8.0 DockerHub openvidu-java-client MVN package 2.8.1 MVN Repository openvidu-node-client NPM package 2.8.0 NPM openvidu-webcomponent ZIP 2.8.0 GitHub openvidu-angular NPM package 2.8.0 NPM openvidu-react NPM package 2.8.0 NPM Kurento Media Server Ubuntu package 6.9.0 Kurento Docs Release Notes NEW FEATURES Individual stream recording Finally individual stream recording is available in OpenVidu. When recording a session you can now configure it to store each published stream in its own file. This, on the one hand, gives developers lots of freedom to compose any kind of layout and achieve any kind of result once the recording has stopped, by using some post-processing video tool. On the other hand, this type of recording has proven to be 4x more efficient in comparison with previous grid recording in our first tests, allowing a better quality and a higher number of streams per recording, and more simultaneous recordings. We have entirely rewritten Recording documentation explaining all these new features. Take a look at it! Audio-only and video-only recording Configure your recordings to be audio-only or video-only. This is available for both COMPOSED and INDIVIDUAL recordings. It is worth mentioning that audio-only COMPOSED recordings takes advantage of the new recording capabilities introduced in this release to make it an extremley efficient process. Check out the full documentation on this subject. Other improvements New property resolution when starting recordings. With it you can set the width and height in pixels of the recorded file. This is only available for COMPOSED recordings. INDIVIDUAL recordings will always record the video files with the native resolution of each video stream Automatic stop of recordings is greatly improved. Check it out here New property Stream.creationTime in OpenVidu Browser. This is the time when a stream was created in OpenVidu Server. Reflects the real starting time of the media stream transmission on the server side. OpenVidu Server now destroys any stranded recording container left on the host on start up. This allows keeping the host machine clean when restarting the service New REST method available in OpenVidu Server: GET /config . You can consult OpenVidu Server version and all active configuration properties with it. Check it out here . BUG FIXES Fixed a problem that was causing unexpected websocket disconnections from OpenVidu Server due to HttpSessions expiring after half an hour. It has been fixed by adding real reconnection capailities to websockets established from clients. This also fixes a problem with recordings longer than 30 minutes sometimes failing. Issue #146 Recording layout improved: default BEST_FIT layout used in COMPOSED recordings was including small black bars in the upper and left margins of the layout, that were visible in the final video file. This is now fixed. openvidu-browser: property Connection.creationTime now has real value (brought from OpenVidu Server) instead of a local value. Now it reflects the real time some user connected to the Session. Issue #170 openvidu-call: now when setting a screen-share stream in full-screen mode, aspect ratio is preserved to avoid loss of information BREAKING CHANGES Even though this is not a major update with incompatibility changes according to semver , there are in fact a couple of changes that are worth mentioning: Recorded files folder structure has changed: each recording is stored now in its own folder, named after the unique recording id. This doesn't affect the recordings management through REST API, openvidu-java-client or openvidu-node-client. But if you were locally managing the recordings, then a new folder structure is expected now. openvidu-node-client: Recording properties Recording.hasAudio , Recording.hasVideo and Recording.name have been included into new Recording.properties attribute: Recording.properties.hasAudio , Recording.properties.hasVideo and Recording.properties.name 2.7.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.7.0 NPM JS file 2.7.0 GitHub openvidu-server JAR 2.7.0 GitHub Docker container 2.7.0 DockerHub Docker container (+KMS) 2.7.0 DockerHub openvidu-java-client MVN package 2.5.0 MVN Repository openvidu-node-client NPM package 2.5.0 NPM openvidu-webcomponent ZIP 2.7.0 GitHub openvidu-angular NPM package 2.7.1 NPM openvidu-react NPM package 2.7.1 NPM Kurento Media Server Ubuntu package 6.8.1 Kurento Docs Release Notes NEW FEATURES Safari support OpenVidu finally brings Safari to its collection of supported platforms. Two things to take into account when developing a Safari compatible application: If there are gonna be other types of clients rather than Safari connecting to the same session, then transcoding will be necessary in OpenVidu Server. This will bring up CPU load significantly. This behavior is due to Safari not supporting any other codec than H264, when rest of platforms usually prefer VP8. Good news is this is a problem that will soon fix on its own: Safari will support VP8 in the near future (see Release 68 Notes ) A little hack is needed in your app if your Safari users are gonna have SUBSCRIBER role (only receiving video, without accessing their microphone or camera). Learn more here Ionic support for iOS Apple support is completed with Ionic platform for iOS. Now you can implement an Ionic app that will compile OK into an iOS native application. Our openvidu-ionic tutorial is now fully compatible with iPhones and iPads. We recommend to use it as a starting point for your Android/iOS application, but in openvidu-ionic tutorial you also have everything you need to integrate OpenVidu in any Ionic app. Take a look at it! New event streamAudioVolumeChange You can now listen to volume changes in any Publisher or Subscriber object. You can, for example, add a real-time audio wave or perform some action when certain level of noise or silence is reached. More details here . BUG FIXES Recording layout now internally hides cursor (no need of styling the layout with cursor:none ). Issue #138 Recording stopping process reinforced to terminate and gracefully generate video files for failed recording containers (those that do not receive any video from the session caused by a misconfiguration or a wrong custom recording layout). This will help getting rid off dead containers and keeping OpenVidu Server clean. Issue #148 Mirroring local video fix: when changing to screen-share, local video is now un-mirrored, and viceversa. Issue #13 Sessions configured with Recording.MANUAL now automatically stop their recording if last participant left the session and no user published to the same session in 2 minutes. Issue #149 Publisher.publishAudio and Publisher.publishVideo may be called without having initialized a Session or having called Session.publish(Publisher) 2.6.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.6.0 NPM JS file 2.6.0 GitHub openvidu-server JAR 2.6.0 GitHub Docker container 2.6.0 DockerHub Docker container (+KMS) 2.6.0 DockerHub openvidu-java-client MVN package 2.5.0 MVN Repository openvidu-node-client NPM package 2.5.0 NPM openvidu-webcomponent ZIP 2.6.0 GitHub openvidu-angular NPM package 2.6.0 NPM openvidu-react NPM package 2.6.0 NPM Kurento Media Server Ubuntu package 6.8.1 Kurento Docs Release Notes NEW FEATURES Ionic support There's a complete tutorial in OpenVidu Docs to get a native Android app working with OpenVidu in just a few steps. You can just clone and use our sample application as a starting point or maybe you want to add OpenVidu to your existing Ionic app. Here you have the necessary configuration steps to do so (basically Android permissions stuff). We are currently working on making OpenVidu work on iOS with Ionic. New types of filters supported OpenVidu 2.5.0 brought a fantastic and a differentiating element: real time audio and video filters . Now we have extended this capability to support new GStreamer based filters such as textoverlay , timeoverlay or clockoverlay . You can embed any text, the timestamp of the video or the current time, easily customizing its position and format. Check these filters in GStreamer section of filters documentation. Recording service now generates a thumbnail when stopping the recording Whenever you stop the recording of a session, OpenVidu will automatically generate a thumbnail for the video, getting it from the middle of the video timeline. You can access it from https://OPENVIDU_SERVER_IP:4443/recordings/RECORDING_NAME.jpg Do not worry about their lifecycle: they are linked to the video file itself. If you decide to delete the recording, thumbnail will also be deleted. BUG FIXES Important fix for increasing success rate in establishing media connections Time ago we ran into a pretty ugly bug that was causing some problems during WebRTC negotiation, resulting in some clients located in complex networks (like a company's internal network) not being able to connect to OpenVidu Server. What developers perceived was that in certain scenarios some users simply couldn't receive or send any media connection. This bug has been completely solved in OpenVidu 2.6.0. Now media connections will work fine in almost every client network configuration. 2.5.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.5.0 NPM JS file 2.5.0 GitHub openvidu-server JAR 2.5.0 GitHub Docker container 2.5.0 DockerHub Docker container (+KMS) 2.5.0 DockerHub openvidu-java-client MVN package 2.5.0 MVN Repository openvidu-node-client NPM package 2.5.0 NPM openvidu-webcomponent ZIP 2.5.0 GitHub openvidu-angular NPM package 2.5.0 NPM openvidu-react NPM package 2.5.0 NPM Release Notes NEW FEATURES Kurento filters support OpenVidu API offers a simple way of applying filters to video and audio streams in the server side by making use of Kurento Media Server capabilities. See Voice and video filters section to learn more. Individual user configuration for maximum/minimum bandwidth In version 2.3.0 we introduced 4 new configuration parameters for OpenVidu Server that allow the limitation of the video bandwidth both sent and received to/from OpenVidu Server, affecting all video streams in a global manner. Now it is possible to specifically configure certain input and output bandwidth for every user connected to a session. This way you can customize the bandwidth for each Publisher and Subscriber object of each Connection object. Users with no specific configuration will use the global values. You can set custom bandwidths by using REST API , openvidu-java-client or openvidu-node-client : REST API : in POST /api/tokens append a property in the json body like this \"kurentoOptions\": { \"videoMaxRecvBandwidth\": 1000, \"videoMinRecvBandwidth\": 1000, \"videoMaxSendBandwidth\": 1000, \"videoMinSendBandwidth\": 1000 } openvidu-java-client : build your tokens like this KurentoOptions kurentoOptions = new KurentoOptions.Builder() .videoMaxRecvBandwidth(1000) .videoMinRecvBandwidth(1000) .videoMaxSendBandwidth(1000) .videoMinSendBandwidth(1000) .build(); TokenOptions tokenOptions = new TokenOptions.Builder() .data(\"User data\") .role(OpenViduRole.PUBLISHER) .kurentoOptions(kurentoOptions) .build(); String myToken = mySession.generateToken(tokenOptions); openvidu-node-client : build your tokens like this var tokenOptions = { data: \"User data\", role: OpenViduRole.PUBLISHER, kurentoOptions: { videoMaxRecvBandwidth: 1000, videoMinRecvBandwidth: 1000, videoMaxSendBandwidth: 1000, videoMinSendBandwidth: 1000 } }; mySession.generateToken(tokenOptions).then(token => { ... } ); REST API and Server SDKs improvements Connection objects have a brand new property very useful for session analysis: platform . It carries a complete description of the platform used by the client to connect to your session. For example: \"Chrome 69.0.3497.81 on OS X 10.13.6 64-bit\" or \"Firefox Mobile 62.0 on Mobile (Android 8.1.0)\" You can get this information by retrieving session information with the REST api ( GET /api/sessions or GET /api/sessions/SESSION_ID ) or inspecting openvidu-java-client and openvidu-node-client Session objects: calling Session.fetch() or OpenVidu.fetch() will update the status of their activeConnections property. Then you can check it out in openvidu-node-client (property Session.activeConnections ) or openvidu-java-client (method Session.getActiveConnections() ) Session , Connection and Publisher objects now have createdAt property, indicating when these objects where initialized in OpenVidu Server. This property has been integrated to maintain consistency with OpenVidu Server Call Detail Record, which has already been storing it in previous versions (check \"timestamp\" property of every CDR entry ). OpenVidu Browser improvements New method OpenVidu.checkScreenSharingCapabilities() . It allows developers to know if the client platform supports screen sharing (see its declaration in OpenVidu Documentation ) New OpenVidu Angular and OpenVidu React libraries We introduced OpenVidu Web Component in release 2.3.0 . Now we offer native libraries for both Angular and React (latest versions) to insert the same powerful component in your applications by making use of each framework capabilities. You can check a tutorial for OpenVidu Angular ( openvidu-library-angular ) and for OpenVidu React ( openvidu-library-react ) right now. Of course you can keep using OpenVidu Browser library instead of these components in any frontend framework. These tutorials show a basic use of OpenVidu Browser in an Angular app ( openvidu-insecure-angular ) and in a React app ( openvidu-insecure-react ). BUG FIXES Local tracks now are not stopped on stream disposal if property PublisherProperties.videoSource was of type MediaStreamTrack (custom stream got with OpenVidu.getUserMedia() ). Issue #107 , PR #108 Deprecated RTCPeerConnection.getRemoteStreams and RTCPeerConnection.getLocalStreams to RTCPeerConnection.getReceivers and RTCPeerConnection.getSenders . Issue #54 Allow full screen sharing in Firefox. Issue #103 , PR #105 Fixed duplicated camera permissions in Firefox if PublisherProperties.videoSource/audioSource are provided as MediaStreamTracks. PR #109 openvidu-node-client now rejects with Error object upon OpenVidu Server unreachable. Issue #116 , PR #117 2.4.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.4.0 NPM JS file 2.4.0 GitHub openvidu-server JAR 2.4.0 GitHub Docker container 2.4.0 DockerHub Docker container (+KMS) 2.4.0 DockerHub openvidu-java-client MVN package 2.4.0 MVN Repository openvidu-node-client NPM package 2.4.0 NPM openvidu-webcomponent ZIP 2.4.0 GitHub Release Notes NEW FEATURES OpenVidu Java Client and OpenVidu Node Client REST API support for v2.3.0 Backend clients are now compatible with REST API 2.3.0, adding methods: Session.close() : close a Session from your backend Session.forceDisconnect() : force some user to leave a Session Session.forceUnpublish() : force some user to unpublish a Publisher from a Session Session.fetch() : bring Session information from OpenVidu Server OpenVidu.fetch() : bring information from every active Session from OpenVidu Server You can call methods Session.fetch() and OpenVidu.fetch() to bring the current status of sessions from OpenVidu Server. You can consult now directly from OpenVidu Java Client / OpenVidu Node Client all the active sessions with OpenVidu.getActiveSessions() / OpenVidu.activeSessions and the active connections of a session with Session.getActiveConnections() / Session.activeConnections . OpenVidu CDR extended Event recordingStopped event now has reason property. Can be: \"recordingStoppedByServer\" : the recording was stopped by the application (using REST API, OpenVidu Java Client or OpenVidu Node Client) \"lastParticipantLeft\" : if the Session was configured for automatic recording ( RecordingMode.ALWAYS , check OpenVidu Node Client docs for more info), then it stopped because the last participant left the session \"sessionClosedByServer\" : the recording stopped because the session was forcibly closed by the application (using REST API, OpenVidu Java Client or OpenVidu Node Client) \"openviduServerStopped\" : the recording stopped because OpenVidu Server process unexpectedly stopped (cannot be guaranteed) OpenVidu WebComponent improvements Added a generic fullscreen button which will set as fullscreen element the entire component Local video toolbar shown on fullscreen User's nickname update process is now less intrusive (pop-up removed, simple text input instead) Updated every dialog: now they appear inside of the component (center position), instead of appended to DOM body The chat component is integrated in the layout for a better experience New close chat button (top right corner) New send button (bottom right corner) New avatar user in each message. A new snapshot image will be displayed with each new message BUG FIXES OpenVidu Server dashboard test could sometimes fail because of a misuse of TURN server OpenVidu Java Client: pending requests bug fixed Remote Stream status properties are now properly updated when calling Session.publish , Session.unpublish and Session.publish for the same Publisher object (having unpublished audio or video in between the calls) 2.3.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.3.0 NPM JS file 2.3.0 GitHub openvidu-server JAR 2.3.0 GitHub Docker container 2.3.0 DockerHub Docker container (+KMS) 2.3.0 DockerHub openvidu-java-client MVN package 2.2.0 MVN Repository openvidu-node-client NPM package 2.2.0 NPM medium openvidu-webcomponent ZIP 2.3.0 GitHub Release Notes OPENVIDU WEB COMPONENT OpenVidu platform now offers an easier way to get started: just include our new Web Component into your web and start enjoying video call capabilities with just 3 new lines of code: Add to your index.html OpenVidu Web Component files: <link rel=\"stylesheet\" href=\"openvidu-webcomponent.css\" /> <script src=\"openvidu-webcomponent.js\"></script> And add your video-call element wherever you want in your application: <openvidu-webcomponent session-config='{\"user\":\"NICKNAME\", \"token\":\"TOKEN\"}' theme=\"dark\"></openvidu-webcomponent> Being NICKNAME the user's name during the call and TOKEN one token generated in OpenVidu Server. Of course, if you want to connect users to the same session, the tokens should be generated for the same session. Attribute theme can be dark or light . Use the one that better fits your application. OpenVidu Web Component supports a reasonable amount of different dimensions, and every video displayed inside of it will be automatically relocated and resized for its optimal position upon window resizing. You can set the position, width and height of the component by styling it like this: Setting its property position to absolute or fixed , depending on your web layout and the desired behavior you want the component to have. Playing with values: width height top or bottom right or left For example, the following CSS rule would position the upper OpenVidu Web Component in the bottom-right corner of your web, taking up half of the height of the page and a third of its width. openvidu-webcomponent { position: absolute; bottom: 0; right: 0; width: 33vw; height: 50vh; } If you give enough width to the component (at least 700px ), users can communicate through an integrated chat. To see some images of OpenVidu Web Component in action, check this post on Medium . If you want to learn more about OpenVidu Web Component, visit Tutorials section NEW FEATURES StreamPropertyChangedEvent (See here ) OpenVidu Browser now lets users connected to a Session know when any Stream they are subscribed to undergoes any possible change in its properties. Every Session object will dispatch this new event (you can subscribe to it to every Publisher or Subscriber object too). This event can refer to the following Stream properties: Stream.audioActive : this property may change if the user publishing the Stream calls Publisher.pusblishAudio(bool) . Stream.videoActive : this property may change if the user publishing the Stream calls Publisher.publishVideo(bool) . Stream.videoDimensions : this property may change if... ...the user publishing the stream is screen-sharing and the shared window changes its dimensions. ...the user is publishing from a mobile device and it is rotated (every camera from a phone will invert the resolution in the output video when rotated). So, for example, now you can do: var OV = new OpenVidu(); var session = OV.initSession(); session.on('streamPropertyChanged', event => { if (event.changedProperty === 'audioActive') { console.log('The state of the audio of the publisher has changed. Is enabled? -> ' + event.newValue); } else if (event.changedProperty === 'videoActive') { console.log('The state of the video of the publisher has changed. Is enabled? -> ' + event.newValue); } else if (event.changedProperty === 'videoDimensions') { console.log('The video dimensions of the publisher has changed. New dimensions: ' + event.newValue); } }); This way you can react more easily upon this variations in the published streams and update your application's layout accordingly. Session.capabilities (See here ) You can check capabilities property of Session object to know which methods are able to invoke each one of your clients, depending on their role. Also, if a client tries to call a method for which he has no permissions, now an OpenViduError is thrown with property name being OPENVIDU_PERMISSION_DENIED . New MODERATOR role At last developers have available the new role that has been in our roadmap for a long time. Users connecting to a session with a token configured with MODERATOR role can call every method granted for SUBSCRIBER and PUBLISHER roles, but also: Session.forceDisconnect : you can evict any user from the Session (force the method Session.disconnect ) Session.forceUnpublish : you can stop the Publisher of any user publishing in the Session (force the method Session.unpublish ) REST API extended 5 new methods join the REST API of OpenVidu Server : Retrieve active session info: GET /api/sessions/<SESSION_ID> Retrieve all active sessions info: GET /api/sessions Close a session: DELETE /api/sessions/<SESSION_ID> Force the disconnection of a user from a session: DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> Force the unpublishing of a user's stream from a session: DELETE /api/sessions/<SESSION_ID>/stream/<STREAM_ID> Future iterations will add this capabilities to openvidu-java-client and openvidu-node-client libraries Configure global bandwidth for your WebRTC connections We have included a first way to set the maximum and minimum bandwidths for the media connections established between browsers and OpenVidu Server. You can configure it with the following system properties, as stated in OpenVidu Server configuration sections: openvidu.streams.video.max-recv-bandwidth : Maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained (default 1000) openvidu.streams.video.min-recv-bandwidth : Minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained (default 300) openvidu.streams.video.max-send-bandwidth : Maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained (default 1000) openvidu.streams.video.min-send-bandwidth : Minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained (default 300) Future iterations will study the possibility of configuring this same parameters for each session individually or even for each incoming or outgoing WebRTC connection (maybe as part of PublisherProperties or SubscriberProperties ) 2.2.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.2.0 NPM JS file 2.2.0 GitHub openvidu-server JAR 2.2.0 GitHub Docker container 2.2.0 DockerHub Docker container (+KMS) 2.2.0 DockerHub openvidu-java-client MVN package 2.2.0 MVN Repository openvidu-node-client NPM package 2.2.0 NPM Release Notes OpenVidu now offers integrated and automated support for TURN server . We encourage developers to check out our post on Medium to learn more about it. The platform now integrates by default a COTURN server as part of its ecosystem. This means that media connections will work OK even when clients are located on restricted networks. When deploying OpenVidu Server in Amazon Web Services with our Cloud Formation template no changes are required at all. If you are deploying OpenVidu Server on your own in an Ubuntu machine, installation instructions have changed a little bit. You have them properly updated here . 2.1.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.1.0 NPM JS file 2.1.0 GitHub openvidu-server JAR 2.1.0 GitHub Docker container 2.1.0 DockerHub Docker container (+KMS) 2.1.0 DockerHub openvidu-java-client MVN package 2.0.0 MVN Repository openvidu-node-client NPM package 2.0.0 NPM Release Notes NEW FEATURES OpenVidu Browser support for video management We have implemented a new class in OpenVidu Browser aimed to better support declarative frontend frameworks such as Angular, React or Vue.js. Now Publisher and Subscriber objects both inherit from StreamManager , which provides 2 different methods to tell OpenVidu what DOM video players should display each specific stream ( addVideoElement and createVideoElement ). This allows us to let OpenVidu take control of the video elements (even if our framework dynamically creates them) and do not worry about its internals. This is all explained in detail in Manage video players section. If you want to check out a real example of this behavior, explore our renovated OpenVidu Angular tutorial . 2.0.0 Artifacts Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.0.0 NPM JS file 2.0.0 GitHub openvidu-server JAR 2.0.0 GitHub Docker container 2.0.0 DockerHub Docker container (+KMS) 2.0.0 DockerHub openvidu-java-client MVN package 2.0.0 MVN Repository openvidu-node-client NPM package 2.0.0 NPM Release Notes This is the first breaking change update for OpenVidu, which brings in lots of new features and internal improvements. NEW FEATURES OpenVidu Browser new methods Session.publish() : now returns a Promise so you can tell if the method was successful or not. Session.signal() : now returns a Promise so you can tell if the method was successful or not. Subcriber.subscribeToAudio() and Subscriber.subscribeToVideo() : new methods that allows you to mute the audio or video tracks of a remote stream. OpenVidu.initPublisher() : now expects properties as interface PublisherProperties . They include: { audioSource: undefined, // The source of audio. If undefined default audio input videoSource: undefined, // The source of video. If undefined default video input publishAudio: true, // Whether you want to start publishing with your audio unmuted or muted publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video will be inserted in the target element mirror: false // Whether to mirror your local video or not } Session.subscribe() : now expects properties as interface SubscriberProperties . They include: { insertMode: 'APPEND', // How the video will be inserted in the target element subscribeToAudio: true, // Whether to initially subscribe to the stream's audio track or not subscribeToVideo: true // Whether to initially subscribe to the stream's video track or not } OpenVidu.getDevices() : now you can use certain video or audio input device when calling OpenVidu.initPublisher() , thanks to properties audioSource or videoSource of PublisherProperties object. Just set these variables to the property deviceId of any of the devices returned by this method. OpenVidu.getUserMedia() : method improved. Now devs can customize a MediaStream object before calling OpenVidu.initPublisher() method, setting property audioSource or videoSource to a MediaStreamTrack object (see docs for further information) OpenVidu Browser new properties Stream.frameRate : new property defining the frame rate of video streams. This property will only have value if the Publisher owning the stream has set property frameRate of PublisherProperties when calling OpenVidu.initPublisher() OpenVidu Browser events New events accessDialogOpened and accessDialogClosed : dispatched by Publisher objects when the browser asks the user to grant permissions to camera or michrophone by opening a pop-up. You can use them to warn your users about it. New events recordingStarted and recordingStopped : dispatched by Session object when the recording of a Session starts and stops. You can customize which clients will receive this event thanks to new property openvidu.recording.notification (see OpenVidu Server configuration ) Events publisherStartSpeaking and publisherStopSpeaking improved: more customizable thanks to OpenVidu.setAdvancedConfiguration() and better overall performance. Events streamDestroyed , connectionDestroyed and sessionDisconnected have new property reason . This gives more information about why the events have been dispatched so you can take specific actions depending on the context: maybe a stream has been destroyed because the user publishing has deliberately diposed it or maybe the network connection has unexpectedly closed (see docs for StreamEvent , ConnectionEvent and SessionDisconnectedEvent ) Other improvements in OpenVidu Browser Support for custom screen sharing extensions for Chrome Support for custom STUN and TURN servers in openvidu-browser. Use OpenVidu.setAdvancedConfiguration() Library size decreased in almost 30% ( openvidu-browser.min.js from 300 KB to 216 KB) OpenVidu Server new features New property name for recordings: you can now specify which name should OpenVidu Server give to each one of your recording files. You can do it by using the REST API (by setting body parameter \"name\" in POST /api/recordings/start ), openvidu-java-client (by using RecordingProperties.Builder.name() ) or openvidu-node-client (by setting property RecordingProperties.name ) Now support for initializing sessions with a custom sessionId . You can take advantage of this new property to facilitate the mapping between OpenVidu Server 'session' entities and your own 'session' entities. You can set it by using the REST API (by setting body parameter \"customSessionId\" in POST /api/sessions ), openvidu-java-client (by using SessionProperties.Builder.customSessionId() ) or openvidu-node-client (by setting property SessionProperties.customSessionId ) Call Detail Record extended: new events recordingStarted and recordingStopped , property reason for events sessionDestroyed , participantLeft and webrtcConnectionDestroyed . BUG FIXES Now when any participant unexpectedly disconnects from a session (for example, due to a network failure), connectionDestroyed event is sent to the rest of participants with property reason set to networkDisconnect . When OpenVidu Server is stopped, it will try to gracefully finish every in progress session and recording. This way no recording file will end corrupted upon OpenVidu Server termination (this cannot be granted if the process crashes or is forcibly terminated) Now both STUN and TURN OpenVidu Server configuration parameters can be set up at the same time with no overwritings. Tons of small fixes and code refactoring that makes OpenVidu more stable and easy to test and develop BREAKING CHANGES OpenVidu Browser OpenVidu.initSession now doesn't receive any input parameter. OpenVidu.initPublisher input parameters have changed. Now properties parameter must match PublisherProperties interface. Session.connect method has been promisified. Change the last mandatory callback parameter for a Promise implementation: session.connect(token, (error) => { ... }) to session.connect(token).then(() => {...}).catch(error => {...}); OpenVidu Java Client All Archive entities are now called Recording . This includes: class Archive to Recording , class ArchiveMode to RecordingMode , class ArchiveLayout to RecordingLayout , method SessionProperties.archiveLayout() to SessionProperties.recordingLayout() , method SessionProperties.archiveMode() to SessionProperties.recordingMode() , method SessionProperties.Builder.archiveLayout() to SessionProperties.Builder.recordingLayout() , method SessionProperties.Builder.archiveMode() to SessionProperties.Builder.recordingMode() RecordingLayout property in SessionProperties.Builder is now configured calling method defaultRecordingLayout() instead of recordingLayout() . This means that if one Session is gonna be recorded more than once, each recording layout may be customize with RecordingProperties.Builder.recordingLayout() , which will overwrite the default one globally configured in SessionProperties object. OpenVidu Node Client We have removed the builder pattern in all openvidu-node-client classes. Now objects are used instead, which includes classes TokenOptions , SessionProperties and RecordingProperties . For example, instead of getting a TokenOptions object like this: var tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build() now it must be like this: var tokenOptions = {data: serverData, role: role} There has been a simple change in certain asynchronous call. Method Session.getSessionId() is now synchronous, but method OpenVidu.createSession() is now asynchronous (the reason is pretty simple: now method createSession implements the behavior that getSessionId was providing the first time it was called for certain Session object). All callback methods have been promisified. This includes method Session.generateToken(tokenOptions?, callback): void (now Session.generateToken(tokenOptions?): Promise<string> ) and method Session.getSessionId(callback): void (now OpenVidu.createSession(): Promise<Session> , take also into account that the async call has changed from one method to the other as stated in the previous point). All Archive entities are now called Recording . This includes: object Archive to Recording , object ArchiveMode to RecordingMode , object ArchiveLayout to RecordingLayout , method SessionProperties.archiveLayout() to SessionProperties.recordingLayout() , method SessionProperties.archiveMode() to SessionProperties.recordingMode() , method SessionProperties.Builder.archiveLayout() to SessionProperties.Builder.recordingLayout() , method SessionProperties.Builder.archiveMode() to SessionProperties.Builder.recordingMode() recordingLayout property in SessionProperties has changed to defaultRecordingLayout . This means that if one Session is gonna be recorded more than once, each recording layout may be customize with recordingLayout property (of RecordingProperties interface, which will overwrite the default one globally configured in SessionProperties object. REST API All Archive entities are now called Recording in API REST. For example: {\"archiveMode\": \"ARCHIVE_MODE\", \"archiveLayout\": \"ARCHIVE_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"} now is {\"recordingMode\": \"RECORDING_MODE\", \"recordingLayout\": \"RECORDING_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"} . Field recordingLayout is now called defaultRecordingLayout in operation POST /api/sessions . This means that if one Session is gonna be recorded more than once, each recording layout may be customize adding a new field recordingLayout in the call to POST /api/recordings/start of the API REST, which will overwrite the default one globally configured during POST /api/sessions Other breaking changes OpenVidu Server default port from 8443 to 4443 OpenVidu Server configuration property openvidu.recording.free-access is now openvidu.recording.public-access 1.9.0-beta-1 Artifacts Artifact Type Compatible version Link Info openvidu-browser NPM package 1.9.0-beta-1 NPM JS file 1.9.0-beta-1 GitHub openvidu-server JAR 1.9.0-beta-1 GitHub Docker container 1.9.0-beta-1 DockerHub Docker container (+KMS) 1.9.0-beta-1 DockerHub openvidu-java-client MVN package 1.8.0 MVN Repository openvidu-node-client NPM package 1.8.0 NPM Release Notes Safari support : now OpenVidu is compatible with the most recent versions of Safari in Mac and iOS. It is necessary to use Kurento Media Server 6.7.0: openvidu/openvidu-server-kms:1.9.0-beta-1 Docker image already incorporates KMS 6.7.0 openvidu/openvidu-server:1.9.0-beta-1 Docker image and openvidu-server-1.9.0-beta-1.jar need KMS 6.7.0. To install it, first be sure to completely uninstall and clean any previous version of KMS and then: # In first command: xenial for Ubuntu 16.04, trusty for Ubuntu 14.04 sudo echo \"deb http://ubuntu.openvidu.io/6.7.0 xenial kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y dist-upgrade sudo apt-get -y install kurento-media-server sudo apt-get -y install openh264-gst-plugins-bad-1.5 To start and stop KMS 6.7.0: sudo service kurento-media-server start sudo service kurento-media-server stop","title":"Releases"},{"location":"releases/#2120","text":"","title":"2.12.0"},{"location":"releases/#artifacts","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.12.0 NPM JS file 2.12.0 GitHub openvidu-server JAR 2.12.0 GitHub Docker container 2.12.0 DockerHub Docker container (+KMS) 2.12.0 DockerHub openvidu-java-client MVN package 2.12.1 MVN Repository openvidu-node-client NPM package 2.12.0 NPM openvidu-webcomponent ZIP 2.12.0 GitHub openvidu-angular NPM package 2.12.0 NPM openvidu-react NPM package 2.12.0 NPM Kurento Media Server Ubuntu package 6.13.0 Kurento Docs","title":"Artifacts"},{"location":"releases/#release-notes","text":"","title":"Release Notes"},{"location":"releases/#new-features-in-openvidu-ce","text":"","title":"NEW FEATURES IN OPENVIDU CE"},{"location":"releases/#ip-cameras-support","text":"You can now publish IP cameras into an OpenVidu Session!. You users will be able to receive it as they receive any other regular webcam stream. With this new feature you can for example implement surveillance systems in the blink of an eye. How about receiving your IP camera video in your mobile app? And what about building a web dashboard where you can observe all of your security cameras footage in real-time? So many possibilities\u2026 You can check out IP cameras section of OpenVidu official documentation to learn more","title":"IP cameras\u00a0support"},{"location":"releases/#send-signals-from-your-backend","text":"You are now able to send messages to the participants of an OpenVidu Session from your application\u2019s backend with method POST /api/signal . This feature brings the power of client side messaging to your server side.","title":"Send signals from your backend"},{"location":"releases/#record-your-webapp-with-composite-layout","text":"You can now use custom recording layouts deployed outside of OpenVidu Server host. Before it was mandatory to build an HTML/CSS layout and upload it to OpenVidu Server host before you could use it as a custom recording layout. But now you can record any webpage hosted anywhere. More information here .","title":"Record your webapp with COMPOSITE layout"},{"location":"releases/#new-cdrwebhook-event-filtereventdispatched","text":"You can now register filterEventDispatched events in OpenVidu CDR and OpenVidu Webhook services. This way you can know when a voice or video filter has emitted an event from your application\u2019s server side (once you add an event listener to a filter).","title":"New CDR/Webhook event filterEventDispatched"},{"location":"releases/#new-data-in-cdrwebhook-event-participantjoined-and-participantleft","text":"Both participantJoined and participantLeft CDR/Webhook events include now clientData and serverData properties. This allows you to better identify your users from your application\u2019s server side.","title":"New data in CDR/Webhook event participantJoined and participantLeft"},{"location":"releases/#automatic-reconnection-when-connection-is-lost","text":"Now your clients can listen to brand new reconnection events triggered by Session object: reconnecting and reconnected events. reconnecting event is triggered when a client connected to a Session loses its network connection with OpenVidu. Automatically openvidu-browser tries to reconnect to the Session with an endless polling. Once the client recovers its network connection, openvidu-browser will automatically try to reset the user state in the session. If it is too late and OpenVidu has already evicted the user due to inactivity, then a SessionDisconnectedEvent with reason networkDisconnect will be triggered. If the user reconnected on time, everything\u2019s back to normal, event reconnected will be dispatched by the Session object and media connections will be automatically re-established if necessary (see Media freeze bug in BUG FIXES). You can check out Automatic reconnection section of OpenVidu official documentation to learn more","title":"Automatic reconnection when connection is lost"},{"location":"releases/#switch-from-camera-to-screenshare-instantly","text":"You can use new Publisher.replaceTrack() method available in openvidu-browser to change the audio or video tracks of a Publisher object on the fly, without unpublishing and re-publishing again (so, no need of WebRTC renegotiation!). This also helps changing the video track (front camera for back camera, webcam for screenshare\u2026) keeping your audio connection at all times. You can check out Switch camera section of OpenVidu official documentation to learn more","title":"Switch from camera to screenshare instantly"},{"location":"releases/#change-publisherspeakingevents-configuration-on-the-fly-in-your-clients","text":"New method StreamManager.updatePublisherSpeakingEventsOptions() allows you to dynamically change the threshold for audio events in openvidu-browser. Affected events are publisherStartSpeaking , publisherStopSpeaking and streamAudioVolumeChange . This way you can adjust in real time the limits and frequency of audio stream polling in the browser to make better use of these events.","title":"Change publisherSpeakingEvents configuration on the fly in your clients"},{"location":"releases/#all-the-goodnes-from-kurento-6120-and-6130-releases","text":"OpenVidu 2.12.0 is now using the latest 6.13.0 version of Kurento . There are lots of improvements in both Kurento 6.12.0 and 6.13.0, including some several critical bug fixes. You can take a look to all of them here: Kurento 6.12.0 Release Notes Kurento 6.13.0 Release Notes","title":"All the goodnes from Kurento 6.12.0 and 6.13.0 releases"},{"location":"releases/#new-features-in-openvidu-pro","text":"","title":"NEW FEATURES IN OPENVIDU PRO"},{"location":"releases/#new-payment-method","text":"This is possibly the biggest change for this release. The number of customers of our OpenVidu Pro tier has increased considerably in recent times, and we needed to facilitate the process of subscribing to OpenVidu Pro. We have introduced a new license key system for deploying OpenVidu Pro. Now anyone can create an OpenVidu account , and in just a few clicks you will be able to purchase an OpenVidu Pro license to launch as many OpenVidu Pro clusters as you want. Visit Pricing section to learn more about the new OpenVidu Pro subscription model. You have a 15-day free trial period when registering as an OpenVidu user!","title":"New payment method"},{"location":"releases/#simplified-pricing","text":"Related to previous point, we have now removed the minimum 10$ per month fee and users receive a 15-day free trial period when they register as OpenVidu users . Check it out now for free!","title":"Simplified pricing"},{"location":"releases/#dynamic-scalability","text":"OpenVidu Pro 2.11.0 allowed you to initialize your OpenVidu Pro cluster with a fixed number of Media Nodes. Now you can add and remove as many Media Nodes as you want on the fly from OpenVidu Inspector or through OpenVidu Pro REST API . Visit Scalability section to learn more.","title":"Dynamic scalability"},{"location":"releases/#openvidu-inspector-big-upgrade","text":"OpenVidu Inspector has undergone a major upgrade to support the new clustering features of OpenVidu Pro 2.12.0. You can now manage your cluster directly from OpenVidu Inspector. Besides, it is now built with Angular 9, which makes it even more efficient and less heavy!","title":"OpenVidu Inspector big upgrade"},{"location":"releases/#detailed-session-monitoring-improved","text":"OpenVidu Pro is now using the latest Elasticsearch and Kibana version . And every new event and important piece of information generated by 2.12.0 is of course stored and processed for later use. Visit Detailed session monitoring section to learn more.","title":"Detailed session monitoring improved"},{"location":"releases/#bug-fixes","text":"Media freeze bug : media connections are now automatically re-negotiated under the hood if they remain freezed after a user is successfully reconnected following a network failure. This happens when a user loses its Internet connection and manages to reconnect to OpenVidu before it was automatically evicted from the Session, but its media streams are broken. This is so because media connections flow through their own plane, separated from Client-OpenViduServer signaling plane. openvidu-server : race condition fixed for same final user establishing more than one connection to a session at the same time. This might be related to some sessions getting stuck even when no participants are connected to it. openvidu-server : concurrency problems when closing a session being recorded in COMPOSED video mode (fix for issue 364 ). Other possible concurrency problems of the same nature have also been addressed, so stability of OpenVidu Server should have improved for these kind of corner cases. openvidu-server : configuration parameter openvidu.recording.public-access could not take effect when set to false. Now it always does. openvidu-browser : LocalRecorder was broken for recent versions of Firefox. Now LocalRecorder.record() method has an optional string parameter to indicate the desired mimeType . If none is provided, then default browser codecs wil be used to record media streams in the browser. openvidu-browser : method OpenVidu.getUserMedia() was broken when requesting screen sharing. Now it works just fine. openvidu-browser : setting a listener for streamAudioVolumeChange event just after initializing a Publisher or Subscriber object could trigger an Exception. Now it doesn\u2019t. openvidu-browser : Session.signal() wrong to array now does not trigger a fatal error. openvidu-node-client : OpenVidu entrypoint object would throw an error if initialized with a URL with no port. Now you can use your openvidu-server domain name without a port (default 443) to initialized it. OpenVidu Inspector : thumbnails of recording files were sometimes asking for the secret in order to be loaded. Now they don\u2019t.","title":"BUG FIXES"},{"location":"releases/#2110","text":"","title":"2.11.0"},{"location":"releases/#artifacts_1","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.11.0 NPM JS file 2.11.0 GitHub openvidu-server JAR 2.11.0 GitHub Docker container 2.11.0 DockerHub Docker container (+KMS) 2.11.0 DockerHub openvidu-java-client MVN package 2.11.0 MVN Repository openvidu-node-client NPM package 2.11.0 NPM openvidu-webcomponent ZIP 2.11.0 GitHub openvidu-angular NPM package 2.11.0 NPM openvidu-react NPM package 2.11.0 NPM Kurento Media Server Ubuntu package 6.11.0 Kurento Docs","title":"Artifacts"},{"location":"releases/#release-notes_1","text":"","title":"Release Notes"},{"location":"releases/#new-features-in-openvidu-community","text":"","title":"NEW FEATURES IN OPENVIDU COMMUNITY"},{"location":"releases/#openvidu-webhook-service","text":"You are now able to receive OpenVidu events in your application server by using the brand new Webhook service. This is a feature that has been requested for a long time, and you can start using it right now. You have all the information in the official documentation: OpenVidu Server Webhook","title":"OpenVidu Webhook\u00a0service"},{"location":"releases/#externalizing-configuration-of-openvidu-server","text":"Are you tired of having to write all the configuration parameters in openvidu-server launch command? Well, now you can externalize all your configuration into a separate file. You just need to use property spring.config.additional-location like this: java -Dspring.config.additional-location=/path/to/application.properties -jar openvidu-server.jar Then all configuration parameters listed in that file will be used. You have all the information in the official documentation: Externalizing configuration","title":"Externalizing configuration of OpenVidu\u00a0Server"},{"location":"releases/#new-features-in-openvidu-pro_1","text":"","title":"NEW FEATURES IN OPENVIDU PRO"},{"location":"releases/#first-version-of-scalability","text":"Finally OpenVidu brings the possibility of deploying a cluster with multiple Media Nodes. OpenVidu Pro will distribute your sessions among all available Media Nodes based on their current load. Take a look to the official OpenVidu Pro tier documentation to learn more: Scalability","title":"First version of scalability"},{"location":"releases/#persistent-configuration-when-restarting-openvidu-server-pro","text":"Whenever you restart OpenVidu Server Pro by using the REST API , the new parameters you provide will be saved to disk. This way you will be able to stop the service or even the host without losing the last configuration you provided when restarting OpenVidu Server Pro through REST API.","title":"Persistent configuration when restarting OpenVidu Server\u00a0Pro"},{"location":"releases/#bug-fixes_1","text":"openvidu-browser : when sharing the entire screen in Electron, no Publisher was being initalized. Now it does. openvidu-browser : mobile devices where sending a streamPropertyChanged event when rotating the phone even when the Publisher wasn't being published to the session (error on the websocket connection). Now they don't. openvidu-server : when KMS crashed and was rebooted, sometimes the first user republishing a Stream would get an error. Now it doesn't. openvidu-pro : restarting OpenVidu Pro from Inspector and enabling CDR failed. Now it doesn't. openvidu-pro : Kibana failed returning documents before running a session. Now it doesn't. openvidu-pro : Inspector loggin process may failed when connecting through Firefox. Now it doesn't.","title":"BUG FIXES"},{"location":"releases/#other-noteworthy-changes","text":"Although this is not a visible feature for OpenVidu final users, we would like to mention that we have updated OpenVidu Server to Spring Boot 2 . OpenVidu Server core has been based on Spring Boot 1 since the beginning of the project, but we decided to invest some time to upgrade it to the latest stable version to take advantage of its many new improvements. This should translate in better performance, stability and security.","title":"OTHER NOTEWORTHY CHANGES"},{"location":"releases/#breaking-changes","text":"OpenVidu CDR events recordingStarted and recordingStopped are now deprecated in favour of recordingStatusChanged event. Check this new event here . Besides, event recordingStopped now won't provide the final values of the recording (specifically its duration and size properties, that will be 0). You will have to listen to recordingStatusChanged with status ready to get them.","title":"BREAKING CHANGES"},{"location":"releases/#2100","text":"","title":"2.10.0"},{"location":"releases/#artifacts_2","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.10.0 NPM JS file 2.10.0 GitHub openvidu-server JAR 2.10.0 GitHub Docker container 2.10.0 DockerHub Docker container (+KMS) 2.10.0 DockerHub openvidu-java-client MVN package 2.10.0 MVN Repository openvidu-node-client NPM package 2.10.0 NPM openvidu-webcomponent ZIP 2.10.0 GitHub openvidu-angular NPM package 2.10.0 NPM openvidu-react NPM package 2.10.0 NPM Kurento Media Server Ubuntu package 6.10.0 Kurento Docs","title":"Artifacts"},{"location":"releases/#release-notes_2","text":"","title":"Release Notes"},{"location":"releases/#new-features","text":"This release brings support to more and more clients, so you can expand your OpenVidu client-side range. Of course, they are all compatible with each other and with every other platform already supported.","title":"NEW FEATURES"},{"location":"releases/#electron-support","text":"OpenVidu has supported most popular browsers since its inception, and past releases brought official support to Android and iOS through Ionic . But there was still a gap regarding desktop applications. With 2.10.0 we are happy to announce that you are now able to implement your Windows, OSX and Linux native app with OpenVidu through Electron. What is Electron? It is great framework for building native desktop applications with classic web technologies (simple, good old HTML, CSS and JS). Electron is to desktop operating systems what Ionic is to mobile operating systems. Some examples of great applications built with Electron are Slack, Skype, Atom or Visual Studio Code Using Electron means that the same codebase you are already using for your web and mobile application can be used to build a desktop app that will work on Windows, OSX and Linux. Take a look to our brand new openvidu-electron tutorial, and you will have a desktop OpenVidu app working in minutes. It even brings screen-sharing!","title":"Electron support"},{"location":"releases/#react-native-support","text":"You\u2019re not convinced by Ionic? Now you can choose React Native framework for developing your OpenVidu mobile app. React Native is rather similar to Ionic from the developers perspective, but at the same time its nature is very different. Essentially, it really uses native Android and iOS UI components under the hood while Ionic is based on WebView (in a nutshell, it runs on the browser). React Native support is not part of the open source stack of OpenVidu platform. Please, contact us through Commercial page to ask for React Native support. You can then use openvidu-react-native tutorial to quickly get started","title":"React Native support"},{"location":"releases/#internet-explorer-support","text":"Yes, it\u2019s 2019. But there\u2019s still a lot of companies out there that provide/require IE support and need videoconferencing systems to work in this browser relic. So that\u2019s why we have brought OpenVidu support to IE through Temasys plugin. Only IE 11 is supported (going further back was too much of a pain). Internet Explorer support is not part of the open source stack of OpenVidu platform. Please, contact us through Commercial page to ask for React Native support. You can then use openvidu-internet-explorer tutorial to quickly get started","title":"Internet Explorer support"},{"location":"releases/#bug-fixes_2","text":"openvidu-angular and openvidu-webcomponent were failing when screen sharing. Now they don\u2019t. openvidu-browser : screen-sharing streams are not mirrored in the local videos now by default. openvidu-browser : event streamPlaying was being triggered anormally when calling StreamManager.addVideoElement method. Now it doesn\u2019t. openvidu-node-client and openvidu-java-client : removed static methods and properties from OpenVidu object. Now it is possible to keep a collection of OpenVidu objects from same Node or Java app by using SDK clients, which allows to manage multiple OpenVidu Servers from the same application. openvidu-browser now checks version compatibility with openvidu-server. If version numbers are not equal, an error will be printed in the browser\u2019s console when calling Session.connect method, so developers know they must use same version number on both sides. This gives devs very useful information about a very common mistake that usually leads to bugs that can be very difficult to trace but have a really simple solution, which is simply upgrading openvidu-browser library version. This new verification is not really a bug fix, but for sure will help avoiding future bugs.","title":"BUG FIXES"},{"location":"releases/#290","text":"","title":"2.9.0"},{"location":"releases/#artifacts_3","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.9.0 NPM JS file 2.9.0 GitHub openvidu-server JAR 2.9.0 GitHub Docker container 2.9.0 DockerHub Docker container (+KMS) 2.9.0 DockerHub openvidu-java-client MVN package 2.9.0 MVN Repository openvidu-node-client NPM package 2.9.0 NPM openvidu-webcomponent ZIP 2.9.0 GitHub openvidu-angular NPM package 2.9.0 NPM openvidu-react NPM package 2.9.0 NPM Kurento Media Server Ubuntu package 6.10.0 Kurento Docs","title":"Artifacts"},{"location":"releases/#release-notes_3","text":"","title":"Release Notes"},{"location":"releases/#new-features_1","text":"","title":"NEW FEATURES"},{"location":"releases/#ubuntu-1804-bionic-support","text":"Our team has released Kurento 6.10.0 , which can now be installed in Ubuntu 18.04 systems. This is a milestone we've been working on for quite some time, and we finally believe we're ready to launch official support for the newest Ubuntu LTS version. Deployment section in OpenVidu Docs is properly updated to inform about this. We still consider Ubuntu Bionic to be in a preliminary support state, and some bugs may appear. In fact, we know for sure there's one limitation: no OpenCV filters will work in Ubuntu 18.04 at this moment. OpenVidu has supported audio and video filters for a long time now, and it is a cool feature that allows developers to implement some advanced audio and video real-time processing in the server side. But unfortunately Kurento has not been updated yet to support it in Bionic, so no FaceOverlayFilter or ChromaFilter will work in new Ubuntu version. But you can still use GStreamer filters !","title":"Ubuntu 18.04 bionic\u00a0support"},{"location":"releases/#openvidu-server-boot-process-greatly-improved","text":"OpenVidu Server now checks all requiered conditions at boot time, which helps solving missconfiguration problems when deploying on Ubuntu . This includes every requirement related to permissions and installed software. If something is missing, wrong or there are not enough permissions in certain path, the OpenVidu Server process immediately exits with a clear description about what happened and a possible solution to fix it. In our experience, this makes the process of installing OpenVidu Server directly in Ubuntu so much easier and manageable.","title":"OpenVidu Server boot process greatly\u00a0improved"},{"location":"releases/#openvidu-reconnection-to-kurento-media-server","text":"If OpenVidu Server loses its connection to Kurento Media Server, now it will try to reconnect automatically. When it does so, if it is a new instance of Kurento, every stream of every previously active session will be destroyed with reason mediaServerDisconnect and every active recording will be stopped with same reason, but your users will not be disconnected from your sessions. This way you can directly re-publish and re-subscribe any desired stream right away. This may help in case Kurento crashes: your users will have lost their media connections, but they will still be connected to their OpenVidu sessions and will only have to re-establish streams once OpenVidu Server is connected to a new Kurento instance.","title":"OpenVidu reconnection to Kurento Media\u00a0Server"},{"location":"releases/#openvidu-upgrade-process","text":"Do you want to upgrade your OpenVidu deployment? Now you have a section entirely dedicated to it in the documentation . If you have deployed OpenVidu in AWS, it's as easy as launching a single command. If you have chosen Ubuntu deployment, then you will have to manually run some commands. Either way, you have available proper instructions now.","title":"OpenVidu upgrade\u00a0process"},{"location":"releases/#native-screen-sharing-for-chrome","text":"OpenVidu has supported native screen-sharing for Firefox since its inception, but Google decided to have Chrome require an extension to allow screen-sharing. Finally they changed their mind and brought Chrome up to the standard, supporting getDisplayMedia API. So, our client library openvidu-browser now supports native screen-sharing for Chrome\u226572. No extension needed for these browsers!","title":"Native screen-sharing for\u00a0Chrome"},{"location":"releases/#openvidu-call-improvements","text":"Our best demo application has been updated with some exciting new features: Users can now share their webcam and their screen at the same time. The chat is better integrated now. You can enlarge as many videos as you want, not just one. Available space will be automatically managed by the application for best fit. Preview window for camera and mic selection has undergone many necessary fixes. Now it works fine in every OS and client supported by OpenVidu. openvidu-call-ionic (Ionic version of OpenVidu Call for mobile devices) now supports Ionic 4 and works fine in iOS.ready to","title":"OpenVidu Call improvements"},{"location":"releases/#bug-fixes_3","text":"For COMPOSED recording with video, when multiple screen sharing streams were being published it crashed. Now it doesn't. For COMPOSED recordings with video, when stopping them immediatley after started, sometimes the generated video file would not be playable. Now in this cases failed status is set to this recordings, so you can take care of them properly. After manually stopping ALWAYS recordings (sessions that are automatically recorded once first publisher starts) in an ongoing session, now publishing a stream when no publishers are active in the session won't start automatically a new recording. Active sessions retrieval now returns sessions created with REST API or server SDKs that have not received any client connection (before this fix they would not be returned until some user had connected to it) Call Detail Record : recordingStopped event for INDIVIDUAL recordings wasn't updating their duration and size values (both properties had value 0) streamPropertyChanged event was firing an exception in the browser for streams for which a user wasn't subscribed to. Avoid 500 error when sending no body on POST operations of the REST API, such as POST /api/sessions Minor bug fixes in openvidu-java-client.","title":"BUG FIXES"},{"location":"releases/#openvidu-pro","text":"We are excited to announce OpenVidu Pro: a commercial tier for OpenVidu platform. Check it out here .","title":"OPENVIDU PRO"},{"location":"releases/#280","text":"","title":"2.8.0"},{"location":"releases/#artifacts_4","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.8.0 NPM JS file 2.8.0 GitHub openvidu-server JAR 2.8.0 GitHub Docker container 2.8.0 DockerHub Docker container (+KMS) 2.8.0 DockerHub openvidu-java-client MVN package 2.8.1 MVN Repository openvidu-node-client NPM package 2.8.0 NPM openvidu-webcomponent ZIP 2.8.0 GitHub openvidu-angular NPM package 2.8.0 NPM openvidu-react NPM package 2.8.0 NPM Kurento Media Server Ubuntu package 6.9.0 Kurento Docs","title":"Artifacts"},{"location":"releases/#release-notes_4","text":"","title":"Release Notes"},{"location":"releases/#new-features_2","text":"","title":"NEW FEATURES"},{"location":"releases/#individual-stream-recording","text":"Finally individual stream recording is available in OpenVidu. When recording a session you can now configure it to store each published stream in its own file. This, on the one hand, gives developers lots of freedom to compose any kind of layout and achieve any kind of result once the recording has stopped, by using some post-processing video tool. On the other hand, this type of recording has proven to be 4x more efficient in comparison with previous grid recording in our first tests, allowing a better quality and a higher number of streams per recording, and more simultaneous recordings. We have entirely rewritten Recording documentation explaining all these new features. Take a look at it!","title":"Individual stream recording"},{"location":"releases/#audio-only-and-video-only-recording","text":"Configure your recordings to be audio-only or video-only. This is available for both COMPOSED and INDIVIDUAL recordings. It is worth mentioning that audio-only COMPOSED recordings takes advantage of the new recording capabilities introduced in this release to make it an extremley efficient process. Check out the full documentation on this subject.","title":"Audio-only and video-only recording"},{"location":"releases/#other-improvements","text":"New property resolution when starting recordings. With it you can set the width and height in pixels of the recorded file. This is only available for COMPOSED recordings. INDIVIDUAL recordings will always record the video files with the native resolution of each video stream Automatic stop of recordings is greatly improved. Check it out here New property Stream.creationTime in OpenVidu Browser. This is the time when a stream was created in OpenVidu Server. Reflects the real starting time of the media stream transmission on the server side. OpenVidu Server now destroys any stranded recording container left on the host on start up. This allows keeping the host machine clean when restarting the service New REST method available in OpenVidu Server: GET /config . You can consult OpenVidu Server version and all active configuration properties with it. Check it out here .","title":"Other improvements"},{"location":"releases/#bug-fixes_4","text":"Fixed a problem that was causing unexpected websocket disconnections from OpenVidu Server due to HttpSessions expiring after half an hour. It has been fixed by adding real reconnection capailities to websockets established from clients. This also fixes a problem with recordings longer than 30 minutes sometimes failing. Issue #146 Recording layout improved: default BEST_FIT layout used in COMPOSED recordings was including small black bars in the upper and left margins of the layout, that were visible in the final video file. This is now fixed. openvidu-browser: property Connection.creationTime now has real value (brought from OpenVidu Server) instead of a local value. Now it reflects the real time some user connected to the Session. Issue #170 openvidu-call: now when setting a screen-share stream in full-screen mode, aspect ratio is preserved to avoid loss of information","title":"BUG FIXES"},{"location":"releases/#breaking-changes_1","text":"Even though this is not a major update with incompatibility changes according to semver , there are in fact a couple of changes that are worth mentioning: Recorded files folder structure has changed: each recording is stored now in its own folder, named after the unique recording id. This doesn't affect the recordings management through REST API, openvidu-java-client or openvidu-node-client. But if you were locally managing the recordings, then a new folder structure is expected now. openvidu-node-client: Recording properties Recording.hasAudio , Recording.hasVideo and Recording.name have been included into new Recording.properties attribute: Recording.properties.hasAudio , Recording.properties.hasVideo and Recording.properties.name","title":"BREAKING CHANGES"},{"location":"releases/#270","text":"","title":"2.7.0"},{"location":"releases/#artifacts_5","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.7.0 NPM JS file 2.7.0 GitHub openvidu-server JAR 2.7.0 GitHub Docker container 2.7.0 DockerHub Docker container (+KMS) 2.7.0 DockerHub openvidu-java-client MVN package 2.5.0 MVN Repository openvidu-node-client NPM package 2.5.0 NPM openvidu-webcomponent ZIP 2.7.0 GitHub openvidu-angular NPM package 2.7.1 NPM openvidu-react NPM package 2.7.1 NPM Kurento Media Server Ubuntu package 6.8.1 Kurento Docs","title":"Artifacts"},{"location":"releases/#release-notes_5","text":"","title":"Release Notes"},{"location":"releases/#new-features_3","text":"","title":"NEW FEATURES"},{"location":"releases/#safari-support","text":"OpenVidu finally brings Safari to its collection of supported platforms. Two things to take into account when developing a Safari compatible application: If there are gonna be other types of clients rather than Safari connecting to the same session, then transcoding will be necessary in OpenVidu Server. This will bring up CPU load significantly. This behavior is due to Safari not supporting any other codec than H264, when rest of platforms usually prefer VP8. Good news is this is a problem that will soon fix on its own: Safari will support VP8 in the near future (see Release 68 Notes ) A little hack is needed in your app if your Safari users are gonna have SUBSCRIBER role (only receiving video, without accessing their microphone or camera). Learn more here","title":"Safari support"},{"location":"releases/#ionic-support-for-ios","text":"Apple support is completed with Ionic platform for iOS. Now you can implement an Ionic app that will compile OK into an iOS native application. Our openvidu-ionic tutorial is now fully compatible with iPhones and iPads. We recommend to use it as a starting point for your Android/iOS application, but in openvidu-ionic tutorial you also have everything you need to integrate OpenVidu in any Ionic app. Take a look at it!","title":"Ionic support for iOS"},{"location":"releases/#new-event-streamaudiovolumechange","text":"You can now listen to volume changes in any Publisher or Subscriber object. You can, for example, add a real-time audio wave or perform some action when certain level of noise or silence is reached. More details here .","title":"New event streamAudioVolumeChange"},{"location":"releases/#bug-fixes_5","text":"Recording layout now internally hides cursor (no need of styling the layout with cursor:none ). Issue #138 Recording stopping process reinforced to terminate and gracefully generate video files for failed recording containers (those that do not receive any video from the session caused by a misconfiguration or a wrong custom recording layout). This will help getting rid off dead containers and keeping OpenVidu Server clean. Issue #148 Mirroring local video fix: when changing to screen-share, local video is now un-mirrored, and viceversa. Issue #13 Sessions configured with Recording.MANUAL now automatically stop their recording if last participant left the session and no user published to the same session in 2 minutes. Issue #149 Publisher.publishAudio and Publisher.publishVideo may be called without having initialized a Session or having called Session.publish(Publisher)","title":"BUG FIXES"},{"location":"releases/#260","text":"","title":"2.6.0"},{"location":"releases/#artifacts_6","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.6.0 NPM JS file 2.6.0 GitHub openvidu-server JAR 2.6.0 GitHub Docker container 2.6.0 DockerHub Docker container (+KMS) 2.6.0 DockerHub openvidu-java-client MVN package 2.5.0 MVN Repository openvidu-node-client NPM package 2.5.0 NPM openvidu-webcomponent ZIP 2.6.0 GitHub openvidu-angular NPM package 2.6.0 NPM openvidu-react NPM package 2.6.0 NPM Kurento Media Server Ubuntu package 6.8.1 Kurento Docs","title":"Artifacts"},{"location":"releases/#release-notes_6","text":"","title":"Release Notes"},{"location":"releases/#new-features_4","text":"","title":"NEW FEATURES"},{"location":"releases/#ionic-support","text":"There's a complete tutorial in OpenVidu Docs to get a native Android app working with OpenVidu in just a few steps. You can just clone and use our sample application as a starting point or maybe you want to add OpenVidu to your existing Ionic app. Here you have the necessary configuration steps to do so (basically Android permissions stuff). We are currently working on making OpenVidu work on iOS with Ionic.","title":"Ionic support"},{"location":"releases/#new-types-of-filters-supported","text":"OpenVidu 2.5.0 brought a fantastic and a differentiating element: real time audio and video filters . Now we have extended this capability to support new GStreamer based filters such as textoverlay , timeoverlay or clockoverlay . You can embed any text, the timestamp of the video or the current time, easily customizing its position and format. Check these filters in GStreamer section of filters documentation.","title":"New types of filters supported"},{"location":"releases/#recording-service-now-generates-a-thumbnail-when-stopping-the-recording","text":"Whenever you stop the recording of a session, OpenVidu will automatically generate a thumbnail for the video, getting it from the middle of the video timeline. You can access it from https://OPENVIDU_SERVER_IP:4443/recordings/RECORDING_NAME.jpg Do not worry about their lifecycle: they are linked to the video file itself. If you decide to delete the recording, thumbnail will also be deleted.","title":"Recording service now generates a thumbnail when stopping the recording"},{"location":"releases/#bug-fixes_6","text":"","title":"BUG FIXES"},{"location":"releases/#important-fix-for-increasing-success-rate-in-establishing-media-connections","text":"Time ago we ran into a pretty ugly bug that was causing some problems during WebRTC negotiation, resulting in some clients located in complex networks (like a company's internal network) not being able to connect to OpenVidu Server. What developers perceived was that in certain scenarios some users simply couldn't receive or send any media connection. This bug has been completely solved in OpenVidu 2.6.0. Now media connections will work fine in almost every client network configuration.","title":"Important fix for increasing success rate in establishing media connections"},{"location":"releases/#250","text":"","title":"2.5.0"},{"location":"releases/#artifacts_7","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.5.0 NPM JS file 2.5.0 GitHub openvidu-server JAR 2.5.0 GitHub Docker container 2.5.0 DockerHub Docker container (+KMS) 2.5.0 DockerHub openvidu-java-client MVN package 2.5.0 MVN Repository openvidu-node-client NPM package 2.5.0 NPM openvidu-webcomponent ZIP 2.5.0 GitHub openvidu-angular NPM package 2.5.0 NPM openvidu-react NPM package 2.5.0 NPM","title":"Artifacts"},{"location":"releases/#release-notes_7","text":"","title":"Release Notes"},{"location":"releases/#new-features_5","text":"","title":"NEW FEATURES"},{"location":"releases/#kurento-filters-support","text":"OpenVidu API offers a simple way of applying filters to video and audio streams in the server side by making use of Kurento Media Server capabilities. See Voice and video filters section to learn more.","title":"Kurento filters support"},{"location":"releases/#individual-user-configuration-for-maximumminimum-bandwidth","text":"In version 2.3.0 we introduced 4 new configuration parameters for OpenVidu Server that allow the limitation of the video bandwidth both sent and received to/from OpenVidu Server, affecting all video streams in a global manner. Now it is possible to specifically configure certain input and output bandwidth for every user connected to a session. This way you can customize the bandwidth for each Publisher and Subscriber object of each Connection object. Users with no specific configuration will use the global values. You can set custom bandwidths by using REST API , openvidu-java-client or openvidu-node-client : REST API : in POST /api/tokens append a property in the json body like this \"kurentoOptions\": { \"videoMaxRecvBandwidth\": 1000, \"videoMinRecvBandwidth\": 1000, \"videoMaxSendBandwidth\": 1000, \"videoMinSendBandwidth\": 1000 } openvidu-java-client : build your tokens like this KurentoOptions kurentoOptions = new KurentoOptions.Builder() .videoMaxRecvBandwidth(1000) .videoMinRecvBandwidth(1000) .videoMaxSendBandwidth(1000) .videoMinSendBandwidth(1000) .build(); TokenOptions tokenOptions = new TokenOptions.Builder() .data(\"User data\") .role(OpenViduRole.PUBLISHER) .kurentoOptions(kurentoOptions) .build(); String myToken = mySession.generateToken(tokenOptions); openvidu-node-client : build your tokens like this var tokenOptions = { data: \"User data\", role: OpenViduRole.PUBLISHER, kurentoOptions: { videoMaxRecvBandwidth: 1000, videoMinRecvBandwidth: 1000, videoMaxSendBandwidth: 1000, videoMinSendBandwidth: 1000 } }; mySession.generateToken(tokenOptions).then(token => { ... } );","title":"Individual user configuration for maximum/minimum bandwidth"},{"location":"releases/#rest-api-and-server-sdks-improvements","text":"Connection objects have a brand new property very useful for session analysis: platform . It carries a complete description of the platform used by the client to connect to your session. For example: \"Chrome 69.0.3497.81 on OS X 10.13.6 64-bit\" or \"Firefox Mobile 62.0 on Mobile (Android 8.1.0)\" You can get this information by retrieving session information with the REST api ( GET /api/sessions or GET /api/sessions/SESSION_ID ) or inspecting openvidu-java-client and openvidu-node-client Session objects: calling Session.fetch() or OpenVidu.fetch() will update the status of their activeConnections property. Then you can check it out in openvidu-node-client (property Session.activeConnections ) or openvidu-java-client (method Session.getActiveConnections() ) Session , Connection and Publisher objects now have createdAt property, indicating when these objects where initialized in OpenVidu Server. This property has been integrated to maintain consistency with OpenVidu Server Call Detail Record, which has already been storing it in previous versions (check \"timestamp\" property of every CDR entry ).","title":"REST API and Server SDKs improvements"},{"location":"releases/#openvidu-browser-improvements","text":"New method OpenVidu.checkScreenSharingCapabilities() . It allows developers to know if the client platform supports screen sharing (see its declaration in OpenVidu Documentation )","title":"OpenVidu Browser improvements"},{"location":"releases/#new-openvidu-angular-and-openvidu-react-libraries","text":"We introduced OpenVidu Web Component in release 2.3.0 . Now we offer native libraries for both Angular and React (latest versions) to insert the same powerful component in your applications by making use of each framework capabilities. You can check a tutorial for OpenVidu Angular ( openvidu-library-angular ) and for OpenVidu React ( openvidu-library-react ) right now. Of course you can keep using OpenVidu Browser library instead of these components in any frontend framework. These tutorials show a basic use of OpenVidu Browser in an Angular app ( openvidu-insecure-angular ) and in a React app ( openvidu-insecure-react ).","title":"New OpenVidu Angular and OpenVidu React libraries"},{"location":"releases/#bug-fixes_7","text":"Local tracks now are not stopped on stream disposal if property PublisherProperties.videoSource was of type MediaStreamTrack (custom stream got with OpenVidu.getUserMedia() ). Issue #107 , PR #108 Deprecated RTCPeerConnection.getRemoteStreams and RTCPeerConnection.getLocalStreams to RTCPeerConnection.getReceivers and RTCPeerConnection.getSenders . Issue #54 Allow full screen sharing in Firefox. Issue #103 , PR #105 Fixed duplicated camera permissions in Firefox if PublisherProperties.videoSource/audioSource are provided as MediaStreamTracks. PR #109 openvidu-node-client now rejects with Error object upon OpenVidu Server unreachable. Issue #116 , PR #117","title":"BUG FIXES"},{"location":"releases/#240","text":"","title":"2.4.0"},{"location":"releases/#artifacts_8","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.4.0 NPM JS file 2.4.0 GitHub openvidu-server JAR 2.4.0 GitHub Docker container 2.4.0 DockerHub Docker container (+KMS) 2.4.0 DockerHub openvidu-java-client MVN package 2.4.0 MVN Repository openvidu-node-client NPM package 2.4.0 NPM openvidu-webcomponent ZIP 2.4.0 GitHub","title":"Artifacts"},{"location":"releases/#release-notes_8","text":"","title":"Release Notes"},{"location":"releases/#new-features_6","text":"","title":"NEW FEATURES"},{"location":"releases/#openvidu-java-client-and-openvidu-node-client-rest-api-support-for-v230","text":"Backend clients are now compatible with REST API 2.3.0, adding methods: Session.close() : close a Session from your backend Session.forceDisconnect() : force some user to leave a Session Session.forceUnpublish() : force some user to unpublish a Publisher from a Session Session.fetch() : bring Session information from OpenVidu Server OpenVidu.fetch() : bring information from every active Session from OpenVidu Server You can call methods Session.fetch() and OpenVidu.fetch() to bring the current status of sessions from OpenVidu Server. You can consult now directly from OpenVidu Java Client / OpenVidu Node Client all the active sessions with OpenVidu.getActiveSessions() / OpenVidu.activeSessions and the active connections of a session with Session.getActiveConnections() / Session.activeConnections .","title":"OpenVidu Java Client and OpenVidu Node Client REST API support for v2.3.0"},{"location":"releases/#openvidu-cdr-extended","text":"Event recordingStopped event now has reason property. Can be: \"recordingStoppedByServer\" : the recording was stopped by the application (using REST API, OpenVidu Java Client or OpenVidu Node Client) \"lastParticipantLeft\" : if the Session was configured for automatic recording ( RecordingMode.ALWAYS , check OpenVidu Node Client docs for more info), then it stopped because the last participant left the session \"sessionClosedByServer\" : the recording stopped because the session was forcibly closed by the application (using REST API, OpenVidu Java Client or OpenVidu Node Client) \"openviduServerStopped\" : the recording stopped because OpenVidu Server process unexpectedly stopped (cannot be guaranteed)","title":"OpenVidu CDR extended"},{"location":"releases/#openvidu-webcomponent-improvements","text":"Added a generic fullscreen button which will set as fullscreen element the entire component Local video toolbar shown on fullscreen User's nickname update process is now less intrusive (pop-up removed, simple text input instead) Updated every dialog: now they appear inside of the component (center position), instead of appended to DOM body The chat component is integrated in the layout for a better experience New close chat button (top right corner) New send button (bottom right corner) New avatar user in each message. A new snapshot image will be displayed with each new message","title":"OpenVidu WebComponent improvements"},{"location":"releases/#bug-fixes_8","text":"OpenVidu Server dashboard test could sometimes fail because of a misuse of TURN server OpenVidu Java Client: pending requests bug fixed Remote Stream status properties are now properly updated when calling Session.publish , Session.unpublish and Session.publish for the same Publisher object (having unpublished audio or video in between the calls)","title":"BUG FIXES"},{"location":"releases/#230","text":"","title":"2.3.0"},{"location":"releases/#artifacts_9","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.3.0 NPM JS file 2.3.0 GitHub openvidu-server JAR 2.3.0 GitHub Docker container 2.3.0 DockerHub Docker container (+KMS) 2.3.0 DockerHub openvidu-java-client MVN package 2.2.0 MVN Repository openvidu-node-client NPM package 2.2.0 NPM medium openvidu-webcomponent ZIP 2.3.0 GitHub","title":"Artifacts"},{"location":"releases/#release-notes_9","text":"","title":"Release Notes"},{"location":"releases/#openvidu-web-component","text":"OpenVidu platform now offers an easier way to get started: just include our new Web Component into your web and start enjoying video call capabilities with just 3 new lines of code: Add to your index.html OpenVidu Web Component files: <link rel=\"stylesheet\" href=\"openvidu-webcomponent.css\" /> <script src=\"openvidu-webcomponent.js\"></script> And add your video-call element wherever you want in your application: <openvidu-webcomponent session-config='{\"user\":\"NICKNAME\", \"token\":\"TOKEN\"}' theme=\"dark\"></openvidu-webcomponent> Being NICKNAME the user's name during the call and TOKEN one token generated in OpenVidu Server. Of course, if you want to connect users to the same session, the tokens should be generated for the same session. Attribute theme can be dark or light . Use the one that better fits your application. OpenVidu Web Component supports a reasonable amount of different dimensions, and every video displayed inside of it will be automatically relocated and resized for its optimal position upon window resizing. You can set the position, width and height of the component by styling it like this: Setting its property position to absolute or fixed , depending on your web layout and the desired behavior you want the component to have. Playing with values: width height top or bottom right or left For example, the following CSS rule would position the upper OpenVidu Web Component in the bottom-right corner of your web, taking up half of the height of the page and a third of its width. openvidu-webcomponent { position: absolute; bottom: 0; right: 0; width: 33vw; height: 50vh; } If you give enough width to the component (at least 700px ), users can communicate through an integrated chat. To see some images of OpenVidu Web Component in action, check this post on Medium . If you want to learn more about OpenVidu Web Component, visit Tutorials section","title":"OPENVIDU WEB COMPONENT"},{"location":"releases/#new-features_7","text":"","title":"NEW FEATURES"},{"location":"releases/#streampropertychangedevent-see-here","text":"OpenVidu Browser now lets users connected to a Session know when any Stream they are subscribed to undergoes any possible change in its properties. Every Session object will dispatch this new event (you can subscribe to it to every Publisher or Subscriber object too). This event can refer to the following Stream properties: Stream.audioActive : this property may change if the user publishing the Stream calls Publisher.pusblishAudio(bool) . Stream.videoActive : this property may change if the user publishing the Stream calls Publisher.publishVideo(bool) . Stream.videoDimensions : this property may change if... ...the user publishing the stream is screen-sharing and the shared window changes its dimensions. ...the user is publishing from a mobile device and it is rotated (every camera from a phone will invert the resolution in the output video when rotated). So, for example, now you can do: var OV = new OpenVidu(); var session = OV.initSession(); session.on('streamPropertyChanged', event => { if (event.changedProperty === 'audioActive') { console.log('The state of the audio of the publisher has changed. Is enabled? -> ' + event.newValue); } else if (event.changedProperty === 'videoActive') { console.log('The state of the video of the publisher has changed. Is enabled? -> ' + event.newValue); } else if (event.changedProperty === 'videoDimensions') { console.log('The video dimensions of the publisher has changed. New dimensions: ' + event.newValue); } }); This way you can react more easily upon this variations in the published streams and update your application's layout accordingly.","title":"StreamPropertyChangedEvent (See here)"},{"location":"releases/#sessioncapabilities-see-here","text":"You can check capabilities property of Session object to know which methods are able to invoke each one of your clients, depending on their role. Also, if a client tries to call a method for which he has no permissions, now an OpenViduError is thrown with property name being OPENVIDU_PERMISSION_DENIED .","title":"Session.capabilities (See here)"},{"location":"releases/#new-moderator-role","text":"At last developers have available the new role that has been in our roadmap for a long time. Users connecting to a session with a token configured with MODERATOR role can call every method granted for SUBSCRIBER and PUBLISHER roles, but also: Session.forceDisconnect : you can evict any user from the Session (force the method Session.disconnect ) Session.forceUnpublish : you can stop the Publisher of any user publishing in the Session (force the method Session.unpublish )","title":"New MODERATOR role"},{"location":"releases/#rest-api-extended","text":"5 new methods join the REST API of OpenVidu Server : Retrieve active session info: GET /api/sessions/<SESSION_ID> Retrieve all active sessions info: GET /api/sessions Close a session: DELETE /api/sessions/<SESSION_ID> Force the disconnection of a user from a session: DELETE /api/sessions/<SESSION_ID>/connection/<CONNECTION_ID> Force the unpublishing of a user's stream from a session: DELETE /api/sessions/<SESSION_ID>/stream/<STREAM_ID> Future iterations will add this capabilities to openvidu-java-client and openvidu-node-client libraries","title":"REST API extended"},{"location":"releases/#configure-global-bandwidth-for-your-webrtc-connections","text":"We have included a first way to set the maximum and minimum bandwidths for the media connections established between browsers and OpenVidu Server. You can configure it with the following system properties, as stated in OpenVidu Server configuration sections: openvidu.streams.video.max-recv-bandwidth : Maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained (default 1000) openvidu.streams.video.min-recv-bandwidth : Minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained (default 300) openvidu.streams.video.max-send-bandwidth : Maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained (default 1000) openvidu.streams.video.min-send-bandwidth : Minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained (default 300) Future iterations will study the possibility of configuring this same parameters for each session individually or even for each incoming or outgoing WebRTC connection (maybe as part of PublisherProperties or SubscriberProperties )","title":"Configure global bandwidth for your WebRTC connections"},{"location":"releases/#220","text":"","title":"2.2.0"},{"location":"releases/#artifacts_10","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.2.0 NPM JS file 2.2.0 GitHub openvidu-server JAR 2.2.0 GitHub Docker container 2.2.0 DockerHub Docker container (+KMS) 2.2.0 DockerHub openvidu-java-client MVN package 2.2.0 MVN Repository openvidu-node-client NPM package 2.2.0 NPM","title":"Artifacts"},{"location":"releases/#release-notes_10","text":"OpenVidu now offers integrated and automated support for TURN server . We encourage developers to check out our post on Medium to learn more about it. The platform now integrates by default a COTURN server as part of its ecosystem. This means that media connections will work OK even when clients are located on restricted networks. When deploying OpenVidu Server in Amazon Web Services with our Cloud Formation template no changes are required at all. If you are deploying OpenVidu Server on your own in an Ubuntu machine, installation instructions have changed a little bit. You have them properly updated here .","title":"Release Notes"},{"location":"releases/#210","text":"","title":"2.1.0"},{"location":"releases/#artifacts_11","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.1.0 NPM JS file 2.1.0 GitHub openvidu-server JAR 2.1.0 GitHub Docker container 2.1.0 DockerHub Docker container (+KMS) 2.1.0 DockerHub openvidu-java-client MVN package 2.0.0 MVN Repository openvidu-node-client NPM package 2.0.0 NPM","title":"Artifacts"},{"location":"releases/#release-notes_11","text":"","title":"Release Notes"},{"location":"releases/#new-features_8","text":"OpenVidu Browser support for video management We have implemented a new class in OpenVidu Browser aimed to better support declarative frontend frameworks such as Angular, React or Vue.js. Now Publisher and Subscriber objects both inherit from StreamManager , which provides 2 different methods to tell OpenVidu what DOM video players should display each specific stream ( addVideoElement and createVideoElement ). This allows us to let OpenVidu take control of the video elements (even if our framework dynamically creates them) and do not worry about its internals. This is all explained in detail in Manage video players section. If you want to check out a real example of this behavior, explore our renovated OpenVidu Angular tutorial .","title":"NEW FEATURES"},{"location":"releases/#200","text":"","title":"2.0.0"},{"location":"releases/#artifacts_12","text":"Artifact Type Compatible Version Link Info openvidu-browser NPM package 2.0.0 NPM JS file 2.0.0 GitHub openvidu-server JAR 2.0.0 GitHub Docker container 2.0.0 DockerHub Docker container (+KMS) 2.0.0 DockerHub openvidu-java-client MVN package 2.0.0 MVN Repository openvidu-node-client NPM package 2.0.0 NPM","title":"Artifacts"},{"location":"releases/#release-notes_12","text":"This is the first breaking change update for OpenVidu, which brings in lots of new features and internal improvements.","title":"Release Notes"},{"location":"releases/#new-features_9","text":"OpenVidu Browser new methods Session.publish() : now returns a Promise so you can tell if the method was successful or not. Session.signal() : now returns a Promise so you can tell if the method was successful or not. Subcriber.subscribeToAudio() and Subscriber.subscribeToVideo() : new methods that allows you to mute the audio or video tracks of a remote stream. OpenVidu.initPublisher() : now expects properties as interface PublisherProperties . They include: { audioSource: undefined, // The source of audio. If undefined default audio input videoSource: undefined, // The source of video. If undefined default video input publishAudio: true, // Whether you want to start publishing with your audio unmuted or muted publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video will be inserted in the target element mirror: false // Whether to mirror your local video or not } Session.subscribe() : now expects properties as interface SubscriberProperties . They include: { insertMode: 'APPEND', // How the video will be inserted in the target element subscribeToAudio: true, // Whether to initially subscribe to the stream's audio track or not subscribeToVideo: true // Whether to initially subscribe to the stream's video track or not } OpenVidu.getDevices() : now you can use certain video or audio input device when calling OpenVidu.initPublisher() , thanks to properties audioSource or videoSource of PublisherProperties object. Just set these variables to the property deviceId of any of the devices returned by this method. OpenVidu.getUserMedia() : method improved. Now devs can customize a MediaStream object before calling OpenVidu.initPublisher() method, setting property audioSource or videoSource to a MediaStreamTrack object (see docs for further information) OpenVidu Browser new properties Stream.frameRate : new property defining the frame rate of video streams. This property will only have value if the Publisher owning the stream has set property frameRate of PublisherProperties when calling OpenVidu.initPublisher() OpenVidu Browser events New events accessDialogOpened and accessDialogClosed : dispatched by Publisher objects when the browser asks the user to grant permissions to camera or michrophone by opening a pop-up. You can use them to warn your users about it. New events recordingStarted and recordingStopped : dispatched by Session object when the recording of a Session starts and stops. You can customize which clients will receive this event thanks to new property openvidu.recording.notification (see OpenVidu Server configuration ) Events publisherStartSpeaking and publisherStopSpeaking improved: more customizable thanks to OpenVidu.setAdvancedConfiguration() and better overall performance. Events streamDestroyed , connectionDestroyed and sessionDisconnected have new property reason . This gives more information about why the events have been dispatched so you can take specific actions depending on the context: maybe a stream has been destroyed because the user publishing has deliberately diposed it or maybe the network connection has unexpectedly closed (see docs for StreamEvent , ConnectionEvent and SessionDisconnectedEvent ) Other improvements in OpenVidu Browser Support for custom screen sharing extensions for Chrome Support for custom STUN and TURN servers in openvidu-browser. Use OpenVidu.setAdvancedConfiguration() Library size decreased in almost 30% ( openvidu-browser.min.js from 300 KB to 216 KB) OpenVidu Server new features New property name for recordings: you can now specify which name should OpenVidu Server give to each one of your recording files. You can do it by using the REST API (by setting body parameter \"name\" in POST /api/recordings/start ), openvidu-java-client (by using RecordingProperties.Builder.name() ) or openvidu-node-client (by setting property RecordingProperties.name ) Now support for initializing sessions with a custom sessionId . You can take advantage of this new property to facilitate the mapping between OpenVidu Server 'session' entities and your own 'session' entities. You can set it by using the REST API (by setting body parameter \"customSessionId\" in POST /api/sessions ), openvidu-java-client (by using SessionProperties.Builder.customSessionId() ) or openvidu-node-client (by setting property SessionProperties.customSessionId ) Call Detail Record extended: new events recordingStarted and recordingStopped , property reason for events sessionDestroyed , participantLeft and webrtcConnectionDestroyed .","title":"NEW FEATURES"},{"location":"releases/#bug-fixes_9","text":"Now when any participant unexpectedly disconnects from a session (for example, due to a network failure), connectionDestroyed event is sent to the rest of participants with property reason set to networkDisconnect . When OpenVidu Server is stopped, it will try to gracefully finish every in progress session and recording. This way no recording file will end corrupted upon OpenVidu Server termination (this cannot be granted if the process crashes or is forcibly terminated) Now both STUN and TURN OpenVidu Server configuration parameters can be set up at the same time with no overwritings. Tons of small fixes and code refactoring that makes OpenVidu more stable and easy to test and develop","title":"BUG FIXES"},{"location":"releases/#breaking-changes_2","text":"OpenVidu Browser OpenVidu.initSession now doesn't receive any input parameter. OpenVidu.initPublisher input parameters have changed. Now properties parameter must match PublisherProperties interface. Session.connect method has been promisified. Change the last mandatory callback parameter for a Promise implementation: session.connect(token, (error) => { ... }) to session.connect(token).then(() => {...}).catch(error => {...}); OpenVidu Java Client All Archive entities are now called Recording . This includes: class Archive to Recording , class ArchiveMode to RecordingMode , class ArchiveLayout to RecordingLayout , method SessionProperties.archiveLayout() to SessionProperties.recordingLayout() , method SessionProperties.archiveMode() to SessionProperties.recordingMode() , method SessionProperties.Builder.archiveLayout() to SessionProperties.Builder.recordingLayout() , method SessionProperties.Builder.archiveMode() to SessionProperties.Builder.recordingMode() RecordingLayout property in SessionProperties.Builder is now configured calling method defaultRecordingLayout() instead of recordingLayout() . This means that if one Session is gonna be recorded more than once, each recording layout may be customize with RecordingProperties.Builder.recordingLayout() , which will overwrite the default one globally configured in SessionProperties object. OpenVidu Node Client We have removed the builder pattern in all openvidu-node-client classes. Now objects are used instead, which includes classes TokenOptions , SessionProperties and RecordingProperties . For example, instead of getting a TokenOptions object like this: var tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build() now it must be like this: var tokenOptions = {data: serverData, role: role} There has been a simple change in certain asynchronous call. Method Session.getSessionId() is now synchronous, but method OpenVidu.createSession() is now asynchronous (the reason is pretty simple: now method createSession implements the behavior that getSessionId was providing the first time it was called for certain Session object). All callback methods have been promisified. This includes method Session.generateToken(tokenOptions?, callback): void (now Session.generateToken(tokenOptions?): Promise<string> ) and method Session.getSessionId(callback): void (now OpenVidu.createSession(): Promise<Session> , take also into account that the async call has changed from one method to the other as stated in the previous point). All Archive entities are now called Recording . This includes: object Archive to Recording , object ArchiveMode to RecordingMode , object ArchiveLayout to RecordingLayout , method SessionProperties.archiveLayout() to SessionProperties.recordingLayout() , method SessionProperties.archiveMode() to SessionProperties.recordingMode() , method SessionProperties.Builder.archiveLayout() to SessionProperties.Builder.recordingLayout() , method SessionProperties.Builder.archiveMode() to SessionProperties.Builder.recordingMode() recordingLayout property in SessionProperties has changed to defaultRecordingLayout . This means that if one Session is gonna be recorded more than once, each recording layout may be customize with recordingLayout property (of RecordingProperties interface, which will overwrite the default one globally configured in SessionProperties object. REST API All Archive entities are now called Recording in API REST. For example: {\"archiveMode\": \"ARCHIVE_MODE\", \"archiveLayout\": \"ARCHIVE_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"} now is {\"recordingMode\": \"RECORDING_MODE\", \"recordingLayout\": \"RECORDING_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"} . Field recordingLayout is now called defaultRecordingLayout in operation POST /api/sessions . This means that if one Session is gonna be recorded more than once, each recording layout may be customize adding a new field recordingLayout in the call to POST /api/recordings/start of the API REST, which will overwrite the default one globally configured during POST /api/sessions Other breaking changes OpenVidu Server default port from 8443 to 4443 OpenVidu Server configuration property openvidu.recording.free-access is now openvidu.recording.public-access","title":"BREAKING CHANGES"},{"location":"releases/#190-beta-1","text":"","title":"1.9.0-beta-1"},{"location":"releases/#artifacts_13","text":"Artifact Type Compatible version Link Info openvidu-browser NPM package 1.9.0-beta-1 NPM JS file 1.9.0-beta-1 GitHub openvidu-server JAR 1.9.0-beta-1 GitHub Docker container 1.9.0-beta-1 DockerHub Docker container (+KMS) 1.9.0-beta-1 DockerHub openvidu-java-client MVN package 1.8.0 MVN Repository openvidu-node-client NPM package 1.8.0 NPM","title":"Artifacts"},{"location":"releases/#release-notes_13","text":"Safari support : now OpenVidu is compatible with the most recent versions of Safari in Mac and iOS. It is necessary to use Kurento Media Server 6.7.0: openvidu/openvidu-server-kms:1.9.0-beta-1 Docker image already incorporates KMS 6.7.0 openvidu/openvidu-server:1.9.0-beta-1 Docker image and openvidu-server-1.9.0-beta-1.jar need KMS 6.7.0. To install it, first be sure to completely uninstall and clean any previous version of KMS and then: # In first command: xenial for Ubuntu 16.04, trusty for Ubuntu 14.04 sudo echo \"deb http://ubuntu.openvidu.io/6.7.0 xenial kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83 sudo apt-get update sudo apt-get -y dist-upgrade sudo apt-get -y install kurento-media-server sudo apt-get -y install openh264-gst-plugins-bad-1.5 To start and stop KMS 6.7.0: sudo service kurento-media-server start sudo service kurento-media-server stop","title":"Release Notes"},{"location":"troubleshooting/","text":"Troubleshooting and FAQ Everything looks alright, but I cannot see any remote video Any tips to make easier the development of my app with OpenVidu? I am using Windows to run the tutorials / develop my app. Anything I should know? Does my app need a server-side? The CloudFormation Stack is a nice option for Amazon, but I don't like it. I want more control What are STUN and TURN servers and why do I need them? What does OpenVidu not integrate regarding WebRTC and Kurento yet? What platforms are supported by OpenVidu? Which is the current status of OpenVidu regarding performance, scalability and fault tolerance? I am getting an \"Error accessing the camera\" and I have already granted permissions on the browser My Safari users with role SUBSCRIBER are not able to receive any remote video Videos are freezing on Safari for iOS Deploying OpenVidu in AWS is failing 1. Everything looks alright, but I cannot see any remote video You have an app that uses OpenVidu to stream some video user-to-user, and the process looks perfectly okey. No errors on the console and all the OpenVidu events you are subscribed to are correctly triggered. So what's happening? 99% of the time this is a problem related with OPENVIDU SERVER NOT HAVING A PUBLIC IP . To learn more about it, you can check this FAQ . The quickest solution to this problem is to deploy our ready-to-use OpenVidu Server in Amazon . If you are a bit reluctant to this quick solution with Amazon CloudFormation, you can always deploy OpenVidu by yourself in Ubuntu 16.04. Check Deploying OpenVidu on Ubuntu section to learn how to properly do it. Besides that, these are the recommended steps to follow when videos are not received: Access your OpenVidu dashboard ( https://YOUR_OPENVIDU_IP:4443 ) to quickly test the video transmission (user: OPENVIDUAPP , pass: [your private secret] ) Please be sure that your OpenVidu Server host meets the network requirements . The other 1% of the time this can be an attempt of accessing the same camera from two different browsers at the same time . Remember that Chrome, Firefox, Opera and Safari are distinct processes which cannot generally access the same physical resource (as a webcam) at the same time on your computer. On the other hand, accessing the camera from different tabs of the same browser is tipically possible. 2. Any tips to make easier the development of my app with OpenVidu? You can do some things to improve your efficiency while using OpenVidu: Multiple tabs to test the video transmission You can use multiple tabs in the same browser to test your video streams. WARNING : you may have trouble for testing with tabs from different browsers at the same time, as they compete for the camera access. Be very aware of the browser's console There you can find logs reporting important stuff. Error messages can help you to solve many issues. OpenVidu Browser is developed with both Chrome (first image) and Firefox (second image) in mind in terms of logging. By default the browser's console displays OpenVidu's high-level messages (that's when the option 'Info' is enabled, as seen in the images). This means logs about OpenVidu objects being created and destroyed and logs for each triggered event (only for those you are subscribed to). Warn and Error messages are specifically reserved for unwanted situations, and you should check your code in case you spot one of them. If you enable the lowest level of logging you can see all the messages concerning the WebRTC negotiation process (generally not very interesting for an OpenVidu user). Remember the browser's cache If you have changed your HTML, JavaScript or CSS code, refreshed the page and cannot see the changes on the browser, probably the cache is still serving the old files. To perform a hard reload of your page on the browser, press Ctrl + Shift + R Share your app through your network to test with multiple devices Making your app accessible to any device connected to your LAN network is very useful for quickly testing your app with different devices at the same time. To achieve this, you just have to indicate OpenVidu Server to use your dev machine LAN IP address as public url. For example, let's say that your machine has assigned ip 192.168.0.107 in your network: docker run -p 4443:4443 -e openvidu.publicurl=https://192.168.0.107:4443/ openvidu/openvidu-server-kms:2.12.0 Then you just have to configure your app (REST API address / OpenVidu Java Client / OpenVidu Node Client) to connect to OpenVidu through https://192.168.0.107:4443/ . Any user connecting to your app through https://192.168.0.107:WHICHEVER_PORT_YOUR_APP_IS_LISTENING_THROUGH will be able to send and receive video. 3. I am using Windows to run the tutorials / develop my app. Anything I should know? Yes, some little changes are needed because of the way Docker runs on Windows. In Linux/Mac, Docker containers are easily accessible through localhost , but in Windows you will have to use the specific IP allocated to your container (usually 192.168.99.100 ). First of all, you must launch the developing Docker container of OpenVidu Server ( openvidu/openvidu-server-kms ) setting parameter openvidu.publicurl to the IP allocated for Docker in your Windows machine. What in Linux/Mac is... docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 ...in Windows is... docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=https://192.168.99.100:4443/ openvidu/openvidu-server-kms:2.12.0 Then, to let your applications know how to connect to OpenVidu Server: Applications Client-Side Only (For example openvidu-hello-world , openvidu-insecure-js , openvidu-insecure-angular , openvidu-getaroom ) When consuming openvidu-server REST API, change location.hostname to the IP of the Docker container running openvidu-server (usually 192.168.99.100 ). For every one of the insecure tutorials listed above, the url where to send the REST operations ... \"https://\" + location.hostname + \":4443/api/<OPERATION>\" ... in Windows is ... \"https://192.168.99.100:4443/api/<OPERATION>\" Change this url in every insecure tutorial right here: openvidu-hello-world : here openvidu-insecure-js : here openvidu-insecure-angular : here openvidu-getaroom : here Also you will need to serve your apps over https . Browsers only accept camera usage on http when the address is localhost , and here it will be 192.168.99.100 or the one that Docker picks up for you. To serve over https with http-server , generate a self-signed certificate and run with -S flag on the root path of your app: Generate a selfsigned certificate (run in your Docker console) openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '//CN=www.mydom.com\\O=My Company LTD.\\C=US' -keyout key.pem -out cert.pem Run with SSL flag http-server -S Applications Client-Side + Server-Side (Tutorials openvidu-js-java , openvidu-mvc-java , openvidu-js-node , openvidu-mvc-node ) You must let know your app/tutorial how to initialize openvidu-java-client or openvidu-node-client (or where to send your REST API operations in case you are not using any of these clients). For example: Java tutorials (tutorials openvidu-js-java , openvidu-mvc-java ): override the default value of the property openvidu.url : mvn package exec:java in Windows is... mvn -Dopenvidu.url=https://192.168.99.100:4443/ package exec:java With this change we are simply changing the param urlOpenViduServer that our OpenVidu object from openvidu-java-client will receive in its constructor . This change is something related to these specific applications. Node tutorials (tutorials openvidu-js-node , openvidu-mvc-node ): change the URL param passed on launch: node server.js https://localhost:4443/ MY_SECRET in Windows is... node server.js https://192.168.99.100:4443/ MY_SECRET With this change we are simply changing the param urlOpenViduServer that our OpenVidu object from openvidu-node-client will receive in its constructor . This change is something related to these specific applications. 4. Does my app need a server-side? First of all, let's differentiate between OpenVidu server-side and your application's server-side. You will always need OpenVidu Server deployed at some place on the Internet (check the Deployment section to learn how to do it in 5 minutes). For now, OpenVidu doesn't support p2p direct connections between two users, so all the traffic must flow to OpenVidu Server or from OpenVidu Server. You will generally want your application to have its own server-side. Why? Well, it is really not necessary. You can have a pure client-side application if you want. Just check any of these tutorials: openvidu-hello-world , openvidu-insecure-js , openvidu-getaroom The problem here is pretty evident: if you don't have any kind of server side to control your users, anyone can use your app. In fact, you can respectively see here , here and here a comment warning about this matter in every insecure tutorial. Due to the lack of a server-side in these tutorials, we have no choice but to embed the REST API consumption methods in our JavaScript code, which includes hardcoding our secret in the JS client code. IMPORTANT : Do NOT include your SECRET in your JavaScript or HTML files in a production environment! First an OpenVidu app Client-Side Only. Second an OpenVidu app Client-Side + Server-Side. In production you will usually want the second option to avoid unwanted users. 5. The CloudFormation Stack is a nice option for Amazon, but I don't like it. I want more control You can always deploy everything by yourself. To do so, check Deploying OpenVidu on Ubuntu section. What platforms are supported by OpenVidu? 6. What are STUN and TURN servers and why do I need them? If the user's devices don't have a public and reachable IP, WebRTC connections cannot be established and therefore, video streams cannot be sent or received. This occurs when the users are behind NAT's and Firewalls. In brief, when they are hidden under complex networks. In order to support these circumstances, WebRTC relies on STUN and TURN servers: STUN can easily provide to the user's devices their own public IP (the IP that other devices on the Internet use to connect to it), so they can tell OpenVidu where to send the video streams. Only with a STUN server, around 86% of the time the connection will be successful. TURN is an extension of STUN, and covers the most extreme cases of complex networks (symmetric NATs). It acts as a gateway, passing all the media streams from one side to the other. This situation will occur with a probability of around 8% . For all purposes, OpenVidu Server acts as a final user, and your connections may fail if it is hosted behind a complex network. To provide a a solid service you definitely need both STUN and TURN servers. There are many public, free-to-use STUN servers ( STUN server list ), but because TURN always faces a much larger load when coming into play, no one offers it free of charge. The good news is that it is very easy to install a COTURN server, which offers both STUN and TURN: Our ready-to-use CloudFormation stack already includes a properly configured COTURN server. If you are deploying OpenVidu Server by your own, there are detailed instructions in the Deploying OpenVidu on Ubuntu section, which explains how to install, configure and run COTURN on Ubuntu. You can test your COTURN server on this website: Trickle ICE . To do so, remove the default Google server from the list and add your own following this format: turn:YOUR_TURN_IP:YOUR_TURN_PORT (add your TURN username and password below) 7. What does OpenVidu not integrate regarding WebRTC and Kurento yet? As the main goal OpenVidu has is to make as simple as possible the integration of video-call capabilities in applications, it would make little sense to support all the features provided by Kurento: why would most of developers want visual recognition or augmented reality capabilities when adding video-calls to their apps? But there's also a bunch of features supported by Kurento or WebRTC that will be part of OpenVidu as well: Video composing : right now OpenVidu streams are always sent and received without any processing in Kurento Media Server, so every subscription to a video stream in a video-session implies its own WebRTC connection. We intend to provide the possibility of configuring video-sessions to be processed and send as only one video, composed in a grid by all the published streams (MCU architecture). Direct p2p connections between users : OpenVidu will offer the possibility of connecting users without having to use Kurento Media Server as central node. This can be very advantegeous for certain use-cases, as will reduce the need of infraestructure. 8. What platforms are supported by OpenVidu? OpenVidu supports a wide range of platforms: Desktop browsers Chrome , Firefox , Opera , Safari and Internet Explorer 11 Mobile browsers Chrome , Firefox and Opera in Android and Safari on iOS Mobile native applications Android and iOS are supported: Since release 2.7.0 through Ionic . You can try openvidu-ionic tutorial and you will have an OpenVidu native mobile application compatible working in minutes. Since release 2.10.0 through React Native . You can try openvidu-react-native tutorial and you will have an OpenVidu native mobile application working in minutes. Desktop native applications Windows , OSX and Linux are supported since release 2.10.0 through Electron . You can try openvidu-electron tutorial and you will have an OpenVidu native desktop application working in minutes. 9. Which is the current status of OpenVidu regarding performance, scalability and fault tolerance? In terms of performance , OpenVidu load testing process is described in detail in this Medium post . Results are the following for 7-to-7 sessions where every participant sends one audio-video stream (540x360, 30 fps) and receives 6 remote streams (same video). The table states the maximum number of entities that can be established until CPU reaches 100% use. About scalability , you can try OpenVidu Pro scalability features . With OpenVidu Pro you can deploy an OpenVidu cluster to make your application scalable. We intend to provide automated elasticity and fault tolerance in OpenVidu Pro tier in the near future. Always seamlessly integrated with most popular cloud providers and platforms (AWS, Azure, Ansible, Kubernetes...) with the final goal of providing automated server scale-in and scale-out capabilities depending on the workload of your application. 10. I am getting an \"Error accessing the camera\" and I have already granted permissions on the browser If you are using Chrome : you cannot access the camera or microphone from a http URL if it is not localhost or 127.0.0.1 . In a nutshell: in Chrome accessing the webcam on http://localhost:8080 or http://127.0.0.1:8080 is perfectly OK. But, for example, on http://172.17.0.1:8080 it will through an error saying \" Only secure origins are allowed \". If for any reason you want to serve your app locally on a custom URL, the only solution is to serve it over https with a certificate. If you are making use of the web server we have strongly suggested over the documentation ( npm install -g http-server ), you can do this with the following commands on your application's root path: Generate a selfsigned certificate with openssl openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem Run http-server with SSL flag http-server -S 11. My Safari users with role SUBSCRIBER are not able to receive any remote video Safari needs a user gesture to allow videos to automatically start playing if they have audio. This applies to users with role SUBSCRIBER : that is, users that don't need to perform a call to OpenVidu.initPublisher . If a user access its camera or microphone, then there's no need of user gestures at all (as soon as they accept camera permissions, remote videos will automatically start playing). So, in this particular case developers must show a button their SUBSCRIBER users must click (any other action that counts as user-gesture is also suitable), and the action executed upon click event should include a call to video.play() . The actual video element is completely irrelevant. It can be hidden and with no media attached at all. For example: <!-- This can be placed anywhere in the DOM. For example, as last child of <body> element --> <video id=\"hidden-video\"></video> // Javascript code run upon any user gesture var video = document.getElementById(\"hidden-video\").play(); After this JavaScript line has been executed any remote video will start playing. This process is not necessary for future subscribed videos, when there is already some audio being played in the DOM. 12. Videos are freezing on Safari for iOS Again, Apple's browser has \"special\" needs when it comes to video playback. In iPhones and iPads, Safari doesn't support out of the box the playback of multiple videos at the same time if they have audio tracks. Here you have a link to a bug related to this behavior. Possible solutions to this issue? Tweaking muted property on videos to have only one playing audio at a time. Maybe using user gestures to directly play videos can help too. Other users have reported that it usually works fine if dynamically adding audio tracks to the same MediaStream object. There is not a clear solution to this problem, and depending on the web application some workarounds can succeed and some may not. On our tests we have even seen different behaviors in video playback from one execution to another, breaking the supposed consistency of the browser. It is really a matter of testing different approaches until you find a good enough solution. Due to these problems, any other WebRTC based service we have tested usually redirected to a native application when trying to connect through iOS Safari. You can implement your native OpenVidu app for both iOS and Android with Ionic ) or Ractt Native ). 13. Deploying OpenVidu in AWS is failing If you are deploying OpenVidu CE or OpenVidu Pro in AWS and the CloudFormation reaches CREATE_FAILED status, then possibly you are missing a default VPC in that specific region. You can inspect your default VPCs like this: https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html#view-default-vpc And you can create a default VPC like this: https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html#create-default-vpc If you are still experiencing problems while deploying OpenVidu on AWS, please check out this guide: AWS Deployment Troubleshooting","title":"Troubleshooting / FAQ"},{"location":"troubleshooting/#1-everything-looks-alright-but-i-cannot-see-any-remote-video","text":"You have an app that uses OpenVidu to stream some video user-to-user, and the process looks perfectly okey. No errors on the console and all the OpenVidu events you are subscribed to are correctly triggered. So what's happening? 99% of the time this is a problem related with OPENVIDU SERVER NOT HAVING A PUBLIC IP . To learn more about it, you can check this FAQ . The quickest solution to this problem is to deploy our ready-to-use OpenVidu Server in Amazon . If you are a bit reluctant to this quick solution with Amazon CloudFormation, you can always deploy OpenVidu by yourself in Ubuntu 16.04. Check Deploying OpenVidu on Ubuntu section to learn how to properly do it. Besides that, these are the recommended steps to follow when videos are not received: Access your OpenVidu dashboard ( https://YOUR_OPENVIDU_IP:4443 ) to quickly test the video transmission (user: OPENVIDUAPP , pass: [your private secret] ) Please be sure that your OpenVidu Server host meets the network requirements . The other 1% of the time this can be an attempt of accessing the same camera from two different browsers at the same time . Remember that Chrome, Firefox, Opera and Safari are distinct processes which cannot generally access the same physical resource (as a webcam) at the same time on your computer. On the other hand, accessing the camera from different tabs of the same browser is tipically possible.","title":"1. Everything looks alright, but I cannot see any remote video"},{"location":"troubleshooting/#2-any-tips-to-make-easier-the-development-of-my-app-with-openvidu","text":"You can do some things to improve your efficiency while using OpenVidu:","title":"2. Any tips to make easier the development of my app with OpenVidu?"},{"location":"troubleshooting/#multiple-tabs-to-test-the-video-transmission","text":"You can use multiple tabs in the same browser to test your video streams. WARNING : you may have trouble for testing with tabs from different browsers at the same time, as they compete for the camera access.","title":"Multiple tabs to test the video transmission"},{"location":"troubleshooting/#be-very-aware-of-the-browsers-console","text":"There you can find logs reporting important stuff. Error messages can help you to solve many issues. OpenVidu Browser is developed with both Chrome (first image) and Firefox (second image) in mind in terms of logging. By default the browser's console displays OpenVidu's high-level messages (that's when the option 'Info' is enabled, as seen in the images). This means logs about OpenVidu objects being created and destroyed and logs for each triggered event (only for those you are subscribed to). Warn and Error messages are specifically reserved for unwanted situations, and you should check your code in case you spot one of them. If you enable the lowest level of logging you can see all the messages concerning the WebRTC negotiation process (generally not very interesting for an OpenVidu user).","title":"Be very aware of the browser's console"},{"location":"troubleshooting/#remember-the-browsers-cache","text":"If you have changed your HTML, JavaScript or CSS code, refreshed the page and cannot see the changes on the browser, probably the cache is still serving the old files. To perform a hard reload of your page on the browser, press Ctrl + Shift + R","title":"Remember the browser's cache"},{"location":"troubleshooting/#share-your-app-through-your-network-to-test-with-multiple-devices","text":"Making your app accessible to any device connected to your LAN network is very useful for quickly testing your app with different devices at the same time. To achieve this, you just have to indicate OpenVidu Server to use your dev machine LAN IP address as public url. For example, let's say that your machine has assigned ip 192.168.0.107 in your network: docker run -p 4443:4443 -e openvidu.publicurl=https://192.168.0.107:4443/ openvidu/openvidu-server-kms:2.12.0 Then you just have to configure your app (REST API address / OpenVidu Java Client / OpenVidu Node Client) to connect to OpenVidu through https://192.168.0.107:4443/ . Any user connecting to your app through https://192.168.0.107:WHICHEVER_PORT_YOUR_APP_IS_LISTENING_THROUGH will be able to send and receive video.","title":"Share your app through your network to test with multiple devices"},{"location":"troubleshooting/#3-i-am-using-windows-to-run-the-tutorials-develop-my-app-anything-i-should-know","text":"Yes, some little changes are needed because of the way Docker runs on Windows. In Linux/Mac, Docker containers are easily accessible through localhost , but in Windows you will have to use the specific IP allocated to your container (usually 192.168.99.100 ). First of all, you must launch the developing Docker container of OpenVidu Server ( openvidu/openvidu-server-kms ) setting parameter openvidu.publicurl to the IP allocated for Docker in your Windows machine. What in Linux/Mac is... docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 ...in Windows is... docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=https://192.168.99.100:4443/ openvidu/openvidu-server-kms:2.12.0 Then, to let your applications know how to connect to OpenVidu Server:","title":"3. I am using Windows to run the tutorials / develop my app. Anything I should know?"},{"location":"troubleshooting/#applications-client-side-only","text":"(For example openvidu-hello-world , openvidu-insecure-js , openvidu-insecure-angular , openvidu-getaroom ) When consuming openvidu-server REST API, change location.hostname to the IP of the Docker container running openvidu-server (usually 192.168.99.100 ). For every one of the insecure tutorials listed above, the url where to send the REST operations ... \"https://\" + location.hostname + \":4443/api/<OPERATION>\" ... in Windows is ... \"https://192.168.99.100:4443/api/<OPERATION>\" Change this url in every insecure tutorial right here: openvidu-hello-world : here openvidu-insecure-js : here openvidu-insecure-angular : here openvidu-getaroom : here Also you will need to serve your apps over https . Browsers only accept camera usage on http when the address is localhost , and here it will be 192.168.99.100 or the one that Docker picks up for you. To serve over https with http-server , generate a self-signed certificate and run with -S flag on the root path of your app: Generate a selfsigned certificate (run in your Docker console) openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '//CN=www.mydom.com\\O=My Company LTD.\\C=US' -keyout key.pem -out cert.pem Run with SSL flag http-server -S","title":"Applications Client-Side Only"},{"location":"troubleshooting/#applications-client-side-server-side","text":"(Tutorials openvidu-js-java , openvidu-mvc-java , openvidu-js-node , openvidu-mvc-node ) You must let know your app/tutorial how to initialize openvidu-java-client or openvidu-node-client (or where to send your REST API operations in case you are not using any of these clients). For example: Java tutorials (tutorials openvidu-js-java , openvidu-mvc-java ): override the default value of the property openvidu.url : mvn package exec:java in Windows is... mvn -Dopenvidu.url=https://192.168.99.100:4443/ package exec:java With this change we are simply changing the param urlOpenViduServer that our OpenVidu object from openvidu-java-client will receive in its constructor . This change is something related to these specific applications. Node tutorials (tutorials openvidu-js-node , openvidu-mvc-node ): change the URL param passed on launch: node server.js https://localhost:4443/ MY_SECRET in Windows is... node server.js https://192.168.99.100:4443/ MY_SECRET With this change we are simply changing the param urlOpenViduServer that our OpenVidu object from openvidu-node-client will receive in its constructor . This change is something related to these specific applications.","title":"Applications Client-Side + Server-Side"},{"location":"troubleshooting/#4-does-my-app-need-a-server-side","text":"First of all, let's differentiate between OpenVidu server-side and your application's server-side. You will always need OpenVidu Server deployed at some place on the Internet (check the Deployment section to learn how to do it in 5 minutes). For now, OpenVidu doesn't support p2p direct connections between two users, so all the traffic must flow to OpenVidu Server or from OpenVidu Server. You will generally want your application to have its own server-side. Why? Well, it is really not necessary. You can have a pure client-side application if you want. Just check any of these tutorials: openvidu-hello-world , openvidu-insecure-js , openvidu-getaroom The problem here is pretty evident: if you don't have any kind of server side to control your users, anyone can use your app. In fact, you can respectively see here , here and here a comment warning about this matter in every insecure tutorial. Due to the lack of a server-side in these tutorials, we have no choice but to embed the REST API consumption methods in our JavaScript code, which includes hardcoding our secret in the JS client code. IMPORTANT : Do NOT include your SECRET in your JavaScript or HTML files in a production environment! First an OpenVidu app Client-Side Only. Second an OpenVidu app Client-Side + Server-Side. In production you will usually want the second option to avoid unwanted users.","title":"4. Does my app need a server-side?"},{"location":"troubleshooting/#5-the-cloudformation-stack-is-a-nice-option-for-amazon-but-i-dont-like-it-i-want-more-control","text":"You can always deploy everything by yourself. To do so, check Deploying OpenVidu on Ubuntu section. What platforms are supported by OpenVidu?","title":"5. The CloudFormation Stack is a nice option for Amazon, but I don't like it. I want more control"},{"location":"troubleshooting/#6-what-are-stun-and-turn-servers-and-why-do-i-need-them","text":"If the user's devices don't have a public and reachable IP, WebRTC connections cannot be established and therefore, video streams cannot be sent or received. This occurs when the users are behind NAT's and Firewalls. In brief, when they are hidden under complex networks. In order to support these circumstances, WebRTC relies on STUN and TURN servers: STUN can easily provide to the user's devices their own public IP (the IP that other devices on the Internet use to connect to it), so they can tell OpenVidu where to send the video streams. Only with a STUN server, around 86% of the time the connection will be successful. TURN is an extension of STUN, and covers the most extreme cases of complex networks (symmetric NATs). It acts as a gateway, passing all the media streams from one side to the other. This situation will occur with a probability of around 8% . For all purposes, OpenVidu Server acts as a final user, and your connections may fail if it is hosted behind a complex network. To provide a a solid service you definitely need both STUN and TURN servers. There are many public, free-to-use STUN servers ( STUN server list ), but because TURN always faces a much larger load when coming into play, no one offers it free of charge. The good news is that it is very easy to install a COTURN server, which offers both STUN and TURN: Our ready-to-use CloudFormation stack already includes a properly configured COTURN server. If you are deploying OpenVidu Server by your own, there are detailed instructions in the Deploying OpenVidu on Ubuntu section, which explains how to install, configure and run COTURN on Ubuntu. You can test your COTURN server on this website: Trickle ICE . To do so, remove the default Google server from the list and add your own following this format: turn:YOUR_TURN_IP:YOUR_TURN_PORT (add your TURN username and password below)","title":"6. What are STUN and TURN servers and why do I need them?"},{"location":"troubleshooting/#7-what-does-openvidu-not-integrate-regarding-webrtc-and-kurento-yet","text":"As the main goal OpenVidu has is to make as simple as possible the integration of video-call capabilities in applications, it would make little sense to support all the features provided by Kurento: why would most of developers want visual recognition or augmented reality capabilities when adding video-calls to their apps? But there's also a bunch of features supported by Kurento or WebRTC that will be part of OpenVidu as well: Video composing : right now OpenVidu streams are always sent and received without any processing in Kurento Media Server, so every subscription to a video stream in a video-session implies its own WebRTC connection. We intend to provide the possibility of configuring video-sessions to be processed and send as only one video, composed in a grid by all the published streams (MCU architecture). Direct p2p connections between users : OpenVidu will offer the possibility of connecting users without having to use Kurento Media Server as central node. This can be very advantegeous for certain use-cases, as will reduce the need of infraestructure.","title":"7. What does OpenVidu not integrate regarding WebRTC and Kurento yet?"},{"location":"troubleshooting/#8-what-platforms-are-supported-by-openvidu","text":"OpenVidu supports a wide range of platforms:","title":"8. What platforms are supported by OpenVidu?"},{"location":"troubleshooting/#desktop-browsers","text":"Chrome , Firefox , Opera , Safari and Internet Explorer 11","title":"Desktop browsers"},{"location":"troubleshooting/#mobile-browsers","text":"Chrome , Firefox and Opera in Android and Safari on iOS","title":"Mobile browsers"},{"location":"troubleshooting/#mobile-native-applications","text":"Android and iOS are supported: Since release 2.7.0 through Ionic . You can try openvidu-ionic tutorial and you will have an OpenVidu native mobile application compatible working in minutes. Since release 2.10.0 through React Native . You can try openvidu-react-native tutorial and you will have an OpenVidu native mobile application working in minutes.","title":"Mobile native applications"},{"location":"troubleshooting/#desktop-native-applications","text":"Windows , OSX and Linux are supported since release 2.10.0 through Electron . You can try openvidu-electron tutorial and you will have an OpenVidu native desktop application working in minutes.","title":"Desktop native applications"},{"location":"troubleshooting/#9-which-is-the-current-status-of-openvidu-regarding-performance-scalability-and-fault-tolerance","text":"In terms of performance , OpenVidu load testing process is described in detail in this Medium post . Results are the following for 7-to-7 sessions where every participant sends one audio-video stream (540x360, 30 fps) and receives 6 remote streams (same video). The table states the maximum number of entities that can be established until CPU reaches 100% use. About scalability , you can try OpenVidu Pro scalability features . With OpenVidu Pro you can deploy an OpenVidu cluster to make your application scalable. We intend to provide automated elasticity and fault tolerance in OpenVidu Pro tier in the near future. Always seamlessly integrated with most popular cloud providers and platforms (AWS, Azure, Ansible, Kubernetes...) with the final goal of providing automated server scale-in and scale-out capabilities depending on the workload of your application.","title":"9. Which is the current status of OpenVidu regarding performance, scalability and fault tolerance?"},{"location":"troubleshooting/#10-i-am-getting-an-error-accessing-the-camera-and-i-have-already-granted-permissions-on-the-browser","text":"If you are using Chrome : you cannot access the camera or microphone from a http URL if it is not localhost or 127.0.0.1 . In a nutshell: in Chrome accessing the webcam on http://localhost:8080 or http://127.0.0.1:8080 is perfectly OK. But, for example, on http://172.17.0.1:8080 it will through an error saying \" Only secure origins are allowed \". If for any reason you want to serve your app locally on a custom URL, the only solution is to serve it over https with a certificate. If you are making use of the web server we have strongly suggested over the documentation ( npm install -g http-server ), you can do this with the following commands on your application's root path: Generate a selfsigned certificate with openssl openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem Run http-server with SSL flag http-server -S","title":"10. I am getting an \"Error accessing the camera\" and I have already granted permissions on the browser"},{"location":"troubleshooting/#11-my-safari-users-with-role-subscriber-are-not-able-to-receive-any-remote-video","text":"Safari needs a user gesture to allow videos to automatically start playing if they have audio. This applies to users with role SUBSCRIBER : that is, users that don't need to perform a call to OpenVidu.initPublisher . If a user access its camera or microphone, then there's no need of user gestures at all (as soon as they accept camera permissions, remote videos will automatically start playing). So, in this particular case developers must show a button their SUBSCRIBER users must click (any other action that counts as user-gesture is also suitable), and the action executed upon click event should include a call to video.play() . The actual video element is completely irrelevant. It can be hidden and with no media attached at all. For example: <!-- This can be placed anywhere in the DOM. For example, as last child of <body> element --> <video id=\"hidden-video\"></video> // Javascript code run upon any user gesture var video = document.getElementById(\"hidden-video\").play(); After this JavaScript line has been executed any remote video will start playing. This process is not necessary for future subscribed videos, when there is already some audio being played in the DOM.","title":"11. My Safari users with role SUBSCRIBER are not able to receive any remote video"},{"location":"troubleshooting/#12-videos-are-freezing-on-safari-for-ios","text":"Again, Apple's browser has \"special\" needs when it comes to video playback. In iPhones and iPads, Safari doesn't support out of the box the playback of multiple videos at the same time if they have audio tracks. Here you have a link to a bug related to this behavior. Possible solutions to this issue? Tweaking muted property on videos to have only one playing audio at a time. Maybe using user gestures to directly play videos can help too. Other users have reported that it usually works fine if dynamically adding audio tracks to the same MediaStream object. There is not a clear solution to this problem, and depending on the web application some workarounds can succeed and some may not. On our tests we have even seen different behaviors in video playback from one execution to another, breaking the supposed consistency of the browser. It is really a matter of testing different approaches until you find a good enough solution. Due to these problems, any other WebRTC based service we have tested usually redirected to a native application when trying to connect through iOS Safari. You can implement your native OpenVidu app for both iOS and Android with Ionic ) or Ractt Native ).","title":"12. Videos are freezing on Safari for iOS"},{"location":"troubleshooting/#13-deploying-openvidu-in-aws-is-failing","text":"If you are deploying OpenVidu CE or OpenVidu Pro in AWS and the CloudFormation reaches CREATE_FAILED status, then possibly you are missing a default VPC in that specific region. You can inspect your default VPCs like this: https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html#view-default-vpc And you can create a default VPC like this: https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html#create-default-vpc If you are still experiencing problems while deploying OpenVidu on AWS, please check out this guide: AWS Deployment Troubleshooting","title":"13. Deploying OpenVidu in AWS is failing"},{"location":"tutorials/","text":"OpenVidu Tutorials Hello World Make your first video-call with just a few lines of code Hello World! x Client Side only Get quickly started without worrying about a server-side x JavaScript Vanilla JavaScript app: good old JS code for a traditional approach x Angular Try this fantastic tutorial using the last version of Angular framework x React Have a look to this nice tutorial based on React x React Native This React Native tutorial will get your mobile app going in the blink of an eye x Ionic This Ionic project will get your mobile app going in the blink of an eye x Electron Build an OpenVidu native desktop application for Windows, OSX and Linux in just a few minutes OpenVidu is present on both client-side and server-side, but the application is only present on client-side. Since these are client-side-only applications, you will be dealing only with frontend technologies : HTML, CSS, Javascript / Typescript ... The main difference compared to Client Side + Server Side tutorials is that here you don't have real control over your users: your video-calls won't be secure because you cannot identify them and cannot determine if allow or deny their access. Client Side + Server Side Try any of our ready-for-production web apps to see OpenVidu in action with a real example x JavaScript + Java SPA Vanilla JavasCript frontend and a SPA Java Backend: forget building HTML templates, just feed your front with HTTP requests x JavaScript + Java MVC Vanilla JavasCript frontend and a traditional Java MVC Backend: serve HTML pages from your server x JavaScript + Node SPA Vanilla JavasCript frontend and a SPA Node Backend: forget building HTML templates, just feed your front with HTTP requests x JavaScript + Node MVC Vanilla JavasCript frontend and a traditional Node MVC backend: serve HTML pages from your server OpenVidu and the application are present on both client-side and server-side. Since these are full web applications, you will be dealing with frontend technologies (HTML, CSS, Javascript / Typescript ...) but also with backend technologies (Java / Node) The main difference compared to Client Side Only tutorials is that here you have total control over your users: your video-calls are secure because you can identify them and allow or deny their access.","title":"Intro"},{"location":"tutorials/openvidu-android/","text":"openvidu-android Check it on GitHub A client-side only Android native application built with Java and using official Google WebRTC library . If it is the first time you use OpenVidu, it is highly recommended to start first with openvidu-hello-world tutorial due to this being a native Android app and being a little more complex for OpenVidu starters. OpenVidu does not provide an Android client SDK yet, so this application directly implements OpenVidu Server RPC protocol . In other words, it internally implements what openvidu-browser library does. Everything about this implementation is explained in section Using OpenVidu Server RPC protocol Understanding this tutorial OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-android : Android application built with Java connected to OpenVidu through websocket openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions Running this tutorial This tutorial is compatible for Android >= 5.0 (API level >= 21) To deploy the Android APK you need to have Android Studio , an Android device (recommended) or an Android emulator and Android SDK installed. You can download Android Studio here . You also can check the official Android Studio guide After we have set up Android Studio we must continue with the following commands: 1) Clone the repo git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) Open Android Studio and import the project (openvidu-tutorials/openvidu-android) 3) Now you need the IP of your PC in the network. In Linux/OSX you can simply get it by running this command on your shell awk '/inet / && $2 != \"127.0.0.1\"{print $2}' <(ifconfig) It will probably output something like 192.168.0.105 . Your complete OpenVidu public url would then be https://192.168.0.105:4443/ When you have your OpenVidu public url, you must set it in default_openvidu_url variable in the app and in the openvidu.publicurl parameter used to run openvidu-server (see next point) 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ) docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=YOUR_OPENVIDU_PUBLIC_URL openvidu/openvidu-server-kms:2.12.0 Remember changing openvidu.publicurl parameter to the actual value. In this example that would be: -e openvidu.publicurl=https://192.168.0.105:4443/ 5) Connect the device to the same network as your PC 6) In Android Studio, you must modify the websocket address inside of strings.xml file. To do that, in Android Studio, go to app > res > values > strings.xml . The value of default_openvidu_url will must be the IP of your PC. In this example that would be: https://192.168.0.105:4443/ 7) Connect the device to the PC. You must enable USB debugging and give permissions (check out official Android docs ) 8) Run the tutorial. In Android Studio, click the app module in the Project window and then select Run > Run . In the Select Deployment Target window, select your device, and click OK . Understanding the code This is an Android project generated with Android Studio, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under app/java folder: SessionActivity.java : this class defines the only Android activity of the app. Participant.java : it is related to the participants info, such as connection information and their UI elements. This is the parent class of RemoteParticipant and LocalParticipant . Session.java : this manages the collection of Participant objects, the behavior of SessionActivity layout and takes care of the creation of PeerConnection objects. CustomWebSocket.java : the negotiation with openvidu-server takes place in this class. Its responsibility is to send RPC methods and listen to openvidu-server events through a websocket connection. To sum up, it implements OpenVidu Server RPC protocol . WebSocket address, session name and participant name As stated above in Running this tutorial , you have to modify the value of default_openvidu_url with the IP of your PC in file res > values > strings.xml . For example: <string name=\"default_openvidu_url\">https://192.168.0.105:4443/</string> Besides, you can change the default values for the local participant name ( default_participant_name ) and session name ( default_session_name ). These will appear as default values in the form to connect to a session. <string name=\"default_session_name\">SessionA</string> <string name=\"default_participant_name\">Participant</string> Get a token from OpenVidu Server WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server src/main/java/io/openvidu/openvidu_android/activities/SessionActivity.java private void getToken(String sessionId) { // See next point to see how to connect to the session using 'token' ... } Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() . Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them. We use an http-client we have wrapped in class CustomHttpClient . First request performs a POST to /api/sessions (we send a customSessionId field to force the id of the session to be the value retrieved from the view's form. This way we don't need a server side to connect multiple users to the same session) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . When token available start the process to connect to openvidu-server Once we have gotten the token, we can set up our session object, our camera and the websocket. We create our session , our localParticipant and capture the camera : src/main/java/io/openvidu/openvidu_android/activities/SessionActivity.java private void getTokenSuccess(String token, String sessionId) { // Initialize our session object session = new Session(sessionId, token, views_container, this); // Initialize our local participant and start local camera String participantName = participant_name.getText().toString(); LocalParticipant localParticipant = new LocalParticipant(participantName, session, this.getApplicationContext(), localVideoView); localParticipant.startCamera(); runOnUiThread(() -> { // Update local participant view main_participant.setText(participant_name.getText().toString()); main_participant.setPadding(20, 3, 20, 3); }); // Initialize and connect the websocket to OpenVidu Server startWebSocket(); } To configure the session , we are going to initialize and build the PeerConnectionFactory . This is the way to initialize WebRTC peer connections with the official Google WebRTC library for Android. src/main/java/io/openvidu/openvidu_android/openvidu/Session.java //Creating a new PeerConnectionFactory instance PeerConnectionFactory.InitializationOptions.Builder optionsBuilder = PeerConnectionFactory.InitializationOptions.builder(activity.getApplicationContext()); optionsBuilder.setEnableInternalTracer(true); PeerConnectionFactory.InitializationOptions opt = optionsBuilder.createInitializationOptions(); PeerConnectionFactory.initialize(opt); PeerConnectionFactory.Options options = new PeerConnectionFactory.Options(); // Using sofware encoder and decoder. final VideoEncoderFactory encoderFactory; final VideoDecoderFactory decoderFactory; encoderFactory = new SoftwareVideoEncoderFactory(); decoderFactory = new SoftwareVideoDecoderFactory(); peerConnectionFactory = PeerConnectionFactory.builder() .setVideoEncoderFactory(encoderFactory) .setVideoDecoderFactory(decoderFactory) .setOptions(options) .createPeerConnectionFactory(); Capture the camera Android provides us a very easy way to use Camera API. This API includes support for various cameras and camera features available on devices, allowing you to capture pictures and videos in your application. In the end, we need to store the video track. src/main/java/io/openvidu/openvidu_android/openvidu/LocalParticipant.java public void startCamera() { final EglBase.Context eglBaseContext = EglBase.create().getEglBaseContext(); PeerConnectionFactory peerConnectionFactory = this.session.getPeerConnectionFactory(); // Create AudioSource AudioSource audioSource = peerConnectionFactory.createAudioSource(new MediaConstraints()); this.audioTrack = peerConnectionFactory.createAudioTrack(\"101\", audioSource); surfaceTextureHelper = SurfaceTextureHelper.create(\"CaptureThread\", eglBaseContext); // Create VideoCapturer VideoCapturer videoCapturer = createCameraCapturer(); VideoSource videoSource = peerConnectionFactory.createVideoSource(videoCapturer.isScreencast()); videoCapturer.initialize(surfaceTextureHelper, context, videoSource.getCapturerObserver()); videoCapturer.startCapture(480, 640, 30); // Create VideoTrack this.videoTrack = peerConnectionFactory.createVideoTrack(\"100\", videoSource); // Display in localView this.videoTrack.addSink(localVideoView); } Since API level 21, Camera class was deprecated. Android introduced Camera2 with Android 5.0 (API level 21) and above. As the Android official documentation recommends, we should use Camera2 on supported devices. src/main/java/io/openvidu/openvidu_android/openvidu/LocalParticipant.java private VideoCapturer createCameraCapturer() { CameraEnumerator enumerator; if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) { enumerator = new Camera2Enumerator(this.context); } else { enumerator = new Camera1Enumerator(false); } final String[] deviceNames = enumerator.getDeviceNames(); // Try to find front facing camera for (String deviceName : deviceNames) { if (enumerator.isFrontFacing(deviceName)) { videoCapturer = enumerator.createCapturer(deviceName, null); if (videoCapturer != null) { return videoCapturer; } } } // Front facing camera not found, try something else for (String deviceName : deviceNames) { if (!enumerator.isFrontFacing(deviceName)) { videoCapturer = enumerator.createCapturer(deviceName, null); if (videoCapturer != null) { return videoCapturer; } } } return null; } We also have to think about the media permissions. You can take a look to the Android permissions under section Android specific requirements . Connect the websocket to OpenVidu Server Ath this point, we will establish a connection between openvidu-server and our Android app through the websocket. This way will be able to consume OpenVidu Server RPC protocol to interact with the session (in the future, when OpenVidu Android SDK is available, this won't be necessary). We do so in background as an async task so the main execution thread is not blocked. src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java @Override protected Void doInBackground(SessionActivity... sessionActivities) { try { WebSocketFactory factory = new WebSocketFactory(); //Returns a SSLContext object that implements the specified secure socket protocol SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustManagers, new java.security.SecureRandom()); factory.setSSLContext(sslContext); // Set the flag which indicates whether the hostname in the server's certificate should be verified or not. factory.setVerifyHostname(false); // Connecting the websocket to OpenVidu URL websocket = factory.createSocket(getWebSocketAddress(openviduUrl)); websocket.addListener(this); websocket.connect(); } catch ( ... ) Using OpenVidu Server RPC protocol Taking the references from OpenVidu Server RPC protocol , we will be able call to the OpenVidu Server methods and receive events from OpenVidu Server. Listening to OpenVidu Server events The app implements a method to handle event messages received from openvidu server. This will be essential in order to know when ice candidates arrive, when a new user joined the session, when a user published a video to the session or when some participant left the session. src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java private void handleServerEvent(JSONObject json) throws JSONException { if (!json.has(JsonConstants.PARAMS)) { Log.e(TAG, \"No params \" + json.toString()); } else { final JSONObject params = new JSONObject(json.getString(JsonConstants.PARAMS)); String method = json.getString(JsonConstants.METHOD); switch (method) { case JsonConstants.ICE_CANDIDATE: iceCandidateEvent(params); break; case JsonConstants.PARTICIPANT_JOINED: participantJoinedEvent(params); break; case JsonConstants.PARTICIPANT_PUBLISHED: participantPublishedEvent(params); break; case JsonConstants.PARTICIPANT_LEFT: participantLeftEvent(params); break; default: throw new JSONException(\"Unknown method: \" + method); } } } iceCandidate : this event brings a new ICE candidate generated in openvidu-server. We must include it in the proper PeerConnection object (we receive ICE candidates for our local PeerConnection and for each remote PeerConnection). To avoid timing problems, the application stores the received ICE candidates until that PeerConnection state is STABLE . Whenever it is reached, it processes all of them at once. participantJoined : this event tells us a new participant has joined our session. We initialize a new PeerConnection object (so we may receive the new user's camera stream) and a new video element in the UI. participantPublished : this event tells us a user has started sending a video to the session. We must start the ICE negotiation for receiving the new video stream over the proper and already initialized PeerConnection object. We do so by simply following WebRTC protocol: creating and setting a local SDP offer, sending it to openvidu-server with RPC method receiveVideoFrom and setting the answer received as remote SDP description of this PeerConnection. participantLeftEvent : dispatched when some user has left the session. We simply dispose the proper PeerConnection and update our view. Sending methods to OpenVidu Server Below we list all the RPC methods that this Android app sends to OpenVidu Server. Each one of them will be answered by OpenVidu Server with a specific response. They must be properly processed and usually a new flow of method calls will follow the reception of these answers. We will not explain in detail every one of them to keep the length of this tutorial under control, but you can easily follow the flow of method calls in the source code. Joining a session with joinRoom method Once the websocket connection is established, we need to join to the session. By sending a JSON-RPC method joinRoom with the followings parameters we'll be able to connect to the session: src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java public void joinRoom() { Map<String, String> joinRoomParams = new HashMap<>(); // Setting the joinRoom parameters joinRoomParams.put(JsonConstants.METADATA, \"{\\\"clientData\\\": \\\"\" + this.session.getLocalParticipant().getParticipantName() + \"\\\"}\"); joinRoomParams.put(\"secret\", \"\"); joinRoomParams.put(\"session\", this.session.getId()); joinRoomParams.put(\"platform\", \"Android \" + android.os.Build.VERSION.SDK_INT); joinRoomParams.put(\"token\", this.session.getToken()); //Sending JSON through websocket specifying 'joinRoom' method. this.ID_JOINROOM.set(this.sendJson(JsonConstants.JOINROOM_METHOD, joinRoomParams)); } As response we will receive an object with all the existing participants in the session and all the published streams. We first process them as explained in events participantJoined and participantPublished in previous section Listening to OpenVidu Server events . And we must publish our own camera by initializing our local PeerConnection and MediaStream and calling publishVideo RPC method (see next point). Publishing the camera with publishVideo method We need to send a JSO-RPC message through the websocket with the required params as shown below: src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java public void publishVideo(SessionDescription sessionDescription) { Map<String, String> publishVideoParams = new HashMap<>(); // Setting the publishVideo parameters publishVideoParams.put(\"audioActive\", \"true\"); publishVideoParams.put(\"videoActive\", \"true\"); publishVideoParams.put(\"doLoopback\", \"false\"); publishVideoParams.put(\"frameRate\", \"30\"); publishVideoParams.put(\"hasAudio\", \"true\"); publishVideoParams.put(\"hasVideo\", \"true\"); publishVideoParams.put(\"typeOfVideo\", \"CAMERA\"); publishVideoParams.put(\"videoDimensions\", \"{\\\"width\\\":320, \\\"height\\\":240}\"); publishVideoParams.put(\"sdpOffer\", sessionDescription.description); //Sending JSON through websocket specifying 'publishVideo' method. this.ID_PUBLISHVIDEO.set(this.sendJson(JsonConstants.PUBLISHVIDEO_METHOD, publishVideoParams)); } Subscribing to a remote video with receiveVideo method We need to send a JSON-RPC through the websocket with the required params as shown below: src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java public void receiveVideoFrom(SessionDescription sessionDescription, RemoteParticipant remoteParticipant, String streamId) { Map<String, String> receiveVideoFromParams = new HashMap<>(); receiveVideoFromParams.put(\"sdpOffer\", sessionDescription.description); receiveVideoFromParams.put(\"sender\", streamId); this.IDS_RECEIVEVIDEO.put( this.sendJson(JsonConstants.RECEIVEVIDEO_METHOD, receiveVideoFromParams), remoteParticipant.getConnectionId()); } Leaving the session with 'leaveRoom' method We need to send a JSON-RPC through the websocket (empty parameters in this case): src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java public void leaveRoom() { this.ID_LEAVEROOM.set(this.sendJson(JsonConstants.LEAVEROOM_METHOD)); } Android specific requirements Android apps need to actively ask for permissions in the code to access camera and microphone. By following steps below we have been able to properly set up the permissions your app will need to work along OpenVidu. You have a great complete guide here . These configurations are already included in this openvidu-android project, so if you start from here no further configurations are needed. Otherwise, if you want to start a new Android project , you should follow these simple steps: 1) Add required permissions to your manifest file <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"io.openvidu.openvidu_android\"> <application> ... </application> <uses-permission android:name=\"android.permission.CAMERA\" /> <uses-permission android:name=\"android.permission.RECORD_AUDIO\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /> <uses-permission android:name=\"android.permission.INTERNET\" /> </manifest> 2) Check if your application has already the necessary permissions. To do so, call the ContextCompat.checkSelfPermission() method. For example: if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { // Permission for camera is not granted } If the app already has the permission, the method returns PackageManager.PERMISSION_GRANTED and the app can proceed with the operation. If the app does not have the permission, the method returns PackageManager.PERMISSION_DENIED , and the app has to explicitly ask the user for permission. 3) Android provides several methods to request for a permission, such as requestPermissions() , as shown in the code snippet below. Calling these methods brings up a standard Android dialog so the user may accept or decline the permissions. // Here, \"this\" object is the current activity if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { // Permission is not granted // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)) { // Show an explanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. } else { // No explanation needed. Request the permission ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. } } else { // Permission has already been granted } $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-android"},{"location":"tutorials/openvidu-android/#openvidu-android","text":"Check it on GitHub A client-side only Android native application built with Java and using official Google WebRTC library . If it is the first time you use OpenVidu, it is highly recommended to start first with openvidu-hello-world tutorial due to this being a native Android app and being a little more complex for OpenVidu starters. OpenVidu does not provide an Android client SDK yet, so this application directly implements OpenVidu Server RPC protocol . In other words, it internally implements what openvidu-browser library does. Everything about this implementation is explained in section Using OpenVidu Server RPC protocol","title":"openvidu-android"},{"location":"tutorials/openvidu-android/#understanding-this-tutorial","text":"OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-android : Android application built with Java connected to OpenVidu through websocket openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-android/#running-this-tutorial","text":"This tutorial is compatible for Android >= 5.0 (API level >= 21) To deploy the Android APK you need to have Android Studio , an Android device (recommended) or an Android emulator and Android SDK installed. You can download Android Studio here . You also can check the official Android Studio guide After we have set up Android Studio we must continue with the following commands: 1) Clone the repo git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) Open Android Studio and import the project (openvidu-tutorials/openvidu-android) 3) Now you need the IP of your PC in the network. In Linux/OSX you can simply get it by running this command on your shell awk '/inet / && $2 != \"127.0.0.1\"{print $2}' <(ifconfig) It will probably output something like 192.168.0.105 . Your complete OpenVidu public url would then be https://192.168.0.105:4443/ When you have your OpenVidu public url, you must set it in default_openvidu_url variable in the app and in the openvidu.publicurl parameter used to run openvidu-server (see next point) 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ) docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=YOUR_OPENVIDU_PUBLIC_URL openvidu/openvidu-server-kms:2.12.0 Remember changing openvidu.publicurl parameter to the actual value. In this example that would be: -e openvidu.publicurl=https://192.168.0.105:4443/ 5) Connect the device to the same network as your PC 6) In Android Studio, you must modify the websocket address inside of strings.xml file. To do that, in Android Studio, go to app > res > values > strings.xml . The value of default_openvidu_url will must be the IP of your PC. In this example that would be: https://192.168.0.105:4443/ 7) Connect the device to the PC. You must enable USB debugging and give permissions (check out official Android docs ) 8) Run the tutorial. In Android Studio, click the app module in the Project window and then select Run > Run . In the Select Deployment Target window, select your device, and click OK .","title":"Running this tutorial"},{"location":"tutorials/openvidu-android/#understanding-the-code","text":"This is an Android project generated with Android Studio, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under app/java folder: SessionActivity.java : this class defines the only Android activity of the app. Participant.java : it is related to the participants info, such as connection information and their UI elements. This is the parent class of RemoteParticipant and LocalParticipant . Session.java : this manages the collection of Participant objects, the behavior of SessionActivity layout and takes care of the creation of PeerConnection objects. CustomWebSocket.java : the negotiation with openvidu-server takes place in this class. Its responsibility is to send RPC methods and listen to openvidu-server events through a websocket connection. To sum up, it implements OpenVidu Server RPC protocol .","title":"Understanding the code"},{"location":"tutorials/openvidu-android/#websocket-address-session-name-and-participant-name","text":"As stated above in Running this tutorial , you have to modify the value of default_openvidu_url with the IP of your PC in file res > values > strings.xml . For example: <string name=\"default_openvidu_url\">https://192.168.0.105:4443/</string> Besides, you can change the default values for the local participant name ( default_participant_name ) and session name ( default_session_name ). These will appear as default values in the form to connect to a session. <string name=\"default_session_name\">SessionA</string> <string name=\"default_participant_name\">Participant</string>","title":"WebSocket address, session name and participant name"},{"location":"tutorials/openvidu-android/#get-a-token-from-openvidu-server","text":"WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server src/main/java/io/openvidu/openvidu_android/activities/SessionActivity.java private void getToken(String sessionId) { // See next point to see how to connect to the session using 'token' ... } Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() . Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them. We use an http-client we have wrapped in class CustomHttpClient . First request performs a POST to /api/sessions (we send a customSessionId field to force the id of the session to be the value retrieved from the view's form. This way we don't need a server side to connect multiple users to the same session) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-android/#when-token-available-start-the-process-to-connect-to-openvidu-server","text":"Once we have gotten the token, we can set up our session object, our camera and the websocket. We create our session , our localParticipant and capture the camera : src/main/java/io/openvidu/openvidu_android/activities/SessionActivity.java private void getTokenSuccess(String token, String sessionId) { // Initialize our session object session = new Session(sessionId, token, views_container, this); // Initialize our local participant and start local camera String participantName = participant_name.getText().toString(); LocalParticipant localParticipant = new LocalParticipant(participantName, session, this.getApplicationContext(), localVideoView); localParticipant.startCamera(); runOnUiThread(() -> { // Update local participant view main_participant.setText(participant_name.getText().toString()); main_participant.setPadding(20, 3, 20, 3); }); // Initialize and connect the websocket to OpenVidu Server startWebSocket(); } To configure the session , we are going to initialize and build the PeerConnectionFactory . This is the way to initialize WebRTC peer connections with the official Google WebRTC library for Android. src/main/java/io/openvidu/openvidu_android/openvidu/Session.java //Creating a new PeerConnectionFactory instance PeerConnectionFactory.InitializationOptions.Builder optionsBuilder = PeerConnectionFactory.InitializationOptions.builder(activity.getApplicationContext()); optionsBuilder.setEnableInternalTracer(true); PeerConnectionFactory.InitializationOptions opt = optionsBuilder.createInitializationOptions(); PeerConnectionFactory.initialize(opt); PeerConnectionFactory.Options options = new PeerConnectionFactory.Options(); // Using sofware encoder and decoder. final VideoEncoderFactory encoderFactory; final VideoDecoderFactory decoderFactory; encoderFactory = new SoftwareVideoEncoderFactory(); decoderFactory = new SoftwareVideoDecoderFactory(); peerConnectionFactory = PeerConnectionFactory.builder() .setVideoEncoderFactory(encoderFactory) .setVideoDecoderFactory(decoderFactory) .setOptions(options) .createPeerConnectionFactory();","title":"When token available start the process to connect to openvidu-server"},{"location":"tutorials/openvidu-android/#capture-the-camera","text":"Android provides us a very easy way to use Camera API. This API includes support for various cameras and camera features available on devices, allowing you to capture pictures and videos in your application. In the end, we need to store the video track. src/main/java/io/openvidu/openvidu_android/openvidu/LocalParticipant.java public void startCamera() { final EglBase.Context eglBaseContext = EglBase.create().getEglBaseContext(); PeerConnectionFactory peerConnectionFactory = this.session.getPeerConnectionFactory(); // Create AudioSource AudioSource audioSource = peerConnectionFactory.createAudioSource(new MediaConstraints()); this.audioTrack = peerConnectionFactory.createAudioTrack(\"101\", audioSource); surfaceTextureHelper = SurfaceTextureHelper.create(\"CaptureThread\", eglBaseContext); // Create VideoCapturer VideoCapturer videoCapturer = createCameraCapturer(); VideoSource videoSource = peerConnectionFactory.createVideoSource(videoCapturer.isScreencast()); videoCapturer.initialize(surfaceTextureHelper, context, videoSource.getCapturerObserver()); videoCapturer.startCapture(480, 640, 30); // Create VideoTrack this.videoTrack = peerConnectionFactory.createVideoTrack(\"100\", videoSource); // Display in localView this.videoTrack.addSink(localVideoView); } Since API level 21, Camera class was deprecated. Android introduced Camera2 with Android 5.0 (API level 21) and above. As the Android official documentation recommends, we should use Camera2 on supported devices. src/main/java/io/openvidu/openvidu_android/openvidu/LocalParticipant.java private VideoCapturer createCameraCapturer() { CameraEnumerator enumerator; if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) { enumerator = new Camera2Enumerator(this.context); } else { enumerator = new Camera1Enumerator(false); } final String[] deviceNames = enumerator.getDeviceNames(); // Try to find front facing camera for (String deviceName : deviceNames) { if (enumerator.isFrontFacing(deviceName)) { videoCapturer = enumerator.createCapturer(deviceName, null); if (videoCapturer != null) { return videoCapturer; } } } // Front facing camera not found, try something else for (String deviceName : deviceNames) { if (!enumerator.isFrontFacing(deviceName)) { videoCapturer = enumerator.createCapturer(deviceName, null); if (videoCapturer != null) { return videoCapturer; } } } return null; } We also have to think about the media permissions. You can take a look to the Android permissions under section Android specific requirements .","title":"Capture the camera"},{"location":"tutorials/openvidu-android/#connect-the-websocket-to-openvidu-server","text":"Ath this point, we will establish a connection between openvidu-server and our Android app through the websocket. This way will be able to consume OpenVidu Server RPC protocol to interact with the session (in the future, when OpenVidu Android SDK is available, this won't be necessary). We do so in background as an async task so the main execution thread is not blocked. src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java @Override protected Void doInBackground(SessionActivity... sessionActivities) { try { WebSocketFactory factory = new WebSocketFactory(); //Returns a SSLContext object that implements the specified secure socket protocol SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustManagers, new java.security.SecureRandom()); factory.setSSLContext(sslContext); // Set the flag which indicates whether the hostname in the server's certificate should be verified or not. factory.setVerifyHostname(false); // Connecting the websocket to OpenVidu URL websocket = factory.createSocket(getWebSocketAddress(openviduUrl)); websocket.addListener(this); websocket.connect(); } catch ( ... )","title":"Connect the websocket to OpenVidu Server"},{"location":"tutorials/openvidu-android/#using-openvidu-server-rpc-protocol","text":"Taking the references from OpenVidu Server RPC protocol , we will be able call to the OpenVidu Server methods and receive events from OpenVidu Server.","title":"Using OpenVidu Server RPC protocol"},{"location":"tutorials/openvidu-android/#listening-to-openvidu-server-events","text":"The app implements a method to handle event messages received from openvidu server. This will be essential in order to know when ice candidates arrive, when a new user joined the session, when a user published a video to the session or when some participant left the session. src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java private void handleServerEvent(JSONObject json) throws JSONException { if (!json.has(JsonConstants.PARAMS)) { Log.e(TAG, \"No params \" + json.toString()); } else { final JSONObject params = new JSONObject(json.getString(JsonConstants.PARAMS)); String method = json.getString(JsonConstants.METHOD); switch (method) { case JsonConstants.ICE_CANDIDATE: iceCandidateEvent(params); break; case JsonConstants.PARTICIPANT_JOINED: participantJoinedEvent(params); break; case JsonConstants.PARTICIPANT_PUBLISHED: participantPublishedEvent(params); break; case JsonConstants.PARTICIPANT_LEFT: participantLeftEvent(params); break; default: throw new JSONException(\"Unknown method: \" + method); } } } iceCandidate : this event brings a new ICE candidate generated in openvidu-server. We must include it in the proper PeerConnection object (we receive ICE candidates for our local PeerConnection and for each remote PeerConnection). To avoid timing problems, the application stores the received ICE candidates until that PeerConnection state is STABLE . Whenever it is reached, it processes all of them at once. participantJoined : this event tells us a new participant has joined our session. We initialize a new PeerConnection object (so we may receive the new user's camera stream) and a new video element in the UI. participantPublished : this event tells us a user has started sending a video to the session. We must start the ICE negotiation for receiving the new video stream over the proper and already initialized PeerConnection object. We do so by simply following WebRTC protocol: creating and setting a local SDP offer, sending it to openvidu-server with RPC method receiveVideoFrom and setting the answer received as remote SDP description of this PeerConnection. participantLeftEvent : dispatched when some user has left the session. We simply dispose the proper PeerConnection and update our view.","title":"Listening to OpenVidu Server events"},{"location":"tutorials/openvidu-android/#sending-methods-to-openvidu-server","text":"Below we list all the RPC methods that this Android app sends to OpenVidu Server. Each one of them will be answered by OpenVidu Server with a specific response. They must be properly processed and usually a new flow of method calls will follow the reception of these answers. We will not explain in detail every one of them to keep the length of this tutorial under control, but you can easily follow the flow of method calls in the source code.","title":"Sending methods to OpenVidu Server"},{"location":"tutorials/openvidu-android/#joining-a-session-with-joinroom-method","text":"Once the websocket connection is established, we need to join to the session. By sending a JSON-RPC method joinRoom with the followings parameters we'll be able to connect to the session: src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java public void joinRoom() { Map<String, String> joinRoomParams = new HashMap<>(); // Setting the joinRoom parameters joinRoomParams.put(JsonConstants.METADATA, \"{\\\"clientData\\\": \\\"\" + this.session.getLocalParticipant().getParticipantName() + \"\\\"}\"); joinRoomParams.put(\"secret\", \"\"); joinRoomParams.put(\"session\", this.session.getId()); joinRoomParams.put(\"platform\", \"Android \" + android.os.Build.VERSION.SDK_INT); joinRoomParams.put(\"token\", this.session.getToken()); //Sending JSON through websocket specifying 'joinRoom' method. this.ID_JOINROOM.set(this.sendJson(JsonConstants.JOINROOM_METHOD, joinRoomParams)); } As response we will receive an object with all the existing participants in the session and all the published streams. We first process them as explained in events participantJoined and participantPublished in previous section Listening to OpenVidu Server events . And we must publish our own camera by initializing our local PeerConnection and MediaStream and calling publishVideo RPC method (see next point).","title":"Joining a session with joinRoom method"},{"location":"tutorials/openvidu-android/#publishing-the-camera-with-publishvideo-method","text":"We need to send a JSO-RPC message through the websocket with the required params as shown below: src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java public void publishVideo(SessionDescription sessionDescription) { Map<String, String> publishVideoParams = new HashMap<>(); // Setting the publishVideo parameters publishVideoParams.put(\"audioActive\", \"true\"); publishVideoParams.put(\"videoActive\", \"true\"); publishVideoParams.put(\"doLoopback\", \"false\"); publishVideoParams.put(\"frameRate\", \"30\"); publishVideoParams.put(\"hasAudio\", \"true\"); publishVideoParams.put(\"hasVideo\", \"true\"); publishVideoParams.put(\"typeOfVideo\", \"CAMERA\"); publishVideoParams.put(\"videoDimensions\", \"{\\\"width\\\":320, \\\"height\\\":240}\"); publishVideoParams.put(\"sdpOffer\", sessionDescription.description); //Sending JSON through websocket specifying 'publishVideo' method. this.ID_PUBLISHVIDEO.set(this.sendJson(JsonConstants.PUBLISHVIDEO_METHOD, publishVideoParams)); }","title":"Publishing the camera with publishVideo method"},{"location":"tutorials/openvidu-android/#subscribing-to-a-remote-video-with-receivevideo-method","text":"We need to send a JSON-RPC through the websocket with the required params as shown below: src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java public void receiveVideoFrom(SessionDescription sessionDescription, RemoteParticipant remoteParticipant, String streamId) { Map<String, String> receiveVideoFromParams = new HashMap<>(); receiveVideoFromParams.put(\"sdpOffer\", sessionDescription.description); receiveVideoFromParams.put(\"sender\", streamId); this.IDS_RECEIVEVIDEO.put( this.sendJson(JsonConstants.RECEIVEVIDEO_METHOD, receiveVideoFromParams), remoteParticipant.getConnectionId()); }","title":"Subscribing to a remote video with receiveVideo method"},{"location":"tutorials/openvidu-android/#leaving-the-session-with-leaveroom-method","text":"We need to send a JSON-RPC through the websocket (empty parameters in this case): src/main/java/io/openvidu/openvidu_android/openvidu/CustomWebSocket.java public void leaveRoom() { this.ID_LEAVEROOM.set(this.sendJson(JsonConstants.LEAVEROOM_METHOD)); }","title":"Leaving the session with 'leaveRoom' method"},{"location":"tutorials/openvidu-android/#android-specific-requirements","text":"Android apps need to actively ask for permissions in the code to access camera and microphone. By following steps below we have been able to properly set up the permissions your app will need to work along OpenVidu. You have a great complete guide here . These configurations are already included in this openvidu-android project, so if you start from here no further configurations are needed. Otherwise, if you want to start a new Android project , you should follow these simple steps: 1) Add required permissions to your manifest file <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"io.openvidu.openvidu_android\"> <application> ... </application> <uses-permission android:name=\"android.permission.CAMERA\" /> <uses-permission android:name=\"android.permission.RECORD_AUDIO\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /> <uses-permission android:name=\"android.permission.INTERNET\" /> </manifest> 2) Check if your application has already the necessary permissions. To do so, call the ContextCompat.checkSelfPermission() method. For example: if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { // Permission for camera is not granted } If the app already has the permission, the method returns PackageManager.PERMISSION_GRANTED and the app can proceed with the operation. If the app does not have the permission, the method returns PackageManager.PERMISSION_DENIED , and the app has to explicitly ask the user for permission. 3) Android provides several methods to request for a permission, such as requestPermissions() , as shown in the code snippet below. Calling these methods brings up a standard Android dialog so the user may accept or decline the permissions. // Here, \"this\" object is the current activity if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { // Permission is not granted // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)) { // Show an explanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. } else { // No explanation needed. Request the permission ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. } } else { // Permission has already been granted } $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Android specific requirements"},{"location":"tutorials/openvidu-electron/","text":"openvidu-electron Check it on GitHub A client-side only application built with Electron . It can be compiled into a native desktop application for Windows , OSX and Linux . It includes electron-forge as a dependency so the compilation process is as simple as running a single command: npm run make If it is the first time you use OpenVidu, it is highly recommended to start first with openvidu-hello-world tutorial due to this being an Electron app and being a little more complex for OpenVidu starters. Understanding this tutorial OpenVidu is composed by the three modules displayed on the image above. openvidu-browser : JavaScript library for your Electron app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions Running this tutorial 1) You will need Node and NPM . Install them with the following commands sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs 2) Clone the repo git clone https://github.com/OpenVidu/openvidu-tutorials 3) Install dependencies and run the tutorial cd openvidu-tutorials/openvidu-electron npm install npm start 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) The app will start automatically as a native desktop application, regardless of the OS you are using. If you are on Windows, it will launch as a Windows app. In OSX as an OSX app, and in Linux as a Linux app. If you are using Windows , read this FAQ to properly run the tutorial Understanding the code As an Electron app, the project has a main.js file that serves as entry point. It has not been modified at all, so it remains the same as it is by default in the electron-quick-start example. Most important files are the following ones: openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. axios.min.js : library for making HTTP requests from the app. You don't have to manipulate this file. modal.html : this is the dialog for selecting the screen to share if the user wants to do so. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . style.css : some CSS classes to style the app. index.html : HTML code for the form to connect to a video-call and for the video-call itself. It has links to 3 JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"axios.min.js\"></script> <script src=\"app.js\"></script> We have implemented screen-sharing capabilities in this application because the process is slightly different from the rest of platforms that support it. Electron does not provide a default screen selector dialog, so we must implement it ourselves (that is the purpose of modal.html file). You can check out this feature in the last section Screen sharing . Let's see first how app.js uses openvidu-browser-VERSION.js : First lines declare the variables that will be needed in different points along the code const ipcRenderer = require('electron').ipcRenderer; const BrowserWindow = require('electron').remote.BrowserWindow; var openvidu; var session; var publisher; var mySessionId; Constants ipcRenderer and BrowserWindow are Electron objects we will need for our screen selector dialog. openvidu will be our OpenVidu object (entry point to the library). session will be the video-call we will connect to. publisher will be our media stream to publish to the session, and finally mySessionId simply identifies the session to connect to. Initialize a publisher function initPublisher() { openvidu = new OpenVidu(); const shareScreen = document.getElementById(\"screen-sharing\").checked; if (shareScreen) { openScreenShareModal(); } else { publisher = openvidu.initPublisher(\"publisher\"); joinSession(); } } We will first initialize a Publisher before connecting to the session. If the user hasn't checked the screen sharing checkbox, we simply call openvidu.initPublisher indicating that we want openvidu-browser to insert our local video inside HTML element with id publisher . Then we proceed to join to the session. If you want to see how to initialize a screen sharing Publisher instead of the webcam, go to section Screen sharing Initialize the session function joinSession() { session = openvidu.initSession(); session.on(\"streamCreated\", function (event) { session.subscribe(event.stream, \"subscriber\"); }); Once we have our Publisher properly initialized, we continue by creating a Session object. We do so with openvidu.initSession method. We then have to configure our session to listen to streamCreated events, so we are able to subscribe to other user media streams when they publish. Get a token from OpenVidu Server We are ready to join the session. But we still need an OpenVidu token, so we must ask for it to openvidu-server. We use axios.min.js library to do so. getToken(mySessionId).then(token => { // See next point to see how to connect to the session using 'token' }); WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First HTTP request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Connect to the session using the token getToken(mySessionId).then(token => { session.connect(token) .then(() => { showSession(); session.publish(publisher); }) .catch(error => { console.log(\"There was an error connecting to the session:\", error.code, error.message); }); }); We simply need to call session.connect passing the recently retrieved token from OpenVidu Server. This method returns a Promise to which you can subscribe to. In case of success we first set the view to the active video session. Then we proceed to publish our previously created Publisher by calling session.publish . At this point the rest of users connected to this session will trigger their own streamCreated event and can start watching our media stream. Leaving the session function leaveSession() { session.disconnect(); hideSession(); } Whenever we want a user to leave the session, we just need to call session.disconnect method. Here it will be called inside leaveSession function, triggered when the user clicks on \"LEAVE\" button. This function also returns the page to the \"Join a video session\" view. Screen sharing The process to screen-share is slightly different from the rest of platforms that support it. Electron does not provide a default screen selector dialog as browsers do, so we must implement it ourselves (that is the purpose of modal.html file). We need a screen unique identifier to initialize our Publisher object like this: OpenVidu.initPublisher({videoSource: \"screen:\" + SCREEN_ID}); // While in other platforms is simply {videoSource: \"screen\"}, // which triggers the screen selector dialog of the browser First of all, we must be able to communicate different windows of the application, because in this case the screen selector dialog will be a completely separate window. But of course you could implement it in the same main window of your app, that's up to you. In main.js we import ipcMain from Electron and configure it to listen to screen-share-selected event. Upon this event it will notify our app with other event ( screen-share-ready ), passing the same message received from the sender. const { app, BrowserWindow, ipcMain } = require('electron'); // ... ipcMain.on('screen-share-selected', (event, message) => { mainWindow.webContents.send('screen-share-ready', message); }); In app.js file, where all our logic lies, we import ipcRenderer and configure it to listen to screen-share-ready event, sent from our main.js file as shown above. At this point we have the necessary parameter to initialize our Publisher: ipcRenderer.on('screen-share-ready', (event, message) => { // User has chosen a screen to share. screenId is message parameter showSession(); publisher = openvidu.initPublisher(\"publisher\", { videoSource: \"screen:\" + message }); joinSession(); }); So, where's the code that initiates this whole event process? That is modal.html file. This HTML view will be launched by app.js file in method initPublisher if the user has checked the screen-sharing checkbox. Method openScreenShareModal will be called then: function openScreenShareModal() { let win = new BrowserWindow({ parent: require('electron').remote.getCurrentWindow(), modal: true, minimizable: false, maximizable: false, webPreferences: { nodeIntegration: true }, resizable: false }) win.setMenu(null); // win.webContents.openDevTools(); var theUrl = 'file://' + __dirname + '/modal.html' win.loadURL(theUrl); } This code will launch modal.html template in a child window. In this file we use Electron API desktopCapturer to list and present all available screens. The user is able to select any of them and by clicking button \"Share\" the selected screen id will be sent as an event screen-share-selected just before closing this child window, by making use of the same ipcRenderer object as app.js do. var availableScreens = []; var htmlElements = []; var selectedElement; const { desktopCapturer } = require('electron') const ipcRenderer = require('electron').ipcRenderer; // Call Electron API to list all available screens desktopCapturer.getSources({ types: ['window', 'screen'] }).then(async sources => { const list = document.getElementById(\"list-of-screens\"); sources.forEach(source => { // Add new element to the list with the thumbnail of the screen var el = document.createElement(\"div\"); el.onclick = () => { // Style the new selected screen and store it as the current selection htmlElements.forEach(e => { e.style.border = \"none\"; e.style.background = \"none\"; }) el.style.border = \"2px solid #0088aa\"; el.style.background = \"rgba(0, 0, 0, 0.06)\"; selectedElement = el; document.getElementById(\"share-btn\").disabled = false; } // Store the new source and the new created HTML element availableScreens.push(source); htmlElements.push(el); var img = document.createElement(\"img\"); var name = document.createElement(\"span\"); img.src = source.thumbnail.toDataURL(); name.innerHTML = source.name; // Append new elements to the template el.appendChild(img); el.appendChild(name); list.appendChild(el); }); }); function sendScreenSelection() { ipcRenderer.send('screen-share-selected', availableScreens[htmlElements.indexOf(selectedElement)].id); closeWindow(); }","title":"openvidu-electron"},{"location":"tutorials/openvidu-electron/#openvidu-electron","text":"Check it on GitHub A client-side only application built with Electron . It can be compiled into a native desktop application for Windows , OSX and Linux . It includes electron-forge as a dependency so the compilation process is as simple as running a single command: npm run make If it is the first time you use OpenVidu, it is highly recommended to start first with openvidu-hello-world tutorial due to this being an Electron app and being a little more complex for OpenVidu starters.","title":"openvidu-electron"},{"location":"tutorials/openvidu-electron/#understanding-this-tutorial","text":"OpenVidu is composed by the three modules displayed on the image above. openvidu-browser : JavaScript library for your Electron app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-electron/#running-this-tutorial","text":"1) You will need Node and NPM . Install them with the following commands sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs 2) Clone the repo git clone https://github.com/OpenVidu/openvidu-tutorials 3) Install dependencies and run the tutorial cd openvidu-tutorials/openvidu-electron npm install npm start 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) The app will start automatically as a native desktop application, regardless of the OS you are using. If you are on Windows, it will launch as a Windows app. In OSX as an OSX app, and in Linux as a Linux app. If you are using Windows , read this FAQ to properly run the tutorial","title":"Running this tutorial"},{"location":"tutorials/openvidu-electron/#understanding-the-code","text":"As an Electron app, the project has a main.js file that serves as entry point. It has not been modified at all, so it remains the same as it is by default in the electron-quick-start example. Most important files are the following ones: openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. axios.min.js : library for making HTTP requests from the app. You don't have to manipulate this file. modal.html : this is the dialog for selecting the screen to share if the user wants to do so. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . style.css : some CSS classes to style the app. index.html : HTML code for the form to connect to a video-call and for the video-call itself. It has links to 3 JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"axios.min.js\"></script> <script src=\"app.js\"></script> We have implemented screen-sharing capabilities in this application because the process is slightly different from the rest of platforms that support it. Electron does not provide a default screen selector dialog, so we must implement it ourselves (that is the purpose of modal.html file). You can check out this feature in the last section Screen sharing . Let's see first how app.js uses openvidu-browser-VERSION.js :","title":"Understanding the code"},{"location":"tutorials/openvidu-electron/#first-lines-declare-the-variables-that-will-be-needed-in-different-points-along-the-code","text":"const ipcRenderer = require('electron').ipcRenderer; const BrowserWindow = require('electron').remote.BrowserWindow; var openvidu; var session; var publisher; var mySessionId; Constants ipcRenderer and BrowserWindow are Electron objects we will need for our screen selector dialog. openvidu will be our OpenVidu object (entry point to the library). session will be the video-call we will connect to. publisher will be our media stream to publish to the session, and finally mySessionId simply identifies the session to connect to.","title":"First lines declare the variables that will be needed in different points along the code"},{"location":"tutorials/openvidu-electron/#initialize-a-publisher","text":"function initPublisher() { openvidu = new OpenVidu(); const shareScreen = document.getElementById(\"screen-sharing\").checked; if (shareScreen) { openScreenShareModal(); } else { publisher = openvidu.initPublisher(\"publisher\"); joinSession(); } } We will first initialize a Publisher before connecting to the session. If the user hasn't checked the screen sharing checkbox, we simply call openvidu.initPublisher indicating that we want openvidu-browser to insert our local video inside HTML element with id publisher . Then we proceed to join to the session. If you want to see how to initialize a screen sharing Publisher instead of the webcam, go to section Screen sharing","title":"Initialize a publisher"},{"location":"tutorials/openvidu-electron/#initialize-the-session","text":"function joinSession() { session = openvidu.initSession(); session.on(\"streamCreated\", function (event) { session.subscribe(event.stream, \"subscriber\"); }); Once we have our Publisher properly initialized, we continue by creating a Session object. We do so with openvidu.initSession method. We then have to configure our session to listen to streamCreated events, so we are able to subscribe to other user media streams when they publish.","title":"Initialize the session"},{"location":"tutorials/openvidu-electron/#get-a-token-from-openvidu-server","text":"We are ready to join the session. But we still need an OpenVidu token, so we must ask for it to openvidu-server. We use axios.min.js library to do so. getToken(mySessionId).then(token => { // See next point to see how to connect to the session using 'token' }); WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First HTTP request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-electron/#connect-to-the-session-using-the-token","text":"getToken(mySessionId).then(token => { session.connect(token) .then(() => { showSession(); session.publish(publisher); }) .catch(error => { console.log(\"There was an error connecting to the session:\", error.code, error.message); }); }); We simply need to call session.connect passing the recently retrieved token from OpenVidu Server. This method returns a Promise to which you can subscribe to. In case of success we first set the view to the active video session. Then we proceed to publish our previously created Publisher by calling session.publish . At this point the rest of users connected to this session will trigger their own streamCreated event and can start watching our media stream.","title":"Connect to the session using the token"},{"location":"tutorials/openvidu-electron/#leaving-the-session","text":"function leaveSession() { session.disconnect(); hideSession(); } Whenever we want a user to leave the session, we just need to call session.disconnect method. Here it will be called inside leaveSession function, triggered when the user clicks on \"LEAVE\" button. This function also returns the page to the \"Join a video session\" view.","title":"Leaving the session"},{"location":"tutorials/openvidu-electron/#screen-sharing","text":"The process to screen-share is slightly different from the rest of platforms that support it. Electron does not provide a default screen selector dialog as browsers do, so we must implement it ourselves (that is the purpose of modal.html file). We need a screen unique identifier to initialize our Publisher object like this: OpenVidu.initPublisher({videoSource: \"screen:\" + SCREEN_ID}); // While in other platforms is simply {videoSource: \"screen\"}, // which triggers the screen selector dialog of the browser First of all, we must be able to communicate different windows of the application, because in this case the screen selector dialog will be a completely separate window. But of course you could implement it in the same main window of your app, that's up to you. In main.js we import ipcMain from Electron and configure it to listen to screen-share-selected event. Upon this event it will notify our app with other event ( screen-share-ready ), passing the same message received from the sender. const { app, BrowserWindow, ipcMain } = require('electron'); // ... ipcMain.on('screen-share-selected', (event, message) => { mainWindow.webContents.send('screen-share-ready', message); }); In app.js file, where all our logic lies, we import ipcRenderer and configure it to listen to screen-share-ready event, sent from our main.js file as shown above. At this point we have the necessary parameter to initialize our Publisher: ipcRenderer.on('screen-share-ready', (event, message) => { // User has chosen a screen to share. screenId is message parameter showSession(); publisher = openvidu.initPublisher(\"publisher\", { videoSource: \"screen:\" + message }); joinSession(); }); So, where's the code that initiates this whole event process? That is modal.html file. This HTML view will be launched by app.js file in method initPublisher if the user has checked the screen-sharing checkbox. Method openScreenShareModal will be called then: function openScreenShareModal() { let win = new BrowserWindow({ parent: require('electron').remote.getCurrentWindow(), modal: true, minimizable: false, maximizable: false, webPreferences: { nodeIntegration: true }, resizable: false }) win.setMenu(null); // win.webContents.openDevTools(); var theUrl = 'file://' + __dirname + '/modal.html' win.loadURL(theUrl); } This code will launch modal.html template in a child window. In this file we use Electron API desktopCapturer to list and present all available screens. The user is able to select any of them and by clicking button \"Share\" the selected screen id will be sent as an event screen-share-selected just before closing this child window, by making use of the same ipcRenderer object as app.js do. var availableScreens = []; var htmlElements = []; var selectedElement; const { desktopCapturer } = require('electron') const ipcRenderer = require('electron').ipcRenderer; // Call Electron API to list all available screens desktopCapturer.getSources({ types: ['window', 'screen'] }).then(async sources => { const list = document.getElementById(\"list-of-screens\"); sources.forEach(source => { // Add new element to the list with the thumbnail of the screen var el = document.createElement(\"div\"); el.onclick = () => { // Style the new selected screen and store it as the current selection htmlElements.forEach(e => { e.style.border = \"none\"; e.style.background = \"none\"; }) el.style.border = \"2px solid #0088aa\"; el.style.background = \"rgba(0, 0, 0, 0.06)\"; selectedElement = el; document.getElementById(\"share-btn\").disabled = false; } // Store the new source and the new created HTML element availableScreens.push(source); htmlElements.push(el); var img = document.createElement(\"img\"); var name = document.createElement(\"span\"); img.src = source.thumbnail.toDataURL(); name.innerHTML = source.name; // Append new elements to the template el.appendChild(img); el.appendChild(name); list.appendChild(el); }); }); function sendScreenSelection() { ipcRenderer.send('screen-share-selected', availableScreens[htmlElements.indexOf(selectedElement)].id); closeWindow(); }","title":"Screen sharing"},{"location":"tutorials/openvidu-hello-world/","text":"openvidu-hello-world Check it on GitHub This is the simplest demo you can try to get started with OpenVidu API. It has the minimum set of features to make a group video-call. You will only need a few minutes to get your first application working! Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need an http web server installed in your development computer to execute the tutorial. If you have node.js installed, you can use http-server to serve application files. It can be installed with: npm install -g http-server 3) Run the tutorial: http-server openvidu-tutorials/openvidu-hello-world/web 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8080 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This application is very simple. It has only 4 files: openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . style.css : some CSS classes to style index.html . index.html : HTML code for the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"app.js\"></script> Let's see how app.js uses openvidu-browser-VERSION.js : First lines declare the variables that will be needed in different points along the code var OV; var session; OV will be our OpenVidu object (entrypoint to the library). session will be the video-call we will connect to. As first sentence in the joinSession() method, we initialize the variable that will identify our video-call retrieving the value from the HTML input. var mySessionId = document.getElementById(\"sessionId\").value; Initialize a new session and its events OV = new OpenVidu(); session = OV.initSession(); session.on('streamCreated', function (event) { session.subscribe(event.stream, 'subscriber'); }); As you can see in the code, the process is very simple: get an OpenVidu object and initialize a Session object with it. Then you can subscribe to all the events you want for your session. In this case we just want to subscribe to every stream that is being created in the session: on streamCreated we subscribe to the specific stream, available at event.stream property. You can take a look at all the events in the Reference Documentation Get a token from OpenVidu Server WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server getToken(mySessionId).then(token => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Connect to the session using the token getToken(mySessionId).then(token => { session.connect(token) .then(() => { document.getElementById(\"session-header\").innerText = mySessionId; document.getElementById(\"join\").style.display = \"none\"; document.getElementById(\"session\").style.display = \"block\"; var publisher = OV.initPublisher(\"publisher\"); session.publish(publisher); }) .catch(error => { console.log(\"There was an error connecting to the session:\", error.code, error.message); }); }); We simply need to call session.connect passing the recently retrieved token from OpenVidu Server. This method returns a Promise to which you can subscribe to. In case of success we first set the view to the active video session. Then we proceed to publish our webcam. To do so we just get a publisher using OpenVidu.initPublisher method, and a new HTML video showing our webcam will be appended to the page inside element with id \"publisher\" . Last but not least, we publish this publisher object thanks to session.publish . At this point the rest of users connected to this session will trigger their own streamCreated event and can start watching our webcam. Leaving the session session.disconnect(); Whenever we want a user to leave the session, we just need to call session.disconnect method. Here it will be called inside leaveSession function, triggered when the user clicks on \"LEAVE\" button. This function also returns the page to the \"Join session\" view.","title":"openvidu-hello-world"},{"location":"tutorials/openvidu-hello-world/#openvidu-hello-world","text":"Check it on GitHub This is the simplest demo you can try to get started with OpenVidu API. It has the minimum set of features to make a group video-call. You will only need a few minutes to get your first application working!","title":"openvidu-hello-world"},{"location":"tutorials/openvidu-hello-world/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need an http web server installed in your development computer to execute the tutorial. If you have node.js installed, you can use http-server to serve application files. It can be installed with: npm install -g http-server 3) Run the tutorial: http-server openvidu-tutorials/openvidu-hello-world/web 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8080 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-hello-world/#understanding-the-code","text":"This application is very simple. It has only 4 files: openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . style.css : some CSS classes to style index.html . index.html : HTML code for the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"app.js\"></script> Let's see how app.js uses openvidu-browser-VERSION.js :","title":"Understanding the code"},{"location":"tutorials/openvidu-hello-world/#first-lines-declare-the-variables-that-will-be-needed-in-different-points-along-the-code","text":"var OV; var session; OV will be our OpenVidu object (entrypoint to the library). session will be the video-call we will connect to. As first sentence in the joinSession() method, we initialize the variable that will identify our video-call retrieving the value from the HTML input. var mySessionId = document.getElementById(\"sessionId\").value;","title":"First lines declare the variables that will be needed in different points along the code"},{"location":"tutorials/openvidu-hello-world/#initialize-a-new-session-and-its-events","text":"OV = new OpenVidu(); session = OV.initSession(); session.on('streamCreated', function (event) { session.subscribe(event.stream, 'subscriber'); }); As you can see in the code, the process is very simple: get an OpenVidu object and initialize a Session object with it. Then you can subscribe to all the events you want for your session. In this case we just want to subscribe to every stream that is being created in the session: on streamCreated we subscribe to the specific stream, available at event.stream property. You can take a look at all the events in the Reference Documentation","title":"Initialize a new session and its events"},{"location":"tutorials/openvidu-hello-world/#get-a-token-from-openvidu-server","text":"WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server getToken(mySessionId).then(token => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-hello-world/#connect-to-the-session-using-the-token","text":"getToken(mySessionId).then(token => { session.connect(token) .then(() => { document.getElementById(\"session-header\").innerText = mySessionId; document.getElementById(\"join\").style.display = \"none\"; document.getElementById(\"session\").style.display = \"block\"; var publisher = OV.initPublisher(\"publisher\"); session.publish(publisher); }) .catch(error => { console.log(\"There was an error connecting to the session:\", error.code, error.message); }); }); We simply need to call session.connect passing the recently retrieved token from OpenVidu Server. This method returns a Promise to which you can subscribe to. In case of success we first set the view to the active video session. Then we proceed to publish our webcam. To do so we just get a publisher using OpenVidu.initPublisher method, and a new HTML video showing our webcam will be appended to the page inside element with id \"publisher\" . Last but not least, we publish this publisher object thanks to session.publish . At this point the rest of users connected to this session will trigger their own streamCreated event and can start watching our webcam.","title":"Connect to the session using the token"},{"location":"tutorials/openvidu-hello-world/#leaving-the-session","text":"session.disconnect(); Whenever we want a user to leave the session, we just need to call session.disconnect method. Here it will be called inside leaveSession function, triggered when the user clicks on \"LEAVE\" button. This function also returns the page to the \"Join session\" view.","title":"Leaving the session"},{"location":"tutorials/openvidu-insecure-angular/","text":"openvidu-insecure-angular Check it on GitHub A client-side only application built with Angular 7 framework. If it is the first time you use OpenVidu, it is highly recommended to start with openvidu-hello-world tutorial, as this app is no more than an extension of it with some new features and styles. This is the Angular version of openvidu-insecure-js . Try it if you plan to use Angular framework for your frontend. Understanding this tutorial OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials. Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need angular-cli (and of course NPM) to serve the Angular frontend. You can install it with the following command: npm install -g @angular/cli@6.2.4 3) Run the tutorial: cd openvidu-tutorials/openvidu-insecure-angular npm install ng serve 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:4200 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This is an Angular project generated with angular-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/app/ folder: app.component.ts : defines AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves. app.component.html : HTML for AppComponent. app.component.css : CSS for AppComponent. user-video.component.ts : defines UserVideoComponent , used to display every user video. It contains one OpenViduVideoComponent , the name of the user and also handles a click event to update the view of AppComponent . ov-video.component.ts : defines OpenViduVideoComponent , which wraps the final HTML <video> that finally displays the media stream. Let's see first how app.component.ts uses NPM package openvidu-browser : We import the necessary objects from openvidu-browser : import { OpenVidu, Publisher, Session, StreamEvent, StreamManager, Subscriber } from 'openvidu-browser'; app.component.ts declares the following properties: // OpenVidu objects OV: OpenVidu; session: Session; publisher: StreamManager; // Local subscribers: StreamManager[] = []; // Remotes // Join form mySessionId: string; myUserName: string; // Main video of the page, will be 'publisher' or one of the 'subscribers', // updated by click event in UserVideoComponent children mainStreamManager: StreamManager; OpenVidu object will allow us to get a Session object, which is declared just after it. publisher StreamManager object will be our own local webcam stream and subscribers StreamManager array will store the active streams of other users in the video-call. Finally, mySessionId and myUserName params simply represent the video-call and your participant's nickname, as you will see in a moment. Whenever a user clicks on the submit input defined in app.component.html , joinSession() method is called: We first get an OpenVidu object and initialize a Session object with it. // --- 1) Get an OpenVidu object --- this.OV = new OpenVidu(); // --- 2) Init a session --- this.session = this.OV.initSession(); Then we subscribe to the Session events that interest us. // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... this.session.on('streamCreated', (event: StreamEvent) => { // Subscribe to the Stream to receive it. Second parameter is undefined // so OpenVidu doesn't create an HTML video by its own let subscriber: Subscriber = this.session.subscribe(event.stream, undefined); this.subscribers.push(subscriber); }); // On every Stream destroyed... this.session.on('streamDestroyed', (event: StreamEvent) => { // Remove the stream from 'subscribers' array this.deleteSubscriber(event.stream.streamManager); }); As we are using Angular framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each Subscriber object and let it manage its video. This component will be our UserVideoComponent . To do this, we need to store each new Subscriber we received in array subscribers (of the parent class StreamManager ), and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events: streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our subscribers array. Method session.subscribe has undefined as second parameter so OpenVidu doesn't insert and HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of AppComponent loops through subscribers array with an ngFor directive, declaring a UserVideoComponent for each subscriber. We feed them not really as Subscriber objects, but rather as their parent class StreamManager . This way we can reuse UserVideoComponent to also display our Publisher object (that also inhertis from class StreamManager). user-video also declares the click event so we can update the main video player view when the user clicks on its Publisher or any Subscriber videos. <div *ngFor=\"let sub of subscribers\" class=\"stream-container col-md-6 col-xs-6\"> <user-video [streamManager]=\"sub\" (click)=\"updateMainStreamManager(sub)\"></user-video> </div> streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from subscribers array, so Angular will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property streamManager that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream). Get a token from OpenVidu Server WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then(token => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token, using @angular/http library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Finally connect to the session and publish your webcam: // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then(token => { // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname this.session.connect(token, { clientData: this.myUserName }) .then(() => { // --- 5) Get your own camera stream --- // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video // element: we will manage it on our own) and with the desired properties let publisher: Publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 6) Publish your stream --- this.session.publish(publisher); // Set the main video in the page to display our webcam and store our Publisher this.mainStreamManager = publisher; this.publisher = publisher; }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); In session.connect method first param is the recently retrieved user token. Second param is the value every user will receive in event.stream.connection.data property on streamCreated event (this value will be used by UserVideoComponent to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input <input class=\"form-control\" type=\"text\" id=\"userName\" name=\"userName\" [(ngModel)]=\"myUserName\" required> (filled by the user). If the method succeeds, we proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties and publish it to the Session through Session.publish() method. The rest of users will receive our Stream object and will execute their streamCreated event. Finally we make the main video player (which is just another UserVideoComponent ) display the Publisher object by default. This is the HTML code that will display the main stream manager: <div *ngIf=\"mainStreamManager\" id=\"main-video\" class=\"col-md-6\"> <user-video [streamManager]=\"mainStreamManager\"></user-video> </div> And we store the Publisher under this.publisher , which is also of parent class StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by UserVideoComponent ): <div *ngIf=\"publisher\" class=\"stream-container col-md-6 col-xs-6\"> <user-video [streamManager]=\"publisher\" (click)=\"updateMainStreamManager(publisher)\"></user-video> </div> You can see that every <user-video> component for our Publisher and every Subscriber also updates the main video player when clicking on it. Last point worth considering is the implementation of UserVideoComponent and OpenViduVideoComponent . Each UserVideoComponent manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component OpenViduVideoComponent . Its main task is not managing the final video player (that is OpenViduVideoComponent responsibility), but displaying custom information for each one of them (the user's nickname in this case): <div> <ov-video [streamManager]=\"streamManager\"></ov-video> <div><p>{% raw %}{{getNicknameTag()}}{% endraw %}</p></div> </div> export class UserVideoComponent { @Input() streamManager: StreamManager; getNicknameTag() { // Gets the nickName of the user return JSON.parse(this.streamManager.stream.connection.data).clientData; } } OpenViduVideoComponent html template is just the video element: <video #videoElement></video> And the unique responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is Angular dependant: we get the video element with @ViewChild tag and we call the method once after the view has initialized ( ngAfterViewInit ) and once every time the StreamManager input changes ( set method with @Input tag) export class OpenViduVideoComponent implements AfterViewInit { @ViewChild('videoElement') elementRef: ElementRef; _streamManager: StreamManager; ngAfterViewInit() { this._streamManager.addVideoElement(this.elementRef.nativeElement); } @Input() set streamManager(streamManager: StreamManager) { this._streamManager = streamManager; if (!!this.elementRef) { this._streamManager.addVideoElement(this.elementRef.nativeElement); } } } Leaving the session Whenever we want a user to leave the session, we just need to call session.disconnect method in app.component.ts : leaveSession() { // --- 7) Leave the session by calling 'disconnect' method over the Session object --- if (this.session) { this.session.disconnect(); }; // Empty all properties... this.subscribers = []; delete this.publisher; delete this.session; delete this.OV; this.generateParticipantInfo(); } $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-insecure-angular"},{"location":"tutorials/openvidu-insecure-angular/#openvidu-insecure-angular","text":"Check it on GitHub A client-side only application built with Angular 7 framework. If it is the first time you use OpenVidu, it is highly recommended to start with openvidu-hello-world tutorial, as this app is no more than an extension of it with some new features and styles. This is the Angular version of openvidu-insecure-js . Try it if you plan to use Angular framework for your frontend.","title":"openvidu-insecure-angular"},{"location":"tutorials/openvidu-insecure-angular/#understanding-this-tutorial","text":"OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-insecure-angular/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need angular-cli (and of course NPM) to serve the Angular frontend. You can install it with the following command: npm install -g @angular/cli@6.2.4 3) Run the tutorial: cd openvidu-tutorials/openvidu-insecure-angular npm install ng serve 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:4200 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-insecure-angular/#understanding-the-code","text":"This is an Angular project generated with angular-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/app/ folder: app.component.ts : defines AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves. app.component.html : HTML for AppComponent. app.component.css : CSS for AppComponent. user-video.component.ts : defines UserVideoComponent , used to display every user video. It contains one OpenViduVideoComponent , the name of the user and also handles a click event to update the view of AppComponent . ov-video.component.ts : defines OpenViduVideoComponent , which wraps the final HTML <video> that finally displays the media stream. Let's see first how app.component.ts uses NPM package openvidu-browser :","title":"Understanding the code"},{"location":"tutorials/openvidu-insecure-angular/#we-import-the-necessary-objects-from-openvidu-browser","text":"import { OpenVidu, Publisher, Session, StreamEvent, StreamManager, Subscriber } from 'openvidu-browser';","title":"We import the necessary objects from openvidu-browser:"},{"location":"tutorials/openvidu-insecure-angular/#appcomponentts-declares-the-following-properties","text":"// OpenVidu objects OV: OpenVidu; session: Session; publisher: StreamManager; // Local subscribers: StreamManager[] = []; // Remotes // Join form mySessionId: string; myUserName: string; // Main video of the page, will be 'publisher' or one of the 'subscribers', // updated by click event in UserVideoComponent children mainStreamManager: StreamManager; OpenVidu object will allow us to get a Session object, which is declared just after it. publisher StreamManager object will be our own local webcam stream and subscribers StreamManager array will store the active streams of other users in the video-call. Finally, mySessionId and myUserName params simply represent the video-call and your participant's nickname, as you will see in a moment.","title":"app.component.ts declares the following properties:"},{"location":"tutorials/openvidu-insecure-angular/#whenever-a-user-clicks-on-the-submit-input-defined-in-appcomponenthtml-joinsession-method-is-called","text":"We first get an OpenVidu object and initialize a Session object with it. // --- 1) Get an OpenVidu object --- this.OV = new OpenVidu(); // --- 2) Init a session --- this.session = this.OV.initSession(); Then we subscribe to the Session events that interest us. // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... this.session.on('streamCreated', (event: StreamEvent) => { // Subscribe to the Stream to receive it. Second parameter is undefined // so OpenVidu doesn't create an HTML video by its own let subscriber: Subscriber = this.session.subscribe(event.stream, undefined); this.subscribers.push(subscriber); }); // On every Stream destroyed... this.session.on('streamDestroyed', (event: StreamEvent) => { // Remove the stream from 'subscribers' array this.deleteSubscriber(event.stream.streamManager); }); As we are using Angular framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each Subscriber object and let it manage its video. This component will be our UserVideoComponent . To do this, we need to store each new Subscriber we received in array subscribers (of the parent class StreamManager ), and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events: streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our subscribers array. Method session.subscribe has undefined as second parameter so OpenVidu doesn't insert and HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of AppComponent loops through subscribers array with an ngFor directive, declaring a UserVideoComponent for each subscriber. We feed them not really as Subscriber objects, but rather as their parent class StreamManager . This way we can reuse UserVideoComponent to also display our Publisher object (that also inhertis from class StreamManager). user-video also declares the click event so we can update the main video player view when the user clicks on its Publisher or any Subscriber videos. <div *ngFor=\"let sub of subscribers\" class=\"stream-container col-md-6 col-xs-6\"> <user-video [streamManager]=\"sub\" (click)=\"updateMainStreamManager(sub)\"></user-video> </div> streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from subscribers array, so Angular will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property streamManager that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).","title":"Whenever a user clicks on the submit input defined in app.component.html, joinSession() method is called:"},{"location":"tutorials/openvidu-insecure-angular/#get-a-token-from-openvidu-server","text":"WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then(token => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token, using @angular/http library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-insecure-angular/#finally-connect-to-the-session-and-publish-your-webcam","text":"// --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then(token => { // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname this.session.connect(token, { clientData: this.myUserName }) .then(() => { // --- 5) Get your own camera stream --- // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video // element: we will manage it on our own) and with the desired properties let publisher: Publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 6) Publish your stream --- this.session.publish(publisher); // Set the main video in the page to display our webcam and store our Publisher this.mainStreamManager = publisher; this.publisher = publisher; }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); In session.connect method first param is the recently retrieved user token. Second param is the value every user will receive in event.stream.connection.data property on streamCreated event (this value will be used by UserVideoComponent to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input <input class=\"form-control\" type=\"text\" id=\"userName\" name=\"userName\" [(ngModel)]=\"myUserName\" required> (filled by the user). If the method succeeds, we proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties and publish it to the Session through Session.publish() method. The rest of users will receive our Stream object and will execute their streamCreated event. Finally we make the main video player (which is just another UserVideoComponent ) display the Publisher object by default. This is the HTML code that will display the main stream manager: <div *ngIf=\"mainStreamManager\" id=\"main-video\" class=\"col-md-6\"> <user-video [streamManager]=\"mainStreamManager\"></user-video> </div> And we store the Publisher under this.publisher , which is also of parent class StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by UserVideoComponent ): <div *ngIf=\"publisher\" class=\"stream-container col-md-6 col-xs-6\"> <user-video [streamManager]=\"publisher\" (click)=\"updateMainStreamManager(publisher)\"></user-video> </div> You can see that every <user-video> component for our Publisher and every Subscriber also updates the main video player when clicking on it. Last point worth considering is the implementation of UserVideoComponent and OpenViduVideoComponent . Each UserVideoComponent manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component OpenViduVideoComponent . Its main task is not managing the final video player (that is OpenViduVideoComponent responsibility), but displaying custom information for each one of them (the user's nickname in this case): <div> <ov-video [streamManager]=\"streamManager\"></ov-video> <div><p>{% raw %}{{getNicknameTag()}}{% endraw %}</p></div> </div> export class UserVideoComponent { @Input() streamManager: StreamManager; getNicknameTag() { // Gets the nickName of the user return JSON.parse(this.streamManager.stream.connection.data).clientData; } } OpenViduVideoComponent html template is just the video element: <video #videoElement></video> And the unique responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is Angular dependant: we get the video element with @ViewChild tag and we call the method once after the view has initialized ( ngAfterViewInit ) and once every time the StreamManager input changes ( set method with @Input tag) export class OpenViduVideoComponent implements AfterViewInit { @ViewChild('videoElement') elementRef: ElementRef; _streamManager: StreamManager; ngAfterViewInit() { this._streamManager.addVideoElement(this.elementRef.nativeElement); } @Input() set streamManager(streamManager: StreamManager) { this._streamManager = streamManager; if (!!this.elementRef) { this._streamManager.addVideoElement(this.elementRef.nativeElement); } } }","title":"Finally connect to the session and publish your webcam:"},{"location":"tutorials/openvidu-insecure-angular/#leaving-the-session","text":"Whenever we want a user to leave the session, we just need to call session.disconnect method in app.component.ts : leaveSession() { // --- 7) Leave the session by calling 'disconnect' method over the Session object --- if (this.session) { this.session.disconnect(); }; // Empty all properties... this.subscribers = []; delete this.publisher; delete this.session; delete this.OV; this.generateParticipantInfo(); } $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Leaving the session"},{"location":"tutorials/openvidu-insecure-js/","text":"openvidu-insecure-js Check it on GitHub A client-side only application built with JavaScript, HTML and CSS. If it is the first time you use OpenVidu, it is highly recommended to start with openvidu-hello-world tutorial, as this app is no more than an extension of it with some new features and styles. Understanding this tutorial OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flows transmission Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials. Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need an http web server installed in your development computer to execute the sample application. If you have node.js installed, you can use http-server to serve application files. It can be installed with: npm install -g http-server 3) Run the tutorial: http-server openvidu-tutorials/openvidu-insecure-js/web 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8080 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This application is very simple. It has only 4 files: openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . You can manipulate this file to suit your needs. style.css : some CSS classes to style index.html . You can manipulate this file to suit your needs. index.html : HTML code for the form to connect to a video-call and for the video-call itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"app.js\"></script> Let's see how app.js uses openvidu-browser-VERSION.js : First lines declare the variables that will be needed in different points along the code var OV; var session; OV will be our OpenVidu object (entrypoint to the library). session will be the video-call we will connect to. As first sentences in the join method, we initialize the two parameters whose value is retrieved from the HTML inputs. var mySessionId = document.getElementById(\"sessionId\").value; // Session the user will join var myUserName = document.getElementById(\"userName\").value; // Nickname of the user in the session Let's initialize a new session and configure our events: // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); As you can see in the code, the process is very simple: get an OpenVidu object and initialize a Session object with it. // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', event => { // Subscribe to the Stream to receive it. HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', event => { // Add a new <p> element for the user's nickname just below its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', event => { // Delete the HTML element with the user's nickname. HTML videos are automatically removed from DOM removeUserData(event.stream.connection); }); Here we subscribe to the events that interest us. In this case, we want to receive all videos published to the session, as well as displaying every user's nickname next to its video. To achieve this: streamCreated : for each new Stream received by OpenVidu, we immediately subscribe to it so we can see its video. A new HTML video element will be appended to element with id 'video-container'. videoElementCreated : event triggered by Subscriber object (returned by the previous Session.subscribe method). This allows us to add the participant nickname to the new video previously added in streamCreated event. Auxiliary method appendUserData is responsible for appending a new paragraph element just below the event.element video, containing subscriber.stream.connection.data field. In this case, this field contains the user's nickName. You can see how to feed this property from the client in a later step. streamDestroyed : for each Stream that has been destroyed (which means a user has left the video-call), we remove the element with the user's nickname that we added in the previous event with the auxiliary method removeUserData ( appendUserData method created the element with an id containing event.stream.connection.connectionId unique value, so we can now identify the right element to be removed). OpenVidu automatically deletes the proper video element by default, so we don't need to do anything else. Check Application specific methods section to see all the auxiliary methods used in this app Get a token from OpenVidu Server WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend getToken(mySessionId).then(token => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Finally connect to the session using the token and publish your webcam: // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend getToken(mySessionId).then(token => { // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname session.connect(token, { clientData: myUserName }) .then(() => { // --- 5) Set page layout for active call --- document.getElementById('session-title').innerText = mySessionId; document.getElementById('join').style.display = 'none'; document.getElementById('session').style.display = 'block'; // --- 6) Get your own camera stream with the desired properties --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', function (event) { initMainVideo(event.element, myUserName); appendUserData(event.element, myUserName); event.element['muted'] = true; }); // --- 8) Publish your stream --- session.publish(publisher); }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); In session.connect method first param is the recently retrieved user token. Remember videoElementCreated event for the Subscriber object, when we added the user's nickname to the HTML? Well, second parameter is the actual value every user will receive in Stream.connection.data property in that event. So in this case it is an object with a property \"clientData\" with value \"myUserName\", which has been set in the first step to the value retrieved from HTML input <input class=\"form-control\" type=\"text\" id=\"userName\" required> (this is filled by the user). If the method succeeds, we first change our view to the active call (5) and then proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties (6). This process will end with the addition of a new HTML video element showing your camera, as a child of element with id 'video-container'. Event videoElementCreated will be fired by the Publisher object just after this video is added to DOM, so we can subscribe to it and do whatever we want with it. In this case, we init another bigger video element with our video and append our nickname to it, by using auxiliary methods initMainVideo and appendUserData (7). Finally we just have to publish publisher object through Session.publish method (8), and the rest of users will begin receiving our webcam ('streamCreated' event will be fired for them). Leaving the session Whenever we want a user to leave the session, we just need to call session.disconnect method: function leaveSession() { // --- 9) Leave the session by calling 'disconnect' method over the Session object --- session.disconnect(); // Removing all HTML elements with user's nicknames. // HTML videos are automatically removed when leaving a Session removeAllUserData(); // Back to 'Join session' page document.getElementById('join').style.display = 'block'; document.getElementById('session').style.display = 'none'; } Application specific methods Here you have all the auxiliary methods used in this app, which are not directly related to OpenVidu: /* APPLICATION SPECIFIC METHODS */ window.addEventListener('load', function () { generateParticipantInfo(); }); window.onbeforeunload = function () { if (session) session.disconnect(); }; function generateParticipantInfo() { document.getElementById(\"sessionId\").value = \"SessionA\"; document.getElementById(\"userName\").value = \"Participant\" + Math.floor(Math.random() * 100); } function appendUserData(videoElement, connection) { var userData; var nodeId; if (typeof connection === \"string\") { userData = connection; nodeId = connection; } else { userData = JSON.parse(connection.data).clientData; nodeId = connection.connectionId; } var dataNode = document.createElement('div'); dataNode.className = \"data-node\"; dataNode.id = \"data-\" + nodeId; dataNode.innerHTML = \"<p>\" + userData + \"</p>\"; videoElement.parentNode.insertBefore(dataNode, videoElement.nextSibling); addClickListener(videoElement, userData); } function removeUserData(connection) { var dataNode = document.getElementById(\"data-\" + connection.connectionId); dataNode.parentNode.removeChild(dataNode); } function removeAllUserData() { var nicknameElements = document.getElementsByClassName('data-node'); while (nicknameElements[0]) { nicknameElements[0].parentNode.removeChild(nicknameElements[0]); } } function addClickListener(videoElement, userData) { videoElement.addEventListener('click', function () { var mainVideo = document.querySelector('#main-video video'); var mainUserData = document.querySelector('#main-video p'); if (mainVideo.srcObject !== videoElement.srcObject) { mainUserData.innerHTML = userData; mainVideo.srcObject = videoElement.srcObject; } }); } function initMainVideo(videoElement, userData) { document.querySelector('#main-video video').srcObject = videoElement.srcObject; document.querySelector('#main-video p').innerHTML = userData; document.querySelector('#main-video video')['muted'] = true; } $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-insecure-js"},{"location":"tutorials/openvidu-insecure-js/#openvidu-insecure-js","text":"Check it on GitHub A client-side only application built with JavaScript, HTML and CSS. If it is the first time you use OpenVidu, it is highly recommended to start with openvidu-hello-world tutorial, as this app is no more than an extension of it with some new features and styles.","title":"openvidu-insecure-js"},{"location":"tutorials/openvidu-insecure-js/#understanding-this-tutorial","text":"OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flows transmission Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-insecure-js/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need an http web server installed in your development computer to execute the sample application. If you have node.js installed, you can use http-server to serve application files. It can be installed with: npm install -g http-server 3) Run the tutorial: http-server openvidu-tutorials/openvidu-insecure-js/web 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8080 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-insecure-js/#understanding-the-code","text":"This application is very simple. It has only 4 files: openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . You can manipulate this file to suit your needs. style.css : some CSS classes to style index.html . You can manipulate this file to suit your needs. index.html : HTML code for the form to connect to a video-call and for the video-call itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"app.js\"></script> Let's see how app.js uses openvidu-browser-VERSION.js :","title":"Understanding the code"},{"location":"tutorials/openvidu-insecure-js/#first-lines-declare-the-variables-that-will-be-needed-in-different-points-along-the-code","text":"var OV; var session; OV will be our OpenVidu object (entrypoint to the library). session will be the video-call we will connect to. As first sentences in the join method, we initialize the two parameters whose value is retrieved from the HTML inputs. var mySessionId = document.getElementById(\"sessionId\").value; // Session the user will join var myUserName = document.getElementById(\"userName\").value; // Nickname of the user in the session","title":"First lines declare the variables that will be needed in different points along the code"},{"location":"tutorials/openvidu-insecure-js/#lets-initialize-a-new-session-and-configure-our-events","text":"// --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); As you can see in the code, the process is very simple: get an OpenVidu object and initialize a Session object with it. // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', event => { // Subscribe to the Stream to receive it. HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', event => { // Add a new <p> element for the user's nickname just below its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', event => { // Delete the HTML element with the user's nickname. HTML videos are automatically removed from DOM removeUserData(event.stream.connection); }); Here we subscribe to the events that interest us. In this case, we want to receive all videos published to the session, as well as displaying every user's nickname next to its video. To achieve this: streamCreated : for each new Stream received by OpenVidu, we immediately subscribe to it so we can see its video. A new HTML video element will be appended to element with id 'video-container'. videoElementCreated : event triggered by Subscriber object (returned by the previous Session.subscribe method). This allows us to add the participant nickname to the new video previously added in streamCreated event. Auxiliary method appendUserData is responsible for appending a new paragraph element just below the event.element video, containing subscriber.stream.connection.data field. In this case, this field contains the user's nickName. You can see how to feed this property from the client in a later step. streamDestroyed : for each Stream that has been destroyed (which means a user has left the video-call), we remove the element with the user's nickname that we added in the previous event with the auxiliary method removeUserData ( appendUserData method created the element with an id containing event.stream.connection.connectionId unique value, so we can now identify the right element to be removed). OpenVidu automatically deletes the proper video element by default, so we don't need to do anything else. Check Application specific methods section to see all the auxiliary methods used in this app","title":"Let's initialize a new session and configure our events:"},{"location":"tutorials/openvidu-insecure-js/#get-a-token-from-openvidu-server","text":"WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend getToken(mySessionId).then(token => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-insecure-js/#finally-connect-to-the-session-using-the-token-and-publish-your-webcam","text":"// --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend getToken(mySessionId).then(token => { // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname session.connect(token, { clientData: myUserName }) .then(() => { // --- 5) Set page layout for active call --- document.getElementById('session-title').innerText = mySessionId; document.getElementById('join').style.display = 'none'; document.getElementById('session').style.display = 'block'; // --- 6) Get your own camera stream with the desired properties --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', function (event) { initMainVideo(event.element, myUserName); appendUserData(event.element, myUserName); event.element['muted'] = true; }); // --- 8) Publish your stream --- session.publish(publisher); }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); In session.connect method first param is the recently retrieved user token. Remember videoElementCreated event for the Subscriber object, when we added the user's nickname to the HTML? Well, second parameter is the actual value every user will receive in Stream.connection.data property in that event. So in this case it is an object with a property \"clientData\" with value \"myUserName\", which has been set in the first step to the value retrieved from HTML input <input class=\"form-control\" type=\"text\" id=\"userName\" required> (this is filled by the user). If the method succeeds, we first change our view to the active call (5) and then proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties (6). This process will end with the addition of a new HTML video element showing your camera, as a child of element with id 'video-container'. Event videoElementCreated will be fired by the Publisher object just after this video is added to DOM, so we can subscribe to it and do whatever we want with it. In this case, we init another bigger video element with our video and append our nickname to it, by using auxiliary methods initMainVideo and appendUserData (7). Finally we just have to publish publisher object through Session.publish method (8), and the rest of users will begin receiving our webcam ('streamCreated' event will be fired for them).","title":"Finally connect to the session using the token and publish your webcam:"},{"location":"tutorials/openvidu-insecure-js/#leaving-the-session","text":"Whenever we want a user to leave the session, we just need to call session.disconnect method: function leaveSession() { // --- 9) Leave the session by calling 'disconnect' method over the Session object --- session.disconnect(); // Removing all HTML elements with user's nicknames. // HTML videos are automatically removed when leaving a Session removeAllUserData(); // Back to 'Join session' page document.getElementById('join').style.display = 'block'; document.getElementById('session').style.display = 'none'; }","title":"Leaving the session"},{"location":"tutorials/openvidu-insecure-js/#application-specific-methods","text":"Here you have all the auxiliary methods used in this app, which are not directly related to OpenVidu: /* APPLICATION SPECIFIC METHODS */ window.addEventListener('load', function () { generateParticipantInfo(); }); window.onbeforeunload = function () { if (session) session.disconnect(); }; function generateParticipantInfo() { document.getElementById(\"sessionId\").value = \"SessionA\"; document.getElementById(\"userName\").value = \"Participant\" + Math.floor(Math.random() * 100); } function appendUserData(videoElement, connection) { var userData; var nodeId; if (typeof connection === \"string\") { userData = connection; nodeId = connection; } else { userData = JSON.parse(connection.data).clientData; nodeId = connection.connectionId; } var dataNode = document.createElement('div'); dataNode.className = \"data-node\"; dataNode.id = \"data-\" + nodeId; dataNode.innerHTML = \"<p>\" + userData + \"</p>\"; videoElement.parentNode.insertBefore(dataNode, videoElement.nextSibling); addClickListener(videoElement, userData); } function removeUserData(connection) { var dataNode = document.getElementById(\"data-\" + connection.connectionId); dataNode.parentNode.removeChild(dataNode); } function removeAllUserData() { var nicknameElements = document.getElementsByClassName('data-node'); while (nicknameElements[0]) { nicknameElements[0].parentNode.removeChild(nicknameElements[0]); } } function addClickListener(videoElement, userData) { videoElement.addEventListener('click', function () { var mainVideo = document.querySelector('#main-video video'); var mainUserData = document.querySelector('#main-video p'); if (mainVideo.srcObject !== videoElement.srcObject) { mainUserData.innerHTML = userData; mainVideo.srcObject = videoElement.srcObject; } }); } function initMainVideo(videoElement, userData) { document.querySelector('#main-video video').srcObject = videoElement.srcObject; document.querySelector('#main-video p').innerHTML = userData; document.querySelector('#main-video video')['muted'] = true; } $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Application specific methods"},{"location":"tutorials/openvidu-insecure-react/","text":"openvidu-insecure-react Check it on GitHub A client-side only application built with Reactjs . If it is the first time you use OpenVidu, it is highly recommended to start with openvidu-hello-world tutorial, as this app is no more than an extension of it with some new features and styles. This is the React version of openvidu-insecure-js . Try it if you plan to use React for your frontend. Understanding this tutorial OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials. Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need NPM to serve the React frontend. Once you have npm installed, you can run the tutorial. cd openvidu-tutorials/openvidu-insecure-react npm install npm start 3) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:3000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This is a React project generated with create-react-app, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/ folder: App.js : AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves. App.css : CSS for AppComponent. UserVideoComponent.js : UserVideoComponent , used to display every user video. It contains one OpenViduVideoComponent , the name of the user and also handles a click event to update the view of AppComponent . OpenViduVideoComponent : defines OpenViduVideoComponent , which wraps the final HTML <video> that finally displays the media stream. Let's see first how App.js uses NPM package openvidu-browser : We import the necessary objects from openvidu-browser : import { OpenVidu } from 'openvidu-browser'; App.js declares the following properties in the state: //These properties are in the state's component in order to re-render the HTML when the values of them change this.state = { mySessionId: 'SessionA', myUserName: 'Participant' + Math.floor(Math.random() * 100), session: undefined, mainStreamManager: undefined, // Main video of the page, will be 'publisher' or one of the 'subscribers', publisher: undefined, subscribers: [], }; OpenVidu object will allow us to get a Session object, which is declared just after it. publisher will be our own local webcam stream and subscribers array will store the active streams of other users in the video-call. Finally, mySessionId and myUserName params simply represent the video-call and your participant's nickname, as you will see in a moment. Whenever a user clicks on the submit input defined in App.js template, joinSession() method is called: We first get an OpenVidu object and initialize a session property in a state. // --- 1) Get an OpenVidu object --- this.OV = new OpenVidu(); // --- 2) Init a session --- this.setState({ session: this.OV.initSession(), }, () => { // See next step } ); Then we subscribe to the Session events that interest us. // --- 3) Specify the actions when events take place in the session --- var mySession = this.state.session; // On every new Stream received... mySession.on('streamCreated', (event) => { // Subscribe to the Stream to receive it. Second parameter is undefined // so OpenVidu doesn't create an HTML video by its own var subscriber = mySession.subscribe(event.stream, undefined); //We use an auxiliar array to push the new stream var subscribers = this.state.subscribers; subscribers.push(subscriber); // Update the state with the new subscribers this.setState({ subscribers: subscribers, }); }); // On every Stream destroyed... mySession.on('streamDestroyed', (event) => { event.preventDefault(); // Remove the stream from 'subscribers' array this.deleteSubscriber(event.stream.streamManager); }); // See next step Here we subscribe to the Session events that interest us. As we are using React framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each Subscriber object and let it manage its video. This component will be our UserVideoComponent . To do this, we need to store each new Subscriber we received in array subscribers , and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events: streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our subscribers array. Method session.subscribe has undefined as second parameter so OpenVidu doesn't insert and HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of AppComponent will show the new video, as it contains a .map js function, declaring a UserVideoComponent for each subscriber. We feed them not really as Subscriber objects, but rather as their parent class StreamManager . This way we can reuse UserVideoComponent to also display our Publisher object (that also inhertis from class StreamManager). {this.state.subscribers.map((sub, i) => ( <div key={i} className=\"stream-container col-md-6 col-xs-6\"> <UserVideoComponent streamManager={sub} mainVideoStream={this.handleMainVideoStream} /> </div> ))} streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from subscribers array, so React will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property streamManager that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream). Get a token from OpenVidu Server WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then(token => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token, using axios library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Finally connect to the session and publish your webcam: // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then(token => { // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname mySession.connect(token, { clientData: this.state.myUserName }) .then(() => { // --- 5) Get your own camera stream --- // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video // element: we will manage it on our own) and with the desired properties let publisher: Publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 6) Publish your stream --- mySession.publish(publisher); // Set the main video in the page to display our webcam and store our Publisher this.setState({ mainStreamManager: publisher, publisher: publisher, }); }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); In mySession.connect method first param is the recently retrieved user token. Second param is the value every user will receive in event.stream.connection.data property on streamCreated event (this value will be used by UserVideoComponent to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input <input className=\"form-control\" type=\"text\" id=\"userName\" value={myUserName} onChange={this.handleChangeUserName} required /> (filled by the user). If the method succeeds, we proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties and publish it to the Session through Session.publish() method. The rest of users will receive our Stream object and will execute their streamCreated event. Finally we make the main video player (which is just another UserVideoComponent ) display the Publisher object by default. This is the HTML code that will display the main stream manager: {this.state.mainStreamManager !== undefined ? ( <div id=\"main-video\" className=\"col-md-6\"> <UserVideoComponent streamManager={this.state.mainStreamManager} /> </div> ) : null} And we store the Publisher under this.state.publisher , which is also of parent class StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by UserVideoComponent ): {this.state.publisher !== undefined ? ( <div className=\"stream-container col-md-6 col-xs-6\"> <UserVideoComponent streamManager={this.state.publisher} mainVideoStream={this.handleMainVideoStream} /> </div> ) : null} Last point worth considering is the implementation of UserVideoComponent and OpenViduVideoComponent . Each UserVideoComponent manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component OpenViduVideoComponent . Its main task is not managing the final video player (that is OpenViduVideoComponent responsibility), but displaying custom information for each one of them (the user's nickname) and handling the click event on them to update property mainStreamManager of parent AppComponent : <div className=\"streamcomponent\" onClick={this.handleVideoClicked}> <OpenViduVideoComponent streamManager={this.props.streamManager} /> <div><p>{this.getNicknameTag()}</p></div> </div> export default class UserVideoComponent extends Component { constructor(props) { super(props); this.handleVideoClicked = this.handleVideoClicked.bind(this); } getNicknameTag() { // Gets the nickName of the user return JSON.parse(this.props.streamManager.stream.connection.data).clientData; } handleVideoClicked(event) { // Triggers event for the parent component to update its main video display (other UserVideoComponent) if (this.props.mainVideoStream) { this.props.mainVideoStream(this.props.streamManager); } } } OpenViduVideoComponent html template is just the video element: <video autoPlay={true} ref={this.videoRef} /> And the unique responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is React Refs: we get the video element with React.createRef() and we call the method once after the component output has been rendered to the DOM ( componentDidMount ). export default class OpenViduVideoComponent extends Component { constructor(props) { super(props); this.videoRef = React.createRef(); } componentDidMount() { if (this.props && !!this.videoRef) { this.props.streamManager.addVideoElement(this.videoRef.current); } } } Leaving the session Whenever we want a user to leave the session, we just need to call session.disconnect method in App.js : leaveSession() { // --- 7) Leave the session by calling 'disconnect' method over the Session object --- const mySession = this.state.session; if (mySession) { mySession.disconnect(); } // Empty all properties... this.OV = null; this.setState({ mySessionId: 'SessionA', myUserName: 'Participant' + Math.floor(Math.random() * 100), session: undefined, mainStreamManager: undefined, publisher: undefined, subscribers: [], }); } $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-insecure-react"},{"location":"tutorials/openvidu-insecure-react/#openvidu-insecure-react","text":"Check it on GitHub A client-side only application built with Reactjs . If it is the first time you use OpenVidu, it is highly recommended to start with openvidu-hello-world tutorial, as this app is no more than an extension of it with some new features and styles. This is the React version of openvidu-insecure-js . Try it if you plan to use React for your frontend.","title":"openvidu-insecure-react"},{"location":"tutorials/openvidu-insecure-react/#understanding-this-tutorial","text":"OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-insecure-react/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need NPM to serve the React frontend. Once you have npm installed, you can run the tutorial. cd openvidu-tutorials/openvidu-insecure-react npm install npm start 3) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:3000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-insecure-react/#understanding-the-code","text":"This is a React project generated with create-react-app, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/ folder: App.js : AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves. App.css : CSS for AppComponent. UserVideoComponent.js : UserVideoComponent , used to display every user video. It contains one OpenViduVideoComponent , the name of the user and also handles a click event to update the view of AppComponent . OpenViduVideoComponent : defines OpenViduVideoComponent , which wraps the final HTML <video> that finally displays the media stream. Let's see first how App.js uses NPM package openvidu-browser :","title":"Understanding the code"},{"location":"tutorials/openvidu-insecure-react/#we-import-the-necessary-objects-from-openvidu-browser","text":"import { OpenVidu } from 'openvidu-browser';","title":"We import the necessary objects from openvidu-browser:"},{"location":"tutorials/openvidu-insecure-react/#appjs-declares-the-following-properties-in-the-state","text":"//These properties are in the state's component in order to re-render the HTML when the values of them change this.state = { mySessionId: 'SessionA', myUserName: 'Participant' + Math.floor(Math.random() * 100), session: undefined, mainStreamManager: undefined, // Main video of the page, will be 'publisher' or one of the 'subscribers', publisher: undefined, subscribers: [], }; OpenVidu object will allow us to get a Session object, which is declared just after it. publisher will be our own local webcam stream and subscribers array will store the active streams of other users in the video-call. Finally, mySessionId and myUserName params simply represent the video-call and your participant's nickname, as you will see in a moment.","title":"App.js declares the following properties in the state:"},{"location":"tutorials/openvidu-insecure-react/#whenever-a-user-clicks-on-the-submit-input-defined-in-appjs-template-joinsession-method-is-called","text":"We first get an OpenVidu object and initialize a session property in a state. // --- 1) Get an OpenVidu object --- this.OV = new OpenVidu(); // --- 2) Init a session --- this.setState({ session: this.OV.initSession(), }, () => { // See next step } ); Then we subscribe to the Session events that interest us. // --- 3) Specify the actions when events take place in the session --- var mySession = this.state.session; // On every new Stream received... mySession.on('streamCreated', (event) => { // Subscribe to the Stream to receive it. Second parameter is undefined // so OpenVidu doesn't create an HTML video by its own var subscriber = mySession.subscribe(event.stream, undefined); //We use an auxiliar array to push the new stream var subscribers = this.state.subscribers; subscribers.push(subscriber); // Update the state with the new subscribers this.setState({ subscribers: subscribers, }); }); // On every Stream destroyed... mySession.on('streamDestroyed', (event) => { event.preventDefault(); // Remove the stream from 'subscribers' array this.deleteSubscriber(event.stream.streamManager); }); // See next step Here we subscribe to the Session events that interest us. As we are using React framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each Subscriber object and let it manage its video. This component will be our UserVideoComponent . To do this, we need to store each new Subscriber we received in array subscribers , and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events: streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our subscribers array. Method session.subscribe has undefined as second parameter so OpenVidu doesn't insert and HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of AppComponent will show the new video, as it contains a .map js function, declaring a UserVideoComponent for each subscriber. We feed them not really as Subscriber objects, but rather as their parent class StreamManager . This way we can reuse UserVideoComponent to also display our Publisher object (that also inhertis from class StreamManager). {this.state.subscribers.map((sub, i) => ( <div key={i} className=\"stream-container col-md-6 col-xs-6\"> <UserVideoComponent streamManager={sub} mainVideoStream={this.handleMainVideoStream} /> </div> ))} streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from subscribers array, so React will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property streamManager that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).","title":"Whenever a user clicks on the submit input defined in App.js template, joinSession() method is called:"},{"location":"tutorials/openvidu-insecure-react/#get-a-token-from-openvidu-server","text":"WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then(token => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token, using axios library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-insecure-react/#finally-connect-to-the-session-and-publish-your-webcam","text":"// --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then(token => { // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname mySession.connect(token, { clientData: this.state.myUserName }) .then(() => { // --- 5) Get your own camera stream --- // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video // element: we will manage it on our own) and with the desired properties let publisher: Publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 6) Publish your stream --- mySession.publish(publisher); // Set the main video in the page to display our webcam and store our Publisher this.setState({ mainStreamManager: publisher, publisher: publisher, }); }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); In mySession.connect method first param is the recently retrieved user token. Second param is the value every user will receive in event.stream.connection.data property on streamCreated event (this value will be used by UserVideoComponent to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input <input className=\"form-control\" type=\"text\" id=\"userName\" value={myUserName} onChange={this.handleChangeUserName} required /> (filled by the user). If the method succeeds, we proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties and publish it to the Session through Session.publish() method. The rest of users will receive our Stream object and will execute their streamCreated event. Finally we make the main video player (which is just another UserVideoComponent ) display the Publisher object by default. This is the HTML code that will display the main stream manager: {this.state.mainStreamManager !== undefined ? ( <div id=\"main-video\" className=\"col-md-6\"> <UserVideoComponent streamManager={this.state.mainStreamManager} /> </div> ) : null} And we store the Publisher under this.state.publisher , which is also of parent class StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by UserVideoComponent ): {this.state.publisher !== undefined ? ( <div className=\"stream-container col-md-6 col-xs-6\"> <UserVideoComponent streamManager={this.state.publisher} mainVideoStream={this.handleMainVideoStream} /> </div> ) : null} Last point worth considering is the implementation of UserVideoComponent and OpenViduVideoComponent . Each UserVideoComponent manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component OpenViduVideoComponent . Its main task is not managing the final video player (that is OpenViduVideoComponent responsibility), but displaying custom information for each one of them (the user's nickname) and handling the click event on them to update property mainStreamManager of parent AppComponent : <div className=\"streamcomponent\" onClick={this.handleVideoClicked}> <OpenViduVideoComponent streamManager={this.props.streamManager} /> <div><p>{this.getNicknameTag()}</p></div> </div> export default class UserVideoComponent extends Component { constructor(props) { super(props); this.handleVideoClicked = this.handleVideoClicked.bind(this); } getNicknameTag() { // Gets the nickName of the user return JSON.parse(this.props.streamManager.stream.connection.data).clientData; } handleVideoClicked(event) { // Triggers event for the parent component to update its main video display (other UserVideoComponent) if (this.props.mainVideoStream) { this.props.mainVideoStream(this.props.streamManager); } } } OpenViduVideoComponent html template is just the video element: <video autoPlay={true} ref={this.videoRef} /> And the unique responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is React Refs: we get the video element with React.createRef() and we call the method once after the component output has been rendered to the DOM ( componentDidMount ). export default class OpenViduVideoComponent extends Component { constructor(props) { super(props); this.videoRef = React.createRef(); } componentDidMount() { if (this.props && !!this.videoRef) { this.props.streamManager.addVideoElement(this.videoRef.current); } } }","title":"Finally connect to the session and publish your webcam:"},{"location":"tutorials/openvidu-insecure-react/#leaving-the-session","text":"Whenever we want a user to leave the session, we just need to call session.disconnect method in App.js : leaveSession() { // --- 7) Leave the session by calling 'disconnect' method over the Session object --- const mySession = this.state.session; if (mySession) { mySession.disconnect(); } // Empty all properties... this.OV = null; this.setState({ mySessionId: 'SessionA', myUserName: 'Participant' + Math.floor(Math.random() * 100), session: undefined, mainStreamManager: undefined, publisher: undefined, subscribers: [], }); } $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Leaving the session"},{"location":"tutorials/openvidu-ionic/","text":"openvidu-ionic Check it on GitHub A client-side only application built with Ionic 5 and Angular 9 frameworks. It can be compiled into a native Android app , a native iOS app and into a standard web app . If it is the first time you use OpenVidu, it is highly recommended to start first with openvidu-hello-world tutorial due to this being a cordova ionic app and being a little more complex for OpenVidu starters. Understanding this tutorial OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : NPM package for your Ionic app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions Running this tutorial 1) You will need Node , NPM , Ionic and Cordova to serve the app. Install them with the following commands sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g ionic@latest sudo npm install -g cordova@latest 2) Clone the repo git clone https://github.com/OpenVidu/openvidu-tutorials.git 3) Install dependencies cd openvidu-tutorials/openvidu-ionic npm install Now depending on the platform you want to run your app... In the browser 4) Run the tutorial # In openvidu-tutorials/openvidu-ionic ionic serve 5) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ) docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 6) Go to localhost:8100 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. 7) To show the app with the device appearance, press F12 button in your keyboard and the browser DevTools will be opened. You can find a button with a device icon at the top of the DevTools. By pressing this button the view will adapt to a mobile device aspect ratio. You can also choose predefined types of devices to see the behavior of your app in different resolutions. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ In an Android device with native app This tutorial has been tested on Android 9 (Pie) To deploy the Android APK not only you need to have Java JDK8 , Android Studio and Android SDK installed but also you have to set up the specific environment variables . Fortunately, Ionic provide us a great guide to allows us to configure step by step all the requirements. After we have completed all the steps of the Ionic guide and performed steps 1) , 2) and 3) stated above, we must continue with the following commands: 4) Connect the device to the same network as your PC 5) Now you need the IP of your PC in the network. In Linux/OSX you can simply get it by running this command on your shell awk '/inet / && $2 != \"127.0.0.1\"{print $2}' <(ifconfig) It will probably output something like 192.168.0.105 . Your complete OpenVidu public url would then be https://192.168.0.105:4443/ When you have your OpenVidu public url, you must set it in OPENVIDU_SERVER_URL variable in the app and in the openvidu.publicurl parameter used to run openvidu-server (see next point) 6) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ) docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=YOUR_OPENVIDU_PUBLIC_URL openvidu/openvidu-server-kms:2.12.0 Remember changing openvidu.publicurl parameter to the actual value. In this example that would be: -e openvidu.publicurl=https://192.168.0.105:4443/ 7) Connect the device to the PC. You must enable USB debugging and give permissions (check out last section here in Ionic docs ) 8) Run the tutorial. The app will be automatically launched in your Android device # In openvidu-tutorials/openvidu-ionic ionic cordova run android In an iOS device with native app This tutorial has been tested with Xcode (10.2.1) and iPhone 7 (iOS 12.2), iPhone 7 Plus (iOS 12.1) and iPad Air (iOS 12.1.1) To deploy the iOS app you will need first to follow this guide to properly configure your development environment. Then, it is crucial to have an OpenVidu Server properly deployed with a valid certificate . iOS devices will require OpenVidu Server to be deployed in a valid domain well-protected with a certificate. No iPhone or iPad will allow connections to a non-secure OpenVidu Server from within a native application. To facilitate first steps with OpenVidu and Ionic on iOS devices, if no custom url is defined here in the app then our demos OpenVidu Server will be used. Note: this is a publicly accessible OpenVidu Server. Anyone could access your sessions. Use it only for an initial test and under your own responsibility After we have completed all the steps of the Ionic guide and performed steps 1), 2) and 3) stated above, we must continue with the following commands: 4) Add ios platform # In openvidu-tutorials/openvidu-ionic ionic cordova platform add ios 5) Run the tutorial. The app will be automatically launched in your iOS device. First execution you'll need to trust your developer account in your device under Settings -> General -> Device management -> your_apple_developer_account # In openvidu-tutorials/openvidu-ionic ionic cordova run ios You will need to sign your application in Xcode (opening folder openvidu-ionic/platforms/ios ) with your developer team to avoid any errors. From Apple official documentation : Understanding the code This is an Ionic project generated with ionic-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/app/ folder: app.component.ts : defines AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves. app.component.html : HTML for AppComponent. app.component.css : CSS for AppComponent. user-video.component.ts : defines UserVideoComponent , used to display every user video. It contains one OpenViduVideoComponent , the name of the user and also handles a click event to update the view of AppComponent . ov-video.component.ts : defines OpenViduVideoComponent , which wraps the final HTML <video> that finally displays the media stream. Let's see first how app.component.ts uses NPM package openvidu-browser : We import the necessary objects from openvidu-browser : import { OpenVidu, Publisher, Session, StreamEvent, StreamManager, Subscriber } from 'openvidu-browser'; app.component.ts declares the following properties: // OpenVidu objects OV: OpenVidu; session: Session; publisher: StreamManager; // Local subscribers: StreamManager[] = []; // Remotes // Join form mySessionId: string; myUserName: string; OpenVidu object will allow us to get a Session object, which is declared just after it. publisher StreamManager object will be our own local webcam stream and subscribers StreamManager array will store the active streams of other users in the video-call. Finally, mySessionId and myUserName params simply represent the video-call and your participant's nickname, as you will see in a moment. Whenever a user clicks on the join button defined in app.component.html , joinSession() method is called: We first get an OpenVidu object and initialize a Session object with it. // --- 1) Get an OpenVidu object --- this.OV = new OpenVidu(); // --- 2) Init a session --- this.session = this.OV.initSession(); Then we subscribe to the Session events that interest us. // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... this.session.on('streamCreated', (event: StreamEvent) => { // Subscribe to the Stream to receive it. Second parameter is undefined // so OpenVidu doesn't create an HTML video on its own const subscriber: Subscriber = this.session.subscribe(event.stream, undefined); this.subscribers.push(subscriber); }); // On every Stream destroyed... this.session.on('streamDestroyed', (event: StreamEvent) => { // Remove the stream from 'subscribers' array this.deleteSubscriber(event.stream.streamManager); }); As we are using Ionic and Angular framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each Subscriber object and let it manage its video. This component will be our UserVideoComponent . To do this, we need to store each new Subscriber we received in array subscribers (of its parent class StreamManager ), and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events: streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our subscribers array. Method session.subscribe has undefined as second parameter so OpenVidu doesn't insert an HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of AppComponent loops through subscribers array with an ngFor directive, declaring a UserVideoComponent for each subscriber. We feed them not really as Subscriber objects, but rather as their parent class StreamManager . This way we can reuse UserVideoComponent to also display our Publisher object (that also inherits from class StreamManager). <ion-col size=\"6\" *ngFor=\"let sub of subscribers\"> <div class=\"stream-container\"> <user-video [streamManager]=\"sub\"></user-video> </div> </ion-col> streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from subscribers array, so Angular will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property streamManager that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream). Get a token from OpenVidu Server WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then((token) => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token, using @angular/http library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Connect to the session: // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then((token) => { // First param is the token got from OpenVidu Server. Second param will be used by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname this.session .connect(token, { clientData: this.myUserName }) .then(() => { // --- 5) Requesting and Checking Android Permissions if (this.platform.is('cordova')) { // Ionic platform if (this.platform.is('android')) { console.log('Android platform'); this.checkAndroidPermissions() .then(() => this.initPublisher()) .catch(err => console.error(err)); } else if (this.platform.is('ios')) { console.log('iOS platform'); this.initPublisher(); } } else { this.initPublisher(); } }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); In session.connect method first param is the recently retrieved user token. Second param is the value every user will receive in event.stream.connection.data property on streamCreated event (this value will be used by UserVideoComponent to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input <ion-input [(ngModel)]=\"myUserName\"></ion-input> (filled by the user). If the method succeeds and is running under a Cordova and Android platform, we will call and receive a promise from checkAndroidPermissions() method. This method requests and checks the Android permissions that our app currently has in the device. Once the promise has been resolved, the initPublisher() method will be called. For iOS and web platforms, permissions will be handled automatically when camera and microphone access are requested. No need for extra steps in these cases, so we directly initialize our Publisher object. We do further talk about Android permissions under section Android specific requirements . Finally publish your webcam calling initPublisher() method: initPublisher() { // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video // element: we will manage it on our own) and with the desired properties const publisher: Publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: true // Whether to mirror your local video or not }); // --- 6) Publish your stream --- this.session.publish(publisher).then(() => { // Store our Publisher this.publisher = publisher; }); } We now proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties and publish it to the Session through Session.publish() method. The rest of users will receive our Stream object and will execute their streamCreated event. In the callback of session.publish we store the Publisher object under this.publisher variable, which is also of parent class StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by UserVideoComponent ): <div *ngIf=\"publisher\" class=\"stream-container\"> <user-video [streamManager]=\"publisher\"></user-video> </div> Last point worth considering is the implementation of UserVideoComponent and OpenViduVideoComponent . Each UserVideoComponent manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component OpenViduVideoComponent . Its main task is not managing the final video player (that is OpenViduVideoComponent responsibility), but displaying custom information for each one of them (the user's nickname in this case): <div> <ov-video [streamManager]=\"streamManager\"></ov-video> <div><p>{% raw %}{{getNicknameTag()}}{% endraw %}</p></div> </div> export class UserVideoComponent { @Input() streamManager: StreamManager; getNicknameTag() { try { return JSON.parse(this.streamManager.stream.connection.data).clientData; } catch (err) { console.error('ClientData is not JSON formatted'); } } } OpenViduVideoComponent html template is just the video element: <video #videoElement></video> And the responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is Angular dependant: we get the video element with @ViewChild tag and we call the method once after the view has initialized ( ngAfterViewInit ) and once every time the StreamManager input changes ( set method with @Input tag) export class OpenViduVideoComponent implements AfterViewInit, OnDestroy { @ViewChild('videoElement') elementRef: ElementRef; _streamManager: StreamManager; ngAfterViewInit() { this._streamManager.addVideoElement(this.elementRef.nativeElement); } @Input() set streamManager(streamManager: StreamManager) { this._streamManager = streamManager; } } To actually see the real implementation of this class, check out iOS specific requirements section, as most of its code is just adjustments to make it work on iOS devices. Leaving the session Whenever we want a user to leave the session, we just need to call session.disconnect method in app.component.ts : leaveSession() { // --- 7) Leave the session by calling 'disconnect' method over the Session object --- if (this.session) { this.session.disconnect(); } // Empty all properties... this.subscribers = []; delete this.publisher; delete this.session; delete this.OV; this.generateParticipantInfo(); } Android specific requirements Android apps need to actively ask for permissions in the code to access camera and microphone. By following steps below we have been able to properly set up the permissions your Ionic app will need to work along OpenVidu. These configurations are already included in this openvidu-ionic project, so if you start from here no further configurations are needed. Otherwise, if you want to start a new project with Ionic and OpenVidu , you should follow these simple steps: 1) Install Cordova AndroidPermissions plugin ionic cordova plugin add cordova-plugin-android-permissions npm install --save @ionic-native/android-permissions@latest 2) Add this plugin to your app's module ( example ) import { AndroidPermissions } from '@ionic-native/android-permissions/ngx'; @NgModule({ providers: [ // others providers AndroidPermissions, ], )} 3) Add this plugin to your component and use it ( example ) import { AndroidPermissions } from '@ionic-native/android-permissions/ngx'; export class AppComponent { constructor(private androidPermissions: AndroidPermissions) } We are finally ready to request permissions to our device. To do so, we need to use requestPermissions() and checkPermission() methods offered by the plugin. It is important to call these methods under platform.ready() , just because it will tell us whenever the platform is ready and the native functionality can be actually called. You can inspect this method in detail in the GitHub repo . You should also declare an array of permissions to use as parameter of requestPermissions() ANDROID_PERMISSIONS = [ this.androidPermissions.PERMISSION.CAMERA, this.androidPermissions.PERMISSION.RECORD_AUDIO, this.androidPermissions.PERMISSION.MODIFY_AUDIO_SETTINGS ]; 4) Last but not least, in root directory you can find file config.xml . These permissions must be included inside of <platform name=\"android\"> ( example ) <config-file mode=\"merge\" parent=\"/*\" target=\"AndroidManifest.xml\"> <uses-permission android:name=\"android.permission.CAMERA\" /> <uses-permission android:name=\"android.permission.RECORD_AUDIO\" /> <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /> </config-file> Moreover, you must add xmlns:android=\"http://schemas.android.com/apk/res/android\" to the end of the opening widget node. <widget id=\"io.openvidu.sampleios\" version=\"2.6.0\" xmlns=\"http://www.w3.org/ns/widgets\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:cdv=\"http://cordova.apache.org/ns/1.0\"> ... </widget> Once these changes are added to our code, the app will be ready to run on our Android phone. iOS specific requirements Unfortunately, Ionic's WebView layer on iOS devices ( WKWebview ) does not support WebRTC (blame Apple and its politics). So the only way to make WebRTC work on iOS Ionic platform is by using a plugin. The result works just fine, but a little work is needed to make your Ionic app compatible with iOS. OpenVidu makes use of cordova-plugin-iosrtc to achieve this. This openvidu-ionic project is ready to work on iOS devices, but we will go through every aspect related to iOS compatibility in case your already have an Ionic application in which you want to integrate OpenVidu. Configuration requirements 1) Install cordova-plugin-iosrtc and xcode ionic cordova plugin add cordova-plugin-iosrtc npm install xcode --save 2) Add the following files to your Ionic app. Consider relative paths under root folder, the one containing your package.json file hooks/iosrtc-swift-support.js ( download file ) src/assets/libs/adapter-4.0.1.js ( download file ) 3) Add the following lines to config.xml file under ios platform: <platform name=\"ios\"> ... <hook src=\"hooks/iosrtc-swift-support.js\" type=\"after_platform_add\" /> <config-file parent=\"NSCameraUsageDescription\" target=\"*-Info.plist\"> <string>OpenVidu needs access to your camera</string> </config-file> <config-file parent=\"NSContactsUsageDescription\" target=\"*-Info.plist\"> <string>OpenVidu needs access to contacts</string> </config-file> <config-file parent=\"NSMicrophoneUsageDescription\" target=\"*-Info.plist\"> <string>OpenVidu needs access to your microphone</string> </config-file> ... </platform> 4) Add this optional dependency to your package.json . Don't forget to run npm install after that to actually install it \"optionalDependencies\": { \"ios-deploy\": \"1.9.4\" } 5) Finally remove and reinstall ios platform ionic cordova platform remove ios ionic cordova platform add ios Code requirements 1) Add to global styles the following rule. For example, in openvidu-ionic app it is done right here . This will allow us to put other HTML elements above the video elements. One limitation for iOS is the background color of your app: we need it to be transparent to allow plugin videos to be visible behind the Ionic app. So you have 2 choices: you can have one video or many videos to fill all available space in the device's screen (which is in fact the most common layout in video conferencing apps for mobile phones) or you'll have to go with a white background if videos leave visible space in your app's layout. :root { --ion-background-color: transparent; } 2) Initialize cordova-plugin-iosrtc . The easiest way is doing so in app.component.ts constructor, using Platform library to identify iOS Ionic context. It is very important to initialize the plugin only for iOS devices running a cordova app. // Import declarations... declare var cordova; ... constructor(private platform: Platform) { if (this.platform.is('ios') && this.platform.is('cordova')) { cordova.plugins.iosrtc.registerGlobals(); // load adapter.js (version 4.0.1) const script2 = document.createElement('script'); script2.type = 'text/javascript'; script2.src = 'assets/libs/adapter-4.0.1.js'; script2.async = false; document.head.appendChild(script2); } } 3) Every <video> element should be managed carefully on cordova iOS. The plugin inserts iOS native video elements whenever it finds an HTMLVideoElement, respecting certain CSS rules. In general, we recommend that at the moment you have video metadata, you apply programmatically the following styles: object-fit , z-index , width and height . In openvidu-ionic app this is done as follows in file ov-video.component.ts We check if the platform is iOS with the following method: private isIos(): boolean { return this.platform.is('ios') && this.platform.is('cordova'); } We call the following updateVideoView method inside ngAfterViewInit , so our video elementRef is properly defined: private updateVideoView() { this._streamManager.addVideoElement(this.elementRef.nativeElement); if (this.isIos()) { (<HTMLVideoElement>this.elementRef.nativeElement).onloadedmetadata = () => { this.applyIosIonicVideoAttributes(); }; } } We call applyIosIonicVideoAttributes method only after the video element has triggered 'loadedmetadata' event. This way we know that the video has certain computed width and we can calculate the exact height it must have according to its aspect ratio, got from Stream.videoDimensions . This is necessary because the plugin needs an exact width and height in order to paint the native iOS video. In this case, every video will have the full width of its container and the height will be obtained from the final computed width and the aspect ratio got from metadata Stream.videoDimensions . private applyIosIonicVideoAttributes() { const ratio = this._streamManager.stream.videoDimensions.height / this._streamManager.stream.videoDimensions.width; this.elementRef.nativeElement.style.width = '100% !important'; this.elementRef.nativeElement.style.objectFit = 'fill'; this.elementRef.nativeElement.style.zIndex = '-1'; const computedWidth = this.elementRef.nativeElement.offsetWidth; this.elementRef.nativeElement.style.height = computedWidth * ratio + 'px'; if (!this._streamManager.remote) { // It is a Publisher video. Custom iosrtc plugin mirror video this.elementRef.nativeElement.style.transform = 'scaleX(-1)'; } cordova.plugins.iosrtc.refreshVideos(); } Finally we also need to listen to dynamic changes on the videos to refresh the plugin view. This includes 3 things: Listen to streamPropertyChanged event of StreamManager, and if videoDimensions changes update the video element accordingly. In openvidu-ionic app we do so when setting StreamManager property in ov-video.component.ts @Input() set streamManager(streamManager: StreamManager) { this._streamManager = streamManager; if (this.isIos()) { this._streamManager.on('streamPropertyChanged', event => { if ((<StreamPropertyChangedEvent>event).changedProperty === 'videoDimensions') { this.applyIosIonicVideoAttributes(); } }); } } Only if your app supports orientation changes : you will have to listen to orientationchange window event for remote streams to update their video dimensions and adjust them to the new window ratio. openvidu-ionic app does this in method ngAfterViewInit in ov-video.component.ts . The timeout gives the video some time to refresh its properties before updating its view. ngAfterViewInit() { if (this.isIos() && this._streamManager.remote) { this.rotationFunction = () => { // Give the remote video some time to update its dimensions when rotating the device setTimeout(() => { this.applyIosIonicVideoAttributes(); }, 250); }; (<any>window).addEventListener('orientationchange', this.rotationFunction); } this.updateVideoView(); } Only if your app supports scrolling : if the view where your videos are gonna be displayed supports scrolling, then you will have to do the following: listen to scroll events in the required <ion-content> element and call cordova.plugin.iosrtc.refreshVideos() method when triggered. If you don't do this, videos will stay fixed in their position, ignoring the scroll behavior. <ion-content [scrollEvents]=\"true\" (ionScroll)=\"refreshVideos()\"> refreshVideos() { if (this.platform.is('ios') && this.platform.is('cordova')) { cordova.plugins.iosrtc.refreshVideos(); } } $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-ionic"},{"location":"tutorials/openvidu-ionic/#openvidu-ionic","text":"Check it on GitHub A client-side only application built with Ionic 5 and Angular 9 frameworks. It can be compiled into a native Android app , a native iOS app and into a standard web app . If it is the first time you use OpenVidu, it is highly recommended to start first with openvidu-hello-world tutorial due to this being a cordova ionic app and being a little more complex for OpenVidu starters.","title":"openvidu-ionic"},{"location":"tutorials/openvidu-ionic/#understanding-this-tutorial","text":"OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : NPM package for your Ionic app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-ionic/#running-this-tutorial","text":"1) You will need Node , NPM , Ionic and Cordova to serve the app. Install them with the following commands sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g ionic@latest sudo npm install -g cordova@latest 2) Clone the repo git clone https://github.com/OpenVidu/openvidu-tutorials.git 3) Install dependencies cd openvidu-tutorials/openvidu-ionic npm install Now depending on the platform you want to run your app...","title":"Running this tutorial"},{"location":"tutorials/openvidu-ionic/#in-the-browser","text":"4) Run the tutorial # In openvidu-tutorials/openvidu-ionic ionic serve 5) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ) docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 6) Go to localhost:8100 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. 7) To show the app with the device appearance, press F12 button in your keyboard and the browser DevTools will be opened. You can find a button with a device icon at the top of the DevTools. By pressing this button the view will adapt to a mobile device aspect ratio. You can also choose predefined types of devices to see the behavior of your app in different resolutions. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"In the browser"},{"location":"tutorials/openvidu-ionic/#in-an-android-device-with-native-app","text":"This tutorial has been tested on Android 9 (Pie) To deploy the Android APK not only you need to have Java JDK8 , Android Studio and Android SDK installed but also you have to set up the specific environment variables . Fortunately, Ionic provide us a great guide to allows us to configure step by step all the requirements. After we have completed all the steps of the Ionic guide and performed steps 1) , 2) and 3) stated above, we must continue with the following commands: 4) Connect the device to the same network as your PC 5) Now you need the IP of your PC in the network. In Linux/OSX you can simply get it by running this command on your shell awk '/inet / && $2 != \"127.0.0.1\"{print $2}' <(ifconfig) It will probably output something like 192.168.0.105 . Your complete OpenVidu public url would then be https://192.168.0.105:4443/ When you have your OpenVidu public url, you must set it in OPENVIDU_SERVER_URL variable in the app and in the openvidu.publicurl parameter used to run openvidu-server (see next point) 6) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ) docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=YOUR_OPENVIDU_PUBLIC_URL openvidu/openvidu-server-kms:2.12.0 Remember changing openvidu.publicurl parameter to the actual value. In this example that would be: -e openvidu.publicurl=https://192.168.0.105:4443/ 7) Connect the device to the PC. You must enable USB debugging and give permissions (check out last section here in Ionic docs ) 8) Run the tutorial. The app will be automatically launched in your Android device # In openvidu-tutorials/openvidu-ionic ionic cordova run android","title":"In an Android device with native app"},{"location":"tutorials/openvidu-ionic/#in-an-ios-device-with-native-app","text":"This tutorial has been tested with Xcode (10.2.1) and iPhone 7 (iOS 12.2), iPhone 7 Plus (iOS 12.1) and iPad Air (iOS 12.1.1) To deploy the iOS app you will need first to follow this guide to properly configure your development environment. Then, it is crucial to have an OpenVidu Server properly deployed with a valid certificate . iOS devices will require OpenVidu Server to be deployed in a valid domain well-protected with a certificate. No iPhone or iPad will allow connections to a non-secure OpenVidu Server from within a native application. To facilitate first steps with OpenVidu and Ionic on iOS devices, if no custom url is defined here in the app then our demos OpenVidu Server will be used. Note: this is a publicly accessible OpenVidu Server. Anyone could access your sessions. Use it only for an initial test and under your own responsibility After we have completed all the steps of the Ionic guide and performed steps 1), 2) and 3) stated above, we must continue with the following commands: 4) Add ios platform # In openvidu-tutorials/openvidu-ionic ionic cordova platform add ios 5) Run the tutorial. The app will be automatically launched in your iOS device. First execution you'll need to trust your developer account in your device under Settings -> General -> Device management -> your_apple_developer_account # In openvidu-tutorials/openvidu-ionic ionic cordova run ios You will need to sign your application in Xcode (opening folder openvidu-ionic/platforms/ios ) with your developer team to avoid any errors. From Apple official documentation :","title":"In an iOS device with native app"},{"location":"tutorials/openvidu-ionic/#understanding-the-code","text":"This is an Ionic project generated with ionic-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/app/ folder: app.component.ts : defines AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves. app.component.html : HTML for AppComponent. app.component.css : CSS for AppComponent. user-video.component.ts : defines UserVideoComponent , used to display every user video. It contains one OpenViduVideoComponent , the name of the user and also handles a click event to update the view of AppComponent . ov-video.component.ts : defines OpenViduVideoComponent , which wraps the final HTML <video> that finally displays the media stream. Let's see first how app.component.ts uses NPM package openvidu-browser :","title":"Understanding the code"},{"location":"tutorials/openvidu-ionic/#we-import-the-necessary-objects-from-openvidu-browser","text":"import { OpenVidu, Publisher, Session, StreamEvent, StreamManager, Subscriber } from 'openvidu-browser';","title":"We import the necessary objects from openvidu-browser:"},{"location":"tutorials/openvidu-ionic/#appcomponentts-declares-the-following-properties","text":"// OpenVidu objects OV: OpenVidu; session: Session; publisher: StreamManager; // Local subscribers: StreamManager[] = []; // Remotes // Join form mySessionId: string; myUserName: string; OpenVidu object will allow us to get a Session object, which is declared just after it. publisher StreamManager object will be our own local webcam stream and subscribers StreamManager array will store the active streams of other users in the video-call. Finally, mySessionId and myUserName params simply represent the video-call and your participant's nickname, as you will see in a moment.","title":"app.component.ts declares the following properties:"},{"location":"tutorials/openvidu-ionic/#whenever-a-user-clicks-on-the-join-button-defined-in-appcomponenthtml-joinsession-method-is-called","text":"We first get an OpenVidu object and initialize a Session object with it. // --- 1) Get an OpenVidu object --- this.OV = new OpenVidu(); // --- 2) Init a session --- this.session = this.OV.initSession(); Then we subscribe to the Session events that interest us. // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... this.session.on('streamCreated', (event: StreamEvent) => { // Subscribe to the Stream to receive it. Second parameter is undefined // so OpenVidu doesn't create an HTML video on its own const subscriber: Subscriber = this.session.subscribe(event.stream, undefined); this.subscribers.push(subscriber); }); // On every Stream destroyed... this.session.on('streamDestroyed', (event: StreamEvent) => { // Remove the stream from 'subscribers' array this.deleteSubscriber(event.stream.streamManager); }); As we are using Ionic and Angular framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each Subscriber object and let it manage its video. This component will be our UserVideoComponent . To do this, we need to store each new Subscriber we received in array subscribers (of its parent class StreamManager ), and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events: streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our subscribers array. Method session.subscribe has undefined as second parameter so OpenVidu doesn't insert an HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of AppComponent loops through subscribers array with an ngFor directive, declaring a UserVideoComponent for each subscriber. We feed them not really as Subscriber objects, but rather as their parent class StreamManager . This way we can reuse UserVideoComponent to also display our Publisher object (that also inherits from class StreamManager). <ion-col size=\"6\" *ngFor=\"let sub of subscribers\"> <div class=\"stream-container\"> <user-video [streamManager]=\"sub\"></user-video> </div> </ion-col> streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from subscribers array, so Angular will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property streamManager that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).","title":"Whenever a user clicks on the join button defined in app.component.html, joinSession() method is called:"},{"location":"tutorials/openvidu-ionic/#get-a-token-from-openvidu-server","text":"WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then((token) => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token, using @angular/http library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-ionic/#connect-to-the-session","text":"// --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then((token) => { // First param is the token got from OpenVidu Server. Second param will be used by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname this.session .connect(token, { clientData: this.myUserName }) .then(() => { // --- 5) Requesting and Checking Android Permissions if (this.platform.is('cordova')) { // Ionic platform if (this.platform.is('android')) { console.log('Android platform'); this.checkAndroidPermissions() .then(() => this.initPublisher()) .catch(err => console.error(err)); } else if (this.platform.is('ios')) { console.log('iOS platform'); this.initPublisher(); } } else { this.initPublisher(); } }) .catch(error => { console.log('There was an error connecting to the session:', error.code, error.message); }); }); In session.connect method first param is the recently retrieved user token. Second param is the value every user will receive in event.stream.connection.data property on streamCreated event (this value will be used by UserVideoComponent to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input <ion-input [(ngModel)]=\"myUserName\"></ion-input> (filled by the user). If the method succeeds and is running under a Cordova and Android platform, we will call and receive a promise from checkAndroidPermissions() method. This method requests and checks the Android permissions that our app currently has in the device. Once the promise has been resolved, the initPublisher() method will be called. For iOS and web platforms, permissions will be handled automatically when camera and microphone access are requested. No need for extra steps in these cases, so we directly initialize our Publisher object. We do further talk about Android permissions under section Android specific requirements .","title":"Connect to the session:"},{"location":"tutorials/openvidu-ionic/#finally-publish-your-webcam-calling-initpublisher-method","text":"initPublisher() { // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video // element: we will manage it on our own) and with the desired properties const publisher: Publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: true // Whether to mirror your local video or not }); // --- 6) Publish your stream --- this.session.publish(publisher).then(() => { // Store our Publisher this.publisher = publisher; }); } We now proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties and publish it to the Session through Session.publish() method. The rest of users will receive our Stream object and will execute their streamCreated event. In the callback of session.publish we store the Publisher object under this.publisher variable, which is also of parent class StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by UserVideoComponent ): <div *ngIf=\"publisher\" class=\"stream-container\"> <user-video [streamManager]=\"publisher\"></user-video> </div> Last point worth considering is the implementation of UserVideoComponent and OpenViduVideoComponent . Each UserVideoComponent manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component OpenViduVideoComponent . Its main task is not managing the final video player (that is OpenViduVideoComponent responsibility), but displaying custom information for each one of them (the user's nickname in this case): <div> <ov-video [streamManager]=\"streamManager\"></ov-video> <div><p>{% raw %}{{getNicknameTag()}}{% endraw %}</p></div> </div> export class UserVideoComponent { @Input() streamManager: StreamManager; getNicknameTag() { try { return JSON.parse(this.streamManager.stream.connection.data).clientData; } catch (err) { console.error('ClientData is not JSON formatted'); } } } OpenViduVideoComponent html template is just the video element: <video #videoElement></video> And the responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is Angular dependant: we get the video element with @ViewChild tag and we call the method once after the view has initialized ( ngAfterViewInit ) and once every time the StreamManager input changes ( set method with @Input tag) export class OpenViduVideoComponent implements AfterViewInit, OnDestroy { @ViewChild('videoElement') elementRef: ElementRef; _streamManager: StreamManager; ngAfterViewInit() { this._streamManager.addVideoElement(this.elementRef.nativeElement); } @Input() set streamManager(streamManager: StreamManager) { this._streamManager = streamManager; } } To actually see the real implementation of this class, check out iOS specific requirements section, as most of its code is just adjustments to make it work on iOS devices.","title":"Finally publish your webcam calling initPublisher() method:"},{"location":"tutorials/openvidu-ionic/#leaving-the-session","text":"Whenever we want a user to leave the session, we just need to call session.disconnect method in app.component.ts : leaveSession() { // --- 7) Leave the session by calling 'disconnect' method over the Session object --- if (this.session) { this.session.disconnect(); } // Empty all properties... this.subscribers = []; delete this.publisher; delete this.session; delete this.OV; this.generateParticipantInfo(); }","title":"Leaving the session"},{"location":"tutorials/openvidu-ionic/#android-specific-requirements","text":"Android apps need to actively ask for permissions in the code to access camera and microphone. By following steps below we have been able to properly set up the permissions your Ionic app will need to work along OpenVidu. These configurations are already included in this openvidu-ionic project, so if you start from here no further configurations are needed. Otherwise, if you want to start a new project with Ionic and OpenVidu , you should follow these simple steps: 1) Install Cordova AndroidPermissions plugin ionic cordova plugin add cordova-plugin-android-permissions npm install --save @ionic-native/android-permissions@latest 2) Add this plugin to your app's module ( example ) import { AndroidPermissions } from '@ionic-native/android-permissions/ngx'; @NgModule({ providers: [ // others providers AndroidPermissions, ], )} 3) Add this plugin to your component and use it ( example ) import { AndroidPermissions } from '@ionic-native/android-permissions/ngx'; export class AppComponent { constructor(private androidPermissions: AndroidPermissions) } We are finally ready to request permissions to our device. To do so, we need to use requestPermissions() and checkPermission() methods offered by the plugin. It is important to call these methods under platform.ready() , just because it will tell us whenever the platform is ready and the native functionality can be actually called. You can inspect this method in detail in the GitHub repo . You should also declare an array of permissions to use as parameter of requestPermissions() ANDROID_PERMISSIONS = [ this.androidPermissions.PERMISSION.CAMERA, this.androidPermissions.PERMISSION.RECORD_AUDIO, this.androidPermissions.PERMISSION.MODIFY_AUDIO_SETTINGS ]; 4) Last but not least, in root directory you can find file config.xml . These permissions must be included inside of <platform name=\"android\"> ( example ) <config-file mode=\"merge\" parent=\"/*\" target=\"AndroidManifest.xml\"> <uses-permission android:name=\"android.permission.CAMERA\" /> <uses-permission android:name=\"android.permission.RECORD_AUDIO\" /> <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /> </config-file> Moreover, you must add xmlns:android=\"http://schemas.android.com/apk/res/android\" to the end of the opening widget node. <widget id=\"io.openvidu.sampleios\" version=\"2.6.0\" xmlns=\"http://www.w3.org/ns/widgets\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:cdv=\"http://cordova.apache.org/ns/1.0\"> ... </widget> Once these changes are added to our code, the app will be ready to run on our Android phone.","title":"Android specific requirements"},{"location":"tutorials/openvidu-ionic/#ios-specific-requirements","text":"Unfortunately, Ionic's WebView layer on iOS devices ( WKWebview ) does not support WebRTC (blame Apple and its politics). So the only way to make WebRTC work on iOS Ionic platform is by using a plugin. The result works just fine, but a little work is needed to make your Ionic app compatible with iOS. OpenVidu makes use of cordova-plugin-iosrtc to achieve this. This openvidu-ionic project is ready to work on iOS devices, but we will go through every aspect related to iOS compatibility in case your already have an Ionic application in which you want to integrate OpenVidu.","title":"iOS specific requirements"},{"location":"tutorials/openvidu-ionic/#configuration-requirements","text":"1) Install cordova-plugin-iosrtc and xcode ionic cordova plugin add cordova-plugin-iosrtc npm install xcode --save 2) Add the following files to your Ionic app. Consider relative paths under root folder, the one containing your package.json file hooks/iosrtc-swift-support.js ( download file ) src/assets/libs/adapter-4.0.1.js ( download file ) 3) Add the following lines to config.xml file under ios platform: <platform name=\"ios\"> ... <hook src=\"hooks/iosrtc-swift-support.js\" type=\"after_platform_add\" /> <config-file parent=\"NSCameraUsageDescription\" target=\"*-Info.plist\"> <string>OpenVidu needs access to your camera</string> </config-file> <config-file parent=\"NSContactsUsageDescription\" target=\"*-Info.plist\"> <string>OpenVidu needs access to contacts</string> </config-file> <config-file parent=\"NSMicrophoneUsageDescription\" target=\"*-Info.plist\"> <string>OpenVidu needs access to your microphone</string> </config-file> ... </platform> 4) Add this optional dependency to your package.json . Don't forget to run npm install after that to actually install it \"optionalDependencies\": { \"ios-deploy\": \"1.9.4\" } 5) Finally remove and reinstall ios platform ionic cordova platform remove ios ionic cordova platform add ios","title":"Configuration requirements"},{"location":"tutorials/openvidu-ionic/#code-requirements","text":"1) Add to global styles the following rule. For example, in openvidu-ionic app it is done right here . This will allow us to put other HTML elements above the video elements. One limitation for iOS is the background color of your app: we need it to be transparent to allow plugin videos to be visible behind the Ionic app. So you have 2 choices: you can have one video or many videos to fill all available space in the device's screen (which is in fact the most common layout in video conferencing apps for mobile phones) or you'll have to go with a white background if videos leave visible space in your app's layout. :root { --ion-background-color: transparent; } 2) Initialize cordova-plugin-iosrtc . The easiest way is doing so in app.component.ts constructor, using Platform library to identify iOS Ionic context. It is very important to initialize the plugin only for iOS devices running a cordova app. // Import declarations... declare var cordova; ... constructor(private platform: Platform) { if (this.platform.is('ios') && this.platform.is('cordova')) { cordova.plugins.iosrtc.registerGlobals(); // load adapter.js (version 4.0.1) const script2 = document.createElement('script'); script2.type = 'text/javascript'; script2.src = 'assets/libs/adapter-4.0.1.js'; script2.async = false; document.head.appendChild(script2); } } 3) Every <video> element should be managed carefully on cordova iOS. The plugin inserts iOS native video elements whenever it finds an HTMLVideoElement, respecting certain CSS rules. In general, we recommend that at the moment you have video metadata, you apply programmatically the following styles: object-fit , z-index , width and height . In openvidu-ionic app this is done as follows in file ov-video.component.ts We check if the platform is iOS with the following method: private isIos(): boolean { return this.platform.is('ios') && this.platform.is('cordova'); } We call the following updateVideoView method inside ngAfterViewInit , so our video elementRef is properly defined: private updateVideoView() { this._streamManager.addVideoElement(this.elementRef.nativeElement); if (this.isIos()) { (<HTMLVideoElement>this.elementRef.nativeElement).onloadedmetadata = () => { this.applyIosIonicVideoAttributes(); }; } } We call applyIosIonicVideoAttributes method only after the video element has triggered 'loadedmetadata' event. This way we know that the video has certain computed width and we can calculate the exact height it must have according to its aspect ratio, got from Stream.videoDimensions . This is necessary because the plugin needs an exact width and height in order to paint the native iOS video. In this case, every video will have the full width of its container and the height will be obtained from the final computed width and the aspect ratio got from metadata Stream.videoDimensions . private applyIosIonicVideoAttributes() { const ratio = this._streamManager.stream.videoDimensions.height / this._streamManager.stream.videoDimensions.width; this.elementRef.nativeElement.style.width = '100% !important'; this.elementRef.nativeElement.style.objectFit = 'fill'; this.elementRef.nativeElement.style.zIndex = '-1'; const computedWidth = this.elementRef.nativeElement.offsetWidth; this.elementRef.nativeElement.style.height = computedWidth * ratio + 'px'; if (!this._streamManager.remote) { // It is a Publisher video. Custom iosrtc plugin mirror video this.elementRef.nativeElement.style.transform = 'scaleX(-1)'; } cordova.plugins.iosrtc.refreshVideos(); } Finally we also need to listen to dynamic changes on the videos to refresh the plugin view. This includes 3 things: Listen to streamPropertyChanged event of StreamManager, and if videoDimensions changes update the video element accordingly. In openvidu-ionic app we do so when setting StreamManager property in ov-video.component.ts @Input() set streamManager(streamManager: StreamManager) { this._streamManager = streamManager; if (this.isIos()) { this._streamManager.on('streamPropertyChanged', event => { if ((<StreamPropertyChangedEvent>event).changedProperty === 'videoDimensions') { this.applyIosIonicVideoAttributes(); } }); } } Only if your app supports orientation changes : you will have to listen to orientationchange window event for remote streams to update their video dimensions and adjust them to the new window ratio. openvidu-ionic app does this in method ngAfterViewInit in ov-video.component.ts . The timeout gives the video some time to refresh its properties before updating its view. ngAfterViewInit() { if (this.isIos() && this._streamManager.remote) { this.rotationFunction = () => { // Give the remote video some time to update its dimensions when rotating the device setTimeout(() => { this.applyIosIonicVideoAttributes(); }, 250); }; (<any>window).addEventListener('orientationchange', this.rotationFunction); } this.updateVideoView(); } Only if your app supports scrolling : if the view where your videos are gonna be displayed supports scrolling, then you will have to do the following: listen to scroll events in the required <ion-content> element and call cordova.plugin.iosrtc.refreshVideos() method when triggered. If you don't do this, videos will stay fixed in their position, ignoring the scroll behavior. <ion-content [scrollEvents]=\"true\" (ionScroll)=\"refreshVideos()\"> refreshVideos() { if (this.platform.is('ios') && this.platform.is('cordova')) { cordova.plugins.iosrtc.refreshVideos(); } } $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Code requirements"},{"location":"tutorials/openvidu-js-java/","text":"openvidu-js-java Check it on GitHub A secure OpenVidu sample app with a Java backend and a SPA frontend. It makes use of openvidu-java-client to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to openvidu-mvc-java . This tutorial is intended for developers who feel more comfortable with a SPA (Single Page Application) architecture for their frontends. Understanding this tutorial OpenVidu is composed by the modules displayed on the image above. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-java-client : server SDK for Java. Quick alternative to REST API openvidu-server : application to control Kurento Media Server Kurento Media Server : handles low level operations of media flow transmissions Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need maven to build the project. You can install it with: sudo apt-get install maven 3) Run the tutorial: cd openvidu-tutorials/openvidu-js-java mvn package exec:java 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive HttpSession API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: journaldev.com , studytonight.com . Backend : SpringBoot app with the following classes ( src/main/java path, io.openvidu.js.java package) App.java : entrypoint for the app LoginController.java : rest controller for handling login and logout operations SessionController.java : rest controller for getting OpenVidu tokens. It also stores our active video-calls and the users connected to them Frontend : Plain JS/HTML/CSS files ( src/main/resources/static ) openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . index.html : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"app.js\"></script> style.css : some CSS classes to style index.html . Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while. 1) User logs in We have implemented a method for making HTTP POST requests to the backend, as we will need to make at least three of them: one for logging in, one for getting a token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this: function httpPostRequest(url, body, errorMsg, callback) Where url is the path of the POST operation, body the object to send as data, errorMsg the output error message if something goes wrong and callback the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL. index.html will first show a form to log in: app.js sends a POST request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked: function logIn() { var user = $(\"#user\").val(); // Username var pass = $(\"#pass\").val(); // Password httpPostRequest( 'api-login/login', {user: user, pass: pass}, 'Login WRONG', (response) => { // HTML shows logged-in page ... } ); } LoginController.java checks the params are correct and if so sets an HttpSession for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object): @RequestMapping(value = \"/login\", method = RequestMethod.POST) public ResponseEntity<Object> login(@RequestBody String userPass, HttpSession httpSession) throws ParseException { System.out.println(\"Logging in | {user, pass}=\" + userPass); // Retrieve params from POST body JSONObject userPassJson = (JSONObject) new JSONParser().parse(userPass); String user = (String) userPassJson.get(\"user\"); String pass = (String) userPassJson.get(\"pass\"); if (login(user, pass)) { // Correct user-pass // Validate session and return OK // Value stored in HttpSession allows us to identify the user in future requests httpSession.setAttribute(\"loggedUser\", user); return new ResponseEntity<>(HttpStatus.OK); } else { // Wrong user-pass // Invalidate session and return error httpSession.invalidate(); return new ResponseEntity<>(\"User/Pass incorrect\", HttpStatus.UNAUTHORIZED); } } 2) User connects to \"TUTORIAL\" video-call HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button: app.js will execute joinSession() method, which starts like this: function joinSession() { getToken((token) => { ... So the first thing to do here is to retrieve an OpenVidu token from our backend. Only when we have it available in the browser we will continue with the join operation. Let's see what getToken() looks like: function getToken(callback) { sessionName = $(\"#sessionName\").val(); // Video-call chosen by the user httpPostRequest( 'api-sessions/get-token', {sessionName: sessionName}, 'Request of TOKEN gone WRONG:', (response) => { token = response[0]; // Get token from response console.warn('Request of TOKEN gone WELL (TOKEN:' + token + ')'); callback(token); // Continue the join operation } ); } Here is the second time we must call our httpPostRequest() method, sending the session we want to connect ( sessionName parameter) and waiting to get a token as response. The interesting part here is in SessionController.java at /api-sessions/get-token . First of all there are some important attributes in this class we must mention: // OpenVidu object as entrypoint of the SDK private OpenVidu openVidu; // Collection to pair session names and OpenVidu Session objects private Map<String, Session> mapSessions = new ConcurrentHashMap<>(); // Collection to pair session names and tokens (the inner Map pairs tokens and role associated) private Map<String, Map<String, OpenViduRole>> mapSessionNamesTokens = new ConcurrentHashMap<>(); // URL where our OpenVidu server is listening private String OPENVIDU_URL; // Secret shared with our OpenVidu server private String SECRET; Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: tokenOptions . @RequestMapping(value = \"/get-token\", method = RequestMethod.POST) public ResponseEntity<JSONObject> getToken(@RequestBody String sessionNameParam, HttpSession httpSession) throws ParseException { // ... check the user is logged with HttpSession and continue ... JSONObject sessionJSON = (JSONObject) new JSONParser().parse(sessionNameParam); // The video-call to connect (\"TUTORIAL\") String sessionName = (String) sessionJSON.get(\"sessionName\"); // Role associated to this user OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\"loggedUser\")).role; // Optional data to be passed to other users when this user connects to the video-call // In this case, a JSON with the value we stored in the HttpSession object on login String serverData = \"{\\\"serverData\\\": \\\"\" + httpSession.getAttribute(\"loggedUser\") + \"\\\"}\"; // Build tokenOptions object with the serverData and the role TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build(); JSONObject responseJson = new JSONObject(); Just after that we check if the session \"TUTORIAL\" already exists if (this.mapSessions.get(sessionName) != null) { ... In this case it doesn't because 'publisher1' is the first user connecting to it. So we directly create a new session: // New session System.out.println(\"New session \" + sessionName); try { // Create a new OpenVidu Session Session session = this.openVidu.createSession(); // Generate a new token with the recently created tokenOptions String token = session.generateToken(tokenOptions); // Store the session and the token in our collections this.mapSessions.put(sessionName, session); this.mapSessionNamesTokens.put(sessionName, new ConcurrentHashMap<>()); this.mapSessionNamesTokens.get(sessionName).put(token, role); // Prepare the response with the token responseJson.put(0, token); // Return the response to the client return new ResponseEntity<>(responseJson, HttpStatus.OK); } catch (Exception e) { // If error generate an error message and return it to client return getErrorResponse(e); } We are almost there! Now in app.js we can init a new Session and connect to it with token : // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', (event) => { // Subscribe to the Stream to receive it // HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', (event) => { // Add a new HTML element for the user's name and nickname over its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', (event) => { // Delete the HTML element with the user's name and nickname removeUserData(event.stream.connection); }); // --- 4) Connect to the session passing the retrieved token and some more data from // the client (in this case a JSON with the nickname chosen by the user) --- var nickName = $(\"#nickName\").val(); session.connect(token, { clientData: nickName }) .then(() => { // --- 5) Set page layout for active call --- var userName = $(\"#user\").val(); $('#session-title').text(sessionName); $('#join').hide(); $('#session').show(); // Here we check somehow if the user has 'PUBLISHER' role before // trying to publish its stream. Even if someone modified the client's code and // published the stream, it wouldn't work if the token sent in Session.connect // method is not recognized as 'PUBLIHSER' role by OpenVidu Server if (isPublisher(userName)) { // --- 6) Get your own camera stream --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', (event) => { // Init the main video with ours and append our data var userData = { nickName: nickName, userName: userName }; initMainVideo(event.element, userData); appendUserData(event.element, userData); $(event.element).prop('muted', true); // Mute local video }); // --- 8) Publish your stream --- session.publish(publisher); } else { console.warn('You don\\'t have permissions to publish'); initMainVideoThumbnail(); // Show SUBSCRIBER message in main video } }) .catch(error => { console.warn('There was an error connecting to the session:', error.code, error.message); }); The user will now see its own video on the page. The connection to the session has completed! 3) Another user connects to the video-call The process would be exactly the same as before until SessionController.java executes getToken() method. Now session 'TUTORIAL' already exists, so now we do enter the if branch that we ignored in the previous step: if (this.mapSessions.get(sessionName) != null) { // Session already exists System.out.println(\"Existing session \" + sessionName); try { // Generate a new token with the recently created tokenOptions String token = this.mapSessions.get(sessionName).generateToken(tokenOptions); // Update our collection storing the new token this.mapSessionNamesTokens.get(sessionName).put(token, role); // Prepare the response with the token responseJson.put(0, token); // Return the response to the client return new ResponseEntity<>(responseJson, HttpStatus.OK); } catch (OpenViduJavaClientException e1) { // If internal error generate an error message and return it to client return getErrorResponse(e1); } catch (OpenViduHttpException e2) { if (404 == e2.getStatus()) { // Invalid sessionId (user left unexpectedly). Session object is not valid // anymore. Clean collections and continue as new session this.mapSessions.remove(sessionName); this.mapSessionNamesTokens.remove(sessionName); } } } The code executed in app.js would also be the same. After the Session.publish() method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it. 4) Users leave the video-call After a while both users decide to leave the session. Apart from calling leaveSession() (and therefore session.disconnect() ) to destroy the connection on OpenVidu Server, we need to run the last POST operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, session.disconnect() updates our OpenVidu Server and the POST operation updates our application's backend. For the POST operation, in app.js we run: function removeUser() { httpPostRequest( 'api-sessions/remove-user', {sessionName: sessionName, token: token}, 'User couldn\\'t be removed from session', (response) => { console.warn(\"You have been removed from session \" + sessionName); } ); } And in SessionController.java we update the collections: @RequestMapping(value = \"/remove-user\", method = RequestMethod.POST) public ResponseEntity<JSONObject> removeUser(@RequestBody String sessionNameToken, HttpSession httpSession) throws Exception { // ... check the user is logged with HttpSession and continue ... // Retrieve the params from BODY JSONObject sessionNameTokenJSON = (JSONObject) new JSONParser().parse(sessionNameToken); String sessionName = (String) sessionNameTokenJSON.get(\"sessionName\"); String token = (String) sessionNameTokenJSON.get(\"token\"); // If the session exists (\"TUTORIAL\" in this case) if (this.mapSessions.get(sessionName) != null && this.mapSessionNamesTokens.get(sessionName) != null) { // If the token exists and is succesfully removed if (this.mapSessionNamesTokens.get(sessionName).remove(token) != null) { // User left the session if (this.mapSessionNamesTokens.get(sessionName).isEmpty()) { // Last user left: session must be removed this.mapSessions.remove(sessionName); } return new ResponseEntity<>(HttpStatus.OK); } else { // The TOKEN wasn't valid System.out.println(\"Problems in the app server: the TOKEN wasn't valid\"); return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); } } else { // The SESSION does not exist System.out.println(\"Problems in the app server: the SESSION does not exist\"); return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); } } When the last user leaves the session this.mapSessions.remove(sessionName); will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated. At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: you can implement your frontend and your backend as you want . The only actual requirements are getting a valid token from openvidu-server (by using openvidu-java-client , openvidu-node-client or the REST API ) and use it in openvidu-browser to connect your clients to the sessions with Session.connect(token) $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-js-java"},{"location":"tutorials/openvidu-js-java/#openvidu-js-java","text":"Check it on GitHub A secure OpenVidu sample app with a Java backend and a SPA frontend. It makes use of openvidu-java-client to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to openvidu-mvc-java . This tutorial is intended for developers who feel more comfortable with a SPA (Single Page Application) architecture for their frontends.","title":"openvidu-js-java"},{"location":"tutorials/openvidu-js-java/#understanding-this-tutorial","text":"OpenVidu is composed by the modules displayed on the image above. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-java-client : server SDK for Java. Quick alternative to REST API openvidu-server : application to control Kurento Media Server Kurento Media Server : handles low level operations of media flow transmissions","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-js-java/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need maven to build the project. You can install it with: sudo apt-get install maven 3) Run the tutorial: cd openvidu-tutorials/openvidu-js-java mvn package exec:java 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-js-java/#understanding-the-code","text":"This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive HttpSession API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: journaldev.com , studytonight.com . Backend : SpringBoot app with the following classes ( src/main/java path, io.openvidu.js.java package) App.java : entrypoint for the app LoginController.java : rest controller for handling login and logout operations SessionController.java : rest controller for getting OpenVidu tokens. It also stores our active video-calls and the users connected to them Frontend : Plain JS/HTML/CSS files ( src/main/resources/static ) openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . index.html : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"app.js\"></script> style.css : some CSS classes to style index.html . Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.","title":"Understanding the code"},{"location":"tutorials/openvidu-js-java/#1-user-logs-in","text":"We have implemented a method for making HTTP POST requests to the backend, as we will need to make at least three of them: one for logging in, one for getting a token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this: function httpPostRequest(url, body, errorMsg, callback) Where url is the path of the POST operation, body the object to send as data, errorMsg the output error message if something goes wrong and callback the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL. index.html will first show a form to log in: app.js sends a POST request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked: function logIn() { var user = $(\"#user\").val(); // Username var pass = $(\"#pass\").val(); // Password httpPostRequest( 'api-login/login', {user: user, pass: pass}, 'Login WRONG', (response) => { // HTML shows logged-in page ... } ); } LoginController.java checks the params are correct and if so sets an HttpSession for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object): @RequestMapping(value = \"/login\", method = RequestMethod.POST) public ResponseEntity<Object> login(@RequestBody String userPass, HttpSession httpSession) throws ParseException { System.out.println(\"Logging in | {user, pass}=\" + userPass); // Retrieve params from POST body JSONObject userPassJson = (JSONObject) new JSONParser().parse(userPass); String user = (String) userPassJson.get(\"user\"); String pass = (String) userPassJson.get(\"pass\"); if (login(user, pass)) { // Correct user-pass // Validate session and return OK // Value stored in HttpSession allows us to identify the user in future requests httpSession.setAttribute(\"loggedUser\", user); return new ResponseEntity<>(HttpStatus.OK); } else { // Wrong user-pass // Invalidate session and return error httpSession.invalidate(); return new ResponseEntity<>(\"User/Pass incorrect\", HttpStatus.UNAUTHORIZED); } }","title":"1) User logs in"},{"location":"tutorials/openvidu-js-java/#2-user-connects-to-tutorial-video-call","text":"HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button: app.js will execute joinSession() method, which starts like this: function joinSession() { getToken((token) => { ... So the first thing to do here is to retrieve an OpenVidu token from our backend. Only when we have it available in the browser we will continue with the join operation. Let's see what getToken() looks like: function getToken(callback) { sessionName = $(\"#sessionName\").val(); // Video-call chosen by the user httpPostRequest( 'api-sessions/get-token', {sessionName: sessionName}, 'Request of TOKEN gone WRONG:', (response) => { token = response[0]; // Get token from response console.warn('Request of TOKEN gone WELL (TOKEN:' + token + ')'); callback(token); // Continue the join operation } ); } Here is the second time we must call our httpPostRequest() method, sending the session we want to connect ( sessionName parameter) and waiting to get a token as response. The interesting part here is in SessionController.java at /api-sessions/get-token . First of all there are some important attributes in this class we must mention: // OpenVidu object as entrypoint of the SDK private OpenVidu openVidu; // Collection to pair session names and OpenVidu Session objects private Map<String, Session> mapSessions = new ConcurrentHashMap<>(); // Collection to pair session names and tokens (the inner Map pairs tokens and role associated) private Map<String, Map<String, OpenViduRole>> mapSessionNamesTokens = new ConcurrentHashMap<>(); // URL where our OpenVidu server is listening private String OPENVIDU_URL; // Secret shared with our OpenVidu server private String SECRET; Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: tokenOptions . @RequestMapping(value = \"/get-token\", method = RequestMethod.POST) public ResponseEntity<JSONObject> getToken(@RequestBody String sessionNameParam, HttpSession httpSession) throws ParseException { // ... check the user is logged with HttpSession and continue ... JSONObject sessionJSON = (JSONObject) new JSONParser().parse(sessionNameParam); // The video-call to connect (\"TUTORIAL\") String sessionName = (String) sessionJSON.get(\"sessionName\"); // Role associated to this user OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\"loggedUser\")).role; // Optional data to be passed to other users when this user connects to the video-call // In this case, a JSON with the value we stored in the HttpSession object on login String serverData = \"{\\\"serverData\\\": \\\"\" + httpSession.getAttribute(\"loggedUser\") + \"\\\"}\"; // Build tokenOptions object with the serverData and the role TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build(); JSONObject responseJson = new JSONObject(); Just after that we check if the session \"TUTORIAL\" already exists if (this.mapSessions.get(sessionName) != null) { ... In this case it doesn't because 'publisher1' is the first user connecting to it. So we directly create a new session: // New session System.out.println(\"New session \" + sessionName); try { // Create a new OpenVidu Session Session session = this.openVidu.createSession(); // Generate a new token with the recently created tokenOptions String token = session.generateToken(tokenOptions); // Store the session and the token in our collections this.mapSessions.put(sessionName, session); this.mapSessionNamesTokens.put(sessionName, new ConcurrentHashMap<>()); this.mapSessionNamesTokens.get(sessionName).put(token, role); // Prepare the response with the token responseJson.put(0, token); // Return the response to the client return new ResponseEntity<>(responseJson, HttpStatus.OK); } catch (Exception e) { // If error generate an error message and return it to client return getErrorResponse(e); } We are almost there! Now in app.js we can init a new Session and connect to it with token : // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', (event) => { // Subscribe to the Stream to receive it // HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', (event) => { // Add a new HTML element for the user's name and nickname over its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', (event) => { // Delete the HTML element with the user's name and nickname removeUserData(event.stream.connection); }); // --- 4) Connect to the session passing the retrieved token and some more data from // the client (in this case a JSON with the nickname chosen by the user) --- var nickName = $(\"#nickName\").val(); session.connect(token, { clientData: nickName }) .then(() => { // --- 5) Set page layout for active call --- var userName = $(\"#user\").val(); $('#session-title').text(sessionName); $('#join').hide(); $('#session').show(); // Here we check somehow if the user has 'PUBLISHER' role before // trying to publish its stream. Even if someone modified the client's code and // published the stream, it wouldn't work if the token sent in Session.connect // method is not recognized as 'PUBLIHSER' role by OpenVidu Server if (isPublisher(userName)) { // --- 6) Get your own camera stream --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', (event) => { // Init the main video with ours and append our data var userData = { nickName: nickName, userName: userName }; initMainVideo(event.element, userData); appendUserData(event.element, userData); $(event.element).prop('muted', true); // Mute local video }); // --- 8) Publish your stream --- session.publish(publisher); } else { console.warn('You don\\'t have permissions to publish'); initMainVideoThumbnail(); // Show SUBSCRIBER message in main video } }) .catch(error => { console.warn('There was an error connecting to the session:', error.code, error.message); }); The user will now see its own video on the page. The connection to the session has completed!","title":"2) User connects to \"TUTORIAL\" video-call"},{"location":"tutorials/openvidu-js-java/#3-another-user-connects-to-the-video-call","text":"The process would be exactly the same as before until SessionController.java executes getToken() method. Now session 'TUTORIAL' already exists, so now we do enter the if branch that we ignored in the previous step: if (this.mapSessions.get(sessionName) != null) { // Session already exists System.out.println(\"Existing session \" + sessionName); try { // Generate a new token with the recently created tokenOptions String token = this.mapSessions.get(sessionName).generateToken(tokenOptions); // Update our collection storing the new token this.mapSessionNamesTokens.get(sessionName).put(token, role); // Prepare the response with the token responseJson.put(0, token); // Return the response to the client return new ResponseEntity<>(responseJson, HttpStatus.OK); } catch (OpenViduJavaClientException e1) { // If internal error generate an error message and return it to client return getErrorResponse(e1); } catch (OpenViduHttpException e2) { if (404 == e2.getStatus()) { // Invalid sessionId (user left unexpectedly). Session object is not valid // anymore. Clean collections and continue as new session this.mapSessions.remove(sessionName); this.mapSessionNamesTokens.remove(sessionName); } } } The code executed in app.js would also be the same. After the Session.publish() method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.","title":"3) Another user connects to the video-call"},{"location":"tutorials/openvidu-js-java/#4-users-leave-the-video-call","text":"After a while both users decide to leave the session. Apart from calling leaveSession() (and therefore session.disconnect() ) to destroy the connection on OpenVidu Server, we need to run the last POST operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, session.disconnect() updates our OpenVidu Server and the POST operation updates our application's backend. For the POST operation, in app.js we run: function removeUser() { httpPostRequest( 'api-sessions/remove-user', {sessionName: sessionName, token: token}, 'User couldn\\'t be removed from session', (response) => { console.warn(\"You have been removed from session \" + sessionName); } ); } And in SessionController.java we update the collections: @RequestMapping(value = \"/remove-user\", method = RequestMethod.POST) public ResponseEntity<JSONObject> removeUser(@RequestBody String sessionNameToken, HttpSession httpSession) throws Exception { // ... check the user is logged with HttpSession and continue ... // Retrieve the params from BODY JSONObject sessionNameTokenJSON = (JSONObject) new JSONParser().parse(sessionNameToken); String sessionName = (String) sessionNameTokenJSON.get(\"sessionName\"); String token = (String) sessionNameTokenJSON.get(\"token\"); // If the session exists (\"TUTORIAL\" in this case) if (this.mapSessions.get(sessionName) != null && this.mapSessionNamesTokens.get(sessionName) != null) { // If the token exists and is succesfully removed if (this.mapSessionNamesTokens.get(sessionName).remove(token) != null) { // User left the session if (this.mapSessionNamesTokens.get(sessionName).isEmpty()) { // Last user left: session must be removed this.mapSessions.remove(sessionName); } return new ResponseEntity<>(HttpStatus.OK); } else { // The TOKEN wasn't valid System.out.println(\"Problems in the app server: the TOKEN wasn't valid\"); return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); } } else { // The SESSION does not exist System.out.println(\"Problems in the app server: the SESSION does not exist\"); return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); } } When the last user leaves the session this.mapSessions.remove(sessionName); will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated. At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: you can implement your frontend and your backend as you want . The only actual requirements are getting a valid token from openvidu-server (by using openvidu-java-client , openvidu-node-client or the REST API ) and use it in openvidu-browser to connect your clients to the sessions with Session.connect(token) $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"4) Users leave the video-call"},{"location":"tutorials/openvidu-js-node/","text":"openvidu-js-node Check it on GitHub A secure OpenVidu sample app with a Node backend and a SPA frontend. It makes use of openvidu-node-client to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to openvidu-mvc-node . This tutorial is intended for developers who feel more comfortable with a SPA (Single Page Application) architecture for their frontends. Understanding this tutorial OpenVidu is composed by the modules displayed on the image above. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-node-client : server SDK for Node. Quick alternative to REST API openvidu-server : application to control Kurento Media Server Kurento Media Server : handles low level operations of media flow transmissions Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need node to execute the app. You can install them with: sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs 3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute server.js server passing two arguments: \"localhost:4443\" as the URL where openvidu-server will be listening and \"MY_SECRET\" as the secret share with it: cd openvidu-tutorials/openvidu-js-node npm install node server.js https://localhost:4443 MY_SECRET 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with express . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive express-session API. Backend : node server server.js : single file which handles all operations of server Frontend : Plain JS/HTML/CSS files ( /public folder) openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . index.html : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"app.js\"></script> style.css : some CSS classes to style index.html . Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while. 1) User logs in We have implemented a method for making HTTP POST requests to the backend, as we will need to make at least three of them: one for logging in, one for getting a token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this: function httpPostRequest(url, body, errorMsg, callback) Where url is the path of the POST operation, body the object to send as data, errorMsg the output error message if something goes wrong and callback the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL. index.html will first show a form to log in: app.js sends a POST request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked: function logIn() { var user = $(\"#user\").val(); // Username var pass = $(\"#pass\").val(); // Password httpPostRequest( 'api-login/login', {user: user, pass: pass}, 'Login WRONG', (response) => { // HTML shows logged-in page ... } ); } server.js at /api-login/login checks the params are correct and if so sets an active session for the newly logged user (adding a loggedUser property with its username in the req.session object): app.post('/api-login/login', function (req, res) { // Retrieve params from POST body var user = req.body.user; var pass = req.body.pass; if (login(user, pass)) { // Correct user-pass // Validate session and return OK // Value stored in req.session allows us to identify the user in future requests req.session.loggedUser = user; res.status(200).send(); } else { // Wrong user-pass // Invalidate session and return error req.session.destroy(); res.status(401).send('User/Pass incorrect'); } }); 2) User connects to \"TUTORIAL\" video-call HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button: app.js will execute joinSession() method, which starts like this: function joinSession() { getToken((token) => { ... So the first thing to do here is to retrieve an OpenVidu token from our backend. Only when we have it available in the browser we will continue with the join operation. Let's see what getToken() looks like: function getToken(callback) { sessionName = $(\"#sessionName\").val(); // Video-call chosen by the user httpPostRequest( 'api-sessions/get-token', {sessionName: sessionName}, 'Request of TOKEN gone WRONG:', (response) => { token = response[0]; // Get token from response console.warn('Request of TOKEN gone WELL (TOKEN:' + token + ')'); callback(token); // Continue the join operation } ); } Here is the second time we must call our httpPostRequest() method, sending the session we want to connect ( sessionName parameter) and waiting to get a token as response. The interesting part here is in server.js controller at /api-sessions/get-token . First of all there are some important attributes in this class we must mention: // Environment variable: URL where our OpenVidu server is listening var OPENVIDU_URL = process.argv[2]; // Environment variable: secret shared with our OpenVidu server var OPENVIDU_SECRET = process.argv[3]; // Entrypoint to OpenVidu Node Client SDK var OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); // Collection to pair session names with OpenVidu Session objects var mapSessions = {}; // Collection to pair session names with tokens var mapSessionNamesTokens = {}; Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: tokenOptions . app.post('/api-sessions/get-token', function (req, res) { // ... check the user is logged with req.session and continue ... // The video-call to connect (\"TUTORIAL\") var sessionName = req.body.sessionName; // Role associated to this user var role = users.find(u => (u.user === req.session.loggedUser)).role; // Optional data to be passed to other users when this user connects to the video-call // In this case, a JSON with the value we stored in the req.session object on login var serverData = JSON.stringify({serverData: req.session.loggedUser}); // Build tokenOptions object with the serverData and the role var tokenOptions = { data: serverData, role: role }; Just after that an if-else statement comes into play: does the session \"TUTORIAL\" already exist? if (mapSessions[sessionName]) { ... In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the else branch: else { // New session console.log('New session ' + sessionName); // Create a new OpenVidu Session asynchronously OV.createSession() .then(session => { // Store the new Session in the collection of Sessions mapSessions[sessionName] = session; // Store a new empty array in the collection of tokens mapSessionNamesTokens[sessionName] = []; // Generate a new token asynchronously with the recently created tokenOptions session.generateToken(tokenOptions) .then(token => { // Store the new token in the collection of tokens mapSessionNamesTokens[sessionName].push(token); // Return the Token to the client res.status(200).send({ 0: token }); }) .catch(error => { console.error(error); }); }) .catch(error => { console.error(error); }); } We are almost there! Now in app.js we can init a new Session and connect to it with token : // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', (event) => { // Subscribe to the Stream to receive it // HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', (event) => { // Add a new HTML element for the user's name and nickname over its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', (event) => { // Delete the HTML element with the user's name and nickname removeUserData(event.stream.connection); }); // --- 4) Connect to the session passing the retrieved token and some more data from // the client (in this case a JSON with the nickname chosen by the user) --- var nickName = $(\"#nickName\").val(); session.connect(token, { clientData: nickName }) .then(() => { // --- 5) Set page layout for active call --- var userName = $(\"#user\").val(); $('#session-title').text(sessionName); $('#join').hide(); $('#session').show(); // Here we check somehow if the user has 'PUBLISHER' role before // trying to publish its stream. Even if someone modified the client's code and // published the stream, it wouldn't work if the token sent in Session.connect // method is not recognized as 'PUBLIHSER' role by OpenVidu Server if (isPublisher(userName)) { // --- 6) Get your own camera stream --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', (event) => { // Init the main video with ours and append our data var userData = { nickName: nickName, userName: userName }; initMainVideo(event.element, userData); appendUserData(event.element, userData); $(event.element).prop('muted', true); // Mute local video }); // --- 8) Publish your stream --- session.publish(publisher); } else { console.warn('You don\\'t have permissions to publish'); initMainVideoThumbnail(); // Show SUBSCRIBER message in main video } }) .catch(error => { console.warn('There was an error connecting to the session:', error.code, error.message); }); The user will now see its own video on the page. The connection to the session has completed! 3) Another user connects to the video-call The process would be exactly the same as before until server.js executes controller at /api-sessions/get-token . Now session 'TUTORIAL' already exists, so in the if-else statement the if branch would be the one executed: if (mapSessions[sessionName]) { // Session already exists console.log('Existing session ' + sessionName); // Get the existing Session from the collection var mySession = mapSessions[sessionName]; // Generate a new token asynchronously with the recently created tokenOptions mySession.generateToken(tokenOptions) .then(token => { // Store the new token in the collection of tokens mapSessionNamesTokens[sessionName].push(token); // Return the token to the client res.status(200).send({ 0: token }); }) .catch(error => { console.error(error); }); } The code executed in app.js would also be the same. After the Session.publish() method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it. 4) Users leave the video-call After a while both users decide to leave the session. Apart from calling leaveSession() (and therefore session.disconnect() ) to destroy the connection on OpenVidu Server, we need to run the last POST operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, session.disconnect() updates our OpenVidu Server and the POST operation updates our application's backend. For the POST operation, in app.js we run: function removeUser() { httpPostRequest( 'api-sessions/remove-user', {sessionName: sessionName, token: token}, 'User couldn\\'t be removed from session', (response) => { console.warn(\"You have been removed from session \" + sessionName); } ); } And in server.js we update the collections in /api-sessions/remove-user : app.post('/api-sessions/remove-user', function (req, res) { // ... check the user is logged with req.session and continue ... // Retrieve params from POST body var sessionName = req.body.sessionName; var token = req.body.token; // If the session exists if (mapSessions[sessionName] && mapSessionNamesTokens[sessionName]) { var tokens = mapSessionNamesTokens[sessionName]; var index = tokens.indexOf(token); // If the token exists if (index !== -1) { // Token removed tokens.splice(index, 1); } else { res.status(500).send('Problems in the app server: the TOKEN wasn\\'t valid'); } if (tokens.length == 0) { // Last user left: session must be removed delete mapSessions[sessionName]; } res.status(200).send(); } else { res.status(500).send('Problems in the app server: the SESSION does not exist'); } }); When the last user leaves the session delete mapSessions[sessionName] will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated. At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: you can implement your frontend and your backend as you want . The only actual requirements are getting a valid token from openvidu-server (by using openvidu-java-client , openvidu-node-client or the REST API ) and use it in openvidu-browser to connect your clients to the sessions with Session.connect(token) $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-js-node"},{"location":"tutorials/openvidu-js-node/#openvidu-js-node","text":"Check it on GitHub A secure OpenVidu sample app with a Node backend and a SPA frontend. It makes use of openvidu-node-client to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to openvidu-mvc-node . This tutorial is intended for developers who feel more comfortable with a SPA (Single Page Application) architecture for their frontends.","title":"openvidu-js-node"},{"location":"tutorials/openvidu-js-node/#understanding-this-tutorial","text":"OpenVidu is composed by the modules displayed on the image above. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-node-client : server SDK for Node. Quick alternative to REST API openvidu-server : application to control Kurento Media Server Kurento Media Server : handles low level operations of media flow transmissions","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-js-node/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need node to execute the app. You can install them with: sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs 3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute server.js server passing two arguments: \"localhost:4443\" as the URL where openvidu-server will be listening and \"MY_SECRET\" as the secret share with it: cd openvidu-tutorials/openvidu-js-node npm install node server.js https://localhost:4443 MY_SECRET 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-js-node/#understanding-the-code","text":"This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with express . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive express-session API. Backend : node server server.js : single file which handles all operations of server Frontend : Plain JS/HTML/CSS files ( /public folder) openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file. app.js : sample application main JavaScript file, which makes use of openvidu-browser-VERSION.js . index.html : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files: <script src=\"openvidu-browser-VERSION.js\"></script> <script src=\"app.js\"></script> style.css : some CSS classes to style index.html . Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.","title":"Understanding the code"},{"location":"tutorials/openvidu-js-node/#1-user-logs-in","text":"We have implemented a method for making HTTP POST requests to the backend, as we will need to make at least three of them: one for logging in, one for getting a token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this: function httpPostRequest(url, body, errorMsg, callback) Where url is the path of the POST operation, body the object to send as data, errorMsg the output error message if something goes wrong and callback the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL. index.html will first show a form to log in: app.js sends a POST request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked: function logIn() { var user = $(\"#user\").val(); // Username var pass = $(\"#pass\").val(); // Password httpPostRequest( 'api-login/login', {user: user, pass: pass}, 'Login WRONG', (response) => { // HTML shows logged-in page ... } ); } server.js at /api-login/login checks the params are correct and if so sets an active session for the newly logged user (adding a loggedUser property with its username in the req.session object): app.post('/api-login/login', function (req, res) { // Retrieve params from POST body var user = req.body.user; var pass = req.body.pass; if (login(user, pass)) { // Correct user-pass // Validate session and return OK // Value stored in req.session allows us to identify the user in future requests req.session.loggedUser = user; res.status(200).send(); } else { // Wrong user-pass // Invalidate session and return error req.session.destroy(); res.status(401).send('User/Pass incorrect'); } });","title":"1) User logs in"},{"location":"tutorials/openvidu-js-node/#2-user-connects-to-tutorial-video-call","text":"HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button: app.js will execute joinSession() method, which starts like this: function joinSession() { getToken((token) => { ... So the first thing to do here is to retrieve an OpenVidu token from our backend. Only when we have it available in the browser we will continue with the join operation. Let's see what getToken() looks like: function getToken(callback) { sessionName = $(\"#sessionName\").val(); // Video-call chosen by the user httpPostRequest( 'api-sessions/get-token', {sessionName: sessionName}, 'Request of TOKEN gone WRONG:', (response) => { token = response[0]; // Get token from response console.warn('Request of TOKEN gone WELL (TOKEN:' + token + ')'); callback(token); // Continue the join operation } ); } Here is the second time we must call our httpPostRequest() method, sending the session we want to connect ( sessionName parameter) and waiting to get a token as response. The interesting part here is in server.js controller at /api-sessions/get-token . First of all there are some important attributes in this class we must mention: // Environment variable: URL where our OpenVidu server is listening var OPENVIDU_URL = process.argv[2]; // Environment variable: secret shared with our OpenVidu server var OPENVIDU_SECRET = process.argv[3]; // Entrypoint to OpenVidu Node Client SDK var OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); // Collection to pair session names with OpenVidu Session objects var mapSessions = {}; // Collection to pair session names with tokens var mapSessionNamesTokens = {}; Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: tokenOptions . app.post('/api-sessions/get-token', function (req, res) { // ... check the user is logged with req.session and continue ... // The video-call to connect (\"TUTORIAL\") var sessionName = req.body.sessionName; // Role associated to this user var role = users.find(u => (u.user === req.session.loggedUser)).role; // Optional data to be passed to other users when this user connects to the video-call // In this case, a JSON with the value we stored in the req.session object on login var serverData = JSON.stringify({serverData: req.session.loggedUser}); // Build tokenOptions object with the serverData and the role var tokenOptions = { data: serverData, role: role }; Just after that an if-else statement comes into play: does the session \"TUTORIAL\" already exist? if (mapSessions[sessionName]) { ... In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the else branch: else { // New session console.log('New session ' + sessionName); // Create a new OpenVidu Session asynchronously OV.createSession() .then(session => { // Store the new Session in the collection of Sessions mapSessions[sessionName] = session; // Store a new empty array in the collection of tokens mapSessionNamesTokens[sessionName] = []; // Generate a new token asynchronously with the recently created tokenOptions session.generateToken(tokenOptions) .then(token => { // Store the new token in the collection of tokens mapSessionNamesTokens[sessionName].push(token); // Return the Token to the client res.status(200).send({ 0: token }); }) .catch(error => { console.error(error); }); }) .catch(error => { console.error(error); }); } We are almost there! Now in app.js we can init a new Session and connect to it with token : // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', (event) => { // Subscribe to the Stream to receive it // HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', (event) => { // Add a new HTML element for the user's name and nickname over its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', (event) => { // Delete the HTML element with the user's name and nickname removeUserData(event.stream.connection); }); // --- 4) Connect to the session passing the retrieved token and some more data from // the client (in this case a JSON with the nickname chosen by the user) --- var nickName = $(\"#nickName\").val(); session.connect(token, { clientData: nickName }) .then(() => { // --- 5) Set page layout for active call --- var userName = $(\"#user\").val(); $('#session-title').text(sessionName); $('#join').hide(); $('#session').show(); // Here we check somehow if the user has 'PUBLISHER' role before // trying to publish its stream. Even if someone modified the client's code and // published the stream, it wouldn't work if the token sent in Session.connect // method is not recognized as 'PUBLIHSER' role by OpenVidu Server if (isPublisher(userName)) { // --- 6) Get your own camera stream --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', (event) => { // Init the main video with ours and append our data var userData = { nickName: nickName, userName: userName }; initMainVideo(event.element, userData); appendUserData(event.element, userData); $(event.element).prop('muted', true); // Mute local video }); // --- 8) Publish your stream --- session.publish(publisher); } else { console.warn('You don\\'t have permissions to publish'); initMainVideoThumbnail(); // Show SUBSCRIBER message in main video } }) .catch(error => { console.warn('There was an error connecting to the session:', error.code, error.message); }); The user will now see its own video on the page. The connection to the session has completed!","title":"2) User connects to \"TUTORIAL\" video-call"},{"location":"tutorials/openvidu-js-node/#3-another-user-connects-to-the-video-call","text":"The process would be exactly the same as before until server.js executes controller at /api-sessions/get-token . Now session 'TUTORIAL' already exists, so in the if-else statement the if branch would be the one executed: if (mapSessions[sessionName]) { // Session already exists console.log('Existing session ' + sessionName); // Get the existing Session from the collection var mySession = mapSessions[sessionName]; // Generate a new token asynchronously with the recently created tokenOptions mySession.generateToken(tokenOptions) .then(token => { // Store the new token in the collection of tokens mapSessionNamesTokens[sessionName].push(token); // Return the token to the client res.status(200).send({ 0: token }); }) .catch(error => { console.error(error); }); } The code executed in app.js would also be the same. After the Session.publish() method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.","title":"3) Another user connects to the video-call"},{"location":"tutorials/openvidu-js-node/#4-users-leave-the-video-call","text":"After a while both users decide to leave the session. Apart from calling leaveSession() (and therefore session.disconnect() ) to destroy the connection on OpenVidu Server, we need to run the last POST operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, session.disconnect() updates our OpenVidu Server and the POST operation updates our application's backend. For the POST operation, in app.js we run: function removeUser() { httpPostRequest( 'api-sessions/remove-user', {sessionName: sessionName, token: token}, 'User couldn\\'t be removed from session', (response) => { console.warn(\"You have been removed from session \" + sessionName); } ); } And in server.js we update the collections in /api-sessions/remove-user : app.post('/api-sessions/remove-user', function (req, res) { // ... check the user is logged with req.session and continue ... // Retrieve params from POST body var sessionName = req.body.sessionName; var token = req.body.token; // If the session exists if (mapSessions[sessionName] && mapSessionNamesTokens[sessionName]) { var tokens = mapSessionNamesTokens[sessionName]; var index = tokens.indexOf(token); // If the token exists if (index !== -1) { // Token removed tokens.splice(index, 1); } else { res.status(500).send('Problems in the app server: the TOKEN wasn\\'t valid'); } if (tokens.length == 0) { // Last user left: session must be removed delete mapSessions[sessionName]; } res.status(200).send(); } else { res.status(500).send('Problems in the app server: the SESSION does not exist'); } }); When the last user leaves the session delete mapSessions[sessionName] will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated. At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: you can implement your frontend and your backend as you want . The only actual requirements are getting a valid token from openvidu-server (by using openvidu-java-client , openvidu-node-client or the REST API ) and use it in openvidu-browser to connect your clients to the sessions with Session.connect(token) $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"4) Users leave the video-call"},{"location":"tutorials/openvidu-library-angular/","text":"openvidu-library-angular Check it on GitHub OpenVidu Library Angular is one of the simplest and quickest tutorials to add videoconference capabilities to your existing web application. This tutorial uses openvidu-angular library. Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need angular-cli (and of course NPM) to serve the Angular frontend. You can install it with the following command: npm install -g @angular/cli@latest 3) Run the tutorial: cd openvidu-tutorials/openvidu-library-angular npm install ng serve 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:4200 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This is a basic Angular project generated with angular-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/app/ folder app.component.ts : defines AppComponent , main component of the app. It contains the functionalities for for handling the the events received from openvidu-angular . app.component.html : HTML for AppComponent. app.component.css : CSS for AppComponent. We must include these elements: 1) First of all, obviously you have to install openvidu-angular: npm install openvidu-angular --save 2) Angular Material is included in openvidu-angular neverthelesst you need to include a theme style in your application. If you're using the Angular CLI, you can add this to your styles.css : @import \"~@angular/material/prebuilt-themes/indigo-pink.css\"; 3) Finally, you need to include Jquery script, the global variable and Material icons font in the index.html file: <head> <!--... other imports ...--> <script src=\"https://code.jquery.com/jquery-3.3.1.min.js\" integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"></script> <script> var global = global || window; </script> <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"> </head> app.module.ts Inside of the app.module.ts you must import OpenviduSessionModule from openvidu-angular : import { OpenviduSessionModule } from 'openvidu-angular'; Moreover, you need to include OpenviduSessionModule inside of imports section of NgModule : imports: [ BrowserModule, FormsModule, OpenviduSessionModule ] Configuring OpenVidu Angular app.component.html As you can see here, you can use <opv-session></opv-session> component to embed openvidu session in your application in a very easy way. Our component will start hidden: <div *ngIf=\"!session\" id=\"join\"> <div id=\"join-dialog\"> <h1>Join a video session</h1> <form (submit)=\"joinSession()\"> <p> <label>Participant </label> <input type=\"text\" id=\"userName\" name=\"userName\" [(ngModel)]=\"myUserName\" required> </p> <p> <label>Session </label> <input type=\"text\" id=\"sessionId\" name=\"sessionId\" [(ngModel)]=\"mySessionId\" required> </p> <p class=\"text-center\"> <input type=\"submit\" name=\"commit\" value=\"Join!\"> </p> </form> </div> </div> <div *ngIf=\"session\" id=\"session\"> <opv-session></opv-session> </div> app.component.ts Method joinSession() gets the token which we provide to our component to connect to the session. You can configure the opv-session with these parameters: sessionName : the session name that will be displayed inside the component user : the nickname that the user will have in the session token : the retrieved token from OpenVidu Server ovSettings : the configuration that the user want to have on the session <opv-session [sessionName]=\"mySessionId\" [user]=\"myUserName\" [token]=\"token\" [ovSettings]=\"ovSettings\" (leaveSession)=\"handlerLeaveSessionEvent($event)\" (joinSession)=\"handlerJoinSessionEvent($event)\" (error)=\"handlerErrorEvent($event)\"> </opv-session> Moreover, opv-session emits events leaveSession , joinSession and error , we can handle them with the next code in app.component.ts file: handlerJoinSessionEvent(event): void { // Do something } handlerLeaveSessionEvent(event): void { // Do something } handlerErrorEvent(event): void { // Do something } In addiction, openvidu-library-angular allows you to have access to specifics internals variables such as OpenVidu Session , OpenVidu Layout , Local User or Remotes User . You can access to them through the following way: 1) You must assign a referece to the opv-session , inside of app.component.html with #ovSessionComponent : <opv-session #ovSessionComponent [sessionName]=\"mySessionId\" [user]=\"myUserName\" [token]=\"token\" [ovSettings]=\"ovSettings\" (leaveSession)=\"handlerLeaveSessionEvent($event)\" (joinSession)=\"handlerJoinSessionEvent($event)\" (error)=\"handlerErrorEvent($event)\"> </opv-session> 2) You have to declare the openvidu component variable in app.component.ts : @ViewChild('ovSessionComponent') public ovSessionComponent: OpenviduSessionComponent; 3) After that, ovSessionComponent will provides us some methods to get the internal variables we need. These methods are: getSession : This method will provide you the Session. Check the Session documentation here getLocalUser : This method will provide you the User. You can check the documentation about the User Class here getOpenviduLayout : This method will return the OpenVidu Layout Object. You can check the information about the OpenVidu Layout Class here getOpenviduLayoutOptions : This method will return the layout options. Click here to more information. myMethod() { this.ovSession = this.ovSessionComponent.getSession(); this.ovLocalUser = this.ovSessionComponent.getLocalUser(); this.ovLayout = this.ovSessionComponent.getOpenviduLayout(); this.ovLayoutOptions = this.ovSessionComponent.getOpenviduLayoutOptions(); } We are invoking myMethod inside of handlerJoinSessionEvent . 4) Last but not least, you must stablish the local variables like this: import {OpenviduSessionComponent, StreamEvent, Session, UserModel, OpenViduLayout, OpenViduLayoutOptions, OvSettings} from 'openvidu-angular'; ovSession: Session; ovRemotesArray: UserModel[]; ovLocalUser: UserModel; ovLayout: OpenViduLayout; ovLayoutOptions: OpenViduLayoutOptions; ovSettings: OvSettings; Moreover, if you want to customize the interface of opv-session-component you can provide a parameter ovSettings to the component. Further details on this topic here . And initializate it with the config properties: this.ovSettings = { chat: false, autopublish: true, toolbarButtons: { audio: true, video: true, screenShare: true, fullscreen: true, exit: true, } }; Get a token from OpenVidu Server WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server this.getToken().then((token) => { // Save the 'token' in token variable }); In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our sessionName value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Extra features of OpenVidu Angular Alternatives to connect to OpenVidu Angular In the example above, opv-session receives the sessionName , the user and the token parameters. If you want to let the opv-session get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the typescript code: <opv-session [sessionName]=\"mySessionId\" [user]=\"myUserName\" [openviduServerUrl]=\"'https://localhost:4443'\" [openviduSecret]=\"'MY_SECRET'\"></opv-session> $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-library-angular"},{"location":"tutorials/openvidu-library-angular/#openvidu-library-angular","text":"Check it on GitHub OpenVidu Library Angular is one of the simplest and quickest tutorials to add videoconference capabilities to your existing web application. This tutorial uses openvidu-angular library.","title":"openvidu-library-angular"},{"location":"tutorials/openvidu-library-angular/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need angular-cli (and of course NPM) to serve the Angular frontend. You can install it with the following command: npm install -g @angular/cli@latest 3) Run the tutorial: cd openvidu-tutorials/openvidu-library-angular npm install ng serve 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:4200 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-library-angular/#understanding-the-code","text":"This is a basic Angular project generated with angular-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/app/ folder app.component.ts : defines AppComponent , main component of the app. It contains the functionalities for for handling the the events received from openvidu-angular . app.component.html : HTML for AppComponent. app.component.css : CSS for AppComponent.","title":"Understanding the code"},{"location":"tutorials/openvidu-library-angular/#we-must-include-these-elements","text":"1) First of all, obviously you have to install openvidu-angular: npm install openvidu-angular --save 2) Angular Material is included in openvidu-angular neverthelesst you need to include a theme style in your application. If you're using the Angular CLI, you can add this to your styles.css : @import \"~@angular/material/prebuilt-themes/indigo-pink.css\"; 3) Finally, you need to include Jquery script, the global variable and Material icons font in the index.html file: <head> <!--... other imports ...--> <script src=\"https://code.jquery.com/jquery-3.3.1.min.js\" integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"></script> <script> var global = global || window; </script> <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"> </head>","title":"We must include these elements:"},{"location":"tutorials/openvidu-library-angular/#appmodulets","text":"Inside of the app.module.ts you must import OpenviduSessionModule from openvidu-angular : import { OpenviduSessionModule } from 'openvidu-angular'; Moreover, you need to include OpenviduSessionModule inside of imports section of NgModule : imports: [ BrowserModule, FormsModule, OpenviduSessionModule ]","title":"app.module.ts"},{"location":"tutorials/openvidu-library-angular/#configuring-openvidu-angular","text":"","title":"Configuring OpenVidu Angular"},{"location":"tutorials/openvidu-library-angular/#appcomponenthtml","text":"As you can see here, you can use <opv-session></opv-session> component to embed openvidu session in your application in a very easy way. Our component will start hidden: <div *ngIf=\"!session\" id=\"join\"> <div id=\"join-dialog\"> <h1>Join a video session</h1> <form (submit)=\"joinSession()\"> <p> <label>Participant </label> <input type=\"text\" id=\"userName\" name=\"userName\" [(ngModel)]=\"myUserName\" required> </p> <p> <label>Session </label> <input type=\"text\" id=\"sessionId\" name=\"sessionId\" [(ngModel)]=\"mySessionId\" required> </p> <p class=\"text-center\"> <input type=\"submit\" name=\"commit\" value=\"Join!\"> </p> </form> </div> </div> <div *ngIf=\"session\" id=\"session\"> <opv-session></opv-session> </div>","title":"app.component.html"},{"location":"tutorials/openvidu-library-angular/#appcomponentts","text":"Method joinSession() gets the token which we provide to our component to connect to the session. You can configure the opv-session with these parameters: sessionName : the session name that will be displayed inside the component user : the nickname that the user will have in the session token : the retrieved token from OpenVidu Server ovSettings : the configuration that the user want to have on the session <opv-session [sessionName]=\"mySessionId\" [user]=\"myUserName\" [token]=\"token\" [ovSettings]=\"ovSettings\" (leaveSession)=\"handlerLeaveSessionEvent($event)\" (joinSession)=\"handlerJoinSessionEvent($event)\" (error)=\"handlerErrorEvent($event)\"> </opv-session> Moreover, opv-session emits events leaveSession , joinSession and error , we can handle them with the next code in app.component.ts file: handlerJoinSessionEvent(event): void { // Do something } handlerLeaveSessionEvent(event): void { // Do something } handlerErrorEvent(event): void { // Do something } In addiction, openvidu-library-angular allows you to have access to specifics internals variables such as OpenVidu Session , OpenVidu Layout , Local User or Remotes User . You can access to them through the following way: 1) You must assign a referece to the opv-session , inside of app.component.html with #ovSessionComponent : <opv-session #ovSessionComponent [sessionName]=\"mySessionId\" [user]=\"myUserName\" [token]=\"token\" [ovSettings]=\"ovSettings\" (leaveSession)=\"handlerLeaveSessionEvent($event)\" (joinSession)=\"handlerJoinSessionEvent($event)\" (error)=\"handlerErrorEvent($event)\"> </opv-session> 2) You have to declare the openvidu component variable in app.component.ts : @ViewChild('ovSessionComponent') public ovSessionComponent: OpenviduSessionComponent; 3) After that, ovSessionComponent will provides us some methods to get the internal variables we need. These methods are: getSession : This method will provide you the Session. Check the Session documentation here getLocalUser : This method will provide you the User. You can check the documentation about the User Class here getOpenviduLayout : This method will return the OpenVidu Layout Object. You can check the information about the OpenVidu Layout Class here getOpenviduLayoutOptions : This method will return the layout options. Click here to more information. myMethod() { this.ovSession = this.ovSessionComponent.getSession(); this.ovLocalUser = this.ovSessionComponent.getLocalUser(); this.ovLayout = this.ovSessionComponent.getOpenviduLayout(); this.ovLayoutOptions = this.ovSessionComponent.getOpenviduLayoutOptions(); } We are invoking myMethod inside of handlerJoinSessionEvent . 4) Last but not least, you must stablish the local variables like this: import {OpenviduSessionComponent, StreamEvent, Session, UserModel, OpenViduLayout, OpenViduLayoutOptions, OvSettings} from 'openvidu-angular'; ovSession: Session; ovRemotesArray: UserModel[]; ovLocalUser: UserModel; ovLayout: OpenViduLayout; ovLayoutOptions: OpenViduLayoutOptions; ovSettings: OvSettings; Moreover, if you want to customize the interface of opv-session-component you can provide a parameter ovSettings to the component. Further details on this topic here . And initializate it with the config properties: this.ovSettings = { chat: false, autopublish: true, toolbarButtons: { audio: true, video: true, screenShare: true, fullscreen: true, exit: true, } };","title":"app.component.ts"},{"location":"tutorials/openvidu-library-angular/#get-a-token-from-openvidu-server","text":"WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server this.getToken().then((token) => { // Save the 'token' in token variable }); In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our sessionName value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-library-angular/#extra-features-of-openvidu-angular","text":"","title":"Extra features of OpenVidu Angular"},{"location":"tutorials/openvidu-library-angular/#alternatives-to-connect-to-openvidu-angular","text":"In the example above, opv-session receives the sessionName , the user and the token parameters. If you want to let the opv-session get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the typescript code: <opv-session [sessionName]=\"mySessionId\" [user]=\"myUserName\" [openviduServerUrl]=\"'https://localhost:4443'\" [openviduSecret]=\"'MY_SECRET'\"></opv-session> $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Alternatives to connect to OpenVidu Angular"},{"location":"tutorials/openvidu-library-react/","text":"openvidu-library-react Check it on GitHub OpenVidu Library React is one of the simplest and quickest tutorials to add videoconference capabilities to your existing web application. This tutorial uses openvidu-react library. Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) Run the tutorial: cd openvidu-tutorials/openvidu-library-react npm install npm start 3) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 4) Go to localhost:3000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This is a basic React project generated with npx create-react-app , and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/ folder App.js : defines App Component , main component of the app. It contains the JSX code and the functionalities for for handling the the events received from openvidu-react . App.css : CSS for App Component. We must include openvidu-react and axios in our app: 1) First of all, you need to install openvidu-react : npm install openvidu-react --save After that, you must include OpvSession in App.js file: import OpvSession from 'openvidu-react'; 2) Secondly, you need to install axios that allows you to do HTTP requests: npm install axios --save And include it in \u00c0pp.js : import axios from 'axios'; Configuring OpenVidu React App.js As you can see here, you can use <OpvSession></OpvSession> component to embed openvidu session in your application in a very easy way. Our component will start hidden: <div> {this.state.session === undefined ? ( <div id=\"join\"> <div id=\"join-dialog\"> <h1> Join a video session </h1> <form onSubmit={this.joinSession}> <p> <label>Participant: </label> <input type=\"text\" id=\"userName\" value={myUserName} onChange={this.handleChangeUserName} required /> </p> <p> <label> Session: </label> <input type=\"text\" id=\"sessionId\" value={mySessionId} onChange={this.handleChangeSessionId} required /> </p> <p> <input name=\"commit\" type=\"submit\" value=\"JOIN\" /> </p> </form> </div> </div> ) : ( <div id=\"session\"> <OpvSession/> </div> )} </div> Method joinSession() gets the token which we provide to our component to connect to the session. You can configure the OpvSession with these parameters: sessionName : the session name that will be displayed inside the component user : the nickname that the user will have in the session token : the retrieved token from OpenVidu Server <OpvSession id=\"opv-session\" sessionName={mySessionId} user={myUserName} token={token} joinSession={this.handlerJoinSessionEvent} leaveSession={this.handlerLeaveSessionEvent} error={this.handlerErrorEvent} /> Moreover, OpvSession emits events leaveSession , joinSession and error , we can handle them with the next code in app.component.ts file: handlerJoinSessionEvent(event) { // Do something } handlerLeaveSessionEvent(event) { // Do something } handlerErrorEvent(event) { // Do something } Get a token from OpenVidu Server WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server this.getToken().then((token) => { // Update the state with the token }); In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our sessionName value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Extra features of OpenVidu React Alternatives to connect to OpenVidu React In the example above, OpvSession receives the sessionName , the user and the token parameters. If you want to let the OpvSession get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the JavaScript code: <OpvSession id=\"opv-session\" sessionName={mySessionId} user={myUserName} openviduServerUrl={'https://localhost:4443'} openviduSecret={'MY_SECRET'} joinSession={this.handlerJoinSessionEvent} leaveSession={this.handlerLeaveSessionEvent} error={this.handlerErrorEvent} /> $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-library-react"},{"location":"tutorials/openvidu-library-react/#openvidu-library-react","text":"Check it on GitHub OpenVidu Library React is one of the simplest and quickest tutorials to add videoconference capabilities to your existing web application. This tutorial uses openvidu-react library.","title":"openvidu-library-react"},{"location":"tutorials/openvidu-library-react/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) Run the tutorial: cd openvidu-tutorials/openvidu-library-react npm install npm start 3) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 4) Go to localhost:3000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-library-react/#understanding-the-code","text":"This is a basic React project generated with npx create-react-app , and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under src/ folder App.js : defines App Component , main component of the app. It contains the JSX code and the functionalities for for handling the the events received from openvidu-react . App.css : CSS for App Component.","title":"Understanding the code"},{"location":"tutorials/openvidu-library-react/#we-must-include-openvidu-react-and-axios-in-our-app","text":"1) First of all, you need to install openvidu-react : npm install openvidu-react --save After that, you must include OpvSession in App.js file: import OpvSession from 'openvidu-react'; 2) Secondly, you need to install axios that allows you to do HTTP requests: npm install axios --save And include it in \u00c0pp.js : import axios from 'axios';","title":"We must include openvidu-react and axios in our app:"},{"location":"tutorials/openvidu-library-react/#configuring-openvidu-react","text":"","title":"Configuring OpenVidu React"},{"location":"tutorials/openvidu-library-react/#appjs","text":"As you can see here, you can use <OpvSession></OpvSession> component to embed openvidu session in your application in a very easy way. Our component will start hidden: <div> {this.state.session === undefined ? ( <div id=\"join\"> <div id=\"join-dialog\"> <h1> Join a video session </h1> <form onSubmit={this.joinSession}> <p> <label>Participant: </label> <input type=\"text\" id=\"userName\" value={myUserName} onChange={this.handleChangeUserName} required /> </p> <p> <label> Session: </label> <input type=\"text\" id=\"sessionId\" value={mySessionId} onChange={this.handleChangeSessionId} required /> </p> <p> <input name=\"commit\" type=\"submit\" value=\"JOIN\" /> </p> </form> </div> </div> ) : ( <div id=\"session\"> <OpvSession/> </div> )} </div> Method joinSession() gets the token which we provide to our component to connect to the session. You can configure the OpvSession with these parameters: sessionName : the session name that will be displayed inside the component user : the nickname that the user will have in the session token : the retrieved token from OpenVidu Server <OpvSession id=\"opv-session\" sessionName={mySessionId} user={myUserName} token={token} joinSession={this.handlerJoinSessionEvent} leaveSession={this.handlerLeaveSessionEvent} error={this.handlerErrorEvent} /> Moreover, OpvSession emits events leaveSession , joinSession and error , we can handle them with the next code in app.component.ts file: handlerJoinSessionEvent(event) { // Do something } handlerLeaveSessionEvent(event) { // Do something } handlerErrorEvent(event) { // Do something }","title":"App.js"},{"location":"tutorials/openvidu-library-react/#get-a-token-from-openvidu-server","text":"WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server this.getToken().then((token) => { // Update the state with the token }); In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our sessionName value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-library-react/#extra-features-of-openvidu-react","text":"","title":"Extra features of OpenVidu React"},{"location":"tutorials/openvidu-library-react/#alternatives-to-connect-to-openvidu-react","text":"In the example above, OpvSession receives the sessionName , the user and the token parameters. If you want to let the OpvSession get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the JavaScript code: <OpvSession id=\"opv-session\" sessionName={mySessionId} user={myUserName} openviduServerUrl={'https://localhost:4443'} openviduSecret={'MY_SECRET'} joinSession={this.handlerJoinSessionEvent} leaveSession={this.handlerLeaveSessionEvent} error={this.handlerErrorEvent} /> $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Alternatives to connect to OpenVidu React"},{"location":"tutorials/openvidu-mvc-java/","text":"openvidu-mvc-java Check it on GitHub A secure OpenVidu sample app with a Java backend and a traditional MVC frontend. It makes use of openvidu-java-client to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to openvidu-js-java . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. Thymeleaf is the template engine of choice for this tutorial. Understanding this tutorial OpenVidu is composed by the modules displayed on the image above. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-java-client : server SDK for Java. Quick alternative to REST API openvidu-server : application to control Kurento Media Server Kurento Media Server : handles low level operations of media flow transmissions Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need maven to build the project. You can install it with: sudo apt-get install maven 3) Run the tutorial: cd openvidu-tutorials/openvidu-mvc-java mvn package exec:java 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend that serves HTML files with a MVC approach, building the templates with the help of Thymeleaf . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive HttpSession API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: journaldev.com , studytonight.com . Backend : SpringBoot app with the following classes ( src/main/java path, io.openvidu.js.java package) App.java : entrypoint for the app LoginController.java : controller for handling login and logout operations SessionController.java : controller for getting OpenVidu tokens. It also stores our active video-calls and the users connected to them Frontend templates : Plain JS/HTML/CSS files served by the backend ( src/main/resources/templates ) index.html : template with the login form dashboard.html : template with the form to join a video-call session.html : template of the video-call itself Frontend static files ( src/main/resources/static ) openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file style.css : some CSS classes to style the templates Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while. 1) User logs in At path / a login form will be displayed: The form will execute a POST operation to path /dashboard whenever \"Log in\" button is clicked, passing the username and the password: <form class=\"form-group jumbotron\" action=\"/dashboard\" method=\"post\"> <p> <label>User</label> <input class=\"form-control\" type=\"text\" name=\"user\" required=\"true\"></input> </p> <p> <label>Pass</label> <input class=\"form-control\" type=\"password\" name=\"pass\" required=\"true\"></input> </p> <p class=\"text-center\"> <button class=\"btn btn-lg btn-info\" type=\"submit\">Log in</button> </p> </form> LoginController.java first checks if the user is already logged (maybe he has just refreshed /dashboard page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets an HttpSession for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object). Finally it returns dashboard.html template: @RequestMapping(value = \"/dashboard\", method = { RequestMethod.GET, RequestMethod.POST }) public String login(@RequestParam(name = \"user\", required = false) String user, @RequestParam(name = \"pass\", required = false) String pass, Model model, HttpSession httpSession) { // Check if the user is already logged in String userName = (String) httpSession.getAttribute(\"loggedUser\"); if (userName != null) { // User is already logged. Immediately return dashboard model.addAttribute(\"username\", userName); return \"dashboard\"; } // User wasn't logged and wants to if (login(user, pass)) { // Correct user-pass // Validate session and return OK // Value stored in HttpSession allows us to identify the user in future requests httpSession.setAttribute(\"loggedUser\", user); model.addAttribute(\"username\", user); // Return dashboard.html template return \"dashboard\"; } else { // Wrong user-pass // Invalidate session and redirect to index.html httpSession.invalidate(); return \"redirect:/\"; } } 2) User connects to \"TUTORIAL\" video-call dashboard.html template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field: The form will execute a POST operation to path /session whenever \"Join!\" button is clicked, passing the nickname and the session name: <form class=\"form-group\" action=\"/session\" method=\"post\"> <p> <label>Participant</label> <input class=\"form-control\" type=\"text\" name=\"data\" required=\"true\"></input> </p> <p> <label>Session</label> <input class=\"form-control\" type=\"text\" name=\"session-name\" required=\"true\"></input> </p> <p class=\"text-center\"> <button class=\"btn btn-lg btn-success\" type=\"submit\">Join!</button> </p> </form> When SessionController.java receives a request at /session path is when things get interesting. First of all there are some important attributes in this class we must mention: // OpenVidu object as entrypoint of the SDK private OpenVidu openVidu; // Collection to pair session names and OpenVidu Session objects private Map<String, Session> mapSessions = new ConcurrentHashMap<>(); // Collection to pair session names and tokens (the inner Map pairs tokens and role associated) private Map<String, Map<String, OpenViduRole>> mapSessionNamesTokens = new ConcurrentHashMap<>(); // URL where our OpenVidu server is listening private String OPENVIDU_URL; // Secret shared with our OpenVidu server private String SECRET; Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: tokenOptions . @RequestMapping(value = \"/session\", method = RequestMethod.POST) public String joinSession(@RequestParam(name = \"data\") String clientData, @RequestParam(name = \"session-name\") String sessionName, Model model, HttpSession httpSession) { // ... check the user is logged with HttpSession and continue ... // Role associated to this user OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\"loggedUser\")).role; // Optional data to be passed to other users when this user connects to the video-call // In this case, a JSON with the value we stored in the HttpSession object on login String serverData = \"{\\\"serverData\\\": \\\"\" + httpSession.getAttribute(\"loggedUser\") + \"\\\"}\"; // Build tokenOptions object with the serverData and the role TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build(); Just after that an if-else statement comes into play: does the session \"TUTORIAL\" already exist? if (this.mapSessions.get(sessionName) != null) { ... In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the else branch: else { // New session System.out.println(\"New session \" + sessionName); try { // Create a new OpenVidu Session Session session = this.openVidu.createSession(); // Generate a new token with the recently created tokenOptions String token = session.generateToken(tokenOptions); // Store the session and the token in our collections this.mapSessions.put(sessionName, session); this.mapSessionNamesTokens.put(sessionName, new ConcurrentHashMap<>()); this.mapSessionNamesTokens.get(sessionName).put(token, role); // Add all the needed attributes to the template model.addAttribute(\"sessionName\", sessionName); model.addAttribute(\"token\", token); model.addAttribute(\"nickName\", clientData); model.addAttribute(\"userName\", httpSession.getAttribute(\"loggedUser\")); // Return session.html template return \"session\"; } catch (Exception e) { // If error just return dashboard.html template model.addAttribute(\"username\", httpSession.getAttribute(\"loggedUser\")); return \"dashboard\"; } } We are almost there! Now in session.html JavaScript code (preceded by a tag <script th:inline=\"javascript\"> ) we can init a new Session and connect to it with token : // Get all the attributes from the template in Thymeleaf style var sessionName = [[${ sessionName }]]; var token = [[${ token }]]; var nickName = [[${ nickName }]]; var userName = [[${ userName }]]; // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', (event) => { // Subscribe to the Stream to receive it // HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', (event) => { // Add a new HTML element for the user's name and nickname over its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', (event) => { // Delete the HTML element with the user's name and nickname removeUserData(event.stream.connection); }); // --- 4) Connect to the session passing the retrieved token and some more data from // the client (in this case a JSON with the nickname chosen by the user) --- session.connect(token, { clientData: nickName }) .then(() => { // --- 5) Set page layout for active call --- $('#session-title').text(sessionName); $('#join').hide(); $('#session').show(); // Here we check somehow if the user has 'PUBLISHER' role before // trying to publish its stream. Even if someone modified the client's code and // published the stream, it wouldn't work if the token sent in Session.connect // method is not recognized as 'PUBLIHSER' role by OpenVidu Server if (isPublisher()) { // --- 6) Get your own camera stream --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', (event) => { // Init the main video with ours and append our data var userData = { nickName: nickName, userName: userName }; initMainVideo(event.element, userData); appendUserData(event.element, userData); $(event.element).prop('muted', true); // Mute local video }); // --- 8) Publish your stream --- session.publish(publisher); } else { console.warn('You don\\'t have permissions to publish'); initMainVideoThumbnail(); // Show SUBSCRIBER message in main video } }) .catch(error => { console.warn('There was an error connecting to the session:', error.code, error.message); }); The user will now see its own video on the page. The connection to the session has completed! 3) Another user connects to the video-call The process would be exactly the same as before until SessionController.java executes joinSession() method. Now session 'TUTORIAL' already exists, so in the if-else statement the if branch would be the one executed: if (this.mapSessions.get(sessionName) != null) { // Session already exists System.out.println(\"Existing session \" + sessionName); try { // Generate a new token with the recently created tokenOptions String token = this.mapSessions.get(sessionName).generateToken(tokenOptions); // Update our collection storing the new token this.mapSessionNamesTokens.get(sessionName).put(token, role); // Add all the needed attributes to the template model.addAttribute(\"sessionName\", sessionName); model.addAttribute(\"token\", token); model.addAttribute(\"nickName\", clientData); model.addAttribute(\"userName\", httpSession.getAttribute(\"loggedUser\")); // Return session.html template return \"session\"; } catch (Exception e) { // If error just return dashboard.html template model.addAttribute(\"username\", httpSession.getAttribute(\"loggedUser\")); return \"dashboard\"; } } The code executed in session.html < script > tag would also be the same. After the Session.publish() method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it. 4) Users leave the video-call After a while both users decide to leave the session. Apart from calling session.disconnect() (triggered in leaveSession() onclick method) to destroy the connection on OpenVidu Server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. In session.html template the \"Leave session\" button actually performs a POST operation to path /leave-session with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the leaveSession() method. First updates our application's backend. Second updates our OpenVidu Server. <form action=\"/leave-session\" method=\"post\"> <input type=\"hidden\" name=\"session-name\" th:value=\"${sessionName}\"></input> <input type=\"hidden\" name=\"token\" th:value=\"${token}\"></input> <button id=\"buttonLeaveSession\" class=\"btn btn-large btn-danger\" type=\"submit\" onclick=\"leaveSession()\"> Leave session</button> </form> In SessionController.java we update the collections: @RequestMapping(value = \"/leave-session\", method = RequestMethod.POST) public String removeUser(@RequestParam(name = \"session-name\") String sessionName, @RequestParam(name = \"token\") String token, Model model, HttpSession httpSession) throws Exception { // ... check the user is logged with HttpSession and continue ... // If the session exists (\"TUTORIAL\" in this case) if (this.mapSessions.get(sessionName) != null && this.mapSessionNamesTokens.get(sessionName) != null) { // If the token exists if (this.mapSessionNamesTokens.get(sessionName).remove(token) != null) { // User left the session if (this.mapSessionNamesTokens.get(sessionName).isEmpty()) { // Last user left: session must be removed this.mapSessions.remove(sessionName); } return \"redirect:/dashboard\"; } else { // The TOKEN wasn't valid System.out.println(\"Problems in the app server: the TOKEN wasn't valid\"); return \"redirect:/dashboard\"; } } else { // The SESSION does not exist System.out.println(\"Problems in the app server: the SESSION does not exist\"); return \"redirect:/dashboard\"; } } When the last user leaves the session this.mapSessions.remove(sessionName); will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated. At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: you can implement your frontend and your backend as you want . The only actual requirements are getting a valid token from openvidu-server (by using openvidu-java-client , openvidu-node-client or the REST API ) and use it in openvidu-browser to connect your clients to the sessions with Session.connect(token) $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-mvc-java"},{"location":"tutorials/openvidu-mvc-java/#openvidu-mvc-java","text":"Check it on GitHub A secure OpenVidu sample app with a Java backend and a traditional MVC frontend. It makes use of openvidu-java-client to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to openvidu-js-java . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. Thymeleaf is the template engine of choice for this tutorial.","title":"openvidu-mvc-java"},{"location":"tutorials/openvidu-mvc-java/#understanding-this-tutorial","text":"OpenVidu is composed by the modules displayed on the image above. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-java-client : server SDK for Java. Quick alternative to REST API openvidu-server : application to control Kurento Media Server Kurento Media Server : handles low level operations of media flow transmissions","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-mvc-java/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need maven to build the project. You can install it with: sudo apt-get install maven 3) Run the tutorial: cd openvidu-tutorials/openvidu-mvc-java mvn package exec:java 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-mvc-java/#understanding-the-code","text":"This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend that serves HTML files with a MVC approach, building the templates with the help of Thymeleaf . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive HttpSession API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: journaldev.com , studytonight.com . Backend : SpringBoot app with the following classes ( src/main/java path, io.openvidu.js.java package) App.java : entrypoint for the app LoginController.java : controller for handling login and logout operations SessionController.java : controller for getting OpenVidu tokens. It also stores our active video-calls and the users connected to them Frontend templates : Plain JS/HTML/CSS files served by the backend ( src/main/resources/templates ) index.html : template with the login form dashboard.html : template with the form to join a video-call session.html : template of the video-call itself Frontend static files ( src/main/resources/static ) openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file style.css : some CSS classes to style the templates Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.","title":"Understanding the code"},{"location":"tutorials/openvidu-mvc-java/#1-user-logs-in","text":"At path / a login form will be displayed: The form will execute a POST operation to path /dashboard whenever \"Log in\" button is clicked, passing the username and the password: <form class=\"form-group jumbotron\" action=\"/dashboard\" method=\"post\"> <p> <label>User</label> <input class=\"form-control\" type=\"text\" name=\"user\" required=\"true\"></input> </p> <p> <label>Pass</label> <input class=\"form-control\" type=\"password\" name=\"pass\" required=\"true\"></input> </p> <p class=\"text-center\"> <button class=\"btn btn-lg btn-info\" type=\"submit\">Log in</button> </p> </form> LoginController.java first checks if the user is already logged (maybe he has just refreshed /dashboard page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets an HttpSession for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object). Finally it returns dashboard.html template: @RequestMapping(value = \"/dashboard\", method = { RequestMethod.GET, RequestMethod.POST }) public String login(@RequestParam(name = \"user\", required = false) String user, @RequestParam(name = \"pass\", required = false) String pass, Model model, HttpSession httpSession) { // Check if the user is already logged in String userName = (String) httpSession.getAttribute(\"loggedUser\"); if (userName != null) { // User is already logged. Immediately return dashboard model.addAttribute(\"username\", userName); return \"dashboard\"; } // User wasn't logged and wants to if (login(user, pass)) { // Correct user-pass // Validate session and return OK // Value stored in HttpSession allows us to identify the user in future requests httpSession.setAttribute(\"loggedUser\", user); model.addAttribute(\"username\", user); // Return dashboard.html template return \"dashboard\"; } else { // Wrong user-pass // Invalidate session and redirect to index.html httpSession.invalidate(); return \"redirect:/\"; } }","title":"1) User logs in"},{"location":"tutorials/openvidu-mvc-java/#2-user-connects-to-tutorial-video-call","text":"dashboard.html template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field: The form will execute a POST operation to path /session whenever \"Join!\" button is clicked, passing the nickname and the session name: <form class=\"form-group\" action=\"/session\" method=\"post\"> <p> <label>Participant</label> <input class=\"form-control\" type=\"text\" name=\"data\" required=\"true\"></input> </p> <p> <label>Session</label> <input class=\"form-control\" type=\"text\" name=\"session-name\" required=\"true\"></input> </p> <p class=\"text-center\"> <button class=\"btn btn-lg btn-success\" type=\"submit\">Join!</button> </p> </form> When SessionController.java receives a request at /session path is when things get interesting. First of all there are some important attributes in this class we must mention: // OpenVidu object as entrypoint of the SDK private OpenVidu openVidu; // Collection to pair session names and OpenVidu Session objects private Map<String, Session> mapSessions = new ConcurrentHashMap<>(); // Collection to pair session names and tokens (the inner Map pairs tokens and role associated) private Map<String, Map<String, OpenViduRole>> mapSessionNamesTokens = new ConcurrentHashMap<>(); // URL where our OpenVidu server is listening private String OPENVIDU_URL; // Secret shared with our OpenVidu server private String SECRET; Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: tokenOptions . @RequestMapping(value = \"/session\", method = RequestMethod.POST) public String joinSession(@RequestParam(name = \"data\") String clientData, @RequestParam(name = \"session-name\") String sessionName, Model model, HttpSession httpSession) { // ... check the user is logged with HttpSession and continue ... // Role associated to this user OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\"loggedUser\")).role; // Optional data to be passed to other users when this user connects to the video-call // In this case, a JSON with the value we stored in the HttpSession object on login String serverData = \"{\\\"serverData\\\": \\\"\" + httpSession.getAttribute(\"loggedUser\") + \"\\\"}\"; // Build tokenOptions object with the serverData and the role TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build(); Just after that an if-else statement comes into play: does the session \"TUTORIAL\" already exist? if (this.mapSessions.get(sessionName) != null) { ... In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the else branch: else { // New session System.out.println(\"New session \" + sessionName); try { // Create a new OpenVidu Session Session session = this.openVidu.createSession(); // Generate a new token with the recently created tokenOptions String token = session.generateToken(tokenOptions); // Store the session and the token in our collections this.mapSessions.put(sessionName, session); this.mapSessionNamesTokens.put(sessionName, new ConcurrentHashMap<>()); this.mapSessionNamesTokens.get(sessionName).put(token, role); // Add all the needed attributes to the template model.addAttribute(\"sessionName\", sessionName); model.addAttribute(\"token\", token); model.addAttribute(\"nickName\", clientData); model.addAttribute(\"userName\", httpSession.getAttribute(\"loggedUser\")); // Return session.html template return \"session\"; } catch (Exception e) { // If error just return dashboard.html template model.addAttribute(\"username\", httpSession.getAttribute(\"loggedUser\")); return \"dashboard\"; } } We are almost there! Now in session.html JavaScript code (preceded by a tag <script th:inline=\"javascript\"> ) we can init a new Session and connect to it with token : // Get all the attributes from the template in Thymeleaf style var sessionName = [[${ sessionName }]]; var token = [[${ token }]]; var nickName = [[${ nickName }]]; var userName = [[${ userName }]]; // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', (event) => { // Subscribe to the Stream to receive it // HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', (event) => { // Add a new HTML element for the user's name and nickname over its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', (event) => { // Delete the HTML element with the user's name and nickname removeUserData(event.stream.connection); }); // --- 4) Connect to the session passing the retrieved token and some more data from // the client (in this case a JSON with the nickname chosen by the user) --- session.connect(token, { clientData: nickName }) .then(() => { // --- 5) Set page layout for active call --- $('#session-title').text(sessionName); $('#join').hide(); $('#session').show(); // Here we check somehow if the user has 'PUBLISHER' role before // trying to publish its stream. Even if someone modified the client's code and // published the stream, it wouldn't work if the token sent in Session.connect // method is not recognized as 'PUBLIHSER' role by OpenVidu Server if (isPublisher()) { // --- 6) Get your own camera stream --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', (event) => { // Init the main video with ours and append our data var userData = { nickName: nickName, userName: userName }; initMainVideo(event.element, userData); appendUserData(event.element, userData); $(event.element).prop('muted', true); // Mute local video }); // --- 8) Publish your stream --- session.publish(publisher); } else { console.warn('You don\\'t have permissions to publish'); initMainVideoThumbnail(); // Show SUBSCRIBER message in main video } }) .catch(error => { console.warn('There was an error connecting to the session:', error.code, error.message); }); The user will now see its own video on the page. The connection to the session has completed!","title":"2) User connects to \"TUTORIAL\" video-call"},{"location":"tutorials/openvidu-mvc-java/#3-another-user-connects-to-the-video-call","text":"The process would be exactly the same as before until SessionController.java executes joinSession() method. Now session 'TUTORIAL' already exists, so in the if-else statement the if branch would be the one executed: if (this.mapSessions.get(sessionName) != null) { // Session already exists System.out.println(\"Existing session \" + sessionName); try { // Generate a new token with the recently created tokenOptions String token = this.mapSessions.get(sessionName).generateToken(tokenOptions); // Update our collection storing the new token this.mapSessionNamesTokens.get(sessionName).put(token, role); // Add all the needed attributes to the template model.addAttribute(\"sessionName\", sessionName); model.addAttribute(\"token\", token); model.addAttribute(\"nickName\", clientData); model.addAttribute(\"userName\", httpSession.getAttribute(\"loggedUser\")); // Return session.html template return \"session\"; } catch (Exception e) { // If error just return dashboard.html template model.addAttribute(\"username\", httpSession.getAttribute(\"loggedUser\")); return \"dashboard\"; } } The code executed in session.html < script > tag would also be the same. After the Session.publish() method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.","title":"3) Another user connects to the video-call"},{"location":"tutorials/openvidu-mvc-java/#4-users-leave-the-video-call","text":"After a while both users decide to leave the session. Apart from calling session.disconnect() (triggered in leaveSession() onclick method) to destroy the connection on OpenVidu Server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. In session.html template the \"Leave session\" button actually performs a POST operation to path /leave-session with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the leaveSession() method. First updates our application's backend. Second updates our OpenVidu Server. <form action=\"/leave-session\" method=\"post\"> <input type=\"hidden\" name=\"session-name\" th:value=\"${sessionName}\"></input> <input type=\"hidden\" name=\"token\" th:value=\"${token}\"></input> <button id=\"buttonLeaveSession\" class=\"btn btn-large btn-danger\" type=\"submit\" onclick=\"leaveSession()\"> Leave session</button> </form> In SessionController.java we update the collections: @RequestMapping(value = \"/leave-session\", method = RequestMethod.POST) public String removeUser(@RequestParam(name = \"session-name\") String sessionName, @RequestParam(name = \"token\") String token, Model model, HttpSession httpSession) throws Exception { // ... check the user is logged with HttpSession and continue ... // If the session exists (\"TUTORIAL\" in this case) if (this.mapSessions.get(sessionName) != null && this.mapSessionNamesTokens.get(sessionName) != null) { // If the token exists if (this.mapSessionNamesTokens.get(sessionName).remove(token) != null) { // User left the session if (this.mapSessionNamesTokens.get(sessionName).isEmpty()) { // Last user left: session must be removed this.mapSessions.remove(sessionName); } return \"redirect:/dashboard\"; } else { // The TOKEN wasn't valid System.out.println(\"Problems in the app server: the TOKEN wasn't valid\"); return \"redirect:/dashboard\"; } } else { // The SESSION does not exist System.out.println(\"Problems in the app server: the SESSION does not exist\"); return \"redirect:/dashboard\"; } } When the last user leaves the session this.mapSessions.remove(sessionName); will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated. At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: you can implement your frontend and your backend as you want . The only actual requirements are getting a valid token from openvidu-server (by using openvidu-java-client , openvidu-node-client or the REST API ) and use it in openvidu-browser to connect your clients to the sessions with Session.connect(token) $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"4) Users leave the video-call"},{"location":"tutorials/openvidu-mvc-node/","text":"openvidu-mvc-node Check it on GitHub A secure OpenVidu sample app with a Node backend and a traditional MVC frontend. It makes use of openvidu-node-client to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to openvidu-js-node . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. Embedded JavaScript is the template engine of choice for this tutorial. Understanding this tutorial OpenVidu is composed by the modules displayed on the image above. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-node-client : server SDK for Node. Quick alternative to REST API openvidu-server : application to control Kurento Media Server Kurento Media Server : handles low level operations of media flow transmissions Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 1) You will need node to execute the app. You can install them with: sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs 3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute server.js server passing two arguments: \"localhost:4443\" as the URL where openvidu-server will be listening and \"MY_SECRET\" as the secret share with it: cd openvidu-tutorials/openvidu-mvc-node npm install node server.js https://localhost:4443 MY_SECRET 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with express that serves HTML files with a MVC approach, building the templates with the help of Embedded JavaScript . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive express-session API. Backend : node server server.js : single file which handles all operations of server. It returns HTML templates as response to HTTP requests. Frontend templates : Plain JS/HTML/CSS files served by the backend, with .ejs extension to support Embedded JavaScript ( /views folder) index.ejs : template with the login form dashboard.ejs : template with the form to join a video-call session.ejs : template of the video-call itself Frontend static files ( /public folder) openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file style.css : some CSS classes to style the templates Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while. 1) User logs in At path / a login form will be displayed: The form will execute a POST operation to path /dashboard whenever \"Log in\" button is clicked, passing the username and the password: <form class=\"form-group jumbotron\" action=\"/dashboard\" method=\"post\"> <p> <label>User</label> <input class=\"form-control\" type=\"text\" name=\"user\" required=\"true\"></input> </p> <p> <label>Pass</label> <input class=\"form-control\" type=\"password\" name=\"pass\" required=\"true\"></input> </p> <p class=\"text-center\"> <button class=\"btn btn-lg btn-info\" type=\"submit\">Log in</button> </p> </form> server.js at /dashboard first checks if the user is already logged (maybe he has just refreshed /dashboard page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets a new express-session for the newly logged user (adding a loggedUser property with its username in the req.session object). Finally it returns dashboard.ejs template: app.post('/dashboard', dashboardController); app.get('/dashboard', dashboardController); function dashboardController(req, res) { // Check if the user is already logged in if (isLogged(req.session)) { // User is already logged. Immediately return dashboard user = req.session.loggedUser; res.render('dashboard.ejs', { user: user }); } else { // User wasn't logged and wants to // Retrieve params from POST body var user = req.body.user; var pass = req.body.pass; if (login(user, pass)) { // Correct user-pass // Validate session and return OK // Value stored in req.session allows us to identify the user in future requests req.session.loggedUser = user; res.render('dashboard.ejs', { user: user }); } else { // Wrong user-pass // Invalidate session and return index template req.session.destroy(); res.redirect('/'); } } } 2) User connects to \"TUTORIAL\" video-call dashboard.ejs template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field: The form will execute a POST operation to path /session whenever \"Join!\" button is clicked, passing the nickname and the session name: <form class=\"form-group\" action=\"/session\" method=\"post\"> <p> <label>Participant</label> <input class=\"form-control\" type=\"text\" name=\"data\" required=\"true\"></input> </p> <p> <label>Session</label> <input class=\"form-control\" type=\"text\" name=\"sessionname\" required=\"true\"></input> </p> <p class=\"text-center\"> <button class=\"btn btn-lg btn-success\" type=\"submit\">Join!</button> </p> </form> When server.js receives a request at /session path is when things get interesting. First of all there are some important attributes in this class we must mention: // Environment variable: URL where our OpenVidu server is listening var OPENVIDU_URL = process.argv[2]; // Environment variable: secret shared with our OpenVidu server var OPENVIDU_SECRET = process.argv[3]; // Entrypoint to OpenVidu Node Client SDK var OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); // Collection to pair session names with OpenVidu Session objects var mapSessions = {}; // Collection to pair session names with tokens var mapSessionNamesTokens = {}; Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: tokenOptions . app.post('/session', (req, res) => { // Check the user is logged ... // The nickname sent by the client var clientData = req.body.data; // The video-call to connect var sessionName = req.body.sessionname; // Role associated to this user var role = users.find(u => (u.user === req.session.loggedUser)).role; // Optional data to be passed to other users when this user connects to the video-call // In this case, a JSON with the value we stored in the req.session object on login var serverData = JSON.stringify({ serverData: req.session.loggedUser }); // Build tokenOptions object with the serverData and the role var tokenOptions = { data: serverData, role: role }; Just after that an if-else statement comes into play: does the session \"TUTORIAL\" already exist? if (mapSessions[sessionName]) { ... In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the else branch: else { // Create a new OpenVidu Session asynchronously OV.createSession() .then(session => { // Store the new Session in the collection of Sessions mapSessions[sessionName] = session; // Store a new empty array in the collection of tokens mapSessionNamesTokens[sessionName] = []; // Generate a new token asynchronously with the recently created tokenOptions session.generateToken(tokenOptions) .then(token => { // Store the new token in the collection of tokens mapSessionNamesTokens[sessionName].push(token); // Return session template with all the needed attributes res.render('session.ejs', { sessionName: sessionName, token: token, nickName: clientData, userName: req.session.loggedUser, }); }) .catch(error => { console.error(error); }); }) .catch(error => { console.error(error); }); } We are almost there! Now in session.ejs JavaScript code (preceded by a tag <script> ) we can init a new Session with sessionId and connect to it with token : // Get all the attributes from the template in EJS style var sessionName = <%- JSON.stringify(sessionName) %>; var token = <%- JSON.stringify(token) %>; var nickName = <%- JSON.stringify(nickName) %>; var userName = <%- JSON.stringify(userName) %>; // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', (event) => { // Subscribe to the Stream to receive it // HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', (event) => { // Add a new HTML element for the user's name and nickname over its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', (event) => { // Delete the HTML element with the user's name and nickname removeUserData(event.stream.connection); }); // --- 4) Connect to the session passing the retrieved token and some more data from // the client (in this case a JSON with the nickname chosen by the user) --- session.connect(token, { clientData: nickName }) .then(() => { // --- 5) Set page layout for active call --- $('#session-title').text(sessionName); $('#join').hide(); $('#session').show(); // Here we check somehow if the user has 'PUBLISHER' role before // trying to publish its stream. Even if someone modified the client's code and // published the stream, it wouldn't work if the token sent in Session.connect // method is not recognized as 'PUBLIHSER' role by OpenVidu Server if (isPublisher()) { // --- 6) Get your own camera stream --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', (event) => { // Init the main video with ours and append our data var userData = { nickName: nickName, userName: userName }; initMainVideo(event.element, userData); appendUserData(event.element, userData); $(event.element).prop('muted', true); // Mute local video }); // --- 8) Publish your stream --- session.publish(publisher); } else { console.warn('You don\\'t have permissions to publish'); initMainVideoThumbnail(); // Show SUBSCRIBER message in main video } }) .catch(error => { console.warn('There was an error connecting to the session:', error.code, error.message); }); }); The user will now see its own video on the page. The connection to the session has completed! 3) Another user connects to the video-call The process would be exactly the same as before until server.js executes controller at /session . Now session 'TUTORIAL' already exists, so in the if-else statement the if branch would be the one executed: if (mapSessions[sessionName]) { // Session already exists: return existing sessionId and a new token // Get the existing Session from the collection var mySession = mapSessions[sessionName]; // Generate a new token asynchronously with the recently created tokenOptions mySession.generateToken(tokenOptions) .then(token => { // Store the new token in the collection of tokens mapSessionNamesTokens[sessionName].push(token); // Return session template with all the needed attributes res.render('session.ejs', { sessionId: mySession.getSessionId(), token: token, nickName: clientData, userName: req.session.loggedUser, sessionName: sessionName }); }) .catch(error => { console.error(error); }); } The code executed in session.ejs < script > tag would also be the same. After the Session.publish() method has been successful, both users will be seeing each other's video, as well as the username and the nickname below it. 4) Users leave the video-call After a while both users decide to leave the session. Apart from calling session.disconnect() (triggered in leaveSession() onclick method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. In session.ejs template the \"Leave session\" button actually performs a POST operation to path /leave-session with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the leaveSession() method. First updates our backend. Second updates our openvidu-server. <form action=\"/leave-session\" method=\"post\"> <input type=\"hidden\" name=\"sessionname\" value=\"<%= sessionName %>\"></input> <input type=\"hidden\" name=\"token\" value=\"<%= token %>\"></input> <button id=\"buttonLeaveSession\" class=\"btn btn-large btn-danger\" type=\"submit\" onclick=\"leaveSession()\">Leave session</button> </form> In server.js we update the collections at /leave-session : app.post('/leave-session', (req, res) => { // Check the user is logged ... // Retrieve params from POST body var sessionName = req.body.sessionname; var token = req.body.token; // If the session exists if (mapSessions[sessionName] && mapSessionNamesTokens[sessionName]) { var tokens = mapSessionNamesTokens[sessionName]; var index = tokens.indexOf(token); // If the token exists if (index !== -1) { // Token removed tokens.splice(index, 1); } else { console.log('Problems in the app server: the TOKEN wasn\\'t valid'); res.redirect('/dashboard'); } if (tokens.length == 0) { // Last user left: session must be removed delete mapSessions[sessionName]; } res.redirect('/dashboard'); } else { var msg = 'Problems in the app server: the SESSION does not exist'; res.status(500).send(msg); } When the last user leaves the session delete mapSessions[sessionName] will be executed: this means the session is empty and that it is going to be closed. The sessionId and all token params associated to it will be invalidated. At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: you can implement your frontend and your backend as you want . The only actual requirements are getting sessionId and token params from openvidu-server (by using one of the available clients or with the REST API) and using them along with openvidu-browser to connect your clients to the sessions. $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-mvc-node"},{"location":"tutorials/openvidu-mvc-node/#openvidu-mvc-node","text":"Check it on GitHub A secure OpenVidu sample app with a Node backend and a traditional MVC frontend. It makes use of openvidu-node-client to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to openvidu-js-node . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. Embedded JavaScript is the template engine of choice for this tutorial.","title":"openvidu-mvc-node"},{"location":"tutorials/openvidu-mvc-node/#understanding-this-tutorial","text":"OpenVidu is composed by the modules displayed on the image above. openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients openvidu-node-client : server SDK for Node. Quick alternative to REST API openvidu-server : application to control Kurento Media Server Kurento Media Server : handles low level operations of media flow transmissions","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-mvc-node/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 1) You will need node to execute the app. You can install them with: sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs 3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute server.js server passing two arguments: \"localhost:4443\" as the URL where openvidu-server will be listening and \"MY_SECRET\" as the secret share with it: cd openvidu-tutorials/openvidu-mvc-node npm install node server.js https://localhost:4443 MY_SECRET 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to https://localhost:5000 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-mvc-node/#understanding-the-code","text":"This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with express that serves HTML files with a MVC approach, building the templates with the help of Embedded JavaScript . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive express-session API. Backend : node server server.js : single file which handles all operations of server. It returns HTML templates as response to HTTP requests. Frontend templates : Plain JS/HTML/CSS files served by the backend, with .ejs extension to support Embedded JavaScript ( /views folder) index.ejs : template with the login form dashboard.ejs : template with the form to join a video-call session.ejs : template of the video-call itself Frontend static files ( /public folder) openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file style.css : some CSS classes to style the templates Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.","title":"Understanding the code"},{"location":"tutorials/openvidu-mvc-node/#1-user-logs-in","text":"At path / a login form will be displayed: The form will execute a POST operation to path /dashboard whenever \"Log in\" button is clicked, passing the username and the password: <form class=\"form-group jumbotron\" action=\"/dashboard\" method=\"post\"> <p> <label>User</label> <input class=\"form-control\" type=\"text\" name=\"user\" required=\"true\"></input> </p> <p> <label>Pass</label> <input class=\"form-control\" type=\"password\" name=\"pass\" required=\"true\"></input> </p> <p class=\"text-center\"> <button class=\"btn btn-lg btn-info\" type=\"submit\">Log in</button> </p> </form> server.js at /dashboard first checks if the user is already logged (maybe he has just refreshed /dashboard page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets a new express-session for the newly logged user (adding a loggedUser property with its username in the req.session object). Finally it returns dashboard.ejs template: app.post('/dashboard', dashboardController); app.get('/dashboard', dashboardController); function dashboardController(req, res) { // Check if the user is already logged in if (isLogged(req.session)) { // User is already logged. Immediately return dashboard user = req.session.loggedUser; res.render('dashboard.ejs', { user: user }); } else { // User wasn't logged and wants to // Retrieve params from POST body var user = req.body.user; var pass = req.body.pass; if (login(user, pass)) { // Correct user-pass // Validate session and return OK // Value stored in req.session allows us to identify the user in future requests req.session.loggedUser = user; res.render('dashboard.ejs', { user: user }); } else { // Wrong user-pass // Invalidate session and return index template req.session.destroy(); res.redirect('/'); } } }","title":"1) User logs in"},{"location":"tutorials/openvidu-mvc-node/#2-user-connects-to-tutorial-video-call","text":"dashboard.ejs template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field: The form will execute a POST operation to path /session whenever \"Join!\" button is clicked, passing the nickname and the session name: <form class=\"form-group\" action=\"/session\" method=\"post\"> <p> <label>Participant</label> <input class=\"form-control\" type=\"text\" name=\"data\" required=\"true\"></input> </p> <p> <label>Session</label> <input class=\"form-control\" type=\"text\" name=\"sessionname\" required=\"true\"></input> </p> <p class=\"text-center\"> <button class=\"btn btn-lg btn-success\" type=\"submit\">Join!</button> </p> </form> When server.js receives a request at /session path is when things get interesting. First of all there are some important attributes in this class we must mention: // Environment variable: URL where our OpenVidu server is listening var OPENVIDU_URL = process.argv[2]; // Environment variable: secret shared with our OpenVidu server var OPENVIDU_SECRET = process.argv[3]; // Entrypoint to OpenVidu Node Client SDK var OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET); // Collection to pair session names with OpenVidu Session objects var mapSessions = {}; // Collection to pair session names with tokens var mapSessionNamesTokens = {}; Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: tokenOptions . app.post('/session', (req, res) => { // Check the user is logged ... // The nickname sent by the client var clientData = req.body.data; // The video-call to connect var sessionName = req.body.sessionname; // Role associated to this user var role = users.find(u => (u.user === req.session.loggedUser)).role; // Optional data to be passed to other users when this user connects to the video-call // In this case, a JSON with the value we stored in the req.session object on login var serverData = JSON.stringify({ serverData: req.session.loggedUser }); // Build tokenOptions object with the serverData and the role var tokenOptions = { data: serverData, role: role }; Just after that an if-else statement comes into play: does the session \"TUTORIAL\" already exist? if (mapSessions[sessionName]) { ... In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the else branch: else { // Create a new OpenVidu Session asynchronously OV.createSession() .then(session => { // Store the new Session in the collection of Sessions mapSessions[sessionName] = session; // Store a new empty array in the collection of tokens mapSessionNamesTokens[sessionName] = []; // Generate a new token asynchronously with the recently created tokenOptions session.generateToken(tokenOptions) .then(token => { // Store the new token in the collection of tokens mapSessionNamesTokens[sessionName].push(token); // Return session template with all the needed attributes res.render('session.ejs', { sessionName: sessionName, token: token, nickName: clientData, userName: req.session.loggedUser, }); }) .catch(error => { console.error(error); }); }) .catch(error => { console.error(error); }); } We are almost there! Now in session.ejs JavaScript code (preceded by a tag <script> ) we can init a new Session with sessionId and connect to it with token : // Get all the attributes from the template in EJS style var sessionName = <%- JSON.stringify(sessionName) %>; var token = <%- JSON.stringify(token) %>; var nickName = <%- JSON.stringify(nickName) %>; var userName = <%- JSON.stringify(userName) %>; // --- 1) Get an OpenVidu object --- OV = new OpenVidu(); // --- 2) Init a session --- session = OV.initSession(); // --- 3) Specify the actions when events take place in the session --- // On every new Stream received... session.on('streamCreated', (event) => { // Subscribe to the Stream to receive it // HTML video will be appended to element with 'video-container' id var subscriber = session.subscribe(event.stream, 'video-container'); // When the HTML video has been appended to DOM... subscriber.on('videoElementCreated', (event) => { // Add a new HTML element for the user's name and nickname over its video appendUserData(event.element, subscriber.stream.connection); }); }); // On every Stream destroyed... session.on('streamDestroyed', (event) => { // Delete the HTML element with the user's name and nickname removeUserData(event.stream.connection); }); // --- 4) Connect to the session passing the retrieved token and some more data from // the client (in this case a JSON with the nickname chosen by the user) --- session.connect(token, { clientData: nickName }) .then(() => { // --- 5) Set page layout for active call --- $('#session-title').text(sessionName); $('#join').hide(); $('#session').show(); // Here we check somehow if the user has 'PUBLISHER' role before // trying to publish its stream. Even if someone modified the client's code and // published the stream, it wouldn't work if the token sent in Session.connect // method is not recognized as 'PUBLIHSER' role by OpenVidu Server if (isPublisher()) { // --- 6) Get your own camera stream --- var publisher = OV.initPublisher('video-container', { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' mirror: false // Whether to mirror your local video or not }); // --- 7) Specify the actions when events take place in our publisher --- // When our HTML video has been added to DOM... publisher.on('videoElementCreated', (event) => { // Init the main video with ours and append our data var userData = { nickName: nickName, userName: userName }; initMainVideo(event.element, userData); appendUserData(event.element, userData); $(event.element).prop('muted', true); // Mute local video }); // --- 8) Publish your stream --- session.publish(publisher); } else { console.warn('You don\\'t have permissions to publish'); initMainVideoThumbnail(); // Show SUBSCRIBER message in main video } }) .catch(error => { console.warn('There was an error connecting to the session:', error.code, error.message); }); }); The user will now see its own video on the page. The connection to the session has completed!","title":"2) User connects to \"TUTORIAL\" video-call"},{"location":"tutorials/openvidu-mvc-node/#3-another-user-connects-to-the-video-call","text":"The process would be exactly the same as before until server.js executes controller at /session . Now session 'TUTORIAL' already exists, so in the if-else statement the if branch would be the one executed: if (mapSessions[sessionName]) { // Session already exists: return existing sessionId and a new token // Get the existing Session from the collection var mySession = mapSessions[sessionName]; // Generate a new token asynchronously with the recently created tokenOptions mySession.generateToken(tokenOptions) .then(token => { // Store the new token in the collection of tokens mapSessionNamesTokens[sessionName].push(token); // Return session template with all the needed attributes res.render('session.ejs', { sessionId: mySession.getSessionId(), token: token, nickName: clientData, userName: req.session.loggedUser, sessionName: sessionName }); }) .catch(error => { console.error(error); }); } The code executed in session.ejs < script > tag would also be the same. After the Session.publish() method has been successful, both users will be seeing each other's video, as well as the username and the nickname below it.","title":"3) Another user connects to the video-call"},{"location":"tutorials/openvidu-mvc-node/#4-users-leave-the-video-call","text":"After a while both users decide to leave the session. Apart from calling session.disconnect() (triggered in leaveSession() onclick method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. In session.ejs template the \"Leave session\" button actually performs a POST operation to path /leave-session with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the leaveSession() method. First updates our backend. Second updates our openvidu-server. <form action=\"/leave-session\" method=\"post\"> <input type=\"hidden\" name=\"sessionname\" value=\"<%= sessionName %>\"></input> <input type=\"hidden\" name=\"token\" value=\"<%= token %>\"></input> <button id=\"buttonLeaveSession\" class=\"btn btn-large btn-danger\" type=\"submit\" onclick=\"leaveSession()\">Leave session</button> </form> In server.js we update the collections at /leave-session : app.post('/leave-session', (req, res) => { // Check the user is logged ... // Retrieve params from POST body var sessionName = req.body.sessionname; var token = req.body.token; // If the session exists if (mapSessions[sessionName] && mapSessionNamesTokens[sessionName]) { var tokens = mapSessionNamesTokens[sessionName]; var index = tokens.indexOf(token); // If the token exists if (index !== -1) { // Token removed tokens.splice(index, 1); } else { console.log('Problems in the app server: the TOKEN wasn\\'t valid'); res.redirect('/dashboard'); } if (tokens.length == 0) { // Last user left: session must be removed delete mapSessions[sessionName]; } res.redirect('/dashboard'); } else { var msg = 'Problems in the app server: the SESSION does not exist'; res.status(500).send(msg); } When the last user leaves the session delete mapSessions[sessionName] will be executed: this means the session is empty and that it is going to be closed. The sessionId and all token params associated to it will be invalidated. At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: you can implement your frontend and your backend as you want . The only actual requirements are getting sessionId and token params from openvidu-server (by using one of the available clients or with the REST API) and using them along with openvidu-browser to connect your clients to the sessions. $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"4) Users leave the video-call"},{"location":"tutorials/openvidu-react-native/","text":"openvidu-react-native Check it on GitHub A client-side only application built with React Native framework using React and JavaScript. It can be compiled into a native Android app , a native iOS app . If it is the first time you use OpenVidu, it is highly recommended to start first with openvidu-hello-world tutorial due to this being a native app and being a little more complex for OpenVidu starters. React Native support is a paid feature. A special version of openvidu-browser library is needed for openvidu-react-native tutorial to work . Contact us through Commercial page support to get it Understanding this tutorial OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : NPM package for your Ionic app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions Running this tutorial 1) You will need Node 8.3 or newer, NPM , React Native CLI to serve the app. Install them with the following command sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g react-native-cli 2) Clone the repo git clone https://github.com/OpenVidu/openvidu-tutorials.git 3) Install dependencies cd openvidu-tutorials/openvidu-react-native npm install 4) Install openvidu-browser with React Native support : Add the artifact in the root project npm install openvidu-browser-Y.Y.Z.tgz 4) Start Metro Bundler : npm start React Native will require OpenVidu Server to be deployed in a valid domain well-protected with a certificate. To facilitate first steps with OpenVidu our demos OpenVidu Server will be used. Note: this is a publicly accessible OpenVidu Server. Anyone could access your sessions. Use it only for an initial test and under your own responsibility Some problems have been encountered while streaming with iOS devices in some networks with complex restrictions. With mobile networks (4G) these problems have not taken place. Make sure there is no problem with the network you are using in your development environment before posting issues about it After deploying on your device and trying to join the session, you may get an error saying \"OpenVidu Server (X.Y.Z) and OpenVidu Browser versions do NOT match\". This error is not significant so just click on the dismiss button. Now depending on the platform you want to run your app... In an Android device This tutorial has been tested from Android 5.1 (Lollipop) to Android 9 (Pie) To deploy the Android APK not only you need to have Java JDK8 , Android Studio and Android SDK installed but also you have to set up the specific environment variables . Fortunately, React Native provide us a great guide to allows us to configure step by step all the requirements. This tutorial is made with React Native CLI Quickstart so you should select and check the React Native CLI requirements inside of React guide website. After we have completed all the steps of the React Native CLI guide and performed steps 1) , 2), 3) and 4) stated above, we must continue with the following commands: 5) Connect the device to the PC. You must enable USB debugging and give permissions (check out first section here in React Native docs ) 6) Run the tutorial. The app will be automatically launched in your Android device # In openvidu-tutorials/openvidu-react-native react-native run-android In an iOS device This tutorial has been tested with Xcode (10.2.1) and iPhone 7 (iOS 12.2), iPhone 7 Plus (iOS 12.1) and iPad Air (iOS 12.1.1) After we have completed all the steps of the performed steps 1), 2) and 3) stated above, we must continue with the following commands: 5) Plug in your device via USB 6) Configure code signing 7) Build and Run your app To deploy the iOS app React has this guide to properly configure your development environment. Understanding the code This is a React Native project generated with React Native CLI tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under App.js file: App.js : defines App component, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves. Let's see first how App.js uses NPM package openvidu-browser : We import the necessary objects from openvidu-browser : import { OpenVidu } from 'openvidu-browser'; App.js declares the following properties in the state: this.state = { mySessionId: 'SessionReactNative', myUserName: 'Participant' + Math.floor(Math.random() * 100), session: undefined, mainStreamManager: undefined, publisher: undefined, subscribers: [], role: 'PUBLISHER', }; OpenVidu object will allow us to get a Session object, which is declared just after it. publisher will be our own local webcam stream and subscribers array will store the active streams of other users in the video-call. Finally, mySessionId and myUserName params simply represent the video-call and your participant's nickname, as you will see in a moment. Whenever a user clicks on the join button defined in App.js , joinSession() method is called: We first get an OpenVidu object and initialize a session property inside the state. // --- 1) Get an OpenVidu object --- this.OV = new OpenVidu(); // --- 2) Init a session --- this.setState({ session: this.OV.initSession(), }, () => { // See next step } ); Then we subscribe to the Session events that interest us. // --- 3) Specify the actions when events take place in the session --- var mySession = this.state.session; // On every new Stream received... mySession.on('streamCreated', (event) => { // Subscribe to the Stream to receive it. Second parameter is undefined // so OpenVidu doesn't create an HTML video by its own var subscriber = mySession.subscribe(event.stream, undefined); //We use an auxiliary array to push the new stream var subscribers = this.state.subscribers; subscribers.push(subscriber); // Update the state with the new subscribers this.setState({ subscribers: subscribers, }); }); // On every Stream destroyed... mySession.on('streamDestroyed', (event) => { event.preventDefault(); // Remove the stream from 'subscribers' array this.deleteSubscriber(event.stream.streamManager); }); // See next step Here we subscribe to the Session events that interest us. As we are using React Native framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each Subscriber object and let it manage its video. This component will be RTCView and is provided from react-native-webrtc library. To do this, we need to store each new Subscriber we received in array subscribers , and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events: streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our subscribers array. Method session.subscribe has undefined as second parameter so OpenVidu doesn't insert and HTML video element in the DOM due to, as it is a native application, the DOM does not exist. The render method of App.js will show the new video, as it contains a .map js function, declaring a RTCView for each subscriber. We get the reference to RTCView and we will run openvidu-browser method addVideoElement , passing the reference of the RTCView when it is defined. {this.state.subscribers.map((item, index) => { if(!!item){ return ( <View key={index}> <Text>{this.getNicknameTag(item.stream)}</Text> <RTCView zOrder={0} objectFit=\"cover\" style={styles.remoteView} ref={(rtcVideo) => { if (!!rtcVideo){ item.addVideoElement(rtcVideo); } }} /> </View> ) } streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from subscribers array, so React will automatically delete the required RTCView component. Get a token from OpenVidu Server WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then((token) => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token, using fetch library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Connect to the session: // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then((token) => { // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname mySession.connect(token, { clientData: this.state.myUserName }) .then(() => { if (Platform.OS == 'android') { this.checkAndroidPermissions(); } // --- 5) Get your own camera stream --- if (this.state.role !== 'SUBSCRIBER') { // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video // element: we will manage it on our own) and with the desired properties let publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' }); // --- 6) Publish your stream --- // Set the main video in the page to display our webcam and store our Publisher this.setState({ mainStreamManager: publisher }); mySession.publish(publisher); } }) .catch((error) => { console.log('There was an error connecting to the session:', error.code, error.message); }); }) .catch((error) => console.log('Error', error)); In session.connect method first param is the recently retrieved user token. Second param is the value every user will receive in event.stream.connection.data property on streamCreated event. (this value will be used to show the user's nickname to the his video). If the method succeeds we will call to checkAndroidPermissions() method. This method requests and checks the device permissions that our app currently has in the device. Once the permissions have been resolved, the OV.initPublisher() method will be called. For iOS and web platforms, permissions will be handled automatically when camera and microphone access are requested. No need for extra steps in these cases, so we directly initialize our Publisher object. We do further talk about Android permissions under section Android specific requirements . Finally publish your webcam calling OV.initPublisher() method: let publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' }); // --- 6) Publish your stream --- // Set the main video in the page to display our webcam and store our Publisher this.setState({ mainStreamManager: publisher }); mySession.publish(publisher); We now proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties and publish it to the Session through Session.publish() method. The rest of users will receive our Stream object and will execute their streamCreated event. Also we store the Publisher object under this.state.mainStreamManager variable. This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown. <View style={styles.container}> <Text>Session: {this.state.mySessionId}</Text> <Text>{this.getNicknameTag(this.state.mainStreamManager.stream)}</Text> <RTCView zOrder={0} objectFit=\"cover\" ref={(rtcVideo) => { if (!!rtcVideo) { this.state.mainStreamManager.addVideoElement(rtcVideo); } }} style={styles.selfView} /> </View> Leaving the session Whenever we want a user to leave the session, we just need to call session.disconnect method in app.component.ts : leaveSession() { // --- 7) Leave the session by calling 'disconnect' method over the Session object --- const mySession = this.state.session; if (mySession) { mySession.disconnect(); } // Empty all properties... this.OV = null; this.setState({ session: undefined, subscribers: [], mySessionId: 'SessionReactNative', myUserName: 'Participant' + Math.floor(Math.random() * 100), mainStreamManager: undefined, publisher: undefined, }); } Android specific requirements Android apps need to actively ask for permissions in the code to access camera and microphone using react-native-webrtc plugin. By following steps below we have been able to properly set up the optimal configuration your React Native app will need to work along OpenVidu. These configurations are already included in this openvidu-react-native project, so if you start from here no further configurations are needed. Otherwise, if you want to start a new project with React Native and OpenVidu , you should follow these simple steps: 1) In android/app/src/main/AndroidManifest.xml add these permissions <uses-permission android:name=\"android.permission.CAMERA\" /> <uses-feature android:name=\"android.hardware.camera\" /> <uses-feature android:name=\"android.hardware.camera.autofocus\"/> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/> <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /> <uses-permission android:name=\"android.permission.RECORD_AUDIO\" /> <uses-permission android:name=\"android.permission.WAKE_LOCK\" /> <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/> 2) In android/settings.gradle , include WebRTCModule include ':WebRTCModule', ':app' project(':WebRTCModule').projectDir = new File(rootProject.projectDir, '../node_modules/openvidu-browser/node_modules/react-native-webrtc/android') 3) In android/app/build.gradle , add WebRTCModule to dependencies dependencies { implementation project(':WebRTCModule') ... } 4) In android/app/src/main/java/com/xxx/MainApplication.java import and add WebRTCModulePackage : If you are using a version prior to 0.60.0: import com.oney.WebRTCModule.WebRTCModulePackage; ... @Override protected List<ReactPackage> getPackages() { return Arrays.<ReactPackage>asList( new MainReactPackage(), new WebRTCModulePackage() // <-- Add this line ); } If you are using a version above to 0.60.0: import com.oney.WebRTCModule.WebRTCModulePackage; .... @Override protected List<ReactPackage> getPackages() { @SuppressWarnings(\"UnnecessaryLocalVariable\") List<ReactPackage> packages = new PackageList(this).getPackages(); // Packages that cannot be autolinked yet can be added manually here, for example: // packages.add(new MyReactNativePackage()); packages.add(new WebRTCModulePackage()); // <-- Add this line return packages; } INFO: react-native-webrtc provide us more information about these requeriments here iOS specific requirements iOS apps need to include the WebRTC modules from react-native-webrtc plugin. We will do it by following the steps bellow. These configurations are already included in this openvidu-react-native project , so if you start from here no further configurations are needed. Otherwise, if you want to start a new project with React Native and OpenVidu , you should follow these simple steps: 1) Add these files into your project in Xcode: Right click on Libraries and Add Files to {project} Go to node_modules/openvidu-browser/node_modules/react-native-webrtc/ios/RCTWebRTC.xcodeproj and click on Add Also add node_modules/react-native-webrtc/ios/WebRTC.framework to Frameworks folder 2) iOS Podfile You can use the included podspec in your podfile to take care of all dependencies instead of manually adding files to the project. If you prefer to add it manually, you should check the official tutorial . Include in the Podfile in your react-native iOS directory: pod 'react-native-webrtc', :path => '../node_modules/openvidu-browser/node_modules/react-native-webrtc' You may have to change the platform field in your Podfile, as react-native-webrtc doesn't support iOS 9 - set it to '10.0' or above (otherwise you get an error when doing pod install ): platform :ios, '10.0' 3) Set up parameters Under Build setting set Dead Code Stripping to No also under Build Options set Enable Bitcode to No as well 4) Add Permissions * Navigate to <ProjectFolder>/ios/<ProjectName>/ * Edit Info.plist and add the following lines <key>NSCameraUsageDescription</key> <string>Camera Permission</string> <key>NSMicrophoneUsageDescription</key> <string>Microphone Permission</string> 5) Install pod You will install the Podfile that we have set up in step 2: cd ios pod install INFO: react-native-webrtc provide us more information about these requeriments here $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-react-native"},{"location":"tutorials/openvidu-react-native/#openvidu-react-native","text":"Check it on GitHub A client-side only application built with React Native framework using React and JavaScript. It can be compiled into a native Android app , a native iOS app . If it is the first time you use OpenVidu, it is highly recommended to start first with openvidu-hello-world tutorial due to this being a native app and being a little more complex for OpenVidu starters. React Native support is a paid feature. A special version of openvidu-browser library is needed for openvidu-react-native tutorial to work . Contact us through Commercial page support to get it","title":"openvidu-react-native"},{"location":"tutorials/openvidu-react-native/#understanding-this-tutorial","text":"OpenVidu is composed by the three modules displayed on the image above in its insecure version. openvidu-browser : NPM package for your Ionic app. It allows you to manage your video-calls straight away from your clients openvidu-server : Java application that controls Kurento Media Server Kurento Media Server : server that handles low level operations of media flow transmissions","title":"Understanding this tutorial"},{"location":"tutorials/openvidu-react-native/#running-this-tutorial","text":"1) You will need Node 8.3 or newer, NPM , React Native CLI to serve the app. Install them with the following command sudo curl -sL https://deb.nodesource.com/setup_12.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g react-native-cli 2) Clone the repo git clone https://github.com/OpenVidu/openvidu-tutorials.git 3) Install dependencies cd openvidu-tutorials/openvidu-react-native npm install 4) Install openvidu-browser with React Native support : Add the artifact in the root project npm install openvidu-browser-Y.Y.Z.tgz 4) Start Metro Bundler : npm start React Native will require OpenVidu Server to be deployed in a valid domain well-protected with a certificate. To facilitate first steps with OpenVidu our demos OpenVidu Server will be used. Note: this is a publicly accessible OpenVidu Server. Anyone could access your sessions. Use it only for an initial test and under your own responsibility Some problems have been encountered while streaming with iOS devices in some networks with complex restrictions. With mobile networks (4G) these problems have not taken place. Make sure there is no problem with the network you are using in your development environment before posting issues about it After deploying on your device and trying to join the session, you may get an error saying \"OpenVidu Server (X.Y.Z) and OpenVidu Browser versions do NOT match\". This error is not significant so just click on the dismiss button. Now depending on the platform you want to run your app...","title":"Running this tutorial"},{"location":"tutorials/openvidu-react-native/#in-an-android-device","text":"This tutorial has been tested from Android 5.1 (Lollipop) to Android 9 (Pie) To deploy the Android APK not only you need to have Java JDK8 , Android Studio and Android SDK installed but also you have to set up the specific environment variables . Fortunately, React Native provide us a great guide to allows us to configure step by step all the requirements. This tutorial is made with React Native CLI Quickstart so you should select and check the React Native CLI requirements inside of React guide website. After we have completed all the steps of the React Native CLI guide and performed steps 1) , 2), 3) and 4) stated above, we must continue with the following commands: 5) Connect the device to the PC. You must enable USB debugging and give permissions (check out first section here in React Native docs ) 6) Run the tutorial. The app will be automatically launched in your Android device # In openvidu-tutorials/openvidu-react-native react-native run-android","title":"In an Android device"},{"location":"tutorials/openvidu-react-native/#in-an-ios-device","text":"This tutorial has been tested with Xcode (10.2.1) and iPhone 7 (iOS 12.2), iPhone 7 Plus (iOS 12.1) and iPad Air (iOS 12.1.1) After we have completed all the steps of the performed steps 1), 2) and 3) stated above, we must continue with the following commands: 5) Plug in your device via USB 6) Configure code signing 7) Build and Run your app To deploy the iOS app React has this guide to properly configure your development environment.","title":"In an iOS device"},{"location":"tutorials/openvidu-react-native/#understanding-the-code","text":"This is a React Native project generated with React Native CLI tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under App.js file: App.js : defines App component, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves. Let's see first how App.js uses NPM package openvidu-browser :","title":"Understanding the code"},{"location":"tutorials/openvidu-react-native/#we-import-the-necessary-objects-from-openvidu-browser","text":"import { OpenVidu } from 'openvidu-browser';","title":"We import the necessary objects from openvidu-browser:"},{"location":"tutorials/openvidu-react-native/#appjs-declares-the-following-properties-in-the-state","text":"this.state = { mySessionId: 'SessionReactNative', myUserName: 'Participant' + Math.floor(Math.random() * 100), session: undefined, mainStreamManager: undefined, publisher: undefined, subscribers: [], role: 'PUBLISHER', }; OpenVidu object will allow us to get a Session object, which is declared just after it. publisher will be our own local webcam stream and subscribers array will store the active streams of other users in the video-call. Finally, mySessionId and myUserName params simply represent the video-call and your participant's nickname, as you will see in a moment.","title":"App.js declares the following properties in the state:"},{"location":"tutorials/openvidu-react-native/#whenever-a-user-clicks-on-the-join-button-defined-in-appjs-joinsession-method-is-called","text":"We first get an OpenVidu object and initialize a session property inside the state. // --- 1) Get an OpenVidu object --- this.OV = new OpenVidu(); // --- 2) Init a session --- this.setState({ session: this.OV.initSession(), }, () => { // See next step } ); Then we subscribe to the Session events that interest us. // --- 3) Specify the actions when events take place in the session --- var mySession = this.state.session; // On every new Stream received... mySession.on('streamCreated', (event) => { // Subscribe to the Stream to receive it. Second parameter is undefined // so OpenVidu doesn't create an HTML video by its own var subscriber = mySession.subscribe(event.stream, undefined); //We use an auxiliary array to push the new stream var subscribers = this.state.subscribers; subscribers.push(subscriber); // Update the state with the new subscribers this.setState({ subscribers: subscribers, }); }); // On every Stream destroyed... mySession.on('streamDestroyed', (event) => { event.preventDefault(); // Remove the stream from 'subscribers' array this.deleteSubscriber(event.stream.streamManager); }); // See next step Here we subscribe to the Session events that interest us. As we are using React Native framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each Subscriber object and let it manage its video. This component will be RTCView and is provided from react-native-webrtc library. To do this, we need to store each new Subscriber we received in array subscribers , and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events: streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our subscribers array. Method session.subscribe has undefined as second parameter so OpenVidu doesn't insert and HTML video element in the DOM due to, as it is a native application, the DOM does not exist. The render method of App.js will show the new video, as it contains a .map js function, declaring a RTCView for each subscriber. We get the reference to RTCView and we will run openvidu-browser method addVideoElement , passing the reference of the RTCView when it is defined. {this.state.subscribers.map((item, index) => { if(!!item){ return ( <View key={index}> <Text>{this.getNicknameTag(item.stream)}</Text> <RTCView zOrder={0} objectFit=\"cover\" style={styles.remoteView} ref={(rtcVideo) => { if (!!rtcVideo){ item.addVideoElement(rtcVideo); } }} /> </View> ) } streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from subscribers array, so React will automatically delete the required RTCView component.","title":"Whenever a user clicks on the join button defined in App.js, joinSession() method is called:"},{"location":"tutorials/openvidu-react-native/#get-a-token-from-openvidu-server","text":"WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server // --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then((token) => { // See next point to see how to connect to the session using 'token' }); Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the REST API , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token, using fetch library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First request performs a POST to /api/sessions (we send a customSessionId field to name the session with our mySessionId value retrieved from HTML input) Second request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-react-native/#connect-to-the-session","text":"// --- 4) Connect to the session with a valid user token --- // 'getToken' method is simulating what your server-side should do. // 'token' parameter should be retrieved and returned by your own backend this.getToken().then((token) => { // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname mySession.connect(token, { clientData: this.state.myUserName }) .then(() => { if (Platform.OS == 'android') { this.checkAndroidPermissions(); } // --- 5) Get your own camera stream --- if (this.state.role !== 'SUBSCRIBER') { // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video // element: we will manage it on our own) and with the desired properties let publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' }); // --- 6) Publish your stream --- // Set the main video in the page to display our webcam and store our Publisher this.setState({ mainStreamManager: publisher }); mySession.publish(publisher); } }) .catch((error) => { console.log('There was an error connecting to the session:', error.code, error.message); }); }) .catch((error) => console.log('Error', error)); In session.connect method first param is the recently retrieved user token. Second param is the value every user will receive in event.stream.connection.data property on streamCreated event. (this value will be used to show the user's nickname to the his video). If the method succeeds we will call to checkAndroidPermissions() method. This method requests and checks the device permissions that our app currently has in the device. Once the permissions have been resolved, the OV.initPublisher() method will be called. For iOS and web platforms, permissions will be handled automatically when camera and microphone access are requested. No need for extra steps in these cases, so we directly initialize our Publisher object. We do further talk about Android permissions under section Android specific requirements .","title":"Connect to the session:"},{"location":"tutorials/openvidu-react-native/#finally-publish-your-webcam-calling-ovinitpublisher-method","text":"let publisher = this.OV.initPublisher(undefined, { audioSource: undefined, // The source of audio. If undefined default microphone videoSource: undefined, // The source of video. If undefined default webcam publishAudio: true, // Whether you want to start publishing with your audio unmuted or not publishVideo: true, // Whether you want to start publishing with your video enabled or not resolution: '640x480', // The resolution of your video frameRate: 30, // The frame rate of your video insertMode: 'APPEND', // How the video is inserted in the target element 'video-container' }); // --- 6) Publish your stream --- // Set the main video in the page to display our webcam and store our Publisher this.setState({ mainStreamManager: publisher }); mySession.publish(publisher); We now proceed to publish our webcam to the session. To do so we get a Publisher object with the desired properties and publish it to the Session through Session.publish() method. The rest of users will receive our Stream object and will execute their streamCreated event. Also we store the Publisher object under this.state.mainStreamManager variable. This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown. <View style={styles.container}> <Text>Session: {this.state.mySessionId}</Text> <Text>{this.getNicknameTag(this.state.mainStreamManager.stream)}</Text> <RTCView zOrder={0} objectFit=\"cover\" ref={(rtcVideo) => { if (!!rtcVideo) { this.state.mainStreamManager.addVideoElement(rtcVideo); } }} style={styles.selfView} /> </View>","title":"Finally publish your webcam calling OV.initPublisher() method:"},{"location":"tutorials/openvidu-react-native/#leaving-the-session","text":"Whenever we want a user to leave the session, we just need to call session.disconnect method in app.component.ts : leaveSession() { // --- 7) Leave the session by calling 'disconnect' method over the Session object --- const mySession = this.state.session; if (mySession) { mySession.disconnect(); } // Empty all properties... this.OV = null; this.setState({ session: undefined, subscribers: [], mySessionId: 'SessionReactNative', myUserName: 'Participant' + Math.floor(Math.random() * 100), mainStreamManager: undefined, publisher: undefined, }); }","title":"Leaving the session"},{"location":"tutorials/openvidu-react-native/#android-specific-requirements","text":"Android apps need to actively ask for permissions in the code to access camera and microphone using react-native-webrtc plugin. By following steps below we have been able to properly set up the optimal configuration your React Native app will need to work along OpenVidu. These configurations are already included in this openvidu-react-native project, so if you start from here no further configurations are needed. Otherwise, if you want to start a new project with React Native and OpenVidu , you should follow these simple steps: 1) In android/app/src/main/AndroidManifest.xml add these permissions <uses-permission android:name=\"android.permission.CAMERA\" /> <uses-feature android:name=\"android.hardware.camera\" /> <uses-feature android:name=\"android.hardware.camera.autofocus\"/> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/> <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /> <uses-permission android:name=\"android.permission.RECORD_AUDIO\" /> <uses-permission android:name=\"android.permission.WAKE_LOCK\" /> <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/> 2) In android/settings.gradle , include WebRTCModule include ':WebRTCModule', ':app' project(':WebRTCModule').projectDir = new File(rootProject.projectDir, '../node_modules/openvidu-browser/node_modules/react-native-webrtc/android') 3) In android/app/build.gradle , add WebRTCModule to dependencies dependencies { implementation project(':WebRTCModule') ... } 4) In android/app/src/main/java/com/xxx/MainApplication.java import and add WebRTCModulePackage : If you are using a version prior to 0.60.0: import com.oney.WebRTCModule.WebRTCModulePackage; ... @Override protected List<ReactPackage> getPackages() { return Arrays.<ReactPackage>asList( new MainReactPackage(), new WebRTCModulePackage() // <-- Add this line ); } If you are using a version above to 0.60.0: import com.oney.WebRTCModule.WebRTCModulePackage; .... @Override protected List<ReactPackage> getPackages() { @SuppressWarnings(\"UnnecessaryLocalVariable\") List<ReactPackage> packages = new PackageList(this).getPackages(); // Packages that cannot be autolinked yet can be added manually here, for example: // packages.add(new MyReactNativePackage()); packages.add(new WebRTCModulePackage()); // <-- Add this line return packages; } INFO: react-native-webrtc provide us more information about these requeriments here","title":"Android specific requirements"},{"location":"tutorials/openvidu-react-native/#ios-specific-requirements","text":"iOS apps need to include the WebRTC modules from react-native-webrtc plugin. We will do it by following the steps bellow. These configurations are already included in this openvidu-react-native project , so if you start from here no further configurations are needed. Otherwise, if you want to start a new project with React Native and OpenVidu , you should follow these simple steps: 1) Add these files into your project in Xcode: Right click on Libraries and Add Files to {project} Go to node_modules/openvidu-browser/node_modules/react-native-webrtc/ios/RCTWebRTC.xcodeproj and click on Add Also add node_modules/react-native-webrtc/ios/WebRTC.framework to Frameworks folder 2) iOS Podfile You can use the included podspec in your podfile to take care of all dependencies instead of manually adding files to the project. If you prefer to add it manually, you should check the official tutorial . Include in the Podfile in your react-native iOS directory: pod 'react-native-webrtc', :path => '../node_modules/openvidu-browser/node_modules/react-native-webrtc' You may have to change the platform field in your Podfile, as react-native-webrtc doesn't support iOS 9 - set it to '10.0' or above (otherwise you get an error when doing pod install ): platform :ios, '10.0' 3) Set up parameters Under Build setting set Dead Code Stripping to No also under Build Options set Enable Bitcode to No as well 4) Add Permissions * Navigate to <ProjectFolder>/ios/<ProjectName>/ * Edit Info.plist and add the following lines <key>NSCameraUsageDescription</key> <string>Camera Permission</string> <key>NSMicrophoneUsageDescription</key> <string>Microphone Permission</string> 5) Install pod You will install the Podfile that we have set up in step 2: cd ios pod install INFO: react-native-webrtc provide us more information about these requeriments here $().fancybox({ selector : '[data-fancybox]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"iOS specific requirements"},{"location":"tutorials/openvidu-webcomponent/","text":"openvidu-webcomponent Check it on GitHub OpenVidu Web Component is the simplest and quickest way to add videoconference capabilities to your existing web application. It brings many of the features of OpenVidu platform, making it very powerful. With just a few lines of code you will have your first video call working! Running this tutorial 1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need an http web server installed in your development computer to execute the tutorial. If you have node.js installed, you can use http-server to serve application files. It can be installed with: npm install -g http-server 3) Run the tutorial: http-server openvidu-tutorials/openvidu-webcomponent/web 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8080 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ Understanding the code This application is very simple. It has only 4 files: openvidu-webcomponent-{VERSION}.js : JavaScript file of OpenVidu Web Component. You don't have to manipulate this file. openvidu-webcomponent-{VERSION}.css : styles for OpenVidu Web Component. You don't have to manipulate this file. app.js : sample application main JavaScript file. index.html : HTML code of the application. Let's see how OpenVidu Web Component works: index.html Inside of the head section of index.html , we reference our app.js script and openvidu-webcomponent files: <head> <!--... other imports ...--> <script src=\"app.js\"></script> <script src='openvidu-webcomponent-{VERSION}.js'></script> <link rel=\"stylesheet\" href=\"openvidu-webcomponent-{VERSION}.css\"> </head> As you can see, the index.html body has the form to connect to a video-session and the OpenVidu Web Component , which starts hidden: <body> <!-- Form to connect to a video-session --> <div id=\"main\" style=\"text-align: center;\"> <h1>Join a video session</h1> <form onsubmit=\"joinSession(); return false\" style=\"padding: 80px; margin: auto\"> <p> <label>Session:</label> <input type=\"text\" id=\"sessionName\" value=\"SessionA\" required> </p> <p> <label>User:</label> <input type=\"text\" id=\"user\" value=\"User1\" required> </p> <p> <input type=\"submit\" value=\"JOIN\"> </p> </form> </div> <!-- OpenVidu Web Component --> <openvidu-webcomponent style=\"display: none;\"></openvidu-webcomponent> </body> app.js (I): OpenVidu Web Component events OpenVidu Web Component emits events joinSession , leaveSession or error , so we can handle them in our JavaScript code. We just need to get the element once the document is ready and add all the listeners we want: $(document).ready(() => { var webComponent = document.querySelector('openvidu-webcomponent'); webComponent.addEventListener('joinSession', (event) => { // Do something }); webComponent.addEventListener('leaveSession', (event) => { // Do something }); webComponent.addEventListener('error', (event) => { // Do something }); }); In this tutorial, we just alternate the view between the form and the web component, hiding or showing them when receiving joinSession or leaveSession events. app.js (II): Configuring OpenVidu Web Component Session Configuration Method joinSession() gets: The form input values, with the video-call to connect and the nickname the user will have in it. The tokens from OpenVidu Server. Check out next point to see how this is done. When we have our tokens available, the only thing left to do is to give the desired configuration to openvidu-webcomponent. To do so we use an object with three parameters: sessionName , user and tokens . sessionName : the session name that will be displayed inside the component user : the nickname that the user will have in the session tokens : the retrieved tokens from OpenVidu Server However, if we give the openvidu-url and openvidu-secret , the webcomponent will build the token for us. function joinSession() { var sessionName = document.getElementById('sessionName').value; var user = document.getElementById('user').value; var tokens = []; var form = document.getElementById('main'); var webComponent = document.querySelector('openvidu-webcomponent'); form.style.display = 'none'; webComponent.style.display = 'block'; if(webComponent.getAttribute(\"openvidu-secret\") != undefined && webComponent.getAttribute(\"openvidu-server-url\") != undefined ){ location.reload(); }else { getToken(sessionName).then((token1) => { tokens.push(token1); getToken(sessionName).then((token2) => { tokens.push(token2); webComponent.sessionConfig = { sessionName, user, tokens }; }); }); } } That's it. Once you configure the token into the webcomponent, it will automatically join the proper session ( joinSession event will be dispatched so you can update your web). The user will see in the webcomponent all other users joined to the same session and will publish the webcam. You have a video-call working! Interface Configuration Optionally, you can add an extra JSON param inside of webcomponent.sessionConfig object named ovSettings . This parameter allows you to set up an extra custom interface. We have the choice to enabling or disabling the chat and each of the toolbar buttons. Besides, openvidu-webcomponent allows you configure your camera and audio device , your avatar and your nickname before join to the room. To do that, you only have to set autopublish property to false . To do that, is necessary to declare the following ovSettings variable: var ovSettings = { chat: true, autopublish: true, toolbarButtons: { audio: true, video: true, screenShare: true, fullscreen: true, exit: true, } }; and add it inside of webcomponent.sessionConfig object: webComponent.sessionConfig = { sessionName, user, token, ovSettings }; Get a token from OpenVidu Server WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server The token must has inside of an array. If you want that the app allows the screen sharing you must include two differents tokens in the array. If you only add one, the app doesn't allow the screen sharing funcionality. getToken(sessionName).then((token) => { // Send the 'token' to OpenVidu web component }); In a production environment we would perform this operations in our application backend, by making use of the API REST , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our sessionName value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo . Extra features of OpenVidu Web Component Alternatives to connect to OpenVidu session In the example above, OpenVidu Web Component receives the sessionConfig parameter dynamically like this: webComponent.sessionConfig = { sessionId, user, token }; But you can also set them statically, for example if you are building your template in the backend: <openvidu-webcomponent session-config='{\"sessionName\":\"SessionA\", \"user\":\"User1\", \"token\": \"[TOKEN_RETRIEVED_FROM_OPENVIDU_SERVER]\"}'></openvidu-webcomponent> Besides, openvidu-webcomponent allows you to add ovSettings parameter statically: <openvidu-webcomponent session-config='{\"sessionName\":\"SessionA\", \"user\":\"User1\", \"ovSettings\": {\"chat\": true, \"autopublish\": true, \"toolbarButtons\": {\"audio\": true, \"video\": true, \"screenShare\": true, \"fullscreen\": true, \"exit\": true }}}'> </openvidu-webcomponent> And if you want to let the webcomponent get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the JavaScript code: <openvidu-webcomponent openvidu-server-url=\"https://localhost:4443\" openvidu-secret=\"MY_SECRET\" session-config='{\"sessionName\":\"SessionA\", \"user\":\"User1\", \"ovSettings\": {\"chat\": true, \"autopublish\": true, \"toolbarButtons\": {\"audio\": true, \"video\":true, \"screenShare\": true, \"fullscreen\": true, \"exit\": true }}}'> </openvidu-webcomponent> WARNING : As you can see, when you add parameters to OpenVidu web component statically, you have to replace the camelCase with a hyphen between words . Close the session dynamically You can also disconnect the user from the session assigning dynamically undefined to the sessionConfig property : ov.sessionConfig = undefined; Choose a theme OpenVidu allows you to choose between two themes. By default, the theme selected is dark theme but if you prefer change it for a light them , you can add theme=\"light\" <openvidu-webcomponent theme=\"light\"></openvidu-webcomponent> $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"openvidu-webcomponent"},{"location":"tutorials/openvidu-webcomponent/#openvidu-webcomponent","text":"Check it on GitHub OpenVidu Web Component is the simplest and quickest way to add videoconference capabilities to your existing web application. It brings many of the features of OpenVidu platform, making it very powerful. With just a few lines of code you will have your first video call working!","title":"openvidu-webcomponent"},{"location":"tutorials/openvidu-webcomponent/#running-this-tutorial","text":"1) Clone the repo: git clone https://github.com/OpenVidu/openvidu-tutorials.git 2) You will need an http web server installed in your development computer to execute the tutorial. If you have node.js installed, you can use http-server to serve application files. It can be installed with: npm install -g http-server 3) Run the tutorial: http-server openvidu-tutorials/openvidu-webcomponent/web 4) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need Docker CE ): docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.12.0 5) Go to localhost:8080 to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of openvidu-server when you first try to join a video-call. If you are using Windows , read this FAQ to properly run the tutorial To learn some tips to develop with OpenVidu, check this FAQ","title":"Running this tutorial"},{"location":"tutorials/openvidu-webcomponent/#understanding-the-code","text":"This application is very simple. It has only 4 files: openvidu-webcomponent-{VERSION}.js : JavaScript file of OpenVidu Web Component. You don't have to manipulate this file. openvidu-webcomponent-{VERSION}.css : styles for OpenVidu Web Component. You don't have to manipulate this file. app.js : sample application main JavaScript file. index.html : HTML code of the application. Let's see how OpenVidu Web Component works:","title":"Understanding the code"},{"location":"tutorials/openvidu-webcomponent/#indexhtml","text":"Inside of the head section of index.html , we reference our app.js script and openvidu-webcomponent files: <head> <!--... other imports ...--> <script src=\"app.js\"></script> <script src='openvidu-webcomponent-{VERSION}.js'></script> <link rel=\"stylesheet\" href=\"openvidu-webcomponent-{VERSION}.css\"> </head> As you can see, the index.html body has the form to connect to a video-session and the OpenVidu Web Component , which starts hidden: <body> <!-- Form to connect to a video-session --> <div id=\"main\" style=\"text-align: center;\"> <h1>Join a video session</h1> <form onsubmit=\"joinSession(); return false\" style=\"padding: 80px; margin: auto\"> <p> <label>Session:</label> <input type=\"text\" id=\"sessionName\" value=\"SessionA\" required> </p> <p> <label>User:</label> <input type=\"text\" id=\"user\" value=\"User1\" required> </p> <p> <input type=\"submit\" value=\"JOIN\"> </p> </form> </div> <!-- OpenVidu Web Component --> <openvidu-webcomponent style=\"display: none;\"></openvidu-webcomponent> </body>","title":"index.html"},{"location":"tutorials/openvidu-webcomponent/#appjs-i-openvidu-web-component-events","text":"OpenVidu Web Component emits events joinSession , leaveSession or error , so we can handle them in our JavaScript code. We just need to get the element once the document is ready and add all the listeners we want: $(document).ready(() => { var webComponent = document.querySelector('openvidu-webcomponent'); webComponent.addEventListener('joinSession', (event) => { // Do something }); webComponent.addEventListener('leaveSession', (event) => { // Do something }); webComponent.addEventListener('error', (event) => { // Do something }); }); In this tutorial, we just alternate the view between the form and the web component, hiding or showing them when receiving joinSession or leaveSession events.","title":"app.js (I): OpenVidu Web Component events"},{"location":"tutorials/openvidu-webcomponent/#appjs-ii-configuring-openvidu-web-component","text":"","title":"app.js (II): Configuring OpenVidu Web Component"},{"location":"tutorials/openvidu-webcomponent/#session-configuration","text":"Method joinSession() gets: The form input values, with the video-call to connect and the nickname the user will have in it. The tokens from OpenVidu Server. Check out next point to see how this is done. When we have our tokens available, the only thing left to do is to give the desired configuration to openvidu-webcomponent. To do so we use an object with three parameters: sessionName , user and tokens . sessionName : the session name that will be displayed inside the component user : the nickname that the user will have in the session tokens : the retrieved tokens from OpenVidu Server However, if we give the openvidu-url and openvidu-secret , the webcomponent will build the token for us. function joinSession() { var sessionName = document.getElementById('sessionName').value; var user = document.getElementById('user').value; var tokens = []; var form = document.getElementById('main'); var webComponent = document.querySelector('openvidu-webcomponent'); form.style.display = 'none'; webComponent.style.display = 'block'; if(webComponent.getAttribute(\"openvidu-secret\") != undefined && webComponent.getAttribute(\"openvidu-server-url\") != undefined ){ location.reload(); }else { getToken(sessionName).then((token1) => { tokens.push(token1); getToken(sessionName).then((token2) => { tokens.push(token2); webComponent.sessionConfig = { sessionName, user, tokens }; }); }); } } That's it. Once you configure the token into the webcomponent, it will automatically join the proper session ( joinSession event will be dispatched so you can update your web). The user will see in the webcomponent all other users joined to the same session and will publish the webcam. You have a video-call working!","title":"Session Configuration"},{"location":"tutorials/openvidu-webcomponent/#interface-configuration","text":"Optionally, you can add an extra JSON param inside of webcomponent.sessionConfig object named ovSettings . This parameter allows you to set up an extra custom interface. We have the choice to enabling or disabling the chat and each of the toolbar buttons. Besides, openvidu-webcomponent allows you configure your camera and audio device , your avatar and your nickname before join to the room. To do that, you only have to set autopublish property to false . To do that, is necessary to declare the following ovSettings variable: var ovSettings = { chat: true, autopublish: true, toolbarButtons: { audio: true, video: true, screenShare: true, fullscreen: true, exit: true, } }; and add it inside of webcomponent.sessionConfig object: webComponent.sessionConfig = { sessionName, user, token, ovSettings };","title":"Interface Configuration"},{"location":"tutorials/openvidu-webcomponent/#get-a-token-from-openvidu-server","text":"WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server The token must has inside of an array. If you want that the app allows the screen sharing you must include two differents tokens in the array. If you only add one, the app doesn't allow the screen sharing funcionality. getToken(sessionName).then((token) => { // Send the 'token' to OpenVidu web component }); In a production environment we would perform this operations in our application backend, by making use of the API REST , OpenVidu Java Client or OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method getToken() that returns a Promise with the token. Without going into too much detail, this method performs two ajax requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them: First ajax request performs a POST to /api/sessions (we send a customSessionId field to name the session with our sessionName value retrieved from HTML input) Second ajax request performs a POST to /api/tokens (we send a session field to assign the token to this same session) You can inspect this method in detail in the GitHub repo .","title":"Get a token from OpenVidu Server"},{"location":"tutorials/openvidu-webcomponent/#extra-features-of-openvidu-web-component","text":"","title":"Extra features of OpenVidu Web Component"},{"location":"tutorials/openvidu-webcomponent/#alternatives-to-connect-to-openvidu-session","text":"In the example above, OpenVidu Web Component receives the sessionConfig parameter dynamically like this: webComponent.sessionConfig = { sessionId, user, token }; But you can also set them statically, for example if you are building your template in the backend: <openvidu-webcomponent session-config='{\"sessionName\":\"SessionA\", \"user\":\"User1\", \"token\": \"[TOKEN_RETRIEVED_FROM_OPENVIDU_SERVER]\"}'></openvidu-webcomponent> Besides, openvidu-webcomponent allows you to add ovSettings parameter statically: <openvidu-webcomponent session-config='{\"sessionName\":\"SessionA\", \"user\":\"User1\", \"ovSettings\": {\"chat\": true, \"autopublish\": true, \"toolbarButtons\": {\"audio\": true, \"video\": true, \"screenShare\": true, \"fullscreen\": true, \"exit\": true }}}'> </openvidu-webcomponent> And if you want to let the webcomponent get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the JavaScript code: <openvidu-webcomponent openvidu-server-url=\"https://localhost:4443\" openvidu-secret=\"MY_SECRET\" session-config='{\"sessionName\":\"SessionA\", \"user\":\"User1\", \"ovSettings\": {\"chat\": true, \"autopublish\": true, \"toolbarButtons\": {\"audio\": true, \"video\":true, \"screenShare\": true, \"fullscreen\": true, \"exit\": true }}}'> </openvidu-webcomponent> WARNING : As you can see, when you add parameters to OpenVidu web component statically, you have to replace the camelCase with a hyphen between words .","title":"Alternatives to connect to OpenVidu session"},{"location":"tutorials/openvidu-webcomponent/#close-the-session-dynamically","text":"You can also disconnect the user from the session assigning dynamically undefined to the sessionConfig property : ov.sessionConfig = undefined;","title":"Close the session dynamically"},{"location":"tutorials/openvidu-webcomponent/#choose-a-theme","text":"OpenVidu allows you to choose between two themes. By default, the theme selected is dark theme but if you prefer change it for a light them , you can add theme=\"light\" <openvidu-webcomponent theme=\"light\"></openvidu-webcomponent> $().fancybox({ selector : '[data-fancybox=\"gallery\"]', infobar : true, arrows : false, loop: true, protect: true, transitionEffect: 'slide', buttons : [ 'close' ], clickOutside : 'close', clickSlide : 'close', });","title":"Choose a theme"}]}