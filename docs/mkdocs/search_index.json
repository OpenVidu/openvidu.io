{
    "docs": [
        {
            "location": "/home/", 
            "text": "What is OpenVidu?\n\n\n\n\n\n\n\nOpenVidu is a platform to facilitate the addition of video calls in your web or mobile application. It provides a complete stack of technologies very easy to integrate in your application. Our main goal is to allow developers to add real-time communications to their apps very fast and with low impact in their code.\n\n\n\n\n\n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nWebRTC videoconferences\n\n      \nOne-to-One, One-to-Many, Many-to-Many. Any combination you can think of is possible with OpenVidu\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nOpen source\n\n      \nOpenVidu is an OpenSource project licensed under \nApache License v2\n. Use it for free\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nMultiplatform\n\n      \nChrome, Firefox, Safari, Opera, Android, iOS. All compatible with each other\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nEasy to use\n\n      \nOpenVidu offers ready-to-use components that you can simply paste in your code to quickly get your videocalls up and running. Or if you want complete freedom when designing your videocalls, our super simple API will make it fun and quick but at the same time very customizable and powerful\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nEasy to deploy\n\n      \nDeveloping your app is just the beginning. And of course we know that the go-to-production process can sometimes be pretty annoying. OpenVidu makes this a seamless process by supporting the \ndeployment in the most popular cloud provider\n in a few clicks. Or if you prefer, we have a very short \nstep-by-step guide\n on how to successfully deploy OpenVidu on Ubuntu\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nTutorials/Demos available\n\n      \nAs developers we believe that the best way to engage other colleagues in our platform is providing lots of working examples and guides that can serve as a starting point or a fun way to learn how to take advantage of OpenVidu full potential\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nKeep your videoconferences private\n\n      \nWebRTC encryption, our server API and our client role-based system guarantee all your calls will be completely private\n\n    \n\n  \n\n  \n\n  \n\n      \n\n      \n\n    \n\n    \n\n      \nCompatible with lots of frontend technologies\n\n      \nJavaScript, TypeScript, Angular, React, Ionic... Just choose your preferred language and framework\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nCompatible with any backend technology\n\n      \nOpenVidu offers out of the box Java and Node clients for controlling your videocalls from your server, but it also exposes a REST API to allow any backend technology to be used. We don't want to limit any developer!\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nLimit client capabilities with predefined roles\n\n      \nDecide which user is allowed to subscribe, publish or moderate video streams with predefined roles. Securing your videocalls has never been so easy!\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nMessage broadcasting\n\n      \nYou can implement a chat within just a few lines of code with OpenVidu. Any \nuser to user text-based communication\n your app may need can be implemented very easily\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nRecording\n\n      \nRecord your videocalls\n with complete freedom: OpenVidu provides predefined layouts, but you can use your own custom layouts to accomplish any kind of result\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nScreen sharing\n\n      \nOpenVidu allows your clients to \nshare their screens\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nAudio and video filters\n\n      \nOpenVidu is the only WebRTC technology that allows you to apply \nreal-time audio and video filters\n. Detecting bar codes, settting a chroma key background or amplifying your clients voices are only just a few examples of what you can achieve with OpenVidu filters. And all of this perfectly integrated in OpenVidu simple high-level API\n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \n\n    \n\n    \n\n      \nSupported plans and professional support\n\n      \nWe offer \nOpenVidu Pro\n for those companies interested in a more advanced production setup, focused on improved monitoring, scalability and fault tolerance. And OpenVidu team is opened to providing professional support for any project related to the platform. \nContact us now!\n\n    \n\n  \n\n\n\n\n\n\n\n\nSome use cases\n\n\n\nSome interesting use cases you can implement with OpenVidu:\n\n\n\n\nAn integrated 1-to-1 video-call center to attend your customers face to face\n\n\nA videoclassroom platform where one or more teachers publish their webcams or desktops and many students receive them\n\n\nAudio-only rooms where users can also interact through a chat\n\n\nA conference service that allows the presenter to apply audio or video filters in real-time and record the lecture in a video file\n\n\nA security platform where you can receive video from security cameras/webcams. You could even receive a notification when some movement is detected in a region of the video\n\n\nAn application to receive video from drones equipped with a camera \n(RTSP support coming soon)\n\n\n\n\nThe possibilities are endless. You can check our \nDemos\n to get an idea of what you can do with OpenVidu. Here some cool pictures of them:\n\n\n\n  \n\n  \n\n  \n\n  \n\n  \n\n\n\n\n\n\n\nOpenVidu Architecture\n\n\n\n  \n\n\n\n\n\nOpenVidu is divided into two parts:\n\n\n\n\nOpenVidu Browser\n: it is a library to use in your client side (available for JavaScript and TypeScript). It allows you to create video-calls, join users to them, send and receive video and audio, etc... All the actions available with OpenVidu are managed via OpenVidu Browser.\n\n\nOpenVidu Server\n: it is an application that handles the server-side stuff. It receives the operations from OpenVidu Browser and do whatever is necessary to establish and manage your video-calls. You will never have to explicitly use it: just to run it and know its IP address.\n\n\n\n\n\n\nGet started\n\n\nThese are the recommended steps for getting started with OpenVidu:\n\n\n\n\n\n\nThe best way to get your first app working in a few minutes is following our \nOpenVidu Hello World Tutorial\n.\n\n\n\n\n\n\nAfter that, you can try any of our \nClient-Side-Only\n tutorials, or maybe go straight to step 3 if you think that you already handle OpenVidu reasonably well.\n\n\n\n\n\n\nTry now any of our \nClient-Side + Server-Side\n tutorials, where you can see how a complete web application works with OpenVidu. Choose your preferred framework, since all 4 applications are exactly the same regarding their look and functionality.\n\n\n\n\n\n\nFinally you can \ndeploy your first app\n and see it working in the real world. You can follow our tutorial, where you can deploy our Demos in your own Amazon machine in a few minutes (\nDeploying OpenVidu Demos on AWS\n). Then you can deploy your own app following these steps (\nDeploying OpenVidu Server\n and \nDeploying your app on AWS\n).\n\n\n\n\n\n\n\n\nHow does OpenVidu work?\n\n\nWebRTC\n is the ultimate responsible for all media transmission at the very heart of OpenVidu. WebRTC is a modern, cross-platform framework that democratizes media transmission over the Internet. It is promoted by Google, Mozilla, Opera and others.\n\n\nKurento\n is the WebRTC framework on which OpenVidu is built. Openvidu was forked from \nKurentoRoom project\n.\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \n\n  \n\n\n\n\n\nWhat are the differences between Kurento and OpenVidu?\n\n\nOpenVidu wraps and hides all the low-level operations. The main goal we pursue is to provide a simple, effective, easy-to-use API so you can forget about WebRTC, ICE candidates and media server tricky stuff. We internally use Kurento to generate, connect, modify and destroy media-pipelines, but OpenVidu simplifies as far as possible the process, focusing on the use-case of video-call sessions (one-to-one, one-to-many, many-to-many, users with different roles).\n\n\nUltimately, developers can create video-calls with just a few lines of code, all from their client-side\n.\n\n\n\n\nAcknowledgments\n\n\nOpenVidu has been supported under Project LERNIM (RTC-2016-4674-7), co-funded by the \nMinistry of Economy, Finance and Competitiveness\n of Spain, as well as by the \nEuropean Regional Development Fund\n, whose main goal is to promote technological development, innovation and high-quality research.\n\n\n\n  \n\n  \n\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery-wellcome\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });\n\n\n\n\n\n\n\n\n\n\n    $('.docs-gallery').slick({\n      autoplay: true,\n      autoplaySpeed: 4000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "What is OpenVidu?"
        }, 
        {
            "location": "/home/#some-use-cases", 
            "text": "Some interesting use cases you can implement with OpenVidu:   An integrated 1-to-1 video-call center to attend your customers face to face  A videoclassroom platform where one or more teachers publish their webcams or desktops and many students receive them  Audio-only rooms where users can also interact through a chat  A conference service that allows the presenter to apply audio or video filters in real-time and record the lecture in a video file  A security platform where you can receive video from security cameras/webcams. You could even receive a notification when some movement is detected in a region of the video  An application to receive video from drones equipped with a camera  (RTSP support coming soon)   The possibilities are endless. You can check our  Demos  to get an idea of what you can do with OpenVidu. Here some cool pictures of them:", 
            "title": "Some use cases"
        }, 
        {
            "location": "/home/#openvidu-architecture", 
            "text": "OpenVidu is divided into two parts:   OpenVidu Browser : it is a library to use in your client side (available for JavaScript and TypeScript). It allows you to create video-calls, join users to them, send and receive video and audio, etc... All the actions available with OpenVidu are managed via OpenVidu Browser.  OpenVidu Server : it is an application that handles the server-side stuff. It receives the operations from OpenVidu Browser and do whatever is necessary to establish and manage your video-calls. You will never have to explicitly use it: just to run it and know its IP address.", 
            "title": "OpenVidu Architecture"
        }, 
        {
            "location": "/home/#get-started", 
            "text": "These are the recommended steps for getting started with OpenVidu:    The best way to get your first app working in a few minutes is following our  OpenVidu Hello World Tutorial .    After that, you can try any of our  Client-Side-Only  tutorials, or maybe go straight to step 3 if you think that you already handle OpenVidu reasonably well.    Try now any of our  Client-Side + Server-Side  tutorials, where you can see how a complete web application works with OpenVidu. Choose your preferred framework, since all 4 applications are exactly the same regarding their look and functionality.    Finally you can  deploy your first app  and see it working in the real world. You can follow our tutorial, where you can deploy our Demos in your own Amazon machine in a few minutes ( Deploying OpenVidu Demos on AWS ). Then you can deploy your own app following these steps ( Deploying OpenVidu Server  and  Deploying your app on AWS ).", 
            "title": "Get started"
        }, 
        {
            "location": "/home/#how-does-openvidu-work", 
            "text": "WebRTC  is the ultimate responsible for all media transmission at the very heart of OpenVidu. WebRTC is a modern, cross-platform framework that democratizes media transmission over the Internet. It is promoted by Google, Mozilla, Opera and others.  Kurento  is the WebRTC framework on which OpenVidu is built. Openvidu was forked from  KurentoRoom project .  \n   \n     \n   \n   \n     \n     What are the differences between Kurento and OpenVidu?  OpenVidu wraps and hides all the low-level operations. The main goal we pursue is to provide a simple, effective, easy-to-use API so you can forget about WebRTC, ICE candidates and media server tricky stuff. We internally use Kurento to generate, connect, modify and destroy media-pipelines, but OpenVidu simplifies as far as possible the process, focusing on the use-case of video-call sessions (one-to-one, one-to-many, many-to-many, users with different roles).  Ultimately, developers can create video-calls with just a few lines of code, all from their client-side .", 
            "title": "How does OpenVidu work?"
        }, 
        {
            "location": "/home/#acknowledgments", 
            "text": "OpenVidu has been supported under Project LERNIM (RTC-2016-4674-7), co-funded by the  Ministry of Economy, Finance and Competitiveness  of Spain, as well as by the  European Regional Development Fund , whose main goal is to promote technological development, innovation and high-quality research.  \n   \n       \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery-wellcome\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });     \n    $('.docs-gallery').slick({\n      autoplay: true,\n      autoplaySpeed: 4000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/tutorials/", 
            "text": "OpenVidu Tutorials\n\n\n\n\n\n\n\n\n\n\n    \n\n\n        \n\n            \nHello World\n\n            \nMake your first video-call with just a few lines of code\n\n        \n\n\n        \n\n            \n\n            \n\n                \n\n                    \n\n                        \nHello World!\n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n            \n\n            \n\n        \n\n\n        \n\n\n        \n\n            \nClient Side only \n\n            \nGet quickly started without worrying about a server-side\n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript\n\n                    \nVanilla JavaScript app: good old JS code for a traditional approach\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nAngular\n\n                    \nTry this fantastic tutorial using the last version of Angular framework\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nReact\n\n                    \nHave a look to this nice tutorial based on React \n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nIonic\n\n                    \nThis Ionic project will get your mobile app going in the blink of an eye\n\n                \n\n            \n\n\n        \n\n        \n\n\n        \n\n            \n\n            \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \nOpenVidu\n is present on both client-side and server-side, but the \napplication\n is only present on client-side.\n\n                        \nSince these are client-side-only applications, you will be dealing only with \nfrontend technologies\n: HTML, CSS, Javascript / Typescript ...\n\n                        \nThe main difference compared to Client Side + Server Side tutorials is that here you don't have real control over your users: your\n                            \nvideo-calls won't be secure\n because you cannot identify them and cannot determine if allow or deny their access.\n\n                    \n\n                \n\n            \n\n        \n\n\n        \n\n\n        \n\n            \nClient Side + Server Side \n\n            \nTry any of our ready-for-production web apps to see OpenVidu in action with a real example\n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Java SPA\n\n                    \nVanilla JavasCript frontend and a SPA Java Backend: forget building HTML templates, just feed your\n                        front with HTTP requests\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Java MVC\n\n                    \nVanilla JavasCript frontend and a traditional Java MVC Backend: serve HTML pages from your server\n\n                \n\n            \n\n\n        \n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Node SPA\n\n                    \nVanilla JavasCript frontend and a SPA Node Backend: forget building HTML templates, just feed your\n                        front with HTTP requests\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Node MVC\n\n                    \nVanilla JavasCript frontend and a traditional Node MVC backend: serve HTML pages from your server\n\n                \n\n            \n\n\n        \n\n\n        \n\n            \n\n            \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \nOpenVidu\n and the \napplication\n are present on both client-side and server-side.\n\n                        \nSince these are full web applications, you will be dealing with \nfrontend technologies\n (HTML, CSS, Javascript / Typescript ...) \n                            but also with \nbackend technologies\n (Java / Node)\n\n                        \nThe main difference compared to Client Side Only tutorials is that here you have total control over your users: your \n                            \nvideo-calls are secure\n because you can identify them and allow or deny their access.", 
            "title": "Intro"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/", 
            "text": "openvidu-webcomponent\n\n\n Check it on GitHub\n\n\nOpenVidu Web Component is the simplest and quickest way to add videoconference capabilities to your existing web application. It brings many of the features of OpenVidu platform, making it very powerful.\nWith just a few lines of code you will have your first video call working!\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need an http web server installed in your development computer to execute the tutorial. If you have \nnode.js\n installed, you can use \nhttp-server\n to serve application files. It can be installed with:\n\n\nnpm install -g http-server\n\n\n\n\n3) Run the tutorial:\n\n\nhttp-server openvidu-tutorials/openvidu-webcomponent/web\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nlocalhost:8080\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\nUnderstanding the code\n\n\nThis application is very simple. It has only 4 files:\n\n\n\n\nopenvidu-webcomponent-{VERSION}.js\n: JavaScript file of OpenVidu Web Component. You don't have to manipulate this file.\n\n\nopenvidu-webcomponent-{VERSION}.css\n: styles for OpenVidu Web Component. You don't have to manipulate this file.\n\n\napp.js\n: sample application main JavaScript file.\n\n\nindex.html\n: HTML code of the application.\n\n\n\n\nLet's see how OpenVidu Web Component works:\n\n\n\n\nindex.html\n\n\nInside of the \nhead\n section of \nindex.html\n, we reference our \napp.js\n script and \nopenvidu-webcomponent\n files:\n\n\nhead\n\n\n    \n!--... other imports ...--\n\n\n    \nscript src=\napp.js\n/script\n\n    \nscript src='openvidu-webcomponent-{VERSION}.js'\n/script\n\n    \nlink rel=\nstylesheet\n href=\nopenvidu-webcomponent-{VERSION}.css\n\n\n/head\n\n\n\n\n\nAs you can see, the \nindex.html\n body has the form to connect to a video-session and the \nOpenVidu Web Component\n, which starts hidden:\n\n\nbody\n\n\n    \n!-- Form to connect to a video-session --\n\n    \ndiv id=\nmain\n style=\ntext-align: center;\n\n        \nh1\nJoin a video session\n/h1\n\n        \nform onsubmit=\njoinSession(); return false\n style=\npadding: 80px; margin: auto\n\n            \np\n\n                \nlabel\nSession:\n/label\n\n                \ninput type=\ntext\n id=\nsessionName\n value=\nSessionA\n required\n\n            \n/p\n\n            \np\n\n                \nlabel\nUser:\n/label\n\n                \ninput type=\ntext\n id=\nuser\n value=\nUser1\n required\n\n            \n/p\n\n            \np\n\n                \ninput type=\nsubmit\n value=\nJOIN\n\n            \n/p\n\n        \n/form\n\n    \n/div\n\n\n    \n!-- OpenVidu Web Component --\n\n    \nopenvidu-webcomponent style=\ndisplay: none;\n/openvidu-webcomponent\n\n\n\n/body\n\n\n\n\n\n\n\napp.js (I): OpenVidu Web Component events\n\n\nOpenVidu Web Component emits events \njoinSession\n, \nleaveSession\n or \nerror\n, so we can handle them in our JavaScript code.\nWe just need to get the element once the document is ready and add all the listeners we want:\n\n\n$(document).ready(() =\n {\n    var webComponent = document.querySelector('openvidu-webcomponent');\n\n    webComponent.addEventListener('joinSession', (event) =\n {\n        // Do something\n    });\n    webComponent.addEventListener('leaveSession', (event) =\n {\n        // Do something\n    });\n    webComponent.addEventListener('error', (event) =\n {\n        // Do something\n    });\n});\n\n\n\n\nIn this tutorial, we just alternate the view between the form and the web component, hiding or showing them when receiving \njoinSession\n or \nleaveSession\n events.\n\n\n\n\napp.js (II): Configuring OpenVidu Web Component\n\n\nSession Configuration\n\n\nMethod \njoinSession()\n gets:\n\n\n\n\nThe form input values, with the video-call to connect and the nickname the user will have in it.\n\n\nThe \ntoken\n from OpenVidu Server. Check out \nnext point\n to see how this is done.\n\n\n\n\nWhen we have our token available, the only thing left to do is to give the desired configuration to openvidu-webcomponent. To do so we use an object with three parameters: \nsessionName\n, \nuser\n and  \ntoken\n.\n\n\n\n\nsessionName\n: the session name that will be displayed inside the component\n\n\nuser\n: the nickname that the user will have in the session\n\n\ntoken\n: the retrieved token from OpenVidu Server\n\n\n\n\nfunction joinSession() {\n    var sessionName = document.getElementById('sessionName').value;\n    var user = document.getElementById('user').value;\n\n    getToken(sessionName).then((token) =\n {\n        var webComponent = document.querySelector('openvidu-webcomponent');\n        webComponent.sessionConfig = { sessionName, user, token };\n    });\n}\n\n\n\n\nThat's it. Once you configure the token into the webcomponent, it will automatically join the proper session (\njoinSession\n event will be dispatched so you can update your web). The user will see in the webcomponent all other users joined to the same session and will publish the webcam. You have a video-call working!\n\n\nInterface Configuration\n\n\nOptionally, you can add an extra JSON param inside of \nwebcomponent.sessionConfig\n object named \novSettings\n. This parameter allows you to set up an extra custom interface. We have the choice to enabling or disabling the chat and each of the toolbar buttons. Besides, openvidu-webcomponent allows you configure your \ncamera\n and \naudio device\n, your \navatar\n and your \nnickname\n before join to the room. To do that, you only have to set \nautopublish\n property to \nfalse\n.\n\n\nTo do that, is necessary to declare the following \novSettings\n variable:  \n\n\nvar ovSettings = {\n  chat: true,\n  autopublish: true,\n  toolbarButtons: {\n    audio: true,\n    video: true,\n    screenShare: true,\n    fullscreen: true,\n    exit: true,\n  }\n};\n\n\n\n\nand add it inside of \nwebcomponent.sessionConfig\n object: \n\n\nwebComponent.sessionConfig = { sessionName, user, token, ovSettings };\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\n\n\nGet a \ntoken\n from OpenVidu Server\n\n\n\n    \n\n\n\n    \nWARNING\n: This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. \nThis process should entirely take place in our server-side\n, not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server\n\n\n\n\n\n\ngetToken(sessionName).then((token) =\n {\n    // Send the 'token' to OpenVidu web component\n});\n\n\n\n\nIn a production environment we would perform this operations in our application backend, by making use of the \nAPI REST\n, \nOpenVidu Java Client\n or \nOpenVidu Node Client\n. Here we have implemented the POST requests to OpenVidu Server in a method \ngetToken()\n that returns a Promise with the token. Without going into too much detail, this method performs two \najax\n requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:\n\n\n\n\nFirst ajax request performs a POST to \n/api/sessions\n (we send a \ncustomSessionId\n field to name the session with our \nsessionName\n value retrieved from HTML input)\n\n\nSecond ajax request performs a POST to \n/api/tokens\n (we send a \nsession\n field to assign the token to this same session)\n\n\n\n\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\n\n\n\nExtra features of OpenVidu Web Component\n\n\nAlternatives to connect to OpenVidu session\n\n\nIn the example above, \nOpenVidu Web Component\n receives the \nsessionConfig\n parameter dynamically like this: \n\n\nwebComponent.sessionConfig = { sessionId, user, token };\n\n\n\n\nBut you can also set them statically, for example if you are building your template in the backend:\n\n\nopenvidu-webcomponent session-config='{\nsessionName\n:\nSessionA\n, \nuser\n:\nUser1\n, \ntoken\n: \nTOKEN_RETRIEVED_FROM_OPENVIDU_SERVER\n}'\n/openvidu-webcomponent\n\n\n\n\n\nBesides, openvidu-webcomponent allows you to add \novSettings\n parameter statically:\n\n\nopenvidu-webcomponent session-config='{\nsessionName\n:\nSessionA\n, \nuser\n:\nUser1\n,               \novSettings\n: {\nchat\n: true, \nautopublish\n: true, \ntoolbarButtons\n: {\naudio\n: true,\n \nvideo\n: true, \nscreenShare\n: true, \nfullscreen\n: true, \nexit\n: true }}}'\n\n\n/openvidu-webcomponent\n\n\n\n\n\nAnd if you want to let the webcomponent get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the JavaScript code:\n\n\nopenvidu-webcomponent  openvidu-server-url=\nhttps://localhost:4443\n openvidu-secret=\nMY_SECRET\n session-config='{\nsessionName\n:\nSessionA\n, \nuser\n:\nUser1\n, \novSettings\n: {\nchat\n: true, \nautopublish\n: true, \ntoolbarButtons\n: {\naudio\n: true, \nvideo\n:true, \nscreenShare\n: true, \nfullscreen\n: true, \nexit\n: true }}}'\n\n\n/openvidu-webcomponent\n\n\n\n\n\n\n    \n\n\n\n    \nWARNING\n: As you can see, when you add parameters to OpenVidu web component statically, you have to replace the \ncamelCase\n with a \nhyphen between words\n.\n\n\n\n\n\n\nClose the session dynamically\n\n\nYou can also disconnect the user from the session assigning dynamically \nundefined\n to the \nsessionConfig\n property :\n\n\nov.sessionConfig = undefined;\n\n\n\n\nChoose a theme\n\n\nOpenVidu  allows you to choose between two themes. By default, the theme selected is \ndark theme\n but if you prefer change it for a \nlight them\n, you can add \ntheme=\"light\"\n\n\nopenvidu-webcomponent theme=\nlight\n/openvidu-webcomponent\n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-webcomponent"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#openvidu-webcomponent", 
            "text": "Check it on GitHub  OpenVidu Web Component is the simplest and quickest way to add videoconference capabilities to your existing web application. It brings many of the features of OpenVidu platform, making it very powerful.\nWith just a few lines of code you will have your first video call working!", 
            "title": "openvidu-webcomponent"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need an http web server installed in your development computer to execute the tutorial. If you have  node.js  installed, you can use  http-server  to serve application files. It can be installed with:  npm install -g http-server  3) Run the tutorial:  http-server openvidu-tutorials/openvidu-webcomponent/web  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  localhost:8080  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.  \n     \n         \n         \n     \n     \n     \n         \n         \n     \n         If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#understanding-the-code", 
            "text": "This application is very simple. It has only 4 files:   openvidu-webcomponent-{VERSION}.js : JavaScript file of OpenVidu Web Component. You don't have to manipulate this file.  openvidu-webcomponent-{VERSION}.css : styles for OpenVidu Web Component. You don't have to manipulate this file.  app.js : sample application main JavaScript file.  index.html : HTML code of the application.   Let's see how OpenVidu Web Component works:", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#indexhtml", 
            "text": "Inside of the  head  section of  index.html , we reference our  app.js  script and  openvidu-webcomponent  files:  head \n\n     !--... other imports ...-- \n\n     script src= app.js /script \n     script src='openvidu-webcomponent-{VERSION}.js' /script \n     link rel= stylesheet  href= openvidu-webcomponent-{VERSION}.css  /head   As you can see, the  index.html  body has the form to connect to a video-session and the  OpenVidu Web Component , which starts hidden:  body \n\n     !-- Form to connect to a video-session -- \n     div id= main  style= text-align: center; \n         h1 Join a video session /h1 \n         form onsubmit= joinSession(); return false  style= padding: 80px; margin: auto \n             p \n                 label Session: /label \n                 input type= text  id= sessionName  value= SessionA  required \n             /p \n             p \n                 label User: /label \n                 input type= text  id= user  value= User1  required \n             /p \n             p \n                 input type= submit  value= JOIN \n             /p \n         /form \n     /div \n\n     !-- OpenVidu Web Component -- \n     openvidu-webcomponent style= display: none; /openvidu-webcomponent  /body", 
            "title": "index.html"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#appjs-i-openvidu-web-component-events", 
            "text": "OpenVidu Web Component emits events  joinSession ,  leaveSession  or  error , so we can handle them in our JavaScript code.\nWe just need to get the element once the document is ready and add all the listeners we want:  $(document).ready(() =  {\n    var webComponent = document.querySelector('openvidu-webcomponent');\n\n    webComponent.addEventListener('joinSession', (event) =  {\n        // Do something\n    });\n    webComponent.addEventListener('leaveSession', (event) =  {\n        // Do something\n    });\n    webComponent.addEventListener('error', (event) =  {\n        // Do something\n    });\n});  In this tutorial, we just alternate the view between the form and the web component, hiding or showing them when receiving  joinSession  or  leaveSession  events.", 
            "title": "app.js (I): OpenVidu Web Component events"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#appjs-ii-configuring-openvidu-web-component", 
            "text": "", 
            "title": "app.js (II): Configuring OpenVidu Web Component"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#session-configuration", 
            "text": "Method  joinSession()  gets:   The form input values, with the video-call to connect and the nickname the user will have in it.  The  token  from OpenVidu Server. Check out  next point  to see how this is done.   When we have our token available, the only thing left to do is to give the desired configuration to openvidu-webcomponent. To do so we use an object with three parameters:  sessionName ,  user  and   token .   sessionName : the session name that will be displayed inside the component  user : the nickname that the user will have in the session  token : the retrieved token from OpenVidu Server   function joinSession() {\n    var sessionName = document.getElementById('sessionName').value;\n    var user = document.getElementById('user').value;\n\n    getToken(sessionName).then((token) =  {\n        var webComponent = document.querySelector('openvidu-webcomponent');\n        webComponent.sessionConfig = { sessionName, user, token };\n    });\n}  That's it. Once you configure the token into the webcomponent, it will automatically join the proper session ( joinSession  event will be dispatched so you can update your web). The user will see in the webcomponent all other users joined to the same session and will publish the webcam. You have a video-call working!", 
            "title": "Session Configuration"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#interface-configuration", 
            "text": "Optionally, you can add an extra JSON param inside of  webcomponent.sessionConfig  object named  ovSettings . This parameter allows you to set up an extra custom interface. We have the choice to enabling or disabling the chat and each of the toolbar buttons. Besides, openvidu-webcomponent allows you configure your  camera  and  audio device , your  avatar  and your  nickname  before join to the room. To do that, you only have to set  autopublish  property to  false .  To do that, is necessary to declare the following  ovSettings  variable:    var ovSettings = {\n  chat: true,\n  autopublish: true,\n  toolbarButtons: {\n    audio: true,\n    video: true,\n    screenShare: true,\n    fullscreen: true,\n    exit: true,\n  }\n};  and add it inside of  webcomponent.sessionConfig  object:   webComponent.sessionConfig = { sessionName, user, token, ovSettings };", 
            "title": "Interface Configuration"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#get-a-token-from-openvidu-server", 
            "text": "WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session.  This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server   getToken(sessionName).then((token) =  {\n    // Send the 'token' to OpenVidu web component\n});  In a production environment we would perform this operations in our application backend, by making use of the  API REST ,  OpenVidu Java Client  or  OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method  getToken()  that returns a Promise with the token. Without going into too much detail, this method performs two  ajax  requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:   First ajax request performs a POST to  /api/sessions  (we send a  customSessionId  field to name the session with our  sessionName  value retrieved from HTML input)  Second ajax request performs a POST to  /api/tokens  (we send a  session  field to assign the token to this same session)   You can inspect this method in detail in the  GitHub repo .", 
            "title": "Get a token from OpenVidu Server"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#extra-features-of-openvidu-web-component", 
            "text": "", 
            "title": "Extra features of OpenVidu Web Component"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#alternatives-to-connect-to-openvidu-session", 
            "text": "In the example above,  OpenVidu Web Component  receives the  sessionConfig  parameter dynamically like this:   webComponent.sessionConfig = { sessionId, user, token };  But you can also set them statically, for example if you are building your template in the backend:  openvidu-webcomponent session-config='{ sessionName : SessionA ,  user : User1 ,  token :  TOKEN_RETRIEVED_FROM_OPENVIDU_SERVER }' /openvidu-webcomponent   Besides, openvidu-webcomponent allows you to add  ovSettings  parameter statically:  openvidu-webcomponent session-config='{ sessionName : SessionA ,  user : User1 ,                ovSettings : { chat : true,  autopublish : true,  toolbarButtons : { audio : true,\n  video : true,  screenShare : true,  fullscreen : true,  exit : true }}}'  /openvidu-webcomponent   And if you want to let the webcomponent get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the JavaScript code:  openvidu-webcomponent  openvidu-server-url= https://localhost:4443  openvidu-secret= MY_SECRET  session-config='{ sessionName : SessionA ,  user : User1 ,  ovSettings : { chat : true,  autopublish : true,  toolbarButtons : { audio : true,  video :true,  screenShare : true,  fullscreen : true,  exit : true }}}'  /openvidu-webcomponent   \n      \n     WARNING : As you can see, when you add parameters to OpenVidu web component statically, you have to replace the  camelCase  with a  hyphen between words .", 
            "title": "Alternatives to connect to OpenVidu session"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#close-the-session-dynamically", 
            "text": "You can also disconnect the user from the session assigning dynamically  undefined  to the  sessionConfig  property :  ov.sessionConfig = undefined;", 
            "title": "Close the session dynamically"
        }, 
        {
            "location": "/tutorials/openvidu-webcomponent/#choose-a-theme", 
            "text": "OpenVidu  allows you to choose between two themes. By default, the theme selected is  dark theme  but if you prefer change it for a  light them , you can add  theme=\"light\"  openvidu-webcomponent theme= light /openvidu-webcomponent   \n     \n         \n             \n         \n     \n     \n         \n             \n         \n         \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Choose a theme"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/", 
            "text": "openvidu-hello-world\n\n\n Check it on GitHub\n\n\nThis is the simplest demo you can try to get started with OpenVidu API. It has the minimum set of features to make a group video-call. You will only need a few minutes to get your first application working!\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need an http web server installed in your development computer to execute the tutorial. If you have \nnode.js\n installed, you can use \nhttp-server\n to serve application files. It can be installed with:\n\n\nnpm install -g http-server\n\n\n\n\n3) Run the tutorial:\n\n\nhttp-server openvidu-tutorials/openvidu-hello-world/web\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nlocalhost:8080\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\nUnderstanding the code\n\n\nThis application is very simple. It has only 4 files:\n\n\n\n\nopenvidu-browser-VERSION.js\n: openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n: sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n.\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n.\n\n\nindex.html\n: HTML code for the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files: \n\n\n\n\n\n  \nscript src=\"openvidu-browser-VERSION.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\nLet's see how \napp.js\n uses \nopenvidu-browser-VERSION.js\n:\n\n\n\n\nFirst lines declare the variables that will be needed in different points along the code\n\n\nvar OV;\nvar session;\n\n\n\n\nOV\n will be our OpenVidu object (entrypoint to the libray). \nsession\n will be the video-call we will connect to. As first sentence in the \njoinSession()\n method, we initialize the variable that will identify our video-call retrieving the value from the HTML input.\n\n\nvar mySessionId = document.getElementById(\nsessionId\n).value;\n\n\n\n\n\n\nInitialize a new session and its events\n\n\nOV = new OpenVidu();\nsession = OV.initSession();\n\nsession.on('streamCreated', function (event) {\n  session.subscribe(event.stream, 'subscriber');\n});\n\n\n\n\nAs you can see in the code, the process is very simple: get an OpenVidu object and initialize a Session object with it.\n\n\nThen you can subscribe to all the events you want for your session. In this case we just want to subscribe to every stream that is being created in the session: on \nstreamCreated\n we subscribe to the specific stream, available at \nevent.stream\n property.\n\n\n\n\nYou can take a look at all the events in the \nReference Documentation\n\n\n\n\n\n\nGet a \ntoken\n from OpenVidu Server\n\n\n\n    \n\n\n\n    \nWARNING\n: This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. \nThis process should entirely take place in our server-side\n, not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server\n\n\n\n\n\n\ngetToken(mySessionId).then(token =\n {\n    // See next point to see how to connect to the session using 'token'\n});\n\n\n\n\nNow we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the \nREST API\n, \nOpenVidu Java Client\n or \nOpenVidu Node Client\n. Here we have implemented the POST requests to OpenVidu Server in a method \ngetToken()\n that returns a Promise with the token. Without going into too much detail, this method performs two \najax\n requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:\n\n\n\n\nFirst ajax request performs a POST to \n/api/sessions\n (we send a \ncustomSessionId\n field to name the session with our \nmySessionId\n value retrieved from HTML input)\n\n\nSecond ajax request performs a POST to \n/api/tokens\n (we send a \nsession\n field to assign the token to this same session)\n\n\n\n\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\n\n\nConnect to the session using the token\n\n\ngetToken(mySessionId).then(token =\n {\n\n  session.connect(token)\n    .then(() =\n {\n      document.getElementById(\nsession-header\n).innerText = mySessionId;\n      document.getElementById(\njoin\n).style.display = \nnone\n;\n      document.getElementById(\nsession\n).style.display = \nblock\n;\n\n      var publisher = OV.initPublisher(\npublisher\n);\n      session.publish(publisher);\n    })\n    .catch(error =\n {\n      console.log(\nThere was an error connecting to the session:\n, error.code, error.message);\n    });\n});\n\n\n\n\nWe simply need to call \nsession.connect\n passing the recently retrieved token from OpenVidu Server. This method returns a Promise to which you can subscribe to.\n\n\nIn case of success we first set the view to the active video session. Then we proceed to publish our webcam. To do so we just get a \npublisher\n using \nOpenVidu.initPublisher\n method, and a new HTML video showing our webcam will be appended to the page inside element with id \n\"publisher\"\n.\n\n\nLast but not least, we publish this \npublisher\n object thanks to \nsession.publish\n. At this point the rest of users connected to this session will trigger their own \nstreamCreated\n event and can start watching our webcam.\n\n\n\n\nLeaving the session:\n\n\nsession.disconnect();\n\n\n\n\nWhenever we want a user to leave the session, we just need to call \nsession.disconnect\n method. Here it will be called inside \nleaveSession\n function, triggered when the user clicks on \"LEAVE\" button. This function also returns the page to the \"Join session\" view.", 
            "title": "openvidu-hello-world"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#openvidu-hello-world", 
            "text": "Check it on GitHub  This is the simplest demo you can try to get started with OpenVidu API. It has the minimum set of features to make a group video-call. You will only need a few minutes to get your first application working!", 
            "title": "openvidu-hello-world"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need an http web server installed in your development computer to execute the tutorial. If you have  node.js  installed, you can use  http-server  to serve application files. It can be installed with:  npm install -g http-server  3) Run the tutorial:  http-server openvidu-tutorials/openvidu-hello-world/web  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  localhost:8080  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#understanding-the-code", 
            "text": "This application is very simple. It has only 4 files:   openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file.   app.js : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js .  style.css : some CSS classes to style  index.html .  index.html : HTML code for the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:    \n   script src=\"openvidu-browser-VERSION.js\" /script  script src=\"app.js\" /script   Let's see how  app.js  uses  openvidu-browser-VERSION.js :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#first-lines-declare-the-variables-that-will-be-needed-in-different-points-along-the-code", 
            "text": "var OV;\nvar session;  OV  will be our OpenVidu object (entrypoint to the libray).  session  will be the video-call we will connect to. As first sentence in the  joinSession()  method, we initialize the variable that will identify our video-call retrieving the value from the HTML input.  var mySessionId = document.getElementById( sessionId ).value;", 
            "title": "First lines declare the variables that will be needed in different points along the code"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#initialize-a-new-session-and-its-events", 
            "text": "OV = new OpenVidu();\nsession = OV.initSession();\n\nsession.on('streamCreated', function (event) {\n  session.subscribe(event.stream, 'subscriber');\n});  As you can see in the code, the process is very simple: get an OpenVidu object and initialize a Session object with it.  Then you can subscribe to all the events you want for your session. In this case we just want to subscribe to every stream that is being created in the session: on  streamCreated  we subscribe to the specific stream, available at  event.stream  property.   You can take a look at all the events in the  Reference Documentation", 
            "title": "Initialize a new session and its events"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#get-a-token-from-openvidu-server", 
            "text": "WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session.  This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server   getToken(mySessionId).then(token =  {\n    // See next point to see how to connect to the session using 'token'\n});  Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the  REST API ,  OpenVidu Java Client  or  OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method  getToken()  that returns a Promise with the token. Without going into too much detail, this method performs two  ajax  requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:   First ajax request performs a POST to  /api/sessions  (we send a  customSessionId  field to name the session with our  mySessionId  value retrieved from HTML input)  Second ajax request performs a POST to  /api/tokens  (we send a  session  field to assign the token to this same session)   You can inspect this method in detail in the  GitHub repo .", 
            "title": "Get a token from OpenVidu Server"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#connect-to-the-session-using-the-token", 
            "text": "getToken(mySessionId).then(token =  {\n\n  session.connect(token)\n    .then(() =  {\n      document.getElementById( session-header ).innerText = mySessionId;\n      document.getElementById( join ).style.display =  none ;\n      document.getElementById( session ).style.display =  block ;\n\n      var publisher = OV.initPublisher( publisher );\n      session.publish(publisher);\n    })\n    .catch(error =  {\n      console.log( There was an error connecting to the session: , error.code, error.message);\n    });\n});  We simply need to call  session.connect  passing the recently retrieved token from OpenVidu Server. This method returns a Promise to which you can subscribe to.  In case of success we first set the view to the active video session. Then we proceed to publish our webcam. To do so we just get a  publisher  using  OpenVidu.initPublisher  method, and a new HTML video showing our webcam will be appended to the page inside element with id  \"publisher\" .  Last but not least, we publish this  publisher  object thanks to  session.publish . At this point the rest of users connected to this session will trigger their own  streamCreated  event and can start watching our webcam.", 
            "title": "Connect to the session using the token"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#leaving-the-session", 
            "text": "session.disconnect();  Whenever we want a user to leave the session, we just need to call  session.disconnect  method. Here it will be called inside  leaveSession  function, triggered when the user clicks on \"LEAVE\" button. This function also returns the page to the \"Join session\" view.", 
            "title": "Leaving the session:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/", 
            "text": "openvidu-insecure-js\n\n\n Check it on GitHub\n\n\nA client-side only application built with JavaScript, HTML and CSS.\n\n\nIf it is the first time you use OpenVidu, it is higly recommended to start with \nopenvidu-hello-world\n tutorial, as this app is no more than an extension of it with some new features and sytles.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flows transmission\n\n\n\n\n\n    \n\n\n\n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.\n\n\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need an http web server installed in your development computer to execute the sample application. If you have \nnode.js\n installed, you can use \nhttp-server\n to serve application files. It can be installed with:\n\n\nnpm install -g http-server\n\n\n\n\n3) Run the tutorial:\n\n\nhttp-server openvidu-tutorials/openvidu-insecure-js/web\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nlocalhost:8080\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis application is very simple. It has only 4 files:\n\n\n\n\nopenvidu-browser-VERSION.js\n: openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n: sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n. You can manipulate this file to suit your needs.\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n. You can manipulate this file to suit your needs.\n\n\nindex.html\n: HTML code for the form to connect to a video-call and for the video-call itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files: \n\n\n\n\n\n    \nscript src=\"openvidu-browser-VERSION.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\nLet's see how \napp.js\n uses \nopenvidu-browser-VERSION.js\n:\n\n\n\n\nFirst lines declare the variables that will be needed in different points along the code\n\n\nvar OV;\nvar session;\n\n\n\n\nOV\n will be our OpenVidu object (entrypoint to the libray). \nsession\n will be the video-call we will connect to. As first sentences in the join method, we initialize the two parameters whose value is retrieved from the HTML inputs.\n\n\nvar mySessionId = document.getElementById(\nsessionId\n).value;   // Session the user will join\nvar myUserName = document.getElementById(\nuserName\n).value;     // Nickname of the user in the session\n\n\n\n\n\n\nLet's initialize a new session and configure our events:\n\n\n// --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n\n\n\nAs you can see in the code, the process is very simple: get an OpenVidu object and initialize a Session object with it.\n\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', event =\n {\n\n    // Subscribe to the Stream to receive it. HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', event =\n {\n\n        // Add a new \np\n element for the user's nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', event =\n {\n\n    // Delete the HTML element with the user's nickname. HTML videos are automatically removed from DOM\n    removeUserData(event.stream.connection);\n});\n\n\n\n\nHere we subscribe to the events that interest us. In this case, we want to receive all videos published to the session, as well as displaying every user's nickname next to its video. To achieve this:\n\n\n\n\n\n\nstreamCreated\n: for each new Stream received by OpenVidu, we immediately subscribe to it so we can see its video. A new HTML video element will be appended to element with id 'video-container'.\n\n\n\n\n\n\nvideoElementCreated\n: event triggered by Subscriber object (returned by the previous \nSession.subscribe\n method). This allows us to add the participant nickname to the new video previously added in \nstreamCreated\n event. Auxiliary method \nappendUserData\n is responsible for appending a new paragraph element just below the \nevent.element\n video, containing \nsubscriber.stream.connection.data\n field. In this case, this field contains the user's nickName. You can see how to feed this property from the client in a later step.\n\n\n\n\n\n\nstreamDestroyed\n: for each Stream that has been destroyed (which means a user has left the video-call), we remove the element with the user's nickname that we added in the previous event with the auxiliary method \nremoveUserData\n (\nappendUserData\n method created the element with an \nid\n containing \nevent.stream.connection.connectionId\n unique value, so we can now identify the right element to be removed). OpenVidu automatically deletes the proper video element by default, so we don't need to do anything else.\n\n\n\n\n\n\n\n\nCheck \nApplication specific methods\n section to see all the auxiliary methods used in this app\n\n\n\n\n\n\nGet a \ntoken\n from OpenVidu Server\n\n\n\n    \n\n\n\n    \nWARNING\n: This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. \nThis process should entirely take place in our server-side\n, not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server\n\n\n\n\n\n\n// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\ngetToken(mySessionId).then(token =\n {\n    // See next point to see how to connect to the session using 'token'\n});\n\n\n\n\nNow we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the \nREST API\n, \nOpenVidu Java Client\n or \nOpenVidu Node Client\n. Here we have implemented the POST requests to OpenVidu Server in a method \ngetToken()\n that returns a Promise with the token. Without going into too much detail, this method performs two \najax\n requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:\n\n\n\n\nFirst ajax request performs a POST to \n/api/sessions\n (we send a \ncustomSessionId\n field to name the session with our \nmySessionId\n value retrieved from HTML input)\n\n\nSecond ajax request performs a POST to \n/api/tokens\n (we send a \nsession\n field to assign the token to this same session)\n\n\n\n\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\n\n\nFinally connect to the session using the token and publish your webcam:\n\n\n// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\ngetToken(mySessionId).then(token =\n {\n\n    // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event\n    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n    session.connect(token, { clientData: myUserName })\n        .then(() =\n {\n\n            // --- 5) Set page layout for active call ---\n\n            document.getElementById('session-title').innerText = mySessionId;\n            document.getElementById('join').style.display = 'none';\n            document.getElementById('session').style.display = 'block';\n\n            // --- 6) Get your own camera stream with the desired properties ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                initMainVideo(event.element, myUserName);\n                appendUserData(event.element, myUserName);\n                event.element['muted'] = true;\n            });\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        })\n        .catch(error =\n {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        });\n});\n\n\n\n\nIn \nsession.connect\n method first param is the recently retrieved user token. Remember \nvideoElementCreated\n event for the Subscriber object, when we added the user's nickname to the HTML? Well, second parameter is the actual value every user will receive in \nStream.connection.data\n property in that event. So in this case it is an object with a property \"clientData\" with value \"myUserName\", which has been set in the first step to the value retrieved from HTML input \ninput class=\"form-control\" type=\"text\" id=\"userName\" required\n (this is filled by the user).\n\n\nIf the method succeeds, we first change our view to the active call (5) and then proceed to publish our webcam to the session. To do so we get a \nPublisher\n object with the desired properties (6). This process will end with the addition of a new HTML video element showing your camera, as a child of element with \nid\n 'video-container'. Event \nvideoElementCreated\n will be fired by the Publisher object just after this video is added to DOM, so we can subscribe to it and do whatever we want with it. In this case, we init another bigger video element with our video and append our nickname to it, by using auxiliary methods \ninitMainVideo\n and \nappendUserData\n (7).\n\n\nFinally we just have to publish \npublisher\n object through \nSession.publish\n method (8), and the rest of users will begin receiving our webcam ('streamCreated' event will be fired for them).\n\n\n\n\nLeaving the session:\n\n\nWhenever we want a user to leave the session, we just need to call \nsession.disconnect\n method:\n\n\nfunction leaveSession() {\n\n    // --- 9) Leave the session by calling 'disconnect' method over the Session object ---\n\n    session.disconnect();\n\n    // Removing all HTML elements with user's nicknames. \n    // HTML videos are automatically removed when leaving a Session\n    removeAllUserData();\n\n    // Back to 'Join session' page\n    document.getElementById('join').style.display = 'block';\n    document.getElementById('session').style.display = 'none';\n}\n\n\n\n\n\n\nApplication specific methods\n\n\nHere you have all the auxiliary methods used in this app, which are not directly related to OpenVidu:\n\n\n/* APPLICATION SPECIFIC METHODS */\n\nwindow.addEventListener('load', function () {\n    generateParticipantInfo();\n});\n\nwindow.onbeforeunload = function () {\n    if (session) session.disconnect();\n};\n\nfunction generateParticipantInfo() {\n    document.getElementById(\nsessionId\n).value = \nSessionA\n;\n    document.getElementById(\nuserName\n).value = \nParticipant\n + Math.floor(Math.random() * 100);\n}\n\nfunction appendUserData(videoElement, connection) {\n    var userData;\n    var nodeId;\n    if (typeof connection === \nstring\n) {\n        userData = connection;\n        nodeId = connection;\n    } else {\n        userData = JSON.parse(connection.data).clientData;\n        nodeId = connection.connectionId;\n    }\n    var dataNode = document.createElement('div');\n    dataNode.className = \ndata-node\n;\n    dataNode.id = \ndata-\n + nodeId;\n    dataNode.innerHTML = \np\n + userData + \n/p\n;\n    videoElement.parentNode.insertBefore(dataNode, videoElement.nextSibling);\n    addClickListener(videoElement, userData);\n}\n\nfunction removeUserData(connection) {\n    var dataNode = document.getElementById(\ndata-\n + connection.connectionId);\n    dataNode.parentNode.removeChild(dataNode);\n}\n\nfunction removeAllUserData() {\n    var nicknameElements = document.getElementsByClassName('data-node');\n    while (nicknameElements[0]) {\n        nicknameElements[0].parentNode.removeChild(nicknameElements[0]);\n    }\n}\n\nfunction addClickListener(videoElement, userData) {\n    videoElement.addEventListener('click', function () {\n        var mainVideo = document.querySelector('#main-video video');\n        var mainUserData = document.querySelector('#main-video p');\n        if (mainVideo.srcObject !== videoElement.srcObject) {\n            mainUserData.innerHTML = userData;\n            mainVideo.srcObject = videoElement.srcObject;\n        }\n    });\n}\n\nfunction initMainVideo(videoElement, userData) {\n    document.querySelector('#main-video video').srcObject = videoElement.srcObject;\n    document.querySelector('#main-video p').innerHTML = userData;\n    document.querySelector('#main-video video')['muted'] = true;\n}\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-insecure-js"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#openvidu-insecure-js", 
            "text": "Check it on GitHub  A client-side only application built with JavaScript, HTML and CSS.  If it is the first time you use OpenVidu, it is higly recommended to start with  openvidu-hello-world  tutorial, as this app is no more than an extension of it with some new features and sytles.", 
            "title": "openvidu-insecure-js"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flows transmission   \n      \n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need an http web server installed in your development computer to execute the sample application. If you have  node.js  installed, you can use  http-server  to serve application files. It can be installed with:  npm install -g http-server  3) Run the tutorial:  http-server openvidu-tutorials/openvidu-insecure-js/web  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  localhost:8080  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#understanding-the-code", 
            "text": "This application is very simple. It has only 4 files:   openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file.   app.js : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js . You can manipulate this file to suit your needs.  style.css : some CSS classes to style  index.html . You can manipulate this file to suit your needs.  index.html : HTML code for the form to connect to a video-call and for the video-call itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files:    \n     script src=\"openvidu-browser-VERSION.js\" /script  script src=\"app.js\" /script   Let's see how  app.js  uses  openvidu-browser-VERSION.js :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#first-lines-declare-the-variables-that-will-be-needed-in-different-points-along-the-code", 
            "text": "var OV;\nvar session;  OV  will be our OpenVidu object (entrypoint to the libray).  session  will be the video-call we will connect to. As first sentences in the join method, we initialize the two parameters whose value is retrieved from the HTML inputs.  var mySessionId = document.getElementById( sessionId ).value;   // Session the user will join\nvar myUserName = document.getElementById( userName ).value;     // Nickname of the user in the session", 
            "title": "First lines declare the variables that will be needed in different points along the code"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#lets-initialize-a-new-session-and-configure-our-events", 
            "text": "// --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();  As you can see in the code, the process is very simple: get an OpenVidu object and initialize a Session object with it.  // --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', event =  {\n\n    // Subscribe to the Stream to receive it. HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', event =  {\n\n        // Add a new  p  element for the user's nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', event =  {\n\n    // Delete the HTML element with the user's nickname. HTML videos are automatically removed from DOM\n    removeUserData(event.stream.connection);\n});  Here we subscribe to the events that interest us. In this case, we want to receive all videos published to the session, as well as displaying every user's nickname next to its video. To achieve this:    streamCreated : for each new Stream received by OpenVidu, we immediately subscribe to it so we can see its video. A new HTML video element will be appended to element with id 'video-container'.    videoElementCreated : event triggered by Subscriber object (returned by the previous  Session.subscribe  method). This allows us to add the participant nickname to the new video previously added in  streamCreated  event. Auxiliary method  appendUserData  is responsible for appending a new paragraph element just below the  event.element  video, containing  subscriber.stream.connection.data  field. In this case, this field contains the user's nickName. You can see how to feed this property from the client in a later step.    streamDestroyed : for each Stream that has been destroyed (which means a user has left the video-call), we remove the element with the user's nickname that we added in the previous event with the auxiliary method  removeUserData  ( appendUserData  method created the element with an  id  containing  event.stream.connection.connectionId  unique value, so we can now identify the right element to be removed). OpenVidu automatically deletes the proper video element by default, so we don't need to do anything else.     Check  Application specific methods  section to see all the auxiliary methods used in this app", 
            "title": "Let's initialize a new session and configure our events:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#get-a-token-from-openvidu-server", 
            "text": "WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session.  This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server   // --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\ngetToken(mySessionId).then(token =  {\n    // See next point to see how to connect to the session using 'token'\n});  Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the  REST API ,  OpenVidu Java Client  or  OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method  getToken()  that returns a Promise with the token. Without going into too much detail, this method performs two  ajax  requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:   First ajax request performs a POST to  /api/sessions  (we send a  customSessionId  field to name the session with our  mySessionId  value retrieved from HTML input)  Second ajax request performs a POST to  /api/tokens  (we send a  session  field to assign the token to this same session)   You can inspect this method in detail in the  GitHub repo .", 
            "title": "Get a token from OpenVidu Server"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#finally-connect-to-the-session-using-the-token-and-publish-your-webcam", 
            "text": "// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\ngetToken(mySessionId).then(token =  {\n\n    // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event\n    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n    session.connect(token, { clientData: myUserName })\n        .then(() =  {\n\n            // --- 5) Set page layout for active call ---\n\n            document.getElementById('session-title').innerText = mySessionId;\n            document.getElementById('join').style.display = 'none';\n            document.getElementById('session').style.display = 'block';\n\n            // --- 6) Get your own camera stream with the desired properties ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                initMainVideo(event.element, myUserName);\n                appendUserData(event.element, myUserName);\n                event.element['muted'] = true;\n            });\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        })\n        .catch(error =  {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        });\n});  In  session.connect  method first param is the recently retrieved user token. Remember  videoElementCreated  event for the Subscriber object, when we added the user's nickname to the HTML? Well, second parameter is the actual value every user will receive in  Stream.connection.data  property in that event. So in this case it is an object with a property \"clientData\" with value \"myUserName\", which has been set in the first step to the value retrieved from HTML input  input class=\"form-control\" type=\"text\" id=\"userName\" required  (this is filled by the user).  If the method succeeds, we first change our view to the active call (5) and then proceed to publish our webcam to the session. To do so we get a  Publisher  object with the desired properties (6). This process will end with the addition of a new HTML video element showing your camera, as a child of element with  id  'video-container'. Event  videoElementCreated  will be fired by the Publisher object just after this video is added to DOM, so we can subscribe to it and do whatever we want with it. In this case, we init another bigger video element with our video and append our nickname to it, by using auxiliary methods  initMainVideo  and  appendUserData  (7).  Finally we just have to publish  publisher  object through  Session.publish  method (8), and the rest of users will begin receiving our webcam ('streamCreated' event will be fired for them).", 
            "title": "Finally connect to the session using the token and publish your webcam:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#leaving-the-session", 
            "text": "Whenever we want a user to leave the session, we just need to call  session.disconnect  method:  function leaveSession() {\n\n    // --- 9) Leave the session by calling 'disconnect' method over the Session object ---\n\n    session.disconnect();\n\n    // Removing all HTML elements with user's nicknames. \n    // HTML videos are automatically removed when leaving a Session\n    removeAllUserData();\n\n    // Back to 'Join session' page\n    document.getElementById('join').style.display = 'block';\n    document.getElementById('session').style.display = 'none';\n}", 
            "title": "Leaving the session:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#application-specific-methods", 
            "text": "Here you have all the auxiliary methods used in this app, which are not directly related to OpenVidu:  /* APPLICATION SPECIFIC METHODS */\n\nwindow.addEventListener('load', function () {\n    generateParticipantInfo();\n});\n\nwindow.onbeforeunload = function () {\n    if (session) session.disconnect();\n};\n\nfunction generateParticipantInfo() {\n    document.getElementById( sessionId ).value =  SessionA ;\n    document.getElementById( userName ).value =  Participant  + Math.floor(Math.random() * 100);\n}\n\nfunction appendUserData(videoElement, connection) {\n    var userData;\n    var nodeId;\n    if (typeof connection ===  string ) {\n        userData = connection;\n        nodeId = connection;\n    } else {\n        userData = JSON.parse(connection.data).clientData;\n        nodeId = connection.connectionId;\n    }\n    var dataNode = document.createElement('div');\n    dataNode.className =  data-node ;\n    dataNode.id =  data-  + nodeId;\n    dataNode.innerHTML =  p  + userData +  /p ;\n    videoElement.parentNode.insertBefore(dataNode, videoElement.nextSibling);\n    addClickListener(videoElement, userData);\n}\n\nfunction removeUserData(connection) {\n    var dataNode = document.getElementById( data-  + connection.connectionId);\n    dataNode.parentNode.removeChild(dataNode);\n}\n\nfunction removeAllUserData() {\n    var nicknameElements = document.getElementsByClassName('data-node');\n    while (nicknameElements[0]) {\n        nicknameElements[0].parentNode.removeChild(nicknameElements[0]);\n    }\n}\n\nfunction addClickListener(videoElement, userData) {\n    videoElement.addEventListener('click', function () {\n        var mainVideo = document.querySelector('#main-video video');\n        var mainUserData = document.querySelector('#main-video p');\n        if (mainVideo.srcObject !== videoElement.srcObject) {\n            mainUserData.innerHTML = userData;\n            mainVideo.srcObject = videoElement.srcObject;\n        }\n    });\n}\n\nfunction initMainVideo(videoElement, userData) {\n    document.querySelector('#main-video video').srcObject = videoElement.srcObject;\n    document.querySelector('#main-video p').innerHTML = userData;\n    document.querySelector('#main-video video')['muted'] = true;\n}    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Application specific methods"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/", 
            "text": "openvidu-insecure-angular\n\n\n Check it on GitHub\n\n\nA client-side only application built with \nAngular 7\n framework.\n\n\nIf it is the first time you use OpenVidu, it is higly recommended to start with \nopenvidu-hello-world\n tutorial, as this app is no more than an extension of it with some new features and sytles.\n\n\nThis is the Angular version of \nopenvidu-insecure-js\n. Try it if you plan to use Angular framework for your frontend.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n    \n\n\n\n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.\n\n\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need angular-cli (and of course NPM) to serve the Angular frontend. You can install it with the following command:\n\n\nnpm install -g @angular/cli@6.2.4\n\n\n\n\n3) Run the tutorial:\n\n\ncd openvidu-tutorials/openvidu-insecure-angular\nnpm install\nng serve\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nlocalhost:4200\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is an Angular project generated with angular-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under \nsrc/app/\n folder:\n\n\n\n\napp.component.ts\n: defines \nAppComponent\n, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.\n\n\napp.component.html\n: HTML for AppComponent.\n\n\napp.component.css\n: CSS for AppComponent.\n\n\nuser-video.component.ts\n: defines \nUserVideoComponent\n, used to display every user video. It contains one \nOpenViduVideoComponent\n, the name of the user and also handles a click event to update the view of \nAppComponent\n.\n\n\nov-video.component.ts\n: defines \nOpenViduVideoComponent\n, which wraps the final HTML \nvideo\n that finally displays the media stream.\n\n\n\n\nLet's see first how \napp.component.ts\n uses NPM package \nopenvidu-browser\n:\n\n\n\n\nWe import the necessary objects from \nopenvidu-browser\n:\n\n\nimport { OpenVidu, Publisher, Session, StreamEvent, StreamManager, Subscriber } from 'openvidu-browser';\n\n\n\n\n\n\napp.component.ts\n declares the following properties:\n\n\n// OpenVidu objects\nOV: OpenVidu;\nsession: Session;\npublisher: StreamManager; // Local\nsubscribers: StreamManager[] = []; // Remotes\n\n// Join form\nmySessionId: string;\nmyUserName: string;\n\n// Main video of the page, will be 'publisher' or one of the 'subscribers',\n// updated by click event in UserVideoComponent children\nmainStreamManager: StreamManager;\n\n\n\n\nOpenVidu\n object will allow us to get a \nSession\n object, which is declared just after it. \npublisher\n StreamManager object will be our own local webcam stream and \nsubscribers\n StreamManager array will store the active streams of other users in the video-call. Finally, \nmySessionId\n and \nmyUserName\n params simply represent the video-call and your participant's nickname, as you will see in a moment.\n\n\n\n\nWhenever a user clicks on the submit input defined in \napp.component.html\n, \njoinSession()\n method is called:\n\n\n\n\nWe first get an OpenVidu object and initialize a Session object with it.\n\n\n// --- 1) Get an OpenVidu object ---\n\nthis.OV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nthis.session = this.OV.initSession();\n\n\n\n\nThen we subscribe to the Session events that interest us.\n\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nthis.session.on('streamCreated', (event: StreamEvent) =\n {\n\n    // Subscribe to the Stream to receive it. Second parameter is undefined\n    // so OpenVidu doesn't create an HTML video by its own\n    let subscriber: Subscriber = this.session.subscribe(event.stream, undefined);\n    this.subscribers.push(subscriber);\n});\n\n// On every Stream destroyed...\nthis.session.on('streamDestroyed', (event: StreamEvent) =\n {\n\n    // Remove the stream from 'subscribers' array\n    this.deleteSubscriber(event.stream.streamManager);\n});\n\n\n\n\nAs we are using Angular framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each \nSubscriber\n object and let it manage its video. This component will be our \nUserVideoComponent\n. To do this, we need to store each new Subscriber we received in array \nsubscribers\n (of the parent class \nStreamManager\n), and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events:\n\n\n\n\n\n\nstreamCreated\n: for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our \nsubscribers\n array. Method \nsession.subscribe\n has \nundefined\n as second parameter so OpenVidu doesn't insert and HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of \nAppComponent\n loops through \nsubscribers\n array with an \nngFor\n directive, declaring a \nUserVideoComponent\n for each subscriber. We feed them not really as \nSubscriber\n objects, but rather as their parent class \nStreamManager\n. This way we can reuse \nUserVideoComponent\n to also display our \nPublisher\n object (that also inhertis from class StreamManager). \nuser-video\n also declares the \nclick\n event so we can update the main video player view when the user clicks on its Publisher or any Subscriber videos.\n\n\ndiv *ngFor=\"let sub of subscribers\" class=\"stream-container col-md-6 col-xs-6\"\n\n    \nuser-video [streamManager]=\"sub\" (click)=\"updateMainStreamManager(sub)\"\n/user-video\n\n\n/div\n\n\n\n\n\n\n\n\nstreamDestroyed\n: for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from \nsubscribers\n array, so Angular will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property \nstreamManager\n that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).\n\n\n\n\n\n\n\n\nGet a \ntoken\n from OpenVidu Server\n\n\n\n    \n\n\n\n    \nWARNING\n: This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. \nThis process should entirely take place in our server-side\n, not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server\n\n\n\n\n\n\n// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then(token =\n {\n    // See next point to see how to connect to the session using 'token'\n});\n\n\n\n\nNow we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the \nREST API\n, \nOpenVidu Java Client\n or \nOpenVidu Node Client\n. Here we have implemented the POST requests to OpenVidu Server in a method \ngetToken()\n that returns a Promise with the token, using \n@angular/http\n library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:\n\n\n\n\nFirst request performs a POST to \n/api/sessions\n (we send a \ncustomSessionId\n field to name the session with our \nmySessionId\n value retrieved from HTML input)\n\n\nSecond request performs a POST to \n/api/tokens\n (we send a \nsession\n field to assign the token to this same session)\n\n\n\n\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\n\n\nFinally connect to the session and publish your webcam:\n\n\n // --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then(token =\n {\n\n    // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event\n    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n    this.session.connect(token, { clientData: this.myUserName })\n        .then(() =\n {\n\n            // --- 5) Get your own camera stream ---\n\n            // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video\n            // element: we will manage it on our own) and with the desired properties\n            let publisher: Publisher = this.OV.initPublisher(undefined, {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 6) Publish your stream ---\n\n            this.session.publish(publisher);\n\n            // Set the main video in the page to display our webcam and store our Publisher\n            this.mainStreamManager = publisher;\n            this.publisher = publisher;\n        })\n        .catch(error =\n {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        });\n});\n\n\n\n\nIn \nsession.connect\n method first param is the recently retrieved user token. Second param is the value every user will receive in \nevent.stream.connection.data\n property on \nstreamCreated\n event (this value will be used by \nUserVideoComponent\n to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input \ninput class=\"form-control\" type=\"text\" id=\"userName\" name=\"userName\" [(ngModel)]=\"myUserName\" required\n (filled by the user).\n\n\nIf the method succeeds, we proceed to publish our webcam to the session. To do so we get a \nPublisher\n object with the desired properties and publish it to the Session through \nSession.publish()\n method. The rest of users will receive our Stream object and will execute their \nstreamCreated\n event. Finally we make the main video player (which is just another \nUserVideoComponent\n) display the Publisher object by default. This is the HTML code that will display the main stream manager:\n\n\ndiv *ngIf=\nmainStreamManager\n id=\nmain-video\n class=\ncol-md-6\n\n    \nuser-video [streamManager]=\nmainStreamManager\n/user-video\n\n\n/div\n\n\n\n\n\nAnd we store the Publisher under \nthis.publisher\n, which is also of parent class \nStreamManager\n. This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by \nUserVideoComponent\n):\n\n\ndiv *ngIf=\npublisher\n class=\nstream-container col-md-6 col-xs-6\n\n    \nuser-video [streamManager]=\npublisher\n (click)=\nupdateMainStreamManager(publisher)\n/user-video\n\n\n/div\n\n\n\n\n\nYou can see that every \nuser-video\n component for our Publisher and every Subscriber also updates the main video player when clicking on it.\n\n\nLast point worth considering is the implementation of \nUserVideoComponent\n and \nOpenViduVideoComponent\n. Each \nUserVideoComponent\n manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component \nOpenViduVideoComponent\n. Its main task is not managing the final video player (that is \nOpenViduVideoComponent\n responsibility), but displaying custom information for each one of them (the user's nickname in this case):\n\n\ndiv\n\n    \nov-video [streamManager]=\nstreamManager\n/ov-video\n\n    \ndiv\np\n{% raw %}{{getNicknameTag()}}{% endraw %}\n/p\n/div\n\n\n/div\n\n\n\n\n\nexport class UserVideoComponent {\n\n    @Input()\n    streamManager: StreamManager;\n\n    getNicknameTag() { // Gets the nickName of the user\n        return JSON.parse(this.streamManager.stream.connection.data).clientData;\n    }\n}\n\n\n\n\nOpenViduVideoComponent\n html template is just the video element:\n\n\nvideo #videoElement\n/video\n\n\n\n\n\nAnd the unique responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method \nStreamManager.addVideoElement\n, which receives a native HTML video element. The way we implement this is Angular dependant: we get the video element with \n@ViewChild\n tag and we call the method once after the view has initialized (\nngAfterViewInit\n) and once every time the StreamManager input changes (\nset\n method with \n@Input\n tag)\n\n\nexport class OpenViduVideoComponent implements AfterViewInit {\n\n    @ViewChild('videoElement') elementRef: ElementRef;\n\n    _streamManager: StreamManager;\n\n    ngAfterViewInit() {\n        this._streamManager.addVideoElement(this.elementRef.nativeElement);\n    }\n\n    @Input()\n    set streamManager(streamManager: StreamManager) {\n        this._streamManager = streamManager;\n        if (!!this.elementRef) {\n            this._streamManager.addVideoElement(this.elementRef.nativeElement);\n        }\n    }\n}\n\n\n\n\n\n\nLeaving the session:\n\n\nWhenever we want a user to leave the session, we just need to call \nsession.disconnect\n method in \napp.component.ts\n:\n\n\n  leaveSession() {\n\n    // --- 7) Leave the session by calling 'disconnect' method over the Session object ---\n\n    if (this.session) { this.session.disconnect(); };\n\n    // Empty all properties...\n    this.subscribers = [];\n    delete this.publisher;\n    delete this.session;\n    delete this.OV;\n    this.generateParticipantInfo();\n  }\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-insecure-angular"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#openvidu-insecure-angular", 
            "text": "Check it on GitHub  A client-side only application built with  Angular 7  framework.  If it is the first time you use OpenVidu, it is higly recommended to start with  openvidu-hello-world  tutorial, as this app is no more than an extension of it with some new features and sytles.  This is the Angular version of  openvidu-insecure-js . Try it if you plan to use Angular framework for your frontend.", 
            "title": "openvidu-insecure-angular"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions   \n      \n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need angular-cli (and of course NPM) to serve the Angular frontend. You can install it with the following command:  npm install -g @angular/cli@6.2.4  3) Run the tutorial:  cd openvidu-tutorials/openvidu-insecure-angular\nnpm install\nng serve  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  localhost:4200  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#understanding-the-code", 
            "text": "This is an Angular project generated with angular-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under  src/app/  folder:   app.component.ts : defines  AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.  app.component.html : HTML for AppComponent.  app.component.css : CSS for AppComponent.  user-video.component.ts : defines  UserVideoComponent , used to display every user video. It contains one  OpenViduVideoComponent , the name of the user and also handles a click event to update the view of  AppComponent .  ov-video.component.ts : defines  OpenViduVideoComponent , which wraps the final HTML  video  that finally displays the media stream.   Let's see first how  app.component.ts  uses NPM package  openvidu-browser :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#we-import-the-necessary-objects-from-openvidu-browser", 
            "text": "import { OpenVidu, Publisher, Session, StreamEvent, StreamManager, Subscriber } from 'openvidu-browser';", 
            "title": "We import the necessary objects from openvidu-browser:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#appcomponentts-declares-the-following-properties", 
            "text": "// OpenVidu objects\nOV: OpenVidu;\nsession: Session;\npublisher: StreamManager; // Local\nsubscribers: StreamManager[] = []; // Remotes\n\n// Join form\nmySessionId: string;\nmyUserName: string;\n\n// Main video of the page, will be 'publisher' or one of the 'subscribers',\n// updated by click event in UserVideoComponent children\nmainStreamManager: StreamManager;  OpenVidu  object will allow us to get a  Session  object, which is declared just after it.  publisher  StreamManager object will be our own local webcam stream and  subscribers  StreamManager array will store the active streams of other users in the video-call. Finally,  mySessionId  and  myUserName  params simply represent the video-call and your participant's nickname, as you will see in a moment.", 
            "title": "app.component.ts declares the following properties:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#whenever-a-user-clicks-on-the-submit-input-defined-in-appcomponenthtml-joinsession-method-is-called", 
            "text": "We first get an OpenVidu object and initialize a Session object with it.  // --- 1) Get an OpenVidu object ---\n\nthis.OV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nthis.session = this.OV.initSession();  Then we subscribe to the Session events that interest us.  // --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nthis.session.on('streamCreated', (event: StreamEvent) =  {\n\n    // Subscribe to the Stream to receive it. Second parameter is undefined\n    // so OpenVidu doesn't create an HTML video by its own\n    let subscriber: Subscriber = this.session.subscribe(event.stream, undefined);\n    this.subscribers.push(subscriber);\n});\n\n// On every Stream destroyed...\nthis.session.on('streamDestroyed', (event: StreamEvent) =  {\n\n    // Remove the stream from 'subscribers' array\n    this.deleteSubscriber(event.stream.streamManager);\n});  As we are using Angular framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each  Subscriber  object and let it manage its video. This component will be our  UserVideoComponent . To do this, we need to store each new Subscriber we received in array  subscribers  (of the parent class  StreamManager ), and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events:    streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our  subscribers  array. Method  session.subscribe  has  undefined  as second parameter so OpenVidu doesn't insert and HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of  AppComponent  loops through  subscribers  array with an  ngFor  directive, declaring a  UserVideoComponent  for each subscriber. We feed them not really as  Subscriber  objects, but rather as their parent class  StreamManager . This way we can reuse  UserVideoComponent  to also display our  Publisher  object (that also inhertis from class StreamManager).  user-video  also declares the  click  event so we can update the main video player view when the user clicks on its Publisher or any Subscriber videos.  div *ngFor=\"let sub of subscribers\" class=\"stream-container col-md-6 col-xs-6\" \n     user-video [streamManager]=\"sub\" (click)=\"updateMainStreamManager(sub)\" /user-video  /div     streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from  subscribers  array, so Angular will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property  streamManager  that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).", 
            "title": "Whenever a user clicks on the submit input defined in app.component.html, joinSession() method is called:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#get-a-token-from-openvidu-server", 
            "text": "WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session.  This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server   // --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then(token =  {\n    // See next point to see how to connect to the session using 'token'\n});  Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the  REST API ,  OpenVidu Java Client  or  OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method  getToken()  that returns a Promise with the token, using  @angular/http  library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:   First request performs a POST to  /api/sessions  (we send a  customSessionId  field to name the session with our  mySessionId  value retrieved from HTML input)  Second request performs a POST to  /api/tokens  (we send a  session  field to assign the token to this same session)   You can inspect this method in detail in the  GitHub repo .", 
            "title": "Get a token from OpenVidu Server"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#finally-connect-to-the-session-and-publish-your-webcam", 
            "text": "// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then(token =  {\n\n    // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event\n    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n    this.session.connect(token, { clientData: this.myUserName })\n        .then(() =  {\n\n            // --- 5) Get your own camera stream ---\n\n            // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video\n            // element: we will manage it on our own) and with the desired properties\n            let publisher: Publisher = this.OV.initPublisher(undefined, {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 6) Publish your stream ---\n\n            this.session.publish(publisher);\n\n            // Set the main video in the page to display our webcam and store our Publisher\n            this.mainStreamManager = publisher;\n            this.publisher = publisher;\n        })\n        .catch(error =  {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        });\n});  In  session.connect  method first param is the recently retrieved user token. Second param is the value every user will receive in  event.stream.connection.data  property on  streamCreated  event (this value will be used by  UserVideoComponent  to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input  input class=\"form-control\" type=\"text\" id=\"userName\" name=\"userName\" [(ngModel)]=\"myUserName\" required  (filled by the user).  If the method succeeds, we proceed to publish our webcam to the session. To do so we get a  Publisher  object with the desired properties and publish it to the Session through  Session.publish()  method. The rest of users will receive our Stream object and will execute their  streamCreated  event. Finally we make the main video player (which is just another  UserVideoComponent ) display the Publisher object by default. This is the HTML code that will display the main stream manager:  div *ngIf= mainStreamManager  id= main-video  class= col-md-6 \n     user-video [streamManager]= mainStreamManager /user-video  /div   And we store the Publisher under  this.publisher , which is also of parent class  StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by  UserVideoComponent ):  div *ngIf= publisher  class= stream-container col-md-6 col-xs-6 \n     user-video [streamManager]= publisher  (click)= updateMainStreamManager(publisher) /user-video  /div   You can see that every  user-video  component for our Publisher and every Subscriber also updates the main video player when clicking on it.  Last point worth considering is the implementation of  UserVideoComponent  and  OpenViduVideoComponent . Each  UserVideoComponent  manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component  OpenViduVideoComponent . Its main task is not managing the final video player (that is  OpenViduVideoComponent  responsibility), but displaying custom information for each one of them (the user's nickname in this case):  div \n     ov-video [streamManager]= streamManager /ov-video \n     div p {% raw %}{{getNicknameTag()}}{% endraw %} /p /div  /div   export class UserVideoComponent {\n\n    @Input()\n    streamManager: StreamManager;\n\n    getNicknameTag() { // Gets the nickName of the user\n        return JSON.parse(this.streamManager.stream.connection.data).clientData;\n    }\n}  OpenViduVideoComponent  html template is just the video element:  video #videoElement /video   And the unique responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method  StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is Angular dependant: we get the video element with  @ViewChild  tag and we call the method once after the view has initialized ( ngAfterViewInit ) and once every time the StreamManager input changes ( set  method with  @Input  tag)  export class OpenViduVideoComponent implements AfterViewInit {\n\n    @ViewChild('videoElement') elementRef: ElementRef;\n\n    _streamManager: StreamManager;\n\n    ngAfterViewInit() {\n        this._streamManager.addVideoElement(this.elementRef.nativeElement);\n    }\n\n    @Input()\n    set streamManager(streamManager: StreamManager) {\n        this._streamManager = streamManager;\n        if (!!this.elementRef) {\n            this._streamManager.addVideoElement(this.elementRef.nativeElement);\n        }\n    }\n}", 
            "title": "Finally connect to the session and publish your webcam:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#leaving-the-session", 
            "text": "Whenever we want a user to leave the session, we just need to call  session.disconnect  method in  app.component.ts :    leaveSession() {\n\n    // --- 7) Leave the session by calling 'disconnect' method over the Session object ---\n\n    if (this.session) { this.session.disconnect(); };\n\n    // Empty all properties...\n    this.subscribers = [];\n    delete this.publisher;\n    delete this.session;\n    delete this.OV;\n    this.generateParticipantInfo();\n  }    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Leaving the session:"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/", 
            "text": "openvidu-library-angular\n\n\n Check it on GitHub\n\n\nOpenVidu Library Angular is one of the simplest and quickest tutorials to add videoconference capabilities to your existing web application. This tutorial uses \nopenvidu-angular\n library.\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need angular-cli (and of course NPM) to serve the Angular frontend. You can install it with the following command:\n\n\nnpm install -g @angular/cli@latest\n\n\n\n\n3) Run the tutorial:\n\n\ncd openvidu-tutorials/openvidu-library-angular\nnpm install\nng serve\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nlocalhost:4200\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a basic Angular project generated with angular-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under \nsrc/app/\n folder\n\n\n\n\napp.component.ts\n: defines \nAppComponent\n, main component of the app. It contains the functionalities for for handling the the events received from \nopenvidu-angular\n.\n\n\napp.component.html\n: HTML for AppComponent.\n\n\napp.component.css\n: CSS for AppComponent.\n\n\n\n\n\n\nWe must include these elements:\n\n\n1) First of all, obviously you have to install openvidu-angular:\n\n\nnpm install openvidu-angular --save\n\n\n\n\n2) \nAngular Material\n is included in openvidu-angular neverthelesst you need to include a theme style in your application. If you're using the Angular CLI, you can add this to your \nstyles.css\n:\n\n\n@import \n~@angular/material/prebuilt-themes/indigo-pink.css\n;\n\n\n\n\n3) Finally, you need to include \nJquery\n script, the \nglobal variable\n and \nMaterial icons font\n in the \nindex.html\n file:\n\n\nhead\n\n\n!--... other imports ...--\n\n  \nscript src=\nhttps://code.jquery.com/jquery-3.3.1.min.js\n integrity=\nsha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\n crossorigin=\nanonymous\n/script\n\n  \nscript\n\n      var global = global || window;\n  \n/script\n\n  \nlink href=\nhttps://fonts.googleapis.com/icon?family=Material+Icons\n rel=\nstylesheet\n\n\n/head\n\n\n\n\n\napp.module.ts\n\n\nInside of the \napp.module.ts\n you must import \nOpenviduSessionModule\n from \nopenvidu-angular\n:\n\n\nimport { OpenviduSessionModule } from 'openvidu-angular';\n\n\n\n\nMoreover, you need to include \nOpenviduSessionModule\n inside of \nimports\n section of \nNgModule\n:\n\n\nimports: [\n    BrowserModule,\n    FormsModule,\n    OpenviduSessionModule\n  ]\n\n\n\n\n\n\n\nConfiguring OpenVidu Angular\n\n\napp.component.html\n\n\nAs you can see here, you can use \nopv-session\n/opv-session\n component to embed openvidu session in your application in a very easy way. Our component will start hidden:\n\n\ndiv *ngIf=\n!session\n id=\njoin\n\n  \ndiv id=\njoin-dialog\n\n    \nh1\nJoin a video session\n/h1\n\n    \nform (submit)=\njoinSession()\n\n      \np\n\n        \nlabel\nParticipant \n/label\n\n        \ninput type=\ntext\n id=\nuserName\n name=\nuserName\n [(ngModel)]=\nmyUserName\n required\n\n      \n/p\n\n      \np\n\n        \nlabel\nSession \n/label\n\n        \ninput type=\ntext\n id=\nsessionId\n name=\nsessionId\n [(ngModel)]=\nmySessionId\n required\n\n      \n/p\n\n      \np class=\ntext-center\n\n        \ninput type=\nsubmit\n name=\ncommit\n value=\nJoin!\n\n      \n/p\n\n    \n/form\n\n  \n/div\n\n\n/div\n\n\n\ndiv *ngIf=\nsession\n id=\nsession\n\n    \nopv-session\n/opv-session\n\n\n/div\n\n\n\n\n\napp.component.ts\n\n\nMethod \njoinSession()\n gets the token which we provide to our component to connect to the session.\n\n\nYou can configure the opv-session with these parameters:\n\n\n\n\nsessionName\n: the session name that will be displayed inside the component\n\n\nuser\n: the nickname that the user will have in the session\n\n\ntoken\n: the retrieved token from OpenVidu Server\n\n\novSettings\n: the configuration that the user want to have on the session\n\n\n\n\nopv-session\n  [sessionName]=\nmySessionId\n\n  [user]=\nmyUserName\n\n  [token]=\ntoken\n\n  [ovSettings]=\novSettings\n\n  (leaveSession)=\nhandlerLeaveSessionEvent($event)\n\n  (joinSession)=\nhandlerJoinSessionEvent($event)\n\n  (error)=\nhandlerErrorEvent($event)\n\n\n/opv-session\n\n\n\n\n\nMoreover, opv-session emits events \nleaveSession\n, \njoinSession\n and \nerror\n, we can handle them with the next code in \napp.component.ts\n file:\n\n\nhandlerJoinSessionEvent(event): void {\n    // Do something\n  }\n\n  handlerLeaveSessionEvent(event): void {\n    // Do something\n  }\n\n  handlerErrorEvent(event): void {\n    // Do something\n  }\n\n\n\n\nIn addiction, \nopenvidu-library-angular\n allows you to have access to specifics internals variables such as \nOpenVidu Session\n, \nOpenVidu Layout\n, \nLocal User\n or \nRemotes User\n.\n\n\nYou can access to them through the following way:\n\n\n1) You must assign a referece to the \nopv-session\n, inside of \napp.component.html\n with \n#ovSessionComponent\n:\n\n\nopv-session\n  #ovSessionComponent\n  [sessionName]=\nmySessionId\n\n  [user]=\nmyUserName\n\n  [token]=\ntoken\n\n  [ovSettings]=\novSettings\n\n  (leaveSession)=\nhandlerLeaveSessionEvent($event)\n\n  (joinSession)=\nhandlerJoinSessionEvent($event)\n\n  (error)=\nhandlerErrorEvent($event)\n\n\n/opv-session\n\n\n\n\n\n2) You have to declare the openvidu component variable in \napp.component.ts\n:\n\n\n@ViewChild('ovSessionComponent')\npublic ovSessionComponent: OpenviduSessionComponent;\n\n\n\n\n3) After that, \novSessionComponent\n will provides us some methods to get the internal variables we need. These methods are:\n\n\n\n\ngetSession\n: This method will provide you the Session. Check the Session documentation \nhere\n\n\ngetLocalUser\n: This method will provide you the User. You can check the documentation about the User Class \nhere\n\n\ngetOpenviduLayout\n: This method will return the OpenVidu Layout Object. You can check the information about the OpenVidu Layout Class \nhere\n\n\ngetOpenviduLayoutOptions\n: This method will return the layout options. Click \nhere\n to more information.\n\n\n\n\nmyMethod() {\n  this.ovSession = this.ovSessionComponent.getSession();\n  this.ovLocalUser = this.ovSessionComponent.getLocalUser();\n  this.ovLayout = this.ovSessionComponent.getOpenviduLayout();\n  this.ovLayoutOptions = this.ovSessionComponent.getOpenviduLayoutOptions();\n}\n\n\n\n\nWe are invoking \nmyMethod\n inside of \nhandlerJoinSessionEvent\n.\n\n\n4) Last but not least, you must stablish the local variables like this: \n\n\nimport {OpenviduSessionComponent, StreamEvent, Session, UserModel, OpenViduLayout, OpenViduLayoutOptions, OvSettings} from 'openvidu-angular';\n\n\n\n\novSession: Session;\novRemotesArray: UserModel[];\novLocalUser: UserModel;\novLayout: OpenViduLayout;\novLayoutOptions: OpenViduLayoutOptions;\novSettings: OvSettings;\n\n\n\n\nMoreover, if you want to customize the interface of \nopv-session-component\n you can provide a parameter \novSettings\n to the component. Further details on this topic \nhere\n.\n\n\nAnd initializate it with the config properties:\n\n\nthis.ovSettings = {\n  chat: false,\n  autopublish: true,\n  toolbarButtons: {\n    audio: true,\n    video: true,\n    screenShare: true,\n    fullscreen: true,\n    exit: true,\n  }\n};\n\n\n\n\n\n\nGet a \ntoken\n from OpenVidu Server\n\n\n\n    \n\n\n\n    \nWARNING\n: This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. \nThis process should entirely take place in our server-side\n, not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server\n\n\n\n\n\n\nthis.getToken().then((token) =\n {\n    // Save the 'token' in token variable\n});\n\n\n\n\nIn a production environment we would perform this operations in our application backend, by making use of the \nREST API\n, \nOpenVidu Java Client\n or \nOpenVidu Node Client\n. Here we have implemented the POST requests to OpenVidu Server in a method \ngetToken()\n that returns a Promise with the token. Without going into too much detail, this method performs two \najax\n requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:\n\n\n\n\nFirst ajax request performs a POST to \n/api/sessions\n (we send a \ncustomSessionId\n field to name the session with our \nsessionName\n value retrieved from HTML input)\n\n\nSecond ajax request performs a POST to \n/api/tokens\n (we send a \nsession\n field to assign the token to this same session)\n\n\n\n\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\n\n\n\nExtra features of OpenVidu Angular\n\n\nAlternatives to connect to OpenVidu Angular\n\n\nIn the example above, \nopv-session\n receives the \nsessionName\n, the \nuser\n and the \ntoken\n parameters. If you want to let the opv-session get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the typescript code:\n\n\nopv-session [sessionName]=\nmySessionId\n [user]=\nmyUserName\n [openviduServerUrl]=\n'https://localhost:4443'\n [openviduSecret]=\n'MY_SECRET'\n/opv-session\n\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-library-angular"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#openvidu-library-angular", 
            "text": "Check it on GitHub  OpenVidu Library Angular is one of the simplest and quickest tutorials to add videoconference capabilities to your existing web application. This tutorial uses  openvidu-angular  library.", 
            "title": "openvidu-library-angular"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need angular-cli (and of course NPM) to serve the Angular frontend. You can install it with the following command:  npm install -g @angular/cli@latest  3) Run the tutorial:  cd openvidu-tutorials/openvidu-library-angular\nnpm install\nng serve  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  localhost:4200  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#understanding-the-code", 
            "text": "This is a basic Angular project generated with angular-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under  src/app/  folder   app.component.ts : defines  AppComponent , main component of the app. It contains the functionalities for for handling the the events received from  openvidu-angular .  app.component.html : HTML for AppComponent.  app.component.css : CSS for AppComponent.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#we-must-include-these-elements", 
            "text": "1) First of all, obviously you have to install openvidu-angular:  npm install openvidu-angular --save  2)  Angular Material  is included in openvidu-angular neverthelesst you need to include a theme style in your application. If you're using the Angular CLI, you can add this to your  styles.css :  @import  ~@angular/material/prebuilt-themes/indigo-pink.css ;  3) Finally, you need to include  Jquery  script, the  global variable  and  Material icons font  in the  index.html  file:  head  !--... other imports ...-- \n   script src= https://code.jquery.com/jquery-3.3.1.min.js  integrity= sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=  crossorigin= anonymous /script \n   script \n      var global = global || window;\n   /script \n   link href= https://fonts.googleapis.com/icon?family=Material+Icons  rel= stylesheet  /head", 
            "title": "We must include these elements:"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#appmodulets", 
            "text": "Inside of the  app.module.ts  you must import  OpenviduSessionModule  from  openvidu-angular :  import { OpenviduSessionModule } from 'openvidu-angular';  Moreover, you need to include  OpenviduSessionModule  inside of  imports  section of  NgModule :  imports: [\n    BrowserModule,\n    FormsModule,\n    OpenviduSessionModule\n  ]", 
            "title": "app.module.ts"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#configuring-openvidu-angular", 
            "text": "", 
            "title": "Configuring OpenVidu Angular"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#appcomponenthtml", 
            "text": "As you can see here, you can use  opv-session /opv-session  component to embed openvidu session in your application in a very easy way. Our component will start hidden:  div *ngIf= !session  id= join \n   div id= join-dialog \n     h1 Join a video session /h1 \n     form (submit)= joinSession() \n       p \n         label Participant  /label \n         input type= text  id= userName  name= userName  [(ngModel)]= myUserName  required \n       /p \n       p \n         label Session  /label \n         input type= text  id= sessionId  name= sessionId  [(ngModel)]= mySessionId  required \n       /p \n       p class= text-center \n         input type= submit  name= commit  value= Join! \n       /p \n     /form \n   /div  /div  div *ngIf= session  id= session \n     opv-session /opv-session  /div", 
            "title": "app.component.html"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#appcomponentts", 
            "text": "Method  joinSession()  gets the token which we provide to our component to connect to the session.  You can configure the opv-session with these parameters:   sessionName : the session name that will be displayed inside the component  user : the nickname that the user will have in the session  token : the retrieved token from OpenVidu Server  ovSettings : the configuration that the user want to have on the session   opv-session\n  [sessionName]= mySessionId \n  [user]= myUserName \n  [token]= token \n  [ovSettings]= ovSettings \n  (leaveSession)= handlerLeaveSessionEvent($event) \n  (joinSession)= handlerJoinSessionEvent($event) \n  (error)= handlerErrorEvent($event)  /opv-session   Moreover, opv-session emits events  leaveSession ,  joinSession  and  error , we can handle them with the next code in  app.component.ts  file:  handlerJoinSessionEvent(event): void {\n    // Do something\n  }\n\n  handlerLeaveSessionEvent(event): void {\n    // Do something\n  }\n\n  handlerErrorEvent(event): void {\n    // Do something\n  }  In addiction,  openvidu-library-angular  allows you to have access to specifics internals variables such as  OpenVidu Session ,  OpenVidu Layout ,  Local User  or  Remotes User .  You can access to them through the following way:  1) You must assign a referece to the  opv-session , inside of  app.component.html  with  #ovSessionComponent :  opv-session\n  #ovSessionComponent\n  [sessionName]= mySessionId \n  [user]= myUserName \n  [token]= token \n  [ovSettings]= ovSettings \n  (leaveSession)= handlerLeaveSessionEvent($event) \n  (joinSession)= handlerJoinSessionEvent($event) \n  (error)= handlerErrorEvent($event)  /opv-session   2) You have to declare the openvidu component variable in  app.component.ts :  @ViewChild('ovSessionComponent')\npublic ovSessionComponent: OpenviduSessionComponent;  3) After that,  ovSessionComponent  will provides us some methods to get the internal variables we need. These methods are:   getSession : This method will provide you the Session. Check the Session documentation  here  getLocalUser : This method will provide you the User. You can check the documentation about the User Class  here  getOpenviduLayout : This method will return the OpenVidu Layout Object. You can check the information about the OpenVidu Layout Class  here  getOpenviduLayoutOptions : This method will return the layout options. Click  here  to more information.   myMethod() {\n  this.ovSession = this.ovSessionComponent.getSession();\n  this.ovLocalUser = this.ovSessionComponent.getLocalUser();\n  this.ovLayout = this.ovSessionComponent.getOpenviduLayout();\n  this.ovLayoutOptions = this.ovSessionComponent.getOpenviduLayoutOptions();\n}  We are invoking  myMethod  inside of  handlerJoinSessionEvent .  4) Last but not least, you must stablish the local variables like this:   import {OpenviduSessionComponent, StreamEvent, Session, UserModel, OpenViduLayout, OpenViduLayoutOptions, OvSettings} from 'openvidu-angular';  ovSession: Session;\novRemotesArray: UserModel[];\novLocalUser: UserModel;\novLayout: OpenViduLayout;\novLayoutOptions: OpenViduLayoutOptions;\novSettings: OvSettings;  Moreover, if you want to customize the interface of  opv-session-component  you can provide a parameter  ovSettings  to the component. Further details on this topic  here .  And initializate it with the config properties:  this.ovSettings = {\n  chat: false,\n  autopublish: true,\n  toolbarButtons: {\n    audio: true,\n    video: true,\n    screenShare: true,\n    fullscreen: true,\n    exit: true,\n  }\n};", 
            "title": "app.component.ts"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#get-a-token-from-openvidu-server", 
            "text": "WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session.  This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server   this.getToken().then((token) =  {\n    // Save the 'token' in token variable\n});  In a production environment we would perform this operations in our application backend, by making use of the  REST API ,  OpenVidu Java Client  or  OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method  getToken()  that returns a Promise with the token. Without going into too much detail, this method performs two  ajax  requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:   First ajax request performs a POST to  /api/sessions  (we send a  customSessionId  field to name the session with our  sessionName  value retrieved from HTML input)  Second ajax request performs a POST to  /api/tokens  (we send a  session  field to assign the token to this same session)   You can inspect this method in detail in the  GitHub repo .", 
            "title": "Get a token from OpenVidu Server"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#extra-features-of-openvidu-angular", 
            "text": "", 
            "title": "Extra features of OpenVidu Angular"
        }, 
        {
            "location": "/tutorials/openvidu-library-angular/#alternatives-to-connect-to-openvidu-angular", 
            "text": "In the example above,  opv-session  receives the  sessionName , the  user  and the  token  parameters. If you want to let the opv-session get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the typescript code:  opv-session [sessionName]= mySessionId  [user]= myUserName  [openviduServerUrl]= 'https://localhost:4443'  [openviduSecret]= 'MY_SECRET' /opv-session     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Alternatives to connect to OpenVidu Angular"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/", 
            "text": "openvidu-insecure-react\n\n\n Check it on GitHub\n\n\nA client-side only application built with \nReactjs\n.\n\n\nIf it is the first time you use OpenVidu, it is higly recommended to start with \nopenvidu-hello-world\n tutorial, as this app is no more than an extension of it with some new features and sytles.\n\n\nThis is the React version of \nopenvidu-insecure-js\n. Try it if you plan to use React for your frontend.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n    \n\n\n\n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.\n\n\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need \nNPM\n to serve the React frontend. Once you have npm installed, you can run the tutorial.\n\n\ncd openvidu-tutorials/openvidu-insecure-react\nnpm install\nnpm start\n\n\n\n\n3) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nlocalhost:3000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a React project generated with create-react-app, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under \nsrc/\n folder:\n\n\n\n\nApp.js\n: \nAppComponent\n, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.\n\n\nApp.css\n: CSS for AppComponent.\n\n\nUserVideoComponent.js\n: \nUserVideoComponent\n, used to display every user video. It contains one \nOpenViduVideoComponent\n, the name of the user and also handles a click event to update the view of \nAppComponent\n.\n\n\nOpenViduVideoComponent\n: defines \nOpenViduVideoComponent\n, which wraps the final HTML \nvideo\n that finally displays the media stream.\n\n\n\n\nLet's see first how \nApp.js\n uses NPM package \nopenvidu-browser\n:\n\n\n\n\nWe import the necessary objects from \nopenvidu-browser\n:\n\n\nimport { OpenVidu } from 'openvidu-browser';\n\n\n\n\n\n\nApp.js\n declares the following properties in the state:\n\n\n//These properties are in the state's component in order to re-render the HTML when the values of them change\nthis.state = {\n    mySessionId: 'SessionA',\n    myUserName: 'Participant' + Math.floor(Math.random() * 100),\n    session: undefined,\n    mainStreamManager: undefined, // Main video of the page, will be 'publisher' or one of the 'subscribers',\n    publisher: undefined,\n    subscribers: [],\n};\n\n\n\n\nOpenVidu\n object will allow us to get a \nSession\n object, which is declared just after it. \npublisher\n will be our own local webcam stream and \nsubscribers\n array will store the active streams of other users in the video-call. Finally, \nmySessionId\n and \nmyUserName\n params simply represent the video-call and your participant's nickname, as you will see in a moment.\n\n\n\n\nWhenever a user clicks on the submit input defined in \nApp.js\n template, \njoinSession()\n method is called:\n\n\n\n\nWe first get an OpenVidu object and initialize a session property in a state.\n\n\n// --- 1) Get an OpenVidu object ---\n\nthis.OV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nthis.setState({\n    session: this.OV.initSession(),\n    }, () =\n {\n        // See next step\n    }\n);\n\n\n\n\nThen we subscribe to the Session events that interest us.\n\n\n// --- 3) Specify the actions when events take place in the session ---\n\n\nvar mySession = this.state.session;\n\n    // On every new Stream received...\nmySession.on('streamCreated', (event) =\n {\n    // Subscribe to the Stream to receive it. Second parameter is undefined\n    // so OpenVidu doesn't create an HTML video by its own\n    var subscriber = mySession.subscribe(event.stream, undefined);\n\n    //We use an auxiliar array to push the new stream\n    var subscribers = this.state.subscribers;\n\n    subscribers.push(subscriber);\n\n    // Update the state with the new subscribers\n    this.setState({\n        subscribers: subscribers,\n    });\n});\n\n    // On every Stream destroyed...\nmySession.on('streamDestroyed', (event) =\n {\n    event.preventDefault();\n\n    // Remove the stream from 'subscribers' array\n    this.deleteSubscriber(event.stream.streamManager);\n});\n\n// See next step\n\n\n\n\nHere we subscribe to the Session events that interest us. As we are using React framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each \nSubscriber\n object and let it manage its video. This component will be our \nUserVideoComponent\n. To do this, we need to store each new Subscriber we received in array \nsubscribers\n, and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events:\n\n\n\n\n\n\nstreamCreated\n: for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our \nsubscribers\n array. Method \nsession.subscribe\n has \nundefined\n as second parameter so OpenVidu doesn't insert and HTML video element in the DOM on its own (we will use the video element contained in one of our child components).  HTML template of \nAppComponent\n will show the new video, as it contains a .map js function, declaring a \nUserVideoComponent\n for each subscriber. We feed them not really as \nSubscriber\n objects, but rather as their parent class \nStreamManager\n. This way we can reuse \nUserVideoComponent\n to also display our \nPublisher\n object (that also inhertis from class StreamManager).\n\n\n{this.state.subscribers.map((sub, i) =\n (\n    \ndiv key={i} className=\"stream-container col-md-6 col-xs-6\"\n\n        \nUserVideoComponent streamManager={sub} mainVideoStream={this.handleMainVideoStream} /\n\n    \n/div\n\n))}\n\n\n\n\n\n\n\nstreamDestroyed\n: for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from \nsubscribers\n array, so React will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property \nstreamManager\n that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).\n\n\n\n\n\n\n\n\nGet a \ntoken\n from OpenVidu Server\n\n\n\n    \n\n\n\n    \nWARNING\n: This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. \nThis process should entirely take place in our server-side\n, not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server\n\n\n\n\n\n\n// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then(token =\n {\n    // See next point to see how to connect to the session using 'token'\n});\n\n\n\n\nNow we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the \nREST API\n, \nOpenVidu Java Client\n or \nOpenVidu Node Client\n. Here we have implemented the POST requests to OpenVidu Server in a method \ngetToken()\n that returns a Promise with the token, using \naxios\n library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:\n\n\n\n\nFirst request performs a POST to \n/api/sessions\n (we send a \ncustomSessionId\n field to name the session with our \nmySessionId\n value retrieved from HTML input)\n\n\nSecond request performs a POST to \n/api/tokens\n (we send a \nsession\n field to assign the token to this same session)\n\n\n\n\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\n\n\nFinally connect to the session and publish your webcam:\n\n\n // --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then(token =\n {\n\n    // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event\n    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n    mySession.connect(token, { clientData: this.state.myUserName })\n        .then(() =\n {\n\n            // --- 5) Get your own camera stream ---\n\n            // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video\n            // element: we will manage it on our own) and with the desired properties\n            let publisher: Publisher = this.OV.initPublisher(undefined, {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 6) Publish your stream ---\n\n            mySession.publish(publisher);\n\n            // Set the main video in the page to display our webcam and store our Publisher\n            this.setState({\n                mainStreamManager: publisher,\n                publisher: publisher,\n            });\n        })\n        .catch(error =\n {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        });\n});\n\n\n\n\nIn \nmySession.connect\n method first param is the recently retrieved user token. Second param is the value every user will receive in \nevent.stream.connection.data\n property on \nstreamCreated\n event (this value will be used by \nUserVideoComponent\n to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input \ninput className=\"form-control\" type=\"text\" id=\"userName\" value={myUserName} onChange={this.handleChangeUserName} required /\n (filled by the user).\n\n\nIf the method succeeds, we proceed to publish our webcam to the session. To do so we get a \nPublisher\n object with the desired properties and publish it to the Session through \nSession.publish()\n method. The rest of users will receive our Stream object and will execute their \nstreamCreated\n event. Finally we make the main video player (which is just another \nUserVideoComponent\n) display the Publisher object by default. This is the HTML code that will display the main stream manager:\n\n\n{this.state.mainStreamManager !== undefined ? (\n    \ndiv id=\nmain-video\n className=\ncol-md-6\n\n        \nUserVideoComponent streamManager={this.state.mainStreamManager} /\n\n    \n/div\n\n) : null}\n\n\n\n\nAnd we store the Publisher under \nthis.state.publisher\n, which is also of parent class \nStreamManager\n. This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by \nUserVideoComponent\n):\n\n\n{this.state.publisher !== undefined ? (\n    \ndiv className=\nstream-container col-md-6 col-xs-6\n\n        \nUserVideoComponent streamManager={this.state.publisher}\n         mainVideoStream={this.handleMainVideoStream} /\n\n    \n/div\n\n) : null}\n\n\n\n\nLast point worth considering is the implementation of \nUserVideoComponent\n and \nOpenViduVideoComponent\n. Each \nUserVideoComponent\n manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component \nOpenViduVideoComponent\n. Its main task is not managing the final video player (that is \nOpenViduVideoComponent\n responsibility), but displaying custom information for each one of them (the user's nickname) and handling the click event on them to update property \nmainStreamManager\n of parent \nAppComponent\n:\n\n\ndiv className=\nstreamcomponent\n onClick={this.handleVideoClicked}\n\n    \nOpenViduVideoComponent streamManager={this.props.streamManager} /\n\n    \ndiv\np\n{this.getNicknameTag()}\n/p\n/div\n\n\n/div\n\n\n\n\n\nexport default class UserVideoComponent extends Component {\n    constructor(props) {\n        super(props);\n\n        this.handleVideoClicked = this.handleVideoClicked.bind(this);\n    }\n\n    getNicknameTag() {\n        // Gets the nickName of the user\n        return JSON.parse(this.props.streamManager.stream.connection.data).clientData;\n    }\n\n    handleVideoClicked(event) {\n        // Triggers event for the parent component to update its main video display (other UserVideoComponent)\n        if (this.props.mainVideoStream) {\n            this.props.mainVideoStream(this.props.streamManager);\n        }\n    }\n}\n\n\n\n\nOpenViduVideoComponent\n html template is just the video element:\n\n\nvideo autoPlay={true} ref={this.videoRef} /\n\n\n\n\n\nAnd the unique responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method \nStreamManager.addVideoElement\n, which receives a native HTML video element. The way we implement this is React Refs: we get the video element with \nReact.createRef()\n and we call the method once after the component output has been rendered to the DOM (\n \ncomponentDidMount\n \n).\n\n\nexport default class OpenViduVideoComponent extends Component {\n    constructor(props) {\n        super(props);\n\n        this.videoRef = React.createRef();\n    }\n\n    componentDidMount() {\n        if (this.props \n !!this.videoRef) {\n            this.props.streamManager.addVideoElement(this.videoRef.current);\n        }\n    }\n}\n\n\n\n\n\n\nLeaving the session:\n\n\nWhenever we want a user to leave the session, we just need to call \nsession.disconnect\n method in \nApp.js\n:\n\n\n  leaveSession() {\n\n    // --- 7) Leave the session by calling 'disconnect' method over the Session object ---\n\n    const mySession = this.state.session;\n\n    if (mySession) {\n        mySession.disconnect();\n    }\n\n    // Empty all properties...\n    this.OV = null;\n    this.setState({\n         mySessionId: 'SessionA',\n        myUserName: 'Participant' + Math.floor(Math.random() * 100),\n        session: undefined,\n        mainStreamManager: undefined,\n        publisher: undefined,\n        subscribers: [],\n    });\n  }\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-insecure-react"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#openvidu-insecure-react", 
            "text": "Check it on GitHub  A client-side only application built with  Reactjs .  If it is the first time you use OpenVidu, it is higly recommended to start with  openvidu-hello-world  tutorial, as this app is no more than an extension of it with some new features and sytles.  This is the React version of  openvidu-insecure-js . Try it if you plan to use React for your frontend.", 
            "title": "openvidu-insecure-react"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions   \n      \n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need  NPM  to serve the React frontend. Once you have npm installed, you can run the tutorial.  cd openvidu-tutorials/openvidu-insecure-react\nnpm install\nnpm start  3)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  localhost:3000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#understanding-the-code", 
            "text": "This is a React project generated with create-react-app, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under  src/  folder:   App.js :  AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.  App.css : CSS for AppComponent.  UserVideoComponent.js :  UserVideoComponent , used to display every user video. It contains one  OpenViduVideoComponent , the name of the user and also handles a click event to update the view of  AppComponent .  OpenViduVideoComponent : defines  OpenViduVideoComponent , which wraps the final HTML  video  that finally displays the media stream.   Let's see first how  App.js  uses NPM package  openvidu-browser :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#we-import-the-necessary-objects-from-openvidu-browser", 
            "text": "import { OpenVidu } from 'openvidu-browser';", 
            "title": "We import the necessary objects from openvidu-browser:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#appjs-declares-the-following-properties-in-the-state", 
            "text": "//These properties are in the state's component in order to re-render the HTML when the values of them change\nthis.state = {\n    mySessionId: 'SessionA',\n    myUserName: 'Participant' + Math.floor(Math.random() * 100),\n    session: undefined,\n    mainStreamManager: undefined, // Main video of the page, will be 'publisher' or one of the 'subscribers',\n    publisher: undefined,\n    subscribers: [],\n};  OpenVidu  object will allow us to get a  Session  object, which is declared just after it.  publisher  will be our own local webcam stream and  subscribers  array will store the active streams of other users in the video-call. Finally,  mySessionId  and  myUserName  params simply represent the video-call and your participant's nickname, as you will see in a moment.", 
            "title": "App.js declares the following properties in the state:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#whenever-a-user-clicks-on-the-submit-input-defined-in-appjs-template-joinsession-method-is-called", 
            "text": "We first get an OpenVidu object and initialize a session property in a state.  // --- 1) Get an OpenVidu object ---\n\nthis.OV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nthis.setState({\n    session: this.OV.initSession(),\n    }, () =  {\n        // See next step\n    }\n);  Then we subscribe to the Session events that interest us.  // --- 3) Specify the actions when events take place in the session ---\n\n\nvar mySession = this.state.session;\n\n    // On every new Stream received...\nmySession.on('streamCreated', (event) =  {\n    // Subscribe to the Stream to receive it. Second parameter is undefined\n    // so OpenVidu doesn't create an HTML video by its own\n    var subscriber = mySession.subscribe(event.stream, undefined);\n\n    //We use an auxiliar array to push the new stream\n    var subscribers = this.state.subscribers;\n\n    subscribers.push(subscriber);\n\n    // Update the state with the new subscribers\n    this.setState({\n        subscribers: subscribers,\n    });\n});\n\n    // On every Stream destroyed...\nmySession.on('streamDestroyed', (event) =  {\n    event.preventDefault();\n\n    // Remove the stream from 'subscribers' array\n    this.deleteSubscriber(event.stream.streamManager);\n});\n\n// See next step  Here we subscribe to the Session events that interest us. As we are using React framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each  Subscriber  object and let it manage its video. This component will be our  UserVideoComponent . To do this, we need to store each new Subscriber we received in array  subscribers , and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events:    streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our  subscribers  array. Method  session.subscribe  has  undefined  as second parameter so OpenVidu doesn't insert and HTML video element in the DOM on its own (we will use the video element contained in one of our child components).  HTML template of  AppComponent  will show the new video, as it contains a .map js function, declaring a  UserVideoComponent  for each subscriber. We feed them not really as  Subscriber  objects, but rather as their parent class  StreamManager . This way we can reuse  UserVideoComponent  to also display our  Publisher  object (that also inhertis from class StreamManager).  {this.state.subscribers.map((sub, i) =  (\n     div key={i} className=\"stream-container col-md-6 col-xs-6\" \n         UserVideoComponent streamManager={sub} mainVideoStream={this.handleMainVideoStream} / \n     /div \n))}    streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from  subscribers  array, so React will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property  streamManager  that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).", 
            "title": "Whenever a user clicks on the submit input defined in App.js template, joinSession() method is called:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#get-a-token-from-openvidu-server", 
            "text": "WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session.  This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server   // --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then(token =  {\n    // See next point to see how to connect to the session using 'token'\n});  Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the  REST API ,  OpenVidu Java Client  or  OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method  getToken()  that returns a Promise with the token, using  axios  library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:   First request performs a POST to  /api/sessions  (we send a  customSessionId  field to name the session with our  mySessionId  value retrieved from HTML input)  Second request performs a POST to  /api/tokens  (we send a  session  field to assign the token to this same session)   You can inspect this method in detail in the  GitHub repo .", 
            "title": "Get a token from OpenVidu Server"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#finally-connect-to-the-session-and-publish-your-webcam", 
            "text": "// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then(token =  {\n\n    // First param is the token got from OpenVidu Server. Second param can be retrieved by every user on event\n    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n    mySession.connect(token, { clientData: this.state.myUserName })\n        .then(() =  {\n\n            // --- 5) Get your own camera stream ---\n\n            // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video\n            // element: we will manage it on our own) and with the desired properties\n            let publisher: Publisher = this.OV.initPublisher(undefined, {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 6) Publish your stream ---\n\n            mySession.publish(publisher);\n\n            // Set the main video in the page to display our webcam and store our Publisher\n            this.setState({\n                mainStreamManager: publisher,\n                publisher: publisher,\n            });\n        })\n        .catch(error =  {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        });\n});  In  mySession.connect  method first param is the recently retrieved user token. Second param is the value every user will receive in  event.stream.connection.data  property on  streamCreated  event (this value will be used by  UserVideoComponent  to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input  input className=\"form-control\" type=\"text\" id=\"userName\" value={myUserName} onChange={this.handleChangeUserName} required /  (filled by the user).  If the method succeeds, we proceed to publish our webcam to the session. To do so we get a  Publisher  object with the desired properties and publish it to the Session through  Session.publish()  method. The rest of users will receive our Stream object and will execute their  streamCreated  event. Finally we make the main video player (which is just another  UserVideoComponent ) display the Publisher object by default. This is the HTML code that will display the main stream manager:  {this.state.mainStreamManager !== undefined ? (\n     div id= main-video  className= col-md-6 \n         UserVideoComponent streamManager={this.state.mainStreamManager} / \n     /div \n) : null}  And we store the Publisher under  this.state.publisher , which is also of parent class  StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by  UserVideoComponent ):  {this.state.publisher !== undefined ? (\n     div className= stream-container col-md-6 col-xs-6 \n         UserVideoComponent streamManager={this.state.publisher}\n         mainVideoStream={this.handleMainVideoStream} / \n     /div \n) : null}  Last point worth considering is the implementation of  UserVideoComponent  and  OpenViduVideoComponent . Each  UserVideoComponent  manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component  OpenViduVideoComponent . Its main task is not managing the final video player (that is  OpenViduVideoComponent  responsibility), but displaying custom information for each one of them (the user's nickname) and handling the click event on them to update property  mainStreamManager  of parent  AppComponent :  div className= streamcomponent  onClick={this.handleVideoClicked} \n     OpenViduVideoComponent streamManager={this.props.streamManager} / \n     div p {this.getNicknameTag()} /p /div  /div   export default class UserVideoComponent extends Component {\n    constructor(props) {\n        super(props);\n\n        this.handleVideoClicked = this.handleVideoClicked.bind(this);\n    }\n\n    getNicknameTag() {\n        // Gets the nickName of the user\n        return JSON.parse(this.props.streamManager.stream.connection.data).clientData;\n    }\n\n    handleVideoClicked(event) {\n        // Triggers event for the parent component to update its main video display (other UserVideoComponent)\n        if (this.props.mainVideoStream) {\n            this.props.mainVideoStream(this.props.streamManager);\n        }\n    }\n}  OpenViduVideoComponent  html template is just the video element:  video autoPlay={true} ref={this.videoRef} /   And the unique responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method  StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is React Refs: we get the video element with  React.createRef()  and we call the method once after the component output has been rendered to the DOM (   componentDidMount   ).  export default class OpenViduVideoComponent extends Component {\n    constructor(props) {\n        super(props);\n\n        this.videoRef = React.createRef();\n    }\n\n    componentDidMount() {\n        if (this.props   !!this.videoRef) {\n            this.props.streamManager.addVideoElement(this.videoRef.current);\n        }\n    }\n}", 
            "title": "Finally connect to the session and publish your webcam:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-react/#leaving-the-session", 
            "text": "Whenever we want a user to leave the session, we just need to call  session.disconnect  method in  App.js :    leaveSession() {\n\n    // --- 7) Leave the session by calling 'disconnect' method over the Session object ---\n\n    const mySession = this.state.session;\n\n    if (mySession) {\n        mySession.disconnect();\n    }\n\n    // Empty all properties...\n    this.OV = null;\n    this.setState({\n         mySessionId: 'SessionA',\n        myUserName: 'Participant' + Math.floor(Math.random() * 100),\n        session: undefined,\n        mainStreamManager: undefined,\n        publisher: undefined,\n        subscribers: [],\n    });\n  }    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Leaving the session:"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/", 
            "text": "openvidu-library-react\n\n\n Check it on GitHub\n\n\nOpenVidu Library React is one of the simplest and quickest tutorials to add videoconference capabilities to your existing web application. This tutorial uses \nopenvidu-react\n library.\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) Run the tutorial:\n\n\ncd openvidu-tutorials/openvidu-library-react\nnpm install\nnpm start\n\n\n\n\n3) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n4) Go to \nlocalhost:3000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a basic React project generated with \nnpx create-react-app\n, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under \nsrc/\n folder\n\n\n\n\nApp.js\n: defines \nApp Component\n, main component of the app. It contains the JSX code and the functionalities for for handling the the events received from \nopenvidu-react\n.\n\n\nApp.css\n: CSS for App Component.\n\n\n\n\n\n\nWe must include \nopenvidu-react\n and \naxios\n in our app:\n\n\n1) First of all, you need to install \nopenvidu-react\n :\n\n\nnpm install openvidu-react --save\n\n\n\n\nAfter that, you must include \nOpvSession\n in \nApp.js\n file:\n\n\nimport OpvSession from 'openvidu-react';\n\n\n\n\n2) Secondly, you need to install \naxios\n that allows you to do HTTP requests:\n\n\nnpm install axios --save\n\n\n\n\nAnd include it in \n\u00c0pp.js\n:\n\n\nimport axios from 'axios';\n\n\n\n\n\n\n\nConfiguring OpenVidu React\n\n\nApp.js\n\n\nAs you can see here, you can use \nOpvSession\n/OpvSession\n component to embed openvidu session in your application in a very easy way. Our component will start hidden:\n\n\ndiv\n\n    {this.state.session === undefined ? (\n        \ndiv id=\njoin\n\n            \ndiv id=\njoin-dialog\n\n                \nh1\n Join a video session \n/h1\n\n                \nform onSubmit={this.joinSession}\n\n                    \np\n\n                        \nlabel\nParticipant: \n/label\n\n                        \ninput\n                            type=\ntext\n\n                            id=\nuserName\n\n                            value={myUserName}\n                            onChange={this.handleChangeUserName}\n                            required\n                        /\n\n                    \n/p\n\n                    \np\n\n                        \nlabel\n Session: \n/label\n\n                        \ninput\n                            type=\ntext\n\n                            id=\nsessionId\n\n                            value={mySessionId}\n                            onChange={this.handleChangeSessionId}\n                            required\n                        /\n\n                    \n/p\n\n                    \np\n\n                        \ninput name=\ncommit\n type=\nsubmit\n value=\nJOIN\n /\n\n                    \n/p\n\n                \n/form\n\n            \n/div\n\n        \n/div\n\n    ) : (\n        \ndiv id=\nsession\n\n            \nOpvSession/\n\n        \n/div\n\n    )}\n\n/div\n\n\n\n\n\nMethod \njoinSession()\n gets the token which we provide to our component to connect to the session.\n\n\nYou can configure the OpvSession with these parameters:\n\n\n\n\nsessionName\n: the session name that will be displayed inside the component\n\n\nuser\n: the nickname that the user will have in the session\n\n\ntoken\n: the retrieved token from OpenVidu Server\n\n\n\n\nOpvSession\n    id=\nopv-session\n\n    sessionName={mySessionId}\n    user={myUserName}\n    token={token}\n    joinSession={this.handlerJoinSessionEvent}\n    leaveSession={this.handlerLeaveSessionEvent}\n    error={this.handlerErrorEvent}\n/\n\n\n\n\n\nMoreover, OpvSession emits events \nleaveSession\n, \njoinSession\n and \nerror\n, we can handle them with the next code in \napp.component.ts\n file:\n\n\nhandlerJoinSessionEvent(event) {\n    // Do something\n  }\n\n  handlerLeaveSessionEvent(event) {\n    // Do something\n  }\n\n  handlerErrorEvent(event) {\n    // Do something\n  }\n\n\n\n\n\n\nGet a \ntoken\n from OpenVidu Server\n\n\n\n    \n\n\n\n    \nWARNING\n: This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. \nThis process should entirely take place in our server-side\n, not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server\n\n\n\n\n\n\nthis.getToken().then((token) =\n {\n    // Update the state with the token\n});\n\n\n\n\nIn a production environment we would perform this operations in our application backend, by making use of the \nREST API\n, \nOpenVidu Java Client\n or \nOpenVidu Node Client\n. Here we have implemented the POST requests to OpenVidu Server in a method \ngetToken()\n that returns a Promise with the token. Without going into too much detail, this method performs two \najax\n requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:\n\n\n\n\nFirst ajax request performs a POST to \n/api/sessions\n (we send a \ncustomSessionId\n field to name the session with our \nsessionName\n value retrieved from HTML input)\n\n\nSecond ajax request performs a POST to \n/api/tokens\n (we send a \nsession\n field to assign the token to this same session)\n\n\n\n\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\n\n\n\nExtra features of OpenVidu React\n\n\nAlternatives to connect to OpenVidu React\n\n\nIn the example above, \nOpvSession\n receives the \nsessionName\n, the \nuser\n and the \ntoken\n parameters. If you want to let the OpvSession get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the JavaScript code:\n\n\nOpvSession\n  id=\nopv-session\n\n  sessionName={mySessionId}\n  user={myUserName}\n  openviduServerUrl={'https://localhost:4443'}\n  openviduSecret={'MY_SECRET'}\n  joinSession={this.handlerJoinSessionEvent}\n  leaveSession={this.handlerLeaveSessionEvent}\n  error={this.handlerErrorEvent}\n/\n\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-library-react"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#openvidu-library-react", 
            "text": "Check it on GitHub  OpenVidu Library React is one of the simplest and quickest tutorials to add videoconference capabilities to your existing web application. This tutorial uses  openvidu-react  library.", 
            "title": "openvidu-library-react"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) Run the tutorial:  cd openvidu-tutorials/openvidu-library-react\nnpm install\nnpm start  3)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  4) Go to  localhost:3000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#understanding-the-code", 
            "text": "This is a basic React project generated with  npx create-react-app , and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under  src/  folder   App.js : defines  App Component , main component of the app. It contains the JSX code and the functionalities for for handling the the events received from  openvidu-react .  App.css : CSS for App Component.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#we-must-include-openvidu-react-and-axios-in-our-app", 
            "text": "1) First of all, you need to install  openvidu-react  :  npm install openvidu-react --save  After that, you must include  OpvSession  in  App.js  file:  import OpvSession from 'openvidu-react';  2) Secondly, you need to install  axios  that allows you to do HTTP requests:  npm install axios --save  And include it in  \u00c0pp.js :  import axios from 'axios';", 
            "title": "We must include openvidu-react and axios in our app:"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#configuring-openvidu-react", 
            "text": "", 
            "title": "Configuring OpenVidu React"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#appjs", 
            "text": "As you can see here, you can use  OpvSession /OpvSession  component to embed openvidu session in your application in a very easy way. Our component will start hidden:  div \n    {this.state.session === undefined ? (\n         div id= join \n             div id= join-dialog \n                 h1  Join a video session  /h1 \n                 form onSubmit={this.joinSession} \n                     p \n                         label Participant:  /label \n                         input\n                            type= text \n                            id= userName \n                            value={myUserName}\n                            onChange={this.handleChangeUserName}\n                            required\n                        / \n                     /p \n                     p \n                         label  Session:  /label \n                         input\n                            type= text \n                            id= sessionId \n                            value={mySessionId}\n                            onChange={this.handleChangeSessionId}\n                            required\n                        / \n                     /p \n                     p \n                         input name= commit  type= submit  value= JOIN  / \n                     /p \n                 /form \n             /div \n         /div \n    ) : (\n         div id= session \n             OpvSession/ \n         /div \n    )} /div   Method  joinSession()  gets the token which we provide to our component to connect to the session.  You can configure the OpvSession with these parameters:   sessionName : the session name that will be displayed inside the component  user : the nickname that the user will have in the session  token : the retrieved token from OpenVidu Server   OpvSession\n    id= opv-session \n    sessionName={mySessionId}\n    user={myUserName}\n    token={token}\n    joinSession={this.handlerJoinSessionEvent}\n    leaveSession={this.handlerLeaveSessionEvent}\n    error={this.handlerErrorEvent}\n/   Moreover, OpvSession emits events  leaveSession ,  joinSession  and  error , we can handle them with the next code in  app.component.ts  file:  handlerJoinSessionEvent(event) {\n    // Do something\n  }\n\n  handlerLeaveSessionEvent(event) {\n    // Do something\n  }\n\n  handlerErrorEvent(event) {\n    // Do something\n  }", 
            "title": "App.js"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#get-a-token-from-openvidu-server", 
            "text": "WARNING : This makes this tutorial an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session.  This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the JavaScript code itself will perform the POST operations to OpenVidu Server   this.getToken().then((token) =  {\n    // Update the state with the token\n});  In a production environment we would perform this operations in our application backend, by making use of the  REST API ,  OpenVidu Java Client  or  OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method  getToken()  that returns a Promise with the token. Without going into too much detail, this method performs two  ajax  requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:   First ajax request performs a POST to  /api/sessions  (we send a  customSessionId  field to name the session with our  sessionName  value retrieved from HTML input)  Second ajax request performs a POST to  /api/tokens  (we send a  session  field to assign the token to this same session)   You can inspect this method in detail in the  GitHub repo .", 
            "title": "Get a token from OpenVidu Server"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#extra-features-of-openvidu-react", 
            "text": "", 
            "title": "Extra features of OpenVidu React"
        }, 
        {
            "location": "/tutorials/openvidu-library-react/#alternatives-to-connect-to-openvidu-react", 
            "text": "In the example above,  OpvSession  receives the  sessionName , the  user  and the  token  parameters. If you want to let the OpvSession get the token for you, you can just dispense with the token and provide two more attributes to it. This is only meant for developing purposes, as you need to hardcode the secret of your OpenVidu Server in the JavaScript code:  OpvSession\n  id= opv-session \n  sessionName={mySessionId}\n  user={myUserName}\n  openviduServerUrl={'https://localhost:4443'}\n  openviduSecret={'MY_SECRET'}\n  joinSession={this.handlerJoinSessionEvent}\n  leaveSession={this.handlerLeaveSessionEvent}\n  error={this.handlerErrorEvent}\n/     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Alternatives to connect to OpenVidu React"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/", 
            "text": "openvidu-ionic\n\n\n Check it on GitHub\n\n\nA client-side only application built with \nIonic v4\n and \nAngular 7\n frameworks. It can be compiled into a \nnative Android app\n, a \nnative iOS app\n and into a standard \nweb app\n.\n\n\nIf it is the first time you use OpenVidu, it is highly recommended to start first with \nopenvidu-hello-world\n tutorial due to this being a cordova ionic app and being a little more complex for OpenVidu starters.\n\n\n\n    \n\n\n\n    Android 5 (Lollipop) and 6 (Marshmallow) will not work with Ionic v4 until \nthis issue\n is properly solved\n\n\n\n\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: NPM package for your Ionic app. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\nRunning this tutorial\n\n\n1) You will need \nNode\n, \nNPM\n, \nIonic\n and \nCordova\n to serve the app. Install them with the following command\n\n\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\nsudo npm install -g ionic@latest\nsudo npm install -g cordova@latest\n\n\n\n\n2) Clone the repo\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n3) Install dependencies\n\n\ncd openvidu-tutorials/openvidu-ionic\nnpm install\n\n\n\n\nNow depending on the platform you want to run your app...\n\n\nIn the browser\n\n\n4) Run the tutorial\n\n\n# In openvidu-tutorials/openvidu-ionic\nionic serve\n\n\n\n\n5) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n)\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n6) Go to \nlocalhost:8100\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n7) To show the app with the device appearance, press \nF12\n button in your keyboard and the browser DevTools will be opened. You can find a button with a device icon at the top of the DevTools. By pressing this button the view will adapt to a mobile device aspect ratio. You can also choose predefined types of devices to see the behavior of your app in different resolutions.\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n\nIn an Android device with native app\n\n\nTo deploy the Android APK not only you need to have \nJava JDK8\n, \nAndroid Studio\n and \nAndroid SDK\n installed but also you have to set up the specific \nenvironment variables\n. Fortunately, Ionic provide us a \ngreat guide\n to allows us to configure step by step all the requirements.\n\n\nAfter we have completed all the steps of the Ionic guide and performed steps 1) , 2) and 3) stated above, we must continue with the following commands:\n\n\n\n\n4) Connect the device to the same network as your PC\n\n\n5) Now you need the IP of your PC in the network. In Linux/OSX you can simply get it by running this command on your shell\n\n\nawk '/inet / \n $2 != \n127.0.0.1\n{print $2}' \n(ifconfig)\n\n\n\n\n\n\nIt will probably output something like \n192.168.0.105\n. Your \ncomplete OpenVidu public url\n would then be \nhttps://192.168.0.105:4443/\n\n\n\n\nWhen you have your OpenVidu public url, you must set it in \nOPENVIDU_SERVER_URL\n variable \nin the app\n and in the \nopenvidu.publicurl\n parameter used to run \nopenvidu-server\n (see next point)\n\n\n6) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n)\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=YOUR_OPENVIDU_PUBLIC_URL openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n\n\nRemember changing \nopenvidu.publicurl\n parameter to the actual value. In this example that would be:\n-e openvidu.publicurl=https://192.168.0.105:4443/\n\n\n\n\n7) Connect the device to the PC. You must enable USB debugging and give permissions (check out \nlast section here in Ionic docs\n)\n\n\n8) Run the tutorial. The app will be automatically launched in your Android device\n\n\n# In openvidu-tutorials/openvidu-ionic\nionic cordova run android\n\n\n\n\nIn an iOS device with native app\n\n\nTo deploy the iOS app you will need first to follow \nthis guide\n to properly configure your development environment. Then, it is crucial to have an OpenVidu Server properly deployed with a \nvalid certificate\n.\n\n\n\n    \n\n\n\n    iOS devices will require OpenVidu Server to be deployed in a valid domain well-protected with a certificate.\nNo iPhone or iPad will allow connections to a non-secure OpenVidu Server from within a native application. To facilitate first steps with OpenVidu and Ionic on iOS devices, if no custom url is defined \nhere in the app\n then our demos OpenVidu Server will be used. \nNote: this is a publicly accessible OpenVidu Server. Anyone could access your sessions. Use it only for an initial test and under your own responsibility\n\n\n\n\n\n\n\nAfter we have completed all the steps of the Ionic guide and performed steps 1), 2) and 3) stated above, we must continue with the following commands:\n\n\n\n\n4) Add ios platform\n\n\n# In openvidu-tutorials/openvidu-ionic\nionic cordova platform add ios\n\n\n\n\n5) Run the tutorial. The app will be automatically launched in your iOS device. First execution you'll need to trust your developer account in your device under \nSettings -\n General -\n Device management -\n your_apple_developer_account\n\n\n# In openvidu-tutorials/openvidu-ionic\nionic cordova run ios\n\n\n\n\nYou will need to sign your application in Xcode (opening folder \nopenvidu-ionic/platforms/ios\n) with your developer team to avoid any errors. From Apple \nofficial documentation\n:\n\n\n\n  \n\n\n\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\n\n\nUnderstanding the code\n\n\nThis is an Ionic project generated with ionic-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under \nsrc/app/\n folder:\n\n\n\n\napp.component.ts\n: defines \nAppComponent\n, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.\n\n\napp.component.html\n: HTML for AppComponent.\n\n\napp.component.css\n: CSS for AppComponent.\n\n\nuser-video.component.ts\n: defines \nUserVideoComponent\n, used to display every user video. It contains one \nOpenViduVideoComponent\n, the name of the user and also handles a click event to update the view of \nAppComponent\n.\n\n\nov-video.component.ts\n: defines \nOpenViduVideoComponent\n, which wraps the final HTML \nvideo\n that finally displays the media stream.\n\n\n\n\nLet's see first how \napp.component.ts\n uses NPM package \nopenvidu-browser\n:\n\n\n\n\nWe import the necessary objects from \nopenvidu-browser\n:\n\n\nimport { OpenVidu, Publisher, Session, StreamEvent, StreamManager, Subscriber } from 'openvidu-browser';\n\n\n\n\n\n\napp.component.ts\n declares the following properties:\n\n\n // OpenVidu objects\nOV: OpenVidu;\nsession: Session;\npublisher: StreamManager; // Local\nsubscribers: StreamManager[] = []; // Remotes\n\n// Join form\nmySessionId: string;\nmyUserName: string;\n\n\n\n\nOpenVidu\n object will allow us to get a \nSession\n object, which is declared just after it. \npublisher\n StreamManager object will be our own local webcam stream and \nsubscribers\n StreamManager array will store the active streams of other users in the video-call. Finally, \nmySessionId\n and \nmyUserName\n params simply represent the video-call and your participant's nickname, as you will see in a moment.\n\n\n\n\nWhenever a user clicks on the join button defined in \napp.component.html\n, \njoinSession()\n method is called:\n\n\n\n\nWe first get an OpenVidu object and initialize a Session object with it.\n\n\n// --- 1) Get an OpenVidu object ---\n\nthis.OV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nthis.session = this.OV.initSession();\n\n\n\n\nThen we subscribe to the Session events that interest us.\n\n\n // --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nthis.session.on('streamCreated', (event: StreamEvent) =\n {\n    // Subscribe to the Stream to receive it. Second parameter is undefined\n    // so OpenVidu doesn't create an HTML video on its own\n    const subscriber: Subscriber = this.session.subscribe(event.stream, undefined);\n    this.subscribers.push(subscriber);\n});\n\n// On every Stream destroyed...\nthis.session.on('streamDestroyed', (event: StreamEvent) =\n {\n    // Remove the stream from 'subscribers' array\n    this.deleteSubscriber(event.stream.streamManager);\n});\n\n\n\n\nAs we are using Ionic and Angular framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each \nSubscriber\n object and let it manage its video. This component will be our \nUserVideoComponent\n. To do this, we need to store each new Subscriber we received in array \nsubscribers\n (of its parent class \nStreamManager\n), and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events:\n\n\n\n\n\n\nstreamCreated\n: for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our \nsubscribers\n array. Method \nsession.subscribe\n has \nundefined\n as second parameter so OpenVidu doesn't insert an HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of \nAppComponent\n loops through \nsubscribers\n array with an \nngFor\n directive, declaring a \nUserVideoComponent\n for each subscriber. We feed them not really as \nSubscriber\n objects, but rather as their parent class \nStreamManager\n. This way we can reuse \nUserVideoComponent\n to also display our \nPublisher\n object (that also inherits from class StreamManager).\n\n\nion-col size=\"6\" *ngFor=\"let sub of subscribers\"\n\n  \ndiv class=\"stream-container\"\n\n    \nuser-video [streamManager]=\"sub\"\n/user-video\n\n  \n/div\n\n\n/ion-col\n\n\n\n\n\n\n\n\nstreamDestroyed\n: for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from \nsubscribers\n array, so Angular will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property \nstreamManager\n that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).\n\n\n\n\n\n\n\n\nGet a \ntoken\n from OpenVidu Server\n\n\n\n    \n\n\n\n    \nWARNING\n: This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session. \nThis process should entirely take place in our server-side\n, not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server\n\n\n\n\n\n\n// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then((token) =\n {\n    // See next point to see how to connect to the session using 'token'\n});\n\n\n\n\nNow we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the \nREST API\n, \nOpenVidu Java Client\n or \nOpenVidu Node Client\n. Here we have implemented the POST requests to OpenVidu Server in a method \ngetToken()\n that returns a Promise with the token, using \n@angular/http\n library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:\n\n\n\n\nFirst request performs a POST to \n/api/sessions\n (we send a \ncustomSessionId\n field to name the session with our \nmySessionId\n value retrieved from HTML input)\n\n\nSecond request performs a POST to \n/api/tokens\n (we send a \nsession\n field to assign the token to this same session)\n\n\n\n\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\n\n\nConnect to the session:\n\n\n// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then((token) =\n {\n    // First param is the token got from OpenVidu Server. Second param will be used by every user on event\n    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n    this.session\n        .connect(token, { clientData: this.myUserName })\n        .then(() =\n {\n            // --- 5) Requesting and Checking Android Permissions\n            if (this.platform.is('cordova')) {\n                // Ionic platform\n                if (this.platform.is('android')) {\n                    console.log('Android platform');\n                    this.checkAndroidPermissions()\n                        .then(() =\n this.initPublisher())\n                        .catch(err =\n console.error(err));\n                } else if (this.platform.is('ios')) {\n                    console.log('iOS platform');\n                    this.initPublisher();\n                }\n            } else {\n                this.initPublisher();\n            }\n        })\n        .catch(error =\n {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        });\n});\n\n\n\n\nIn \nsession.connect\n method first param is the recently retrieved user token. Second param is the value every user will receive in \nevent.stream.connection.data\n property on \nstreamCreated\n event (this value will be used by \nUserVideoComponent\n to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input \nion-input [(ngModel)]=\"myUserName\"\n/ion-input\n (filled by the user).\n\n\nIf the method succeeds and is running under a Cordova and Android platform, we will call and receive a promise from \ncheckAndroidPermissions()\n method. This method requests and checks the Android permissions that our app currently has in the device. Once the promise has been resolved, the \ninitPublisher()\n method will be called. For iOS  and web platforms, permissions will be handled automatically when camera and microphone access are requested. No need for extra steps in these cases, so we directly initialize our Publisher object.\n\n\nWe do further talk about Android permissions under section \nAndroid specific requirements\n.\n\n\nFinally publish your webcam calling \ninitPublisher()\n method:\n\n\ninitPublisher() {\n    // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video\n    // element: we will manage it on our own) and with the desired properties\n    const publisher: Publisher = this.OV.initPublisher(undefined, {\n        audioSource: undefined, // The source of audio. If undefined default microphone\n        videoSource: undefined, // The source of video. If undefined default webcam\n        publishAudio: true, // Whether you want to start publishing with your audio unmuted or not\n        publishVideo: true, // Whether you want to start publishing with your video enabled or not\n        resolution: '640x480', // The resolution of your video\n        frameRate: 30, // The frame rate of your video\n        insertMode: 'APPEND', // How the video is inserted in the target element 'video-container'\n        mirror: true // Whether to mirror your local video or not\n    });\n\n    // --- 6) Publish your stream ---\n\n    this.session.publish(publisher).then(() =\n {\n        // Store our Publisher\n        this.publisher = publisher;\n    });\n}\n\n\n\n\nWe now proceed to publish our webcam to the session. To do so we get a \nPublisher\n object with the desired properties and publish it to the Session through \nSession.publish()\n method. The rest of users will receive our Stream object and will execute their \nstreamCreated\n event.\n\n\nIn the callback of \nsession.publish\n we store the Publisher object under \nthis.publisher\n variable, which is also of parent class \nStreamManager\n. This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by \nUserVideoComponent\n):\n\n\ndiv *ngIf=\npublisher\n class=\nstream-container\n\n    \nuser-video [streamManager]=\npublisher\n/user-video\n\n\n/div\n\n\n\n\n\nLast point worth considering is the implementation of \nUserVideoComponent\n and \nOpenViduVideoComponent\n. Each \nUserVideoComponent\n manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component \nOpenViduVideoComponent\n . Its main task is not managing the final video player (that is \nOpenViduVideoComponent\n responsibility), but displaying custom information for each one of them (the user's nickname in this case):\n\n\ndiv\n\n    \nov-video [streamManager]=\nstreamManager\n/ov-video\n\n    \ndiv\np\n{% raw %}{{getNicknameTag()}}{% endraw %}\n/p\n/div\n\n\n/div\n\n\n\n\n\nexport class UserVideoComponent {\n\n    @Input()\n    streamManager: StreamManager;\n\n    getNicknameTag() {\n        try {\n            return JSON.parse(this.streamManager.stream.connection.data).clientData;\n        } catch (err) {\n            console.error('ClientData is not JSON formatted');\n        }\n    }\n}\n\n\n\n\nOpenViduVideoComponent\n html template is just the video element:\n\n\nvideo #videoElement\n/video\n\n\n\n\n\nAnd the responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method \nStreamManager.addVideoElement\n, which receives a native HTML video element. The way we implement this is Angular dependant: we get the video element with \n@ViewChild\n tag and we call the method once after the view has initialized (\nngAfterViewInit\n) and once every time the StreamManager input changes (\nset\n method with \n@Input\n tag)\n\n\nexport class OpenViduVideoComponent implements AfterViewInit, OnDestroy {\n\n    @ViewChild('videoElement') elementRef: ElementRef;\n    _streamManager: StreamManager;\n\n    ngAfterViewInit() {\n        this._streamManager.addVideoElement(this.elementRef.nativeElement);\n    }\n\n    @Input()\n    set streamManager(streamManager: StreamManager) {\n        this._streamManager = streamManager;\n    }\n}\n\n\n\n\nTo actually see the real implementation of this class, check out \niOS specific requirements\n section, as most of its code is just adjustments to make it work on iOS devices.\n\n\n\n\nLeaving the session:\n\n\nWhenever we want a user to leave the session, we just need to call \nsession.disconnect\n method in \napp.component.ts\n:\n\n\nleaveSession() {\n    // --- 7) Leave the session by calling 'disconnect' method over the Session object ---\n\n    if (this.session) {\n        this.session.disconnect();\n    }\n\n    // Empty all properties...\n    this.subscribers = [];\n    delete this.publisher;\n    delete this.session;\n    delete this.OV;\n    this.generateParticipantInfo();\n}\n\n\n\n\n\n\nAndroid specific requirements\n\n\nAndroid apps need to actively ask for permissions in the code to access camera and microphone. By following steps below we have been able to properly set up the permissions your Ionic app will need to work along OpenVidu.\n\n\nThese configurations are already included in this \nopenvidu-ionic\n project, so if you start from here no further configurations are needed. Otherwise, if you want to \nstart a new project with Ionic and OpenVidu\n, you should follow these simple steps:\n\n\n1) Install Cordova AndroidPermissions plugin\n\n\nionic cordova plugin add cordova-plugin-android-permissions\nnpm install --save @ionic-native/android-permissions@latest\n\n\n\n\n2) Add this plugin to your app's module (\nexample\n)\n\n\nimport { AndroidPermissions } from '@ionic-native/android-permissions/ngx';\n@NgModule({\n    providers: [\n        // others providers\n        AndroidPermissions,\n    ],\n)}\n\n\n\n\n3) Add this plugin to your component and use it (\nexample\n)\n\n\nimport { AndroidPermissions } from '@ionic-native/android-permissions/ngx';\n\nexport class AppComponent  {\n    constructor(private androidPermissions: AndroidPermissions)\n}\n\n\n\n\nWe are finally ready to request permissions to our device. To do so, we need to use \nrequestPermissions()\n and \ncheckPermission()\n methods offered by the plugin. \n\n\nIt is important to call these methods under \nplatform.ready()\n, just because it will tell us whenever the platform is ready and the native functionality can be actually called.\nYou can inspect this method in detail in the \nGitHub repo\n.\n\n\nYou should also declare an array of permissions to use as parameter of \nrequestPermissions()\n\n\nANDROID_PERMISSIONS = [\n    this.androidPermissions.PERMISSION.CAMERA,\n    this.androidPermissions.PERMISSION.RECORD_AUDIO,\n    this.androidPermissions.PERMISSION.MODIFY_AUDIO_SETTINGS\n];\n\n\n\n\n4) Last but not least, in \nroot\n directory you can find file \nconfig.xml\n. These permissions must be included inside of \nplatform name=\"android\"\n (\nexample\n)\n\n\nconfig-file mode=\nmerge\n parent=\n/*\n target=\nAndroidManifest.xml\n\n    \nuses-permission android:name=\nandroid.permission.CAMERA\n /\n\n    \nuses-permission android:name=\nandroid.permission.RECORD_AUDIO\n /\n\n    \nuses-permission android:name=\nandroid.permission.MODIFY_AUDIO_SETTINGS\n /\n\n\n/config-file\n\n\n\n\n\nMoreover, you must add \nxmlns:android=\"http://schemas.android.com/apk/res/android\"\n to the end of the opening \nwidget\n node.\n\n\nwidget id=\nio.openvidu.sampleios\n version=\n2.6.0\n xmlns=\nhttp://www.w3.org/ns/widgets\n xmlns:android=\nhttp://schemas.android.com/apk/res/android\n xmlns:cdv=\nhttp://cordova.apache.org/ns/1.0\n\n    ...\n\n/widget\n\n\n\n\n\nOnce these changes are added to our code, the app will be ready to run on our Android phone.\n\n\n\n\niOS specific requirements\n\n\nUnfortunately, Ionic's WebView layer on iOS devices (\nWKWebview\n) does not support WebRTC (blame Apple and its politics). So the only way to make WebRTC work on iOS Ionic platform is by using a plugin. The result works just fine, but a little work is needed to make your Ionic app compatible with iOS. OpenVidu makes use of \ncordova-plugin-iosrtc\n to achieve this.\n\n\nThis \nopenvidu-ionic\n project is ready to work on iOS devices, but we will go through every aspect related to iOS compatibility in case your already have an Ionic application in which you want to integrate OpenVidu.\n\n\nConfiguration requirements\n\n\n1) Install cordova-plugin-iosrtc and xcode\n\n\nionic cordova plugin add cordova-plugin-iosrtc\nnpm install xcode --save\n\n\n\n\n2) Add the following files to your Ionic app. Consider relative paths under root folder, the one containing your \npackage.json\n file\n\n\n\n\nhooks/iosrtc-swift-support.js\n (\ndownload file\n)\n\n\nsrc/assets/libs/adapter-4.0.1.js\n (\ndownload file\n)\n\n\n\n\n3) Add the following lines to \nconfig.xml\n file under ios platform:\n\n\nplatform name=\nios\n\n    ...\n    \nhook src=\nhooks/iosrtc-swift-support.js\n type=\nafter_platform_add\n /\n\n    \nconfig-file parent=\nNSCameraUsageDescription\n target=\n*-Info.plist\n\n        \nstring\nOpenVidu needs access to your camera\n/string\n\n    \n/config-file\n\n    \nconfig-file parent=\nNSContactsUsageDescription\n target=\n*-Info.plist\n\n        \nstring\nOpenVidu needs access to contacts\n/string\n\n    \n/config-file\n\n    \nconfig-file parent=\nNSMicrophoneUsageDescription\n target=\n*-Info.plist\n\n        \nstring\nOpenVidu needs access to your microphone\n/string\n\n    \n/config-file\n\n    ...\n\n/platform\n\n\n\n\n\n4) Add this optional dependency to your \npackage.json\n. Don't forget to run \nnpm install\n after that to actually install it\n\n\noptionalDependencies\n: {\n    \nios-deploy\n: \n1.9.4\n\n}\n\n\n\n\n5) Finally remove and reinstall ios platform\n\n\nionic cordova platform remove ios\nionic cordova platform add ios\n\n\n\n\nCode requirements\n\n\n1)\n Add to global styles the following rule. For example, in openvidu-ionic app it is done \nright here\n. This will allow us to put other HTML elements above the video elements.\n\n\nOne limitation for iOS is the background color of your app: we need it to be transparent to allow plugin videos to be visible behind the Ionic app. So you have 2 choices: you can have one video or many videos to fill all available space in the device's screen (which is in fact the most common layout in video conferencing apps for mobile phones) or you'll have to go with a white background if videos leave visible space in your app's layout.\n\n\n:root {\n    --ion-background-color: transparent;\n}\n\n\n\n\n2)\n Initialize \ncordova-plugin-iosrtc\n. The easiest way is doing so in \napp.component.ts\n constructor, using Platform library to identify iOS Ionic context. It is very important to initialize the plugin only for \niOS\n devices running a \ncordova\n app.\n\n\n// Import declarations...\ndeclare var cordova;\n\n...\n\n    constructor(private platform: Platform) {\n        if (this.platform.is('ios') \n this.platform.is('cordova')) {\n            cordova.plugins.iosrtc.registerGlobals();\n            // load adapter.js (version 4.0.1)\n            const script2 = document.createElement('script');\n            script2.type = 'text/javascript';\n            script2.src = 'assets/libs/adapter-4.0.1.js';\n            script2.async = false;\n            document.head.appendChild(script2);\n        }\n    }\n\n\n\n\n3)\n Every \nvideo\n element should be managed carefully on cordova iOS. The plugin inserts iOS native video elements whenever it finds an HTMLVideoElement, respecting certain CSS rules. In general, we recommend that at the moment you have video metadata, you apply programmatically the following styles: \nobject-fit\n, \nz-index\n, \nwidth\n and \nheight\n.\nIn openvidu-ionic app this is done as follows in file \nov-video.component.ts\n\n\nWe check if the platform is iOS with the following method: \n\n\nprivate isIos(): boolean {\n    return this.platform.is('ios') \n this.platform.is('cordova');\n}\n\n\n\n\nWe call the following \nupdateVideoView\n method inside \nngAfterViewInit\n, so our video elementRef is properly defined:\n\n\nprivate updateVideoView() {\n    this._streamManager.addVideoElement(this.elementRef.nativeElement);\n    if (this.isIos()) {\n        (\nHTMLVideoElement\nthis.elementRef.nativeElement).onloadedmetadata = () =\n {\n            this.applyIosIonicVideoAttributes();\n        };\n    }\n}\n\n\n\n\nWe call \napplyIosIonicVideoAttributes\n method only after the video element has triggered 'loadedmetadata' event. This way we know that the video has certain computed width and we can calculate the exact height it must have according to its aspect ratio, got from \nStream.videoDimensions\n. This is necessary because the plugin needs an exact width and height in order to paint the native iOS video. In this case, every video will have the full width of its container and the height will be obtained from the final computed width and the aspect ratio got from metadata  \nStream.videoDimensions\n.\n\n\nprivate applyIosIonicVideoAttributes() {\n    const ratio = this._streamManager.stream.videoDimensions.height / this._streamManager.stream.videoDimensions.width;\n    this.elementRef.nativeElement.style.width = '100% !important';\n    this.elementRef.nativeElement.style.objectFit = 'fill';\n    this.elementRef.nativeElement.style.zIndex = '-1';\n    const computedWidth = this.elementRef.nativeElement.offsetWidth;\n    this.elementRef.nativeElement.style.height = computedWidth * ratio + 'px';\n    if (!this._streamManager.remote) {\n        // It is a Publisher video. Custom iosrtc plugin mirror video\n        this.elementRef.nativeElement.style.transform = 'scaleX(-1)';\n    }\n    cordova.plugins.iosrtc.refreshVideos();\n}\n\n\n\n\nFinally we also need to listen to dynamic changes on the videos to refresh the plugin view. This includes 3 things:\n\n\n\n\nListen to \nstreamPropertyChanged\n event of StreamManager, and if \nvideoDimensions\n changes update the video element accordingly. In openvidu-ionic app we do so when setting StreamManager property in \nov-video.component.ts\n\n\n\n\n@Input()\nset streamManager(streamManager: StreamManager) {\n    this._streamManager = streamManager;\n    if (this.isIos()) {\n        this._streamManager.on('streamPropertyChanged', event =\n {\n            if ((\nStreamPropertyChangedEvent\nevent).changedProperty === 'videoDimensions') {\n                this.applyIosIonicVideoAttributes();\n            }\n        });\n    }\n}\n\n\n\n\n\n\nOnly if your app supports orientation changes\n: you will have to listen to \norientationchange\n window event for remote streams to update their video dimensions and adjust them to the new window ratio. openvidu-ionic app does this in method \nngAfterViewInit\n in \nov-video.component.ts\n. The timeout gives the video some time to refresh its properties before updating its view.\n\n\n\n\nngAfterViewInit() {\n    if (this.isIos() \n this._streamManager.remote) {\n        this.rotationFunction = () =\n {\n            // Give the remote video some time to update its dimensions when rotating the device\n            setTimeout(() =\n {\n                this.applyIosIonicVideoAttributes();\n            }, 250);\n        };\n        (\nany\nwindow).addEventListener('orientationchange', this.rotationFunction);\n    }\n    this.updateVideoView();\n}\n\n\n\n\n\n\nOnly if your app supports scrolling\n: if the view where your videos are gonna be displayed supports scrolling, then you will have to do the following: listen to scroll events in the required \nion-content\n element and call \ncordova.plugin.iosrtc.refreshVideos()\n method when triggered. If you don't do this, videos will stay fixed in their position, ignoring the scroll behavior.\n\n\n\n\nion-content [scrollEvents]=\ntrue\n (ionScroll)=\nrefreshVideos()\n\n\n\n\n\nrefreshVideos() {\n    if (this.platform.is('ios') \n this.platform.is('cordova')) {\n        cordova.plugins.iosrtc.refreshVideos();\n    }\n}\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-ionic"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#openvidu-ionic", 
            "text": "Check it on GitHub  A client-side only application built with  Ionic v4  and  Angular 7  frameworks. It can be compiled into a  native Android app , a  native iOS app  and into a standard  web app .  If it is the first time you use OpenVidu, it is highly recommended to start first with  openvidu-hello-world  tutorial due to this being a cordova ionic app and being a little more complex for OpenVidu starters.  \n      \n    Android 5 (Lollipop) and 6 (Marshmallow) will not work with Ionic v4 until  this issue  is properly solved", 
            "title": "openvidu-ionic"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : NPM package for your Ionic app. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#running-this-tutorial", 
            "text": "1) You will need  Node ,  NPM ,  Ionic  and  Cordova  to serve the app. Install them with the following command  sudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\nsudo npm install -g ionic@latest\nsudo npm install -g cordova@latest  2) Clone the repo  git clone https://github.com/OpenVidu/openvidu-tutorials.git  3) Install dependencies  cd openvidu-tutorials/openvidu-ionic\nnpm install  Now depending on the platform you want to run your app...", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#in-the-browser", 
            "text": "4) Run the tutorial  # In openvidu-tutorials/openvidu-ionic\nionic serve  5)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE )  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  6) Go to  localhost:8100  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.  7) To show the app with the device appearance, press  F12  button in your keyboard and the browser DevTools will be opened. You can find a button with a device icon at the top of the DevTools. By pressing this button the view will adapt to a mobile device aspect ratio. You can also choose predefined types of devices to see the behavior of your app in different resolutions.  \n     \n         \n         \n     \n     \n     \n         \n         \n     \n         If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "In the browser"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#in-an-android-device-with-native-app", 
            "text": "To deploy the Android APK not only you need to have  Java JDK8 ,  Android Studio  and  Android SDK  installed but also you have to set up the specific  environment variables . Fortunately, Ionic provide us a  great guide  to allows us to configure step by step all the requirements.  After we have completed all the steps of the Ionic guide and performed steps 1) , 2) and 3) stated above, we must continue with the following commands:   4) Connect the device to the same network as your PC  5) Now you need the IP of your PC in the network. In Linux/OSX you can simply get it by running this command on your shell  awk '/inet /   $2 !=  127.0.0.1 {print $2}'  (ifconfig)   It will probably output something like  192.168.0.105 . Your  complete OpenVidu public url  would then be  https://192.168.0.105:4443/   When you have your OpenVidu public url, you must set it in  OPENVIDU_SERVER_URL  variable  in the app  and in the  openvidu.publicurl  parameter used to run  openvidu-server  (see next point)  6)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE )  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=YOUR_OPENVIDU_PUBLIC_URL openvidu/openvidu-server-kms:2.8.0   Remember changing  openvidu.publicurl  parameter to the actual value. In this example that would be: -e openvidu.publicurl=https://192.168.0.105:4443/   7) Connect the device to the PC. You must enable USB debugging and give permissions (check out  last section here in Ionic docs )  8) Run the tutorial. The app will be automatically launched in your Android device  # In openvidu-tutorials/openvidu-ionic\nionic cordova run android", 
            "title": "In an Android device with native app"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#in-an-ios-device-with-native-app", 
            "text": "To deploy the iOS app you will need first to follow  this guide  to properly configure your development environment. Then, it is crucial to have an OpenVidu Server properly deployed with a  valid certificate .  \n      \n    iOS devices will require OpenVidu Server to be deployed in a valid domain well-protected with a certificate. No iPhone or iPad will allow connections to a non-secure OpenVidu Server from within a native application. To facilitate first steps with OpenVidu and Ionic on iOS devices, if no custom url is defined  here in the app  then our demos OpenVidu Server will be used.  Note: this is a publicly accessible OpenVidu Server. Anyone could access your sessions. Use it only for an initial test and under your own responsibility    After we have completed all the steps of the Ionic guide and performed steps 1), 2) and 3) stated above, we must continue with the following commands:   4) Add ios platform  # In openvidu-tutorials/openvidu-ionic\nionic cordova platform add ios  5) Run the tutorial. The app will be automatically launched in your iOS device. First execution you'll need to trust your developer account in your device under  Settings -  General -  Device management -  your_apple_developer_account  # In openvidu-tutorials/openvidu-ionic\nionic cordova run ios  You will need to sign your application in Xcode (opening folder  openvidu-ionic/platforms/ios ) with your developer team to avoid any errors. From Apple  official documentation :", 
            "title": "In an iOS device with native app"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#understanding-the-code", 
            "text": "This is an Ionic project generated with ionic-cli tool, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under  src/app/  folder:   app.component.ts : defines  AppComponent , main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.  app.component.html : HTML for AppComponent.  app.component.css : CSS for AppComponent.  user-video.component.ts : defines  UserVideoComponent , used to display every user video. It contains one  OpenViduVideoComponent , the name of the user and also handles a click event to update the view of  AppComponent .  ov-video.component.ts : defines  OpenViduVideoComponent , which wraps the final HTML  video  that finally displays the media stream.   Let's see first how  app.component.ts  uses NPM package  openvidu-browser :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#we-import-the-necessary-objects-from-openvidu-browser", 
            "text": "import { OpenVidu, Publisher, Session, StreamEvent, StreamManager, Subscriber } from 'openvidu-browser';", 
            "title": "We import the necessary objects from openvidu-browser:"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#appcomponentts-declares-the-following-properties", 
            "text": "// OpenVidu objects\nOV: OpenVidu;\nsession: Session;\npublisher: StreamManager; // Local\nsubscribers: StreamManager[] = []; // Remotes\n\n// Join form\nmySessionId: string;\nmyUserName: string;  OpenVidu  object will allow us to get a  Session  object, which is declared just after it.  publisher  StreamManager object will be our own local webcam stream and  subscribers  StreamManager array will store the active streams of other users in the video-call. Finally,  mySessionId  and  myUserName  params simply represent the video-call and your participant's nickname, as you will see in a moment.", 
            "title": "app.component.ts declares the following properties:"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#whenever-a-user-clicks-on-the-join-button-defined-in-appcomponenthtml-joinsession-method-is-called", 
            "text": "We first get an OpenVidu object and initialize a Session object with it.  // --- 1) Get an OpenVidu object ---\n\nthis.OV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nthis.session = this.OV.initSession();  Then we subscribe to the Session events that interest us.   // --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nthis.session.on('streamCreated', (event: StreamEvent) =  {\n    // Subscribe to the Stream to receive it. Second parameter is undefined\n    // so OpenVidu doesn't create an HTML video on its own\n    const subscriber: Subscriber = this.session.subscribe(event.stream, undefined);\n    this.subscribers.push(subscriber);\n});\n\n// On every Stream destroyed...\nthis.session.on('streamDestroyed', (event: StreamEvent) =  {\n    // Remove the stream from 'subscribers' array\n    this.deleteSubscriber(event.stream.streamManager);\n});  As we are using Ionic and Angular framework, a good approach for managing the remote media streams is to loop across an array of them, feeding a common component with each  Subscriber  object and let it manage its video. This component will be our  UserVideoComponent . To do this, we need to store each new Subscriber we received in array  subscribers  (of its parent class  StreamManager ), and we must remove from it every deleted subscriber whenever it is necessary. To achieve this, we use the following events:    streamCreated : for each new Stream received by the Session object, we subscribe to it and store the returned Subscriber object in our  subscribers  array. Method  session.subscribe  has  undefined  as second parameter so OpenVidu doesn't insert an HTML video element in the DOM on its own (we will use the video element contained in one of our child components). HTML template of  AppComponent  loops through  subscribers  array with an  ngFor  directive, declaring a  UserVideoComponent  for each subscriber. We feed them not really as  Subscriber  objects, but rather as their parent class  StreamManager . This way we can reuse  UserVideoComponent  to also display our  Publisher  object (that also inherits from class StreamManager).  ion-col size=\"6\" *ngFor=\"let sub of subscribers\" \n   div class=\"stream-container\" \n     user-video [streamManager]=\"sub\" /user-video \n   /div  /ion-col     streamDestroyed : for each Stream that has been destroyed from the Session object (which means a user has left the video-call), we remove the associated Subscriber from  subscribers  array, so Angular will automatically delete the required UserVideoComponent from HTML. Each Stream object has a property  streamManager  that indicates which Subscriber or Publisher owns it (in the same way, each StreamManager object also has a reference to its Stream).", 
            "title": "Whenever a user clicks on the join button defined in app.component.html, joinSession() method is called:"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#get-a-token-from-openvidu-server", 
            "text": "WARNING : This is why this tutorial is an insecure application. We need to ask OpenVidu Server for a user token in order to connect to our session.  This process should entirely take place in our server-side , not in our client-side. But due to the lack of an application backend in this tutorial, the Angular front itself will perform the POST operations to OpenVidu Server   // --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then((token) =  {\n    // See next point to see how to connect to the session using 'token'\n});  Now we need a token from OpenVidu Server. In a production environment we would perform this operations in our application backend, by making use of the  REST API ,  OpenVidu Java Client  or  OpenVidu Node Client . Here we have implemented the POST requests to OpenVidu Server in a method  getToken()  that returns a Promise with the token, using  @angular/http  library. Without going into too much detail, this method performs two POST requests to OpenVidu Server, passing OpenVidu Server secret to authenticate them:   First request performs a POST to  /api/sessions  (we send a  customSessionId  field to name the session with our  mySessionId  value retrieved from HTML input)  Second request performs a POST to  /api/tokens  (we send a  session  field to assign the token to this same session)   You can inspect this method in detail in the  GitHub repo .", 
            "title": "Get a token from OpenVidu Server"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#connect-to-the-session", 
            "text": "// --- 4) Connect to the session with a valid user token ---\n\n// 'getToken' method is simulating what your server-side should do.\n// 'token' parameter should be retrieved and returned by your own backend\nthis.getToken().then((token) =  {\n    // First param is the token got from OpenVidu Server. Second param will be used by every user on event\n    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n    this.session\n        .connect(token, { clientData: this.myUserName })\n        .then(() =  {\n            // --- 5) Requesting and Checking Android Permissions\n            if (this.platform.is('cordova')) {\n                // Ionic platform\n                if (this.platform.is('android')) {\n                    console.log('Android platform');\n                    this.checkAndroidPermissions()\n                        .then(() =  this.initPublisher())\n                        .catch(err =  console.error(err));\n                } else if (this.platform.is('ios')) {\n                    console.log('iOS platform');\n                    this.initPublisher();\n                }\n            } else {\n                this.initPublisher();\n            }\n        })\n        .catch(error =  {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        });\n});  In  session.connect  method first param is the recently retrieved user token. Second param is the value every user will receive in  event.stream.connection.data  property on  streamCreated  event (this value will be used by  UserVideoComponent  to append the user's nickname to the his video). So in this case it is an object with a property \"clientData\" with value \"myUserName\", which is binded from HTML input  ion-input [(ngModel)]=\"myUserName\" /ion-input  (filled by the user).  If the method succeeds and is running under a Cordova and Android platform, we will call and receive a promise from  checkAndroidPermissions()  method. This method requests and checks the Android permissions that our app currently has in the device. Once the promise has been resolved, the  initPublisher()  method will be called. For iOS  and web platforms, permissions will be handled automatically when camera and microphone access are requested. No need for extra steps in these cases, so we directly initialize our Publisher object.  We do further talk about Android permissions under section  Android specific requirements .", 
            "title": "Connect to the session:"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#finally-publish-your-webcam-calling-initpublisher-method", 
            "text": "initPublisher() {\n    // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video\n    // element: we will manage it on our own) and with the desired properties\n    const publisher: Publisher = this.OV.initPublisher(undefined, {\n        audioSource: undefined, // The source of audio. If undefined default microphone\n        videoSource: undefined, // The source of video. If undefined default webcam\n        publishAudio: true, // Whether you want to start publishing with your audio unmuted or not\n        publishVideo: true, // Whether you want to start publishing with your video enabled or not\n        resolution: '640x480', // The resolution of your video\n        frameRate: 30, // The frame rate of your video\n        insertMode: 'APPEND', // How the video is inserted in the target element 'video-container'\n        mirror: true // Whether to mirror your local video or not\n    });\n\n    // --- 6) Publish your stream ---\n\n    this.session.publish(publisher).then(() =  {\n        // Store our Publisher\n        this.publisher = publisher;\n    });\n}  We now proceed to publish our webcam to the session. To do so we get a  Publisher  object with the desired properties and publish it to the Session through  Session.publish()  method. The rest of users will receive our Stream object and will execute their  streamCreated  event.  In the callback of  session.publish  we store the Publisher object under  this.publisher  variable, which is also of parent class  StreamManager . This way our webcam will be appended along all remote subscribers, in exactly the same way they are shown (remember all of them are displayed by  UserVideoComponent ):  div *ngIf= publisher  class= stream-container \n     user-video [streamManager]= publisher /user-video  /div   Last point worth considering is the implementation of  UserVideoComponent  and  OpenViduVideoComponent . Each  UserVideoComponent  manages one StreamManager object (a Subscriber or a Publisher) that will be fed to its child component  OpenViduVideoComponent  . Its main task is not managing the final video player (that is  OpenViduVideoComponent  responsibility), but displaying custom information for each one of them (the user's nickname in this case):  div \n     ov-video [streamManager]= streamManager /ov-video \n     div p {% raw %}{{getNicknameTag()}}{% endraw %} /p /div  /div   export class UserVideoComponent {\n\n    @Input()\n    streamManager: StreamManager;\n\n    getNicknameTag() {\n        try {\n            return JSON.parse(this.streamManager.stream.connection.data).clientData;\n        } catch (err) {\n            console.error('ClientData is not JSON formatted');\n        }\n    }\n}  OpenViduVideoComponent  html template is just the video element:  video #videoElement /video   And the responsibility of the component's logic is letting OpenVidu know the exact HTML DOM video player associated to its StreamManger. To do so we use method  StreamManager.addVideoElement , which receives a native HTML video element. The way we implement this is Angular dependant: we get the video element with  @ViewChild  tag and we call the method once after the view has initialized ( ngAfterViewInit ) and once every time the StreamManager input changes ( set  method with  @Input  tag)  export class OpenViduVideoComponent implements AfterViewInit, OnDestroy {\n\n    @ViewChild('videoElement') elementRef: ElementRef;\n    _streamManager: StreamManager;\n\n    ngAfterViewInit() {\n        this._streamManager.addVideoElement(this.elementRef.nativeElement);\n    }\n\n    @Input()\n    set streamManager(streamManager: StreamManager) {\n        this._streamManager = streamManager;\n    }\n}  To actually see the real implementation of this class, check out  iOS specific requirements  section, as most of its code is just adjustments to make it work on iOS devices.", 
            "title": "Finally publish your webcam calling initPublisher() method:"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#leaving-the-session", 
            "text": "Whenever we want a user to leave the session, we just need to call  session.disconnect  method in  app.component.ts :  leaveSession() {\n    // --- 7) Leave the session by calling 'disconnect' method over the Session object ---\n\n    if (this.session) {\n        this.session.disconnect();\n    }\n\n    // Empty all properties...\n    this.subscribers = [];\n    delete this.publisher;\n    delete this.session;\n    delete this.OV;\n    this.generateParticipantInfo();\n}", 
            "title": "Leaving the session:"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#android-specific-requirements", 
            "text": "Android apps need to actively ask for permissions in the code to access camera and microphone. By following steps below we have been able to properly set up the permissions your Ionic app will need to work along OpenVidu.  These configurations are already included in this  openvidu-ionic  project, so if you start from here no further configurations are needed. Otherwise, if you want to  start a new project with Ionic and OpenVidu , you should follow these simple steps:  1) Install Cordova AndroidPermissions plugin  ionic cordova plugin add cordova-plugin-android-permissions\nnpm install --save @ionic-native/android-permissions@latest  2) Add this plugin to your app's module ( example )  import { AndroidPermissions } from '@ionic-native/android-permissions/ngx';\n@NgModule({\n    providers: [\n        // others providers\n        AndroidPermissions,\n    ],\n)}  3) Add this plugin to your component and use it ( example )  import { AndroidPermissions } from '@ionic-native/android-permissions/ngx';\n\nexport class AppComponent  {\n    constructor(private androidPermissions: AndroidPermissions)\n}  We are finally ready to request permissions to our device. To do so, we need to use  requestPermissions()  and  checkPermission()  methods offered by the plugin.   It is important to call these methods under  platform.ready() , just because it will tell us whenever the platform is ready and the native functionality can be actually called.\nYou can inspect this method in detail in the  GitHub repo .  You should also declare an array of permissions to use as parameter of  requestPermissions()  ANDROID_PERMISSIONS = [\n    this.androidPermissions.PERMISSION.CAMERA,\n    this.androidPermissions.PERMISSION.RECORD_AUDIO,\n    this.androidPermissions.PERMISSION.MODIFY_AUDIO_SETTINGS\n];  4) Last but not least, in  root  directory you can find file  config.xml . These permissions must be included inside of  platform name=\"android\"  ( example )  config-file mode= merge  parent= /*  target= AndroidManifest.xml \n     uses-permission android:name= android.permission.CAMERA  / \n     uses-permission android:name= android.permission.RECORD_AUDIO  / \n     uses-permission android:name= android.permission.MODIFY_AUDIO_SETTINGS  /  /config-file   Moreover, you must add  xmlns:android=\"http://schemas.android.com/apk/res/android\"  to the end of the opening  widget  node.  widget id= io.openvidu.sampleios  version= 2.6.0  xmlns= http://www.w3.org/ns/widgets  xmlns:android= http://schemas.android.com/apk/res/android  xmlns:cdv= http://cordova.apache.org/ns/1.0 \n    ... /widget   Once these changes are added to our code, the app will be ready to run on our Android phone.", 
            "title": "Android specific requirements"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#ios-specific-requirements", 
            "text": "Unfortunately, Ionic's WebView layer on iOS devices ( WKWebview ) does not support WebRTC (blame Apple and its politics). So the only way to make WebRTC work on iOS Ionic platform is by using a plugin. The result works just fine, but a little work is needed to make your Ionic app compatible with iOS. OpenVidu makes use of  cordova-plugin-iosrtc  to achieve this.  This  openvidu-ionic  project is ready to work on iOS devices, but we will go through every aspect related to iOS compatibility in case your already have an Ionic application in which you want to integrate OpenVidu.", 
            "title": "iOS specific requirements"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#configuration-requirements", 
            "text": "1) Install cordova-plugin-iosrtc and xcode  ionic cordova plugin add cordova-plugin-iosrtc\nnpm install xcode --save  2) Add the following files to your Ionic app. Consider relative paths under root folder, the one containing your  package.json  file   hooks/iosrtc-swift-support.js  ( download file )  src/assets/libs/adapter-4.0.1.js  ( download file )   3) Add the following lines to  config.xml  file under ios platform:  platform name= ios \n    ...\n     hook src= hooks/iosrtc-swift-support.js  type= after_platform_add  / \n     config-file parent= NSCameraUsageDescription  target= *-Info.plist \n         string OpenVidu needs access to your camera /string \n     /config-file \n     config-file parent= NSContactsUsageDescription  target= *-Info.plist \n         string OpenVidu needs access to contacts /string \n     /config-file \n     config-file parent= NSMicrophoneUsageDescription  target= *-Info.plist \n         string OpenVidu needs access to your microphone /string \n     /config-file \n    ... /platform   4) Add this optional dependency to your  package.json . Don't forget to run  npm install  after that to actually install it  optionalDependencies : {\n     ios-deploy :  1.9.4 \n}  5) Finally remove and reinstall ios platform  ionic cordova platform remove ios\nionic cordova platform add ios", 
            "title": "Configuration requirements"
        }, 
        {
            "location": "/tutorials/openvidu-ionic/#code-requirements", 
            "text": "1)  Add to global styles the following rule. For example, in openvidu-ionic app it is done  right here . This will allow us to put other HTML elements above the video elements.  One limitation for iOS is the background color of your app: we need it to be transparent to allow plugin videos to be visible behind the Ionic app. So you have 2 choices: you can have one video or many videos to fill all available space in the device's screen (which is in fact the most common layout in video conferencing apps for mobile phones) or you'll have to go with a white background if videos leave visible space in your app's layout.  :root {\n    --ion-background-color: transparent;\n}  2)  Initialize  cordova-plugin-iosrtc . The easiest way is doing so in  app.component.ts  constructor, using Platform library to identify iOS Ionic context. It is very important to initialize the plugin only for  iOS  devices running a  cordova  app.  // Import declarations...\ndeclare var cordova;\n\n...\n\n    constructor(private platform: Platform) {\n        if (this.platform.is('ios')   this.platform.is('cordova')) {\n            cordova.plugins.iosrtc.registerGlobals();\n            // load adapter.js (version 4.0.1)\n            const script2 = document.createElement('script');\n            script2.type = 'text/javascript';\n            script2.src = 'assets/libs/adapter-4.0.1.js';\n            script2.async = false;\n            document.head.appendChild(script2);\n        }\n    }  3)  Every  video  element should be managed carefully on cordova iOS. The plugin inserts iOS native video elements whenever it finds an HTMLVideoElement, respecting certain CSS rules. In general, we recommend that at the moment you have video metadata, you apply programmatically the following styles:  object-fit ,  z-index ,  width  and  height .\nIn openvidu-ionic app this is done as follows in file  ov-video.component.ts  We check if the platform is iOS with the following method:   private isIos(): boolean {\n    return this.platform.is('ios')   this.platform.is('cordova');\n}  We call the following  updateVideoView  method inside  ngAfterViewInit , so our video elementRef is properly defined:  private updateVideoView() {\n    this._streamManager.addVideoElement(this.elementRef.nativeElement);\n    if (this.isIos()) {\n        ( HTMLVideoElement this.elementRef.nativeElement).onloadedmetadata = () =  {\n            this.applyIosIonicVideoAttributes();\n        };\n    }\n}  We call  applyIosIonicVideoAttributes  method only after the video element has triggered 'loadedmetadata' event. This way we know that the video has certain computed width and we can calculate the exact height it must have according to its aspect ratio, got from  Stream.videoDimensions . This is necessary because the plugin needs an exact width and height in order to paint the native iOS video. In this case, every video will have the full width of its container and the height will be obtained from the final computed width and the aspect ratio got from metadata   Stream.videoDimensions .  private applyIosIonicVideoAttributes() {\n    const ratio = this._streamManager.stream.videoDimensions.height / this._streamManager.stream.videoDimensions.width;\n    this.elementRef.nativeElement.style.width = '100% !important';\n    this.elementRef.nativeElement.style.objectFit = 'fill';\n    this.elementRef.nativeElement.style.zIndex = '-1';\n    const computedWidth = this.elementRef.nativeElement.offsetWidth;\n    this.elementRef.nativeElement.style.height = computedWidth * ratio + 'px';\n    if (!this._streamManager.remote) {\n        // It is a Publisher video. Custom iosrtc plugin mirror video\n        this.elementRef.nativeElement.style.transform = 'scaleX(-1)';\n    }\n    cordova.plugins.iosrtc.refreshVideos();\n}  Finally we also need to listen to dynamic changes on the videos to refresh the plugin view. This includes 3 things:   Listen to  streamPropertyChanged  event of StreamManager, and if  videoDimensions  changes update the video element accordingly. In openvidu-ionic app we do so when setting StreamManager property in  ov-video.component.ts   @Input()\nset streamManager(streamManager: StreamManager) {\n    this._streamManager = streamManager;\n    if (this.isIos()) {\n        this._streamManager.on('streamPropertyChanged', event =  {\n            if (( StreamPropertyChangedEvent event).changedProperty === 'videoDimensions') {\n                this.applyIosIonicVideoAttributes();\n            }\n        });\n    }\n}   Only if your app supports orientation changes : you will have to listen to  orientationchange  window event for remote streams to update their video dimensions and adjust them to the new window ratio. openvidu-ionic app does this in method  ngAfterViewInit  in  ov-video.component.ts . The timeout gives the video some time to refresh its properties before updating its view.   ngAfterViewInit() {\n    if (this.isIos()   this._streamManager.remote) {\n        this.rotationFunction = () =  {\n            // Give the remote video some time to update its dimensions when rotating the device\n            setTimeout(() =  {\n                this.applyIosIonicVideoAttributes();\n            }, 250);\n        };\n        ( any window).addEventListener('orientationchange', this.rotationFunction);\n    }\n    this.updateVideoView();\n}   Only if your app supports scrolling : if the view where your videos are gonna be displayed supports scrolling, then you will have to do the following: listen to scroll events in the required  ion-content  element and call  cordova.plugin.iosrtc.refreshVideos()  method when triggered. If you don't do this, videos will stay fixed in their position, ignoring the scroll behavior.   ion-content [scrollEvents]= true  (ionScroll)= refreshVideos()   refreshVideos() {\n    if (this.platform.is('ios')   this.platform.is('cordova')) {\n        cordova.plugins.iosrtc.refreshVideos();\n    }\n}    \n  $().fancybox({\n    selector : '[data-fancybox]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Code requirements"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/", 
            "text": "openvidu-js-java\n\n\n Check it on GitHub\n\n\nA secure OpenVidu sample app with a Java backend and a SPA frontend. It makes use of \nopenvidu-java-client\n to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to \nopenvidu-mvc-java\n. This tutorial is intended for developers who feel more comfortable with a SPA (Single Page Application) architecture for their frontends.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-java-client\n: server SDK for Java. Quick alternative to REST API\n\n\nopenvidu-server\n: application to control Kurento Media Server\n\n\nKurento Media Server\n: handles low level operations of media flow transmissions\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need \nmaven\n to build the project. You can install it with:\n\n\nsudo apt-get install maven\n\n\n\n\n3) Run the tutorial:\n\n\ncd openvidu-tutorials/openvidu-js-java\nmvn package exec:java\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nHttpSession\n API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: \njournaldev.com\n, \nstudytonight.com\n.\n\n\n\n\n\n\nBackend\n: SpringBoot app with the following classes (\nsrc/main/java\n path, \nio.openvidu.js.java\n package)\n\n\n\n\nApp.java\n : entrypoint for the app\n\n\nLoginController.java\n : rest controller for handling login and logout operations\n\n\nSessionController.java\n : rest controller for getting OpenVidu tokens. It also stores our active video-calls and the users connected to them\n\n\n\n\n\n\n\n\nFrontend\n: Plain JS/HTML/CSS files (\nsrc/main/resources/static\n)\n\n\n\n\nopenvidu-browser-VERSION.js\n : openvidu-browser library. You don't have to manipulate this file.\n\n\napp.js\n : sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n.\n\n\n\n\nindex.html\n : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:\n\n\nscript src=\"openvidu-browser-VERSION.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n.\n\n\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nWe have implemented a method for making HTTP POST requests to the backend, as we will need to make at least three of them: one for logging in, one for getting a token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:\n\n\nfunction httpPostRequest(url, body, errorMsg, callback)\n\n\n\n\nWhere \nurl\n is the path of the POST operation, \nbody\n the object to send as data, \nerrorMsg\n the output error message if something goes wrong and \ncallback\n the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.\n\n\nindex.html\n will first show a form to log in:\n\n\n\n  \n\n\n\n\n\napp.js\n sends a POST request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:\n\n\nfunction logIn() {\n    var user = $(\n#user\n).val(); // Username\n    var pass = $(\n#pass\n).val(); // Password\n\n    httpPostRequest(\n        'api-login/login',\n        {user: user, pass: pass},\n        'Login WRONG',\n        (response) =\n {\n            // HTML shows logged-in page ...\n        }\n    );\n}\n\n\n\n\nLoginController.java\n checks the params are correct and if so sets an \nHttpSession\n for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object):\n\n\n@RequestMapping(value = \n/login\n, method = RequestMethod.POST)\npublic ResponseEntity\nObject\n login(@RequestBody String userPass, HttpSession httpSession) \n    throws ParseException {\n\n    System.out.println(\nLogging in | {user, pass}=\n + userPass);\n    // Retrieve params from POST body\n    JSONObject userPassJson = (JSONObject) new JSONParser().parse(userPass);\n    String user = (String) userPassJson.get(\nuser\n);\n    String pass = (String) userPassJson.get(\npass\n);\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute(\nloggedUser\n, user);\n        return new ResponseEntity\n(HttpStatus.OK);\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        httpSession.invalidate();\n        return new ResponseEntity\n(\nUser/Pass incorrect\n, HttpStatus.UNAUTHORIZED);\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\nHTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:\n\n\n\n  \n\n\n\n\n\napp.js\n will execute \njoinSession()\n method, which starts like this:\n\n\nfunction joinSession() {\n    getToken((token) =\n { ...\n\n\n\n\nSo the first thing to do here is to retrieve an OpenVidu \ntoken\n from our backend. Only when we have it available in the browser we will continue with the \njoin\n operation. Let's see what \ngetToken()\n looks like:\n\n\nfunction getToken(callback) {\n    sessionName = $(\n#sessionName\n).val(); // Video-call chosen by the user\n\n    httpPostRequest(\n        'api-sessions/get-token',\n        {sessionName: sessionName},\n        'Request of TOKEN gone WRONG:',\n        (response) =\n {\n            token = response[0]; // Get token from response\n            console.warn('Request of TOKEN gone WELL (TOKEN:' + token + ')');\n            callback(token); // Continue the join operation\n        }\n    );\n}\n\n\n\n\nHere is the second time we must call our \nhttpPostRequest()\n method, sending the session we want to connect (\nsessionName\n parameter) and waiting to get a \ntoken\n as response. The interesting part here is in \nSessionController.java\n at \n/api-sessions/get-token\n. First of all there are some important attributes in this class we must mention:\n\n\n// OpenVidu object as entrypoint of the SDK\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map\nString, Session\n mapSessions = new ConcurrentHashMap\n();\n// Collection to pair session names and tokens (the inner Map pairs tokens and role associated)\nprivate Map\nString, Map\nString, OpenViduRole\n mapSessionNamesTokens = new ConcurrentHashMap\n();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;\n\n\n\n\nRest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: \ntokenOptions\n.\n\n\n@RequestMapping(value = \n/get-token\n, method = RequestMethod.POST)\n    public ResponseEntity\nJSONObject\n getToken(@RequestBody String sessionNameParam,\n        HttpSession httpSession) throws ParseException {\n\n    // ... check the user is logged with HttpSession and continue ...\n\n    JSONObject sessionJSON = (JSONObject) new JSONParser().parse(sessionNameParam);\n\n    // The video-call to connect (\nTUTORIAL\n)\n    String sessionName = (String) sessionJSON.get(\nsessionName\n);\n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\nloggedUser\n)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData = \n{\\\nserverData\\\n: \\\n + httpSession.getAttribute(\nloggedUser\n) + \n\\\n}\n;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n    JSONObject responseJson = new JSONObject();\n\n\n\n\nJust after that we check if the session \"TUTORIAL\" already exists\n\n\nif (this.mapSessions.get(sessionName) != null) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we directly create a new session:\n\n\n// New session\nSystem.out.println(\nNew session \n + sessionName);\ntry {\n\n    // Create a new OpenVidu Session\n    Session session = this.openVidu.createSession();\n    // Generate a new token with the recently created tokenOptions\n    String token = session.generateToken(tokenOptions);\n\n    // Store the session and the token in our collections\n    this.mapSessions.put(sessionName, session);\n    this.mapSessionNamesTokens.put(sessionName, new ConcurrentHashMap\n());\n    this.mapSessionNamesTokens.get(sessionName).put(token, role);\n\n    // Prepare the response with the token\n    responseJson.put(0, token);\n\n    // Return the response to the client\n    return new ResponseEntity\n(responseJson, HttpStatus.OK);\n\n} catch (Exception e) {\n    // If error generate an error message and return it to client\n    return getErrorResponse(e);\n}\n\n\n\n\nWe are almost there! Now in \napp.js\n we can init a new Session and connect to it with \ntoken\n:\n\n\n// --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', (event) =\n {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', (event) =\n {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', (event) =\n {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n// --- 4) Connect to the session passing the retrieved token and some more data from\n//        the client (in this case a JSON with the nickname chosen by the user) ---\n\nvar nickName = $(\n#nickName\n).val();\nsession.connect(token, { clientData: nickName })\n    .then(() =\n {\n\n        // --- 5) Set page layout for active call ---\n\n        var userName = $(\n#user\n).val();\n        $('#session-title').text(sessionName);\n        $('#join').hide();\n        $('#session').show();\n\n\n        // Here we check somehow if the user has 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method is not recognized as 'PUBLIHSER' role by OpenVidu Server\n        if (isPublisher(userName)) {\n\n            // --- 6) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', (event) =\n {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    })\n    .catch(error =\n {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    });\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nSessionController.java\n executes \ngetToken()\n method. Now session 'TUTORIAL' already exists, so now we do enter the \nif\n branch that we ignored in the previous step:\n\n\nif (this.mapSessions.get(sessionName) != null) {\n    // Session already exists\n    System.out.println(\nExisting session \n + sessionName);\n    try {\n\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionNamesTokens.get(sessionName).put(token, role);\n\n        // Prepare the response with the token\n        responseJson.put(0, token);\n\n        // Return the response to the client\n        return new ResponseEntity\n(responseJson, HttpStatus.OK);\n    } catch (OpenViduJavaClientException e1) {\n        // If internal error generate an error message and return it to client\n        return getErrorResponse(e1);\n    } catch (OpenViduHttpException e2) {\n        if (404 == e2.getStatus()) {\n            // Invalid sessionId (user left unexpectedly). Session object is not valid\n            // anymore. Clean collections and continue as new session\n            this.mapSessions.remove(sessionName);\n            this.mapSessionNamesTokens.remove(sessionName);\n        }\n    }\n}\n\n\n\n\nThe code executed in \napp.js\n would also be the same. After the \nSession.publish()\n method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nleaveSession()\n (and therefore \nsession.disconnect()\n) to destroy the connection on OpenVidu Server, we need to run the last POST operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, \nsession.disconnect()\n updates our OpenVidu Server and the POST operation updates our application's backend.\nFor the POST operation, in \napp.js\n we run:\n\n\nfunction removeUser() {\n    httpPostRequest(\n        'api-sessions/remove-user',\n        {sessionName: sessionName, token: token},\n        'User couldn\\'t be removed from session',\n        (response) =\n {\n            console.warn(\nYou have been removed from session \n + sessionName);\n        }\n    );\n}\n\n\n\n\nAnd in \nSessionController.java\n we update the collections:\n\n\n@RequestMapping(value = \n/remove-user\n, method = RequestMethod.POST)\npublic ResponseEntity\nJSONObject\n removeUser(@RequestBody String sessionNameToken,\n    HttpSession httpSession) throws Exception {\n\n    // ... check the user is logged with HttpSession and continue ...\n\n    // Retrieve the params from BODY\n    JSONObject sessionNameTokenJSON = (JSONObject) new JSONParser().parse(sessionNameToken);\n    String sessionName = (String) sessionNameTokenJSON.get(\nsessionName\n);\n    String token = (String) sessionNameTokenJSON.get(\ntoken\n);\n\n    // If the session exists (\nTUTORIAL\n in this case)\n    if (this.mapSessions.get(sessionName) != null \n this.mapSessionNamesTokens.get(sessionName) != null) {\n\n        // If the token exists and is succesfully removed\n        if (this.mapSessionNamesTokens.get(sessionName).remove(token) != null) {\n            // User left the session\n            if (this.mapSessionNamesTokens.get(sessionName).isEmpty()) {\n                // Last user left: session must be removed\n                this.mapSessions.remove(sessionName);\n            }\n            return new ResponseEntity\n(HttpStatus.OK);\n        } else {\n            // The TOKEN wasn't valid\n            System.out.println(\nProblems in the app server: the TOKEN wasn't valid\n);\n            return new ResponseEntity\n(HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    } else {\n        // The SESSION does not exist\n        System.out.println(\nProblems in the app server: the SESSION does not exist\n);\n        return new ResponseEntity\n(HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n\n\n\n\nWhen the last user leaves the session \nthis.mapSessions.remove(sessionName);\n will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n.\n\n\nThe only actual requirements are getting a valid \ntoken\n from  \nopenvidu-server\n (by using \nopenvidu-java-client\n, \nopenvidu-node-client\n or the \nREST API\n) and use it in \nopenvidu-browser\n to connect your clients to the sessions with \nSession.connect(token)\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-js-java"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#openvidu-js-java", 
            "text": "Check it on GitHub  A secure OpenVidu sample app with a Java backend and a SPA frontend. It makes use of  openvidu-java-client  to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to  openvidu-mvc-java . This tutorial is intended for developers who feel more comfortable with a SPA (Single Page Application) architecture for their frontends.", 
            "title": "openvidu-js-java"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-java-client : server SDK for Java. Quick alternative to REST API  openvidu-server : application to control Kurento Media Server  Kurento Media Server : handles low level operations of media flow transmissions", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need  maven  to build the project. You can install it with:  sudo apt-get install maven  3) Run the tutorial:  cd openvidu-tutorials/openvidu-js-java\nmvn package exec:java  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  HttpSession  API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial:  journaldev.com ,  studytonight.com .    Backend : SpringBoot app with the following classes ( src/main/java  path,  io.openvidu.js.java  package)   App.java  : entrypoint for the app  LoginController.java  : rest controller for handling login and logout operations  SessionController.java  : rest controller for getting OpenVidu tokens. It also stores our active video-calls and the users connected to them     Frontend : Plain JS/HTML/CSS files ( src/main/resources/static )   openvidu-browser-VERSION.js  : openvidu-browser library. You don't have to manipulate this file.  app.js  : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js .   index.html  : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:  script src=\"openvidu-browser-VERSION.js\" /script  script src=\"app.js\" /script     style.css : some CSS classes to style  index.html .      Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#1-user-logs-in", 
            "text": "We have implemented a method for making HTTP POST requests to the backend, as we will need to make at least three of them: one for logging in, one for getting a token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:  function httpPostRequest(url, body, errorMsg, callback)  Where  url  is the path of the POST operation,  body  the object to send as data,  errorMsg  the output error message if something goes wrong and  callback  the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.  index.html  will first show a form to log in:  \n     app.js  sends a POST request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:  function logIn() {\n    var user = $( #user ).val(); // Username\n    var pass = $( #pass ).val(); // Password\n\n    httpPostRequest(\n        'api-login/login',\n        {user: user, pass: pass},\n        'Login WRONG',\n        (response) =  {\n            // HTML shows logged-in page ...\n        }\n    );\n}  LoginController.java  checks the params are correct and if so sets an  HttpSession  for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object):  @RequestMapping(value =  /login , method = RequestMethod.POST)\npublic ResponseEntity Object  login(@RequestBody String userPass, HttpSession httpSession) \n    throws ParseException {\n\n    System.out.println( Logging in | {user, pass}=  + userPass);\n    // Retrieve params from POST body\n    JSONObject userPassJson = (JSONObject) new JSONParser().parse(userPass);\n    String user = (String) userPassJson.get( user );\n    String pass = (String) userPassJson.get( pass );\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute( loggedUser , user);\n        return new ResponseEntity (HttpStatus.OK);\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        httpSession.invalidate();\n        return new ResponseEntity ( User/Pass incorrect , HttpStatus.UNAUTHORIZED);\n    }\n}", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#2-user-connects-to-tutorial-video-call", 
            "text": "HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:  \n     app.js  will execute  joinSession()  method, which starts like this:  function joinSession() {\n    getToken((token) =  { ...  So the first thing to do here is to retrieve an OpenVidu  token  from our backend. Only when we have it available in the browser we will continue with the  join  operation. Let's see what  getToken()  looks like:  function getToken(callback) {\n    sessionName = $( #sessionName ).val(); // Video-call chosen by the user\n\n    httpPostRequest(\n        'api-sessions/get-token',\n        {sessionName: sessionName},\n        'Request of TOKEN gone WRONG:',\n        (response) =  {\n            token = response[0]; // Get token from response\n            console.warn('Request of TOKEN gone WELL (TOKEN:' + token + ')');\n            callback(token); // Continue the join operation\n        }\n    );\n}  Here is the second time we must call our  httpPostRequest()  method, sending the session we want to connect ( sessionName  parameter) and waiting to get a  token  as response. The interesting part here is in  SessionController.java  at  /api-sessions/get-token . First of all there are some important attributes in this class we must mention:  // OpenVidu object as entrypoint of the SDK\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map String, Session  mapSessions = new ConcurrentHashMap ();\n// Collection to pair session names and tokens (the inner Map pairs tokens and role associated)\nprivate Map String, Map String, OpenViduRole  mapSessionNamesTokens = new ConcurrentHashMap ();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;  Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on:  tokenOptions .  @RequestMapping(value =  /get-token , method = RequestMethod.POST)\n    public ResponseEntity JSONObject  getToken(@RequestBody String sessionNameParam,\n        HttpSession httpSession) throws ParseException {\n\n    // ... check the user is logged with HttpSession and continue ...\n\n    JSONObject sessionJSON = (JSONObject) new JSONParser().parse(sessionNameParam);\n\n    // The video-call to connect ( TUTORIAL )\n    String sessionName = (String) sessionJSON.get( sessionName );\n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute( loggedUser )).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData =  {\\ serverData\\ : \\  + httpSession.getAttribute( loggedUser ) +  \\ } ;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n    JSONObject responseJson = new JSONObject();  Just after that we check if the session \"TUTORIAL\" already exists  if (this.mapSessions.get(sessionName) != null) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we directly create a new session:  // New session\nSystem.out.println( New session   + sessionName);\ntry {\n\n    // Create a new OpenVidu Session\n    Session session = this.openVidu.createSession();\n    // Generate a new token with the recently created tokenOptions\n    String token = session.generateToken(tokenOptions);\n\n    // Store the session and the token in our collections\n    this.mapSessions.put(sessionName, session);\n    this.mapSessionNamesTokens.put(sessionName, new ConcurrentHashMap ());\n    this.mapSessionNamesTokens.get(sessionName).put(token, role);\n\n    // Prepare the response with the token\n    responseJson.put(0, token);\n\n    // Return the response to the client\n    return new ResponseEntity (responseJson, HttpStatus.OK);\n\n} catch (Exception e) {\n    // If error generate an error message and return it to client\n    return getErrorResponse(e);\n}  We are almost there! Now in  app.js  we can init a new Session and connect to it with  token :  // --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', (event) =  {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', (event) =  {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', (event) =  {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n// --- 4) Connect to the session passing the retrieved token and some more data from\n//        the client (in this case a JSON with the nickname chosen by the user) ---\n\nvar nickName = $( #nickName ).val();\nsession.connect(token, { clientData: nickName })\n    .then(() =  {\n\n        // --- 5) Set page layout for active call ---\n\n        var userName = $( #user ).val();\n        $('#session-title').text(sessionName);\n        $('#join').hide();\n        $('#session').show();\n\n\n        // Here we check somehow if the user has 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method is not recognized as 'PUBLIHSER' role by OpenVidu Server\n        if (isPublisher(userName)) {\n\n            // --- 6) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', (event) =  {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    })\n    .catch(error =  {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    });  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  SessionController.java  executes  getToken()  method. Now session 'TUTORIAL' already exists, so now we do enter the  if  branch that we ignored in the previous step:  if (this.mapSessions.get(sessionName) != null) {\n    // Session already exists\n    System.out.println( Existing session   + sessionName);\n    try {\n\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionNamesTokens.get(sessionName).put(token, role);\n\n        // Prepare the response with the token\n        responseJson.put(0, token);\n\n        // Return the response to the client\n        return new ResponseEntity (responseJson, HttpStatus.OK);\n    } catch (OpenViduJavaClientException e1) {\n        // If internal error generate an error message and return it to client\n        return getErrorResponse(e1);\n    } catch (OpenViduHttpException e2) {\n        if (404 == e2.getStatus()) {\n            // Invalid sessionId (user left unexpectedly). Session object is not valid\n            // anymore. Clean collections and continue as new session\n            this.mapSessions.remove(sessionName);\n            this.mapSessionNamesTokens.remove(sessionName);\n        }\n    }\n}  The code executed in  app.js  would also be the same. After the  Session.publish()  method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  leaveSession()  (and therefore  session.disconnect() ) to destroy the connection on OpenVidu Server, we need to run the last POST operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up,  session.disconnect()  updates our OpenVidu Server and the POST operation updates our application's backend.\nFor the POST operation, in  app.js  we run:  function removeUser() {\n    httpPostRequest(\n        'api-sessions/remove-user',\n        {sessionName: sessionName, token: token},\n        'User couldn\\'t be removed from session',\n        (response) =  {\n            console.warn( You have been removed from session   + sessionName);\n        }\n    );\n}  And in  SessionController.java  we update the collections:  @RequestMapping(value =  /remove-user , method = RequestMethod.POST)\npublic ResponseEntity JSONObject  removeUser(@RequestBody String sessionNameToken,\n    HttpSession httpSession) throws Exception {\n\n    // ... check the user is logged with HttpSession and continue ...\n\n    // Retrieve the params from BODY\n    JSONObject sessionNameTokenJSON = (JSONObject) new JSONParser().parse(sessionNameToken);\n    String sessionName = (String) sessionNameTokenJSON.get( sessionName );\n    String token = (String) sessionNameTokenJSON.get( token );\n\n    // If the session exists ( TUTORIAL  in this case)\n    if (this.mapSessions.get(sessionName) != null   this.mapSessionNamesTokens.get(sessionName) != null) {\n\n        // If the token exists and is succesfully removed\n        if (this.mapSessionNamesTokens.get(sessionName).remove(token) != null) {\n            // User left the session\n            if (this.mapSessionNamesTokens.get(sessionName).isEmpty()) {\n                // Last user left: session must be removed\n                this.mapSessions.remove(sessionName);\n            }\n            return new ResponseEntity (HttpStatus.OK);\n        } else {\n            // The TOKEN wasn't valid\n            System.out.println( Problems in the app server: the TOKEN wasn't valid );\n            return new ResponseEntity (HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    } else {\n        // The SESSION does not exist\n        System.out.println( Problems in the app server: the SESSION does not exist );\n        return new ResponseEntity (HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}  When the last user leaves the session  this.mapSessions.remove(sessionName);  will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .  The only actual requirements are getting a valid  token  from   openvidu-server  (by using  openvidu-java-client ,  openvidu-node-client  or the  REST API ) and use it in  openvidu-browser  to connect your clients to the sessions with  Session.connect(token)     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/", 
            "text": "openvidu-mvc-java\n\n\n Check it on GitHub\n\n\nA secure OpenVidu sample app with a Java backend and a traditional MVC frontend. It makes use of \nopenvidu-java-client\n to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to \nopenvidu-js-java\n. This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. \nThymeleaf\n is the template engine of choice for this tutorial.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-java-client\n: server SDK for Java. Quick alternative to REST API\n\n\nopenvidu-server\n: application to control Kurento Media Server\n\n\nKurento Media Server\n: handles low level operations of media flow transmissions\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need \nmaven\n to build the project. You can install it with:\n\n\nsudo apt-get install maven\n\n\n\n\n3) Run the tutorial:\n\n\ncd openvidu-tutorials/openvidu-mvc-java\nmvn package exec:java\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend that serves HTML files with a MVC approach, building the templates with the help of \nThymeleaf\n.\n\n\nOpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nHttpSession\n API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: \njournaldev.com\n, \nstudytonight.com\n.\n\n\n\n\n\n\nBackend\n: SpringBoot app with the following classes (\nsrc/main/java\n path, \nio.openvidu.js.java\n package)\n\n\n\n\nApp.java\n : entrypoint for the app\n\n\nLoginController.java\n : controller for handling login and logout operations\n\n\nSessionController.java\n : controller for getting OpenVidu tokens. It also stores our active video-calls and the users connected to them\n\n\n\n\n\n\n\n\nFrontend templates\n: Plain JS/HTML/CSS files served by the backend (\nsrc/main/resources/templates\n)\n\n\n\n\nindex.html\n : template with the login form\n\n\ndashboard.html\n : template with the form to join a video-call\n\n\nsession.html\n : template of the video-call itself\n\n\n\n\n\n\n\n\nFrontend static files\n (\nsrc/main/resources/static\n)\n\n\n\n\nopenvidu-browser-VERSION.js\n : openvidu-browser library. You don't have to manipulate this file\n\n\nstyle.css\n : some CSS classes to style the templates\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nAt path \n/\n a login form will be displayed:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/dashboard\n whenever \"Log in\" button is clicked, passing the username and the password:\n\n\nform class=\nform-group jumbotron\n action=\n/dashboard\n method=\npost\n\n    \np\n\n        \nlabel\nUser\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\nuser\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nPass\n/label\n\n        \ninput class=\nform-control\n type=\npassword\n name=\npass\n required=\ntrue\n/input\n\n    \n/p\n\n    \np class=\ntext-center\n\n        \nbutton class=\nbtn btn-lg btn-info\n type=\nsubmit\nLog in\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nLoginController.java\n first checks if the user is already logged (maybe he has just refreshed \n/dashboard\n page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets an \nHttpSession\n for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object). Finally it returns \ndashboard.html\n template:\n\n\n@RequestMapping(value = \n/dashboard\n, method = { RequestMethod.GET, RequestMethod.POST })\npublic String login(@RequestParam(name = \nuser\n, required = false) String user,\n            @RequestParam(name = \npass\n, required = false) String pass,\n            Model model, HttpSession httpSession) {\n\n    // Check if the user is already logged in\n    String userName = (String) httpSession.getAttribute(\nloggedUser\n);\n    if (userName != null) { \n        // User is already logged. Immediately return dashboard\n        model.addAttribute(\nusername\n, userName);\n        return \ndashboard\n;\n    }\n\n    // User wasn't logged and wants to\n    if (login(user, pass)) { // Correct user-pass\n\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute(\nloggedUser\n, user);\n        model.addAttribute(\nusername\n, user);\n\n        // Return dashboard.html template\n        return \ndashboard\n;\n\n    } else { // Wrong user-pass\n        // Invalidate session and redirect to index.html\n        httpSession.invalidate();\n        return \nredirect:/\n;\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\ndashboard.html\n template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/session\n whenever \"Join!\" button is clicked, passing the nickname and the session name:\n\n\nform class=\nform-group\n action=\n/session\n method=\npost\n\n    \np\n\n        \nlabel\nParticipant\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\ndata\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nSession\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\nsession-name\n required=\ntrue\n/input\n\n    \n/p\n\n    \np class=\ntext-center\n\n        \nbutton class=\nbtn btn-lg btn-success\n type=\nsubmit\nJoin!\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nWhen \nSessionController.java\n receives a request at \n/session\n path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:\n\n\n// OpenVidu object as entrypoint of the SDK\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map\nString, Session\n mapSessions = new ConcurrentHashMap\n();\n// Collection to pair session names and tokens (the inner Map pairs tokens and role associated)\nprivate Map\nString, Map\nString, OpenViduRole\n mapSessionNamesTokens = new ConcurrentHashMap\n();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;\n\n\n\n\nRest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: \ntokenOptions\n.\n\n\n@RequestMapping(value = \n/session\n, method = RequestMethod.POST)\npublic String joinSession(@RequestParam(name = \ndata\n) String clientData,\n            @RequestParam(name = \nsession-name\n) String sessionName,\n            Model model, HttpSession httpSession) {\n\n    // ... check the user is logged with HttpSession and continue ...\n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\nloggedUser\n)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData = \n{\\\nserverData\\\n: \\\n + httpSession.getAttribute(\nloggedUser\n) + \n\\\n}\n;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exist?\n\n\nif (this.mapSessions.get(sessionName) != null) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse {\n    // New session\n    System.out.println(\nNew session \n + sessionName);\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionNamesTokens.put(sessionName, new ConcurrentHashMap\n());\n        this.mapSessionNamesTokens.get(sessionName).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute(\nsessionName\n, sessionName);\n        model.addAttribute(\ntoken\n, token);\n        model.addAttribute(\nnickName\n, clientData);\n        model.addAttribute(\nuserName\n, httpSession.getAttribute(\nloggedUser\n));\n\n        // Return session.html template\n        return \nsession\n;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute(\nusername\n, httpSession.getAttribute(\nloggedUser\n));\n        return \ndashboard\n;\n    }\n}\n\n\n\n\nWe are almost there! Now in \nsession.html\n JavaScript code (preceded by a tag \nscript th:inline=\"javascript\"\n) we can init a new Session and connect to it with \ntoken\n:\n\n\n// Get all the attributes from the template in Thymeleaf style\nvar sessionName = [[${ sessionName }]];\nvar token = [[${ token }]];\nvar nickName = [[${ nickName }]];\nvar userName = [[${ userName }]];\n\n// --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', (event) =\n {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', (event) =\n {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', (event) =\n {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n// --- 4) Connect to the session passing the retrieved token and some more data from\n//        the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, { clientData: nickName })\n    .then(() =\n {\n\n        // --- 5) Set page layout for active call ---\n\n        $('#session-title').text(sessionName);\n        $('#join').hide();\n        $('#session').show();\n\n\n        // Here we check somehow if the user has 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method is not recognized as 'PUBLIHSER' role by OpenVidu Server\n        if (isPublisher()) {\n\n            // --- 6) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', (event) =\n {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    })\n    .catch(error =\n {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    });\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nSessionController.java\n executes \njoinSession()\n method. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (this.mapSessions.get(sessionName) != null) {\n    // Session already exists\n    System.out.println(\nExisting session \n + sessionName);\n    try {\n\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionNamesTokens.get(sessionName).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute(\nsessionName\n, sessionName);\n        model.addAttribute(\ntoken\n, token);\n        model.addAttribute(\nnickName\n, clientData);\n        model.addAttribute(\nuserName\n, httpSession.getAttribute(\nloggedUser\n));\n\n        // Return session.html template\n        return \nsession\n;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute(\nusername\n, httpSession.getAttribute(\nloggedUser\n));\n        return \ndashboard\n;\n    }\n}\n\n\n\n\nThe code executed in \nsession.html\n \n script \n tag would also be the same. After the \nSession.publish()\n method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nsession.disconnect()\n (triggered in \nleaveSession()\n \nonclick\n method) to destroy the connection on OpenVidu Server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.\n\n\nIn \nsession.html\n template the \"Leave session\" button actually performs a POST operation to path \n/leave-session\n with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the \nleaveSession()\n method. First updates our application's backend. Second updates our OpenVidu Server.\n\n\nform action=\n/leave-session\n method=\npost\n\n    \ninput type=\nhidden\n name=\nsession-name\n th:value=\n${sessionName}\n/input\n\n    \ninput type=\nhidden\n name=\ntoken\n th:value=\n${token}\n/input\n\n    \nbutton id=\nbuttonLeaveSession\n class=\nbtn btn-large btn-danger\n type=\nsubmit\n onclick=\nleaveSession()\n\n        Leave session\n/button\n\n\n/form\n\n\n\n\n\nIn \nSessionController.java\n we update the collections:\n\n\n@RequestMapping(value = \n/leave-session\n, method = RequestMethod.POST)\npublic String removeUser(@RequestParam(name = \nsession-name\n) String sessionName,\n            @RequestParam(name = \ntoken\n) String token,\n            Model model, HttpSession httpSession) throws Exception {\n\n    // ... check the user is logged with HttpSession and continue ...\n\n    // If the session exists (\nTUTORIAL\n in this case)\n    if (this.mapSessions.get(sessionName) != null \n this.mapSessionNamesTokens.get(sessionName) != null) {\n\n        // If the token exists\n        if (this.mapSessionNamesTokens.get(sessionName).remove(token) != null) {\n            // User left the session\n            if (this.mapSessionNamesTokens.get(sessionName).isEmpty()) {\n                // Last user left: session must be removed\n                this.mapSessions.remove(sessionName);\n            }\n            return \nredirect:/dashboard\n;\n\n        } else {\n            // The TOKEN wasn't valid\n            System.out.println(\nProblems in the app server: the TOKEN wasn't valid\n);\n            return \nredirect:/dashboard\n;\n        }\n\n    } else {\n        // The SESSION does not exist\n        System.out.println(\nProblems in the app server: the SESSION does not exist\n);\n        return \nredirect:/dashboard\n;\n    }\n}\n\n\n\n\nWhen the last user leaves the session \nthis.mapSessions.remove(sessionName);\n will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n.\n\n\nThe only actual requirements are getting a valid \ntoken\n from  \nopenvidu-server\n (by using \nopenvidu-java-client\n, \nopenvidu-node-client\n or the \nREST API\n) and use it in \nopenvidu-browser\n to connect your clients to the sessions with \nSession.connect(token)\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-mvc-java"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#openvidu-mvc-java", 
            "text": "Check it on GitHub  A secure OpenVidu sample app with a Java backend and a traditional MVC frontend. It makes use of  openvidu-java-client  to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to  openvidu-js-java . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends.  Thymeleaf  is the template engine of choice for this tutorial.", 
            "title": "openvidu-mvc-java"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-java-client : server SDK for Java. Quick alternative to REST API  openvidu-server : application to control Kurento Media Server  Kurento Media Server : handles low level operations of media flow transmissions", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need  maven  to build the project. You can install it with:  sudo apt-get install maven  3) Run the tutorial:  cd openvidu-tutorials/openvidu-mvc-java\nmvn package exec:java  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend that serves HTML files with a MVC approach, building the templates with the help of  Thymeleaf .  OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  HttpSession  API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial:  journaldev.com ,  studytonight.com .    Backend : SpringBoot app with the following classes ( src/main/java  path,  io.openvidu.js.java  package)   App.java  : entrypoint for the app  LoginController.java  : controller for handling login and logout operations  SessionController.java  : controller for getting OpenVidu tokens. It also stores our active video-calls and the users connected to them     Frontend templates : Plain JS/HTML/CSS files served by the backend ( src/main/resources/templates )   index.html  : template with the login form  dashboard.html  : template with the form to join a video-call  session.html  : template of the video-call itself     Frontend static files  ( src/main/resources/static )   openvidu-browser-VERSION.js  : openvidu-browser library. You don't have to manipulate this file  style.css  : some CSS classes to style the templates     Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#1-user-logs-in", 
            "text": "At path  /  a login form will be displayed:  \n     The form will execute a POST operation to path  /dashboard  whenever \"Log in\" button is clicked, passing the username and the password:  form class= form-group jumbotron  action= /dashboard  method= post \n     p \n         label User /label \n         input class= form-control  type= text  name= user  required= true /input \n     /p \n     p \n         label Pass /label \n         input class= form-control  type= password  name= pass  required= true /input \n     /p \n     p class= text-center \n         button class= btn btn-lg btn-info  type= submit Log in /button \n     /p  /form   LoginController.java  first checks if the user is already logged (maybe he has just refreshed  /dashboard  page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets an  HttpSession  for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object). Finally it returns  dashboard.html  template:  @RequestMapping(value =  /dashboard , method = { RequestMethod.GET, RequestMethod.POST })\npublic String login(@RequestParam(name =  user , required = false) String user,\n            @RequestParam(name =  pass , required = false) String pass,\n            Model model, HttpSession httpSession) {\n\n    // Check if the user is already logged in\n    String userName = (String) httpSession.getAttribute( loggedUser );\n    if (userName != null) { \n        // User is already logged. Immediately return dashboard\n        model.addAttribute( username , userName);\n        return  dashboard ;\n    }\n\n    // User wasn't logged and wants to\n    if (login(user, pass)) { // Correct user-pass\n\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute( loggedUser , user);\n        model.addAttribute( username , user);\n\n        // Return dashboard.html template\n        return  dashboard ;\n\n    } else { // Wrong user-pass\n        // Invalidate session and redirect to index.html\n        httpSession.invalidate();\n        return  redirect:/ ;\n    }\n}", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#2-user-connects-to-tutorial-video-call", 
            "text": "dashboard.html  template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:  \n     The form will execute a POST operation to path  /session  whenever \"Join!\" button is clicked, passing the nickname and the session name:  form class= form-group  action= /session  method= post \n     p \n         label Participant /label \n         input class= form-control  type= text  name= data  required= true /input \n     /p \n     p \n         label Session /label \n         input class= form-control  type= text  name= session-name  required= true /input \n     /p \n     p class= text-center \n         button class= btn btn-lg btn-success  type= submit Join! /button \n     /p  /form   When  SessionController.java  receives a request at  /session  path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:  // OpenVidu object as entrypoint of the SDK\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map String, Session  mapSessions = new ConcurrentHashMap ();\n// Collection to pair session names and tokens (the inner Map pairs tokens and role associated)\nprivate Map String, Map String, OpenViduRole  mapSessionNamesTokens = new ConcurrentHashMap ();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;  Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on:  tokenOptions .  @RequestMapping(value =  /session , method = RequestMethod.POST)\npublic String joinSession(@RequestParam(name =  data ) String clientData,\n            @RequestParam(name =  session-name ) String sessionName,\n            Model model, HttpSession httpSession) {\n\n    // ... check the user is logged with HttpSession and continue ...\n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute( loggedUser )).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData =  {\\ serverData\\ : \\  + httpSession.getAttribute( loggedUser ) +  \\ } ;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exist?  if (this.mapSessions.get(sessionName) != null) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else {\n    // New session\n    System.out.println( New session   + sessionName);\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionNamesTokens.put(sessionName, new ConcurrentHashMap ());\n        this.mapSessionNamesTokens.get(sessionName).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute( sessionName , sessionName);\n        model.addAttribute( token , token);\n        model.addAttribute( nickName , clientData);\n        model.addAttribute( userName , httpSession.getAttribute( loggedUser ));\n\n        // Return session.html template\n        return  session ;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute( username , httpSession.getAttribute( loggedUser ));\n        return  dashboard ;\n    }\n}  We are almost there! Now in  session.html  JavaScript code (preceded by a tag  script th:inline=\"javascript\" ) we can init a new Session and connect to it with  token :  // Get all the attributes from the template in Thymeleaf style\nvar sessionName = [[${ sessionName }]];\nvar token = [[${ token }]];\nvar nickName = [[${ nickName }]];\nvar userName = [[${ userName }]];\n\n// --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', (event) =  {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', (event) =  {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', (event) =  {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n// --- 4) Connect to the session passing the retrieved token and some more data from\n//        the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, { clientData: nickName })\n    .then(() =  {\n\n        // --- 5) Set page layout for active call ---\n\n        $('#session-title').text(sessionName);\n        $('#join').hide();\n        $('#session').show();\n\n\n        // Here we check somehow if the user has 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method is not recognized as 'PUBLIHSER' role by OpenVidu Server\n        if (isPublisher()) {\n\n            // --- 6) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', (event) =  {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    })\n    .catch(error =  {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    });  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  SessionController.java  executes  joinSession()  method. Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (this.mapSessions.get(sessionName) != null) {\n    // Session already exists\n    System.out.println( Existing session   + sessionName);\n    try {\n\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionNamesTokens.get(sessionName).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute( sessionName , sessionName);\n        model.addAttribute( token , token);\n        model.addAttribute( nickName , clientData);\n        model.addAttribute( userName , httpSession.getAttribute( loggedUser ));\n\n        // Return session.html template\n        return  session ;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute( username , httpSession.getAttribute( loggedUser ));\n        return  dashboard ;\n    }\n}  The code executed in  session.html    script   tag would also be the same. After the  Session.publish()  method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  session.disconnect()  (triggered in  leaveSession()   onclick  method) to destroy the connection on OpenVidu Server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.  In  session.html  template the \"Leave session\" button actually performs a POST operation to path  /leave-session  with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the  leaveSession()  method. First updates our application's backend. Second updates our OpenVidu Server.  form action= /leave-session  method= post \n     input type= hidden  name= session-name  th:value= ${sessionName} /input \n     input type= hidden  name= token  th:value= ${token} /input \n     button id= buttonLeaveSession  class= btn btn-large btn-danger  type= submit  onclick= leaveSession() \n        Leave session /button  /form   In  SessionController.java  we update the collections:  @RequestMapping(value =  /leave-session , method = RequestMethod.POST)\npublic String removeUser(@RequestParam(name =  session-name ) String sessionName,\n            @RequestParam(name =  token ) String token,\n            Model model, HttpSession httpSession) throws Exception {\n\n    // ... check the user is logged with HttpSession and continue ...\n\n    // If the session exists ( TUTORIAL  in this case)\n    if (this.mapSessions.get(sessionName) != null   this.mapSessionNamesTokens.get(sessionName) != null) {\n\n        // If the token exists\n        if (this.mapSessionNamesTokens.get(sessionName).remove(token) != null) {\n            // User left the session\n            if (this.mapSessionNamesTokens.get(sessionName).isEmpty()) {\n                // Last user left: session must be removed\n                this.mapSessions.remove(sessionName);\n            }\n            return  redirect:/dashboard ;\n\n        } else {\n            // The TOKEN wasn't valid\n            System.out.println( Problems in the app server: the TOKEN wasn't valid );\n            return  redirect:/dashboard ;\n        }\n\n    } else {\n        // The SESSION does not exist\n        System.out.println( Problems in the app server: the SESSION does not exist );\n        return  redirect:/dashboard ;\n    }\n}  When the last user leaves the session  this.mapSessions.remove(sessionName);  will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .  The only actual requirements are getting a valid  token  from   openvidu-server  (by using  openvidu-java-client ,  openvidu-node-client  or the  REST API ) and use it in  openvidu-browser  to connect your clients to the sessions with  Session.connect(token)     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/", 
            "text": "openvidu-js-node\n\n\n Check it on GitHub\n\n\nA secure OpenVidu sample app with a Node backend and a SPA frontend. It makes use of \nopenvidu-node-client\n to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to \nopenvidu-mvc-node\n. This tutorial is intended for developers who feel more comfortable with a SPA (Single Page Application) architecture for their frontends.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-node-client\n: server SDK for Node. Quick alternative to REST API\n\n\nopenvidu-server\n: application to control Kurento Media Server\n\n\nKurento Media Server\n: handles low level operations of media flow transmissions\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need \nnode\n to execute the app. You can install them with:\n\n\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\n\n\n\n\n3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute \nserver.js\n server passing two arguments: \"localhost:4443\" as the URL where \nopenvidu-server\n will be listening and \"MY_SECRET\" as the secret share with it:\n\n\ncd openvidu-tutorials/openvidu-js-node\nnpm install\nnode server.js localhost:4443 MY_SECRET\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with \nexpress\n. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nexpress-session\n API.\n\n\n\n\n\n\nBackend\n: node server\n\n\n\n\nserver.js\n : single file which handles all operations of server\n\n\n\n\n\n\n\n\nFrontend\n: Plain JS/HTML/CSS files (\n/public\n folder)\n\n\n\n\nopenvidu-browser-VERSION.js\n : openvidu-browser library. You don't have to manipulate this file.\n\n\napp.js\n : sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n.\n\n\n\n\nindex.html\n : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:\n\n\nscript src=\"openvidu-browser-VERSION.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n.\n\n\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nWe have implemented a method for making HTTP POST requests to the backend, as we will need to make at least three of them: one for logging in, one for getting a token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:\n\n\nfunction httpPostRequest(url, body, errorMsg, callback)\n\n\n\n\nWhere \nurl\n is the path of the POST operation, \nbody\n the object to send as data, \nerrorMsg\n the output error message if something goes wrong and \ncallback\n the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.\n\n\nindex.html\n will first show a form to log in:\n\n\n\n  \n\n\n\n\n\napp.js\n sends a POST request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:\n\n\nfunction logIn() {\n    var user = $(\n#user\n).val(); // Username\n    var pass = $(\n#pass\n).val(); // Password\n\n    httpPostRequest(\n        'api-login/login',\n        {user: user, pass: pass},\n        'Login WRONG',\n        (response) =\n {\n            // HTML shows logged-in page ...\n        }\n    );\n}\n\n\n\n\nserver.js\n at \n/api-login/login\n checks the params are correct and if so sets an active session for the newly logged user (adding a \nloggedUser\n property with its username in the \nreq.session\n object):\n\n\napp.post('/api-login/login', function (req, res) {\n\n    // Retrieve params from POST body\n    var user = req.body.user;\n    var pass = req.body.pass;\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK\n        // Value stored in req.session allows us to identify the user in future requests\n        req.session.loggedUser = user;\n        res.status(200).send();\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        req.session.destroy();\n        res.status(401).send('User/Pass incorrect');\n    }\n});\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\nHTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:\n\n\n\n  \n\n\n\n\n\napp.js\n will execute \njoinSession()\n method, which starts like this:\n\n\nfunction joinSession() {\n    getToken((token) =\n { ...\n\n\n\n\nSo the first thing to do here is to retrieve an OpenVidu \ntoken\n from our backend. Only when we have it available in the browser we will continue with the \njoin\n operation. Let's see what \ngetToken()\n looks like:\n\n\nfunction getToken(callback) {\n    sessionName = $(\n#sessionName\n).val(); // Video-call chosen by the user\n\n    httpPostRequest(\n        'api-sessions/get-token',\n        {sessionName: sessionName},\n        'Request of TOKEN gone WRONG:',\n        (response) =\n {\n            token = response[0]; // Get token from response\n            console.warn('Request of TOKEN gone WELL (TOKEN:' + token + ')');\n            callback(token); // Continue the join operation\n        }\n    );\n}\n\n\n\n\nHere is the second time we must call our \nhttpPostRequest()\n method, sending the session we want to connect (\nsessionName\n parameter) and waiting to get a \ntoken\n as response. The interesting part here is in \nserver.js\n controller at \n/api-sessions/get-token\n. First of all there are some important attributes in this class we must mention:\n\n\n// Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// Entrypoint to OpenVidu Node Client SDK\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names with OpenVidu Session objects\nvar mapSessions = {};\n// Collection to pair session names with tokens\nvar mapSessionNamesTokens = {};\n\n\n\n\nRest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: \ntokenOptions\n.\n\n\napp.post('/api-sessions/get-token', function (req, res) {\n\n   // ... check the user is logged with req.session and continue ...\n\n    // The video-call to connect (\nTUTORIAL\n)\n    var sessionName = req.body.sessionName;\n\n    // Role associated to this user\n    var role = users.find(u =\n (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = JSON.stringify({serverData: req.session.loggedUser});\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = {\n        data: serverData,\n        role: role\n    };\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exist?\n\n\nif (mapSessions[sessionName]) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse {\n    // New session\n    console.log('New session ' + sessionName);\n\n    // Create a new OpenVidu Session asynchronously\n    OV.createSession()\n        .then(session =\n {\n            // Store the new Session in the collection of Sessions\n            mapSessions[sessionName] = session;\n            // Store a new empty array in the collection of tokens\n            mapSessionNamesTokens[sessionName] = [];\n\n            // Generate a new token asynchronously with the recently created tokenOptions\n            session.generateToken(tokenOptions)\n                .then(token =\n {\n\n                    // Store the new token in the collection of tokens\n                    mapSessionNamesTokens[sessionName].push(token);\n\n                    // Return the Token to the client\n                    res.status(200).send({\n                        0: token\n                    });\n                })\n                .catch(error =\n {\n                    console.error(error);\n                });\n        })\n        .catch(error =\n {\n            console.error(error);\n        });\n}\n\n\n\n\nWe are almost there! Now in \napp.js\n we can init a new Session and connect to it with \ntoken\n:\n\n\n// --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', (event) =\n {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', (event) =\n {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', (event) =\n {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n// --- 4) Connect to the session passing the retrieved token and some more data from\n//        the client (in this case a JSON with the nickname chosen by the user) ---\n\nvar nickName = $(\n#nickName\n).val();\nsession.connect(token, { clientData: nickName })\n    .then(() =\n {\n\n        // --- 5) Set page layout for active call ---\n\n        var userName = $(\n#user\n).val();\n        $('#session-title').text(sessionName);\n        $('#join').hide();\n        $('#session').show();\n\n\n        // Here we check somehow if the user has 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method is not recognized as 'PUBLIHSER' role by OpenVidu Server\n        if (isPublisher(userName)) {\n\n            // --- 6) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', (event) =\n {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    })\n    .catch(error =\n {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    });\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nserver.js\n executes controller at \n/api-sessions/get-token\n. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (mapSessions[sessionName]) {\n    // Session already exists\n    console.log('Existing session ' + sessionName);\n\n    // Get the existing Session from the collection\n    var mySession = mapSessions[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions)\n        .then(token =\n {\n\n            // Store the new token in the collection of tokens\n            mapSessionNamesTokens[sessionName].push(token);\n\n            // Return the token to the client\n            res.status(200).send({\n                0: token\n            });\n        })\n        .catch(error =\n {\n            console.error(error);\n        });\n}\n\n\n\n\nThe code executed in \napp.js\n would also be the same. After the \nSession.publish()\n method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nleaveSession()\n (and therefore \nsession.disconnect()\n) to destroy the connection on OpenVidu Server, we need to run the last POST operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, \nsession.disconnect()\n updates our OpenVidu Server and the POST operation updates our application's backend.\nFor the POST operation, in \napp.js\n we run:\n\n\nfunction removeUser() {\n    httpPostRequest(\n        'api-sessions/remove-user',\n        {sessionName: sessionName, token: token},\n        'User couldn\\'t be removed from session', \n        (response) =\n {\n            console.warn(\nYou have been removed from session \n + sessionName);\n        }\n    );\n}\n\n\n\n\nAnd in \nserver.js\n we update the collections in \n/api-sessions/remove-user\n:\n\n\n\napp.post('/api-sessions/remove-user', function (req, res) {\n\n    // ... check the user is logged with req.session and continue ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionName;\n    var token = req.body.token;\n\n    // If the session exists\n    if (mapSessions[sessionName] \n mapSessionNamesTokens[sessionName]) {\n        var tokens = mapSessionNamesTokens[sessionName];\n        var index = tokens.indexOf(token);\n\n        // If the token exists\n        if (index !== -1) {\n            // Token removed\n            tokens.splice(index, 1);\n        } else {\n            res.status(500).send('Problems in the app server: the TOKEN wasn\\'t valid');\n        }\n        if (tokens.length == 0) {\n            // Last user left: session must be removed\n            delete mapSessions[sessionName];\n        }\n        res.status(200).send();\n    } else {\n        res.status(500).send('Problems in the app server: the SESSION does not exist');\n    }\n});\n\n\n\n\nWhen the last user leaves the session \ndelete mapSessions[sessionName]\n will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n.\n\n\nThe only actual requirements are getting a valid \ntoken\n from  \nopenvidu-server\n (by using \nopenvidu-java-client\n, \nopenvidu-node-client\n or the \nREST API\n) and use it in \nopenvidu-browser\n to connect your clients to the sessions with \nSession.connect(token)\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-js-node"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#openvidu-js-node", 
            "text": "Check it on GitHub  A secure OpenVidu sample app with a Node backend and a SPA frontend. It makes use of  openvidu-node-client  to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to  openvidu-mvc-node . This tutorial is intended for developers who feel more comfortable with a SPA (Single Page Application) architecture for their frontends.", 
            "title": "openvidu-js-node"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-node-client : server SDK for Node. Quick alternative to REST API  openvidu-server : application to control Kurento Media Server  Kurento Media Server : handles low level operations of media flow transmissions", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need  node  to execute the app. You can install them with:  sudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs  3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute  server.js  server passing two arguments: \"localhost:4443\" as the URL where  openvidu-server  will be listening and \"MY_SECRET\" as the secret share with it:  cd openvidu-tutorials/openvidu-js-node\nnpm install\nnode server.js localhost:4443 MY_SECRET  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with  express . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  express-session  API.    Backend : node server   server.js  : single file which handles all operations of server     Frontend : Plain JS/HTML/CSS files ( /public  folder)   openvidu-browser-VERSION.js  : openvidu-browser library. You don't have to manipulate this file.  app.js  : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js .   index.html  : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:  script src=\"openvidu-browser-VERSION.js\" /script  script src=\"app.js\" /script     style.css : some CSS classes to style  index.html .      Let's describe the code following this scenario: a user logs into the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#1-user-logs-in", 
            "text": "We have implemented a method for making HTTP POST requests to the backend, as we will need to make at least three of them: one for logging in, one for getting a token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:  function httpPostRequest(url, body, errorMsg, callback)  Where  url  is the path of the POST operation,  body  the object to send as data,  errorMsg  the output error message if something goes wrong and  callback  the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.  index.html  will first show a form to log in:  \n     app.js  sends a POST request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:  function logIn() {\n    var user = $( #user ).val(); // Username\n    var pass = $( #pass ).val(); // Password\n\n    httpPostRequest(\n        'api-login/login',\n        {user: user, pass: pass},\n        'Login WRONG',\n        (response) =  {\n            // HTML shows logged-in page ...\n        }\n    );\n}  server.js  at  /api-login/login  checks the params are correct and if so sets an active session for the newly logged user (adding a  loggedUser  property with its username in the  req.session  object):  app.post('/api-login/login', function (req, res) {\n\n    // Retrieve params from POST body\n    var user = req.body.user;\n    var pass = req.body.pass;\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK\n        // Value stored in req.session allows us to identify the user in future requests\n        req.session.loggedUser = user;\n        res.status(200).send();\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        req.session.destroy();\n        res.status(401).send('User/Pass incorrect');\n    }\n});", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#2-user-connects-to-tutorial-video-call", 
            "text": "HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:  \n     app.js  will execute  joinSession()  method, which starts like this:  function joinSession() {\n    getToken((token) =  { ...  So the first thing to do here is to retrieve an OpenVidu  token  from our backend. Only when we have it available in the browser we will continue with the  join  operation. Let's see what  getToken()  looks like:  function getToken(callback) {\n    sessionName = $( #sessionName ).val(); // Video-call chosen by the user\n\n    httpPostRequest(\n        'api-sessions/get-token',\n        {sessionName: sessionName},\n        'Request of TOKEN gone WRONG:',\n        (response) =  {\n            token = response[0]; // Get token from response\n            console.warn('Request of TOKEN gone WELL (TOKEN:' + token + ')');\n            callback(token); // Continue the join operation\n        }\n    );\n}  Here is the second time we must call our  httpPostRequest()  method, sending the session we want to connect ( sessionName  parameter) and waiting to get a  token  as response. The interesting part here is in  server.js  controller at  /api-sessions/get-token . First of all there are some important attributes in this class we must mention:  // Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// Entrypoint to OpenVidu Node Client SDK\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names with OpenVidu Session objects\nvar mapSessions = {};\n// Collection to pair session names with tokens\nvar mapSessionNamesTokens = {};  Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on:  tokenOptions .  app.post('/api-sessions/get-token', function (req, res) {\n\n   // ... check the user is logged with req.session and continue ...\n\n    // The video-call to connect ( TUTORIAL )\n    var sessionName = req.body.sessionName;\n\n    // Role associated to this user\n    var role = users.find(u =  (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = JSON.stringify({serverData: req.session.loggedUser});\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = {\n        data: serverData,\n        role: role\n    };  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exist?  if (mapSessions[sessionName]) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else {\n    // New session\n    console.log('New session ' + sessionName);\n\n    // Create a new OpenVidu Session asynchronously\n    OV.createSession()\n        .then(session =  {\n            // Store the new Session in the collection of Sessions\n            mapSessions[sessionName] = session;\n            // Store a new empty array in the collection of tokens\n            mapSessionNamesTokens[sessionName] = [];\n\n            // Generate a new token asynchronously with the recently created tokenOptions\n            session.generateToken(tokenOptions)\n                .then(token =  {\n\n                    // Store the new token in the collection of tokens\n                    mapSessionNamesTokens[sessionName].push(token);\n\n                    // Return the Token to the client\n                    res.status(200).send({\n                        0: token\n                    });\n                })\n                .catch(error =  {\n                    console.error(error);\n                });\n        })\n        .catch(error =  {\n            console.error(error);\n        });\n}  We are almost there! Now in  app.js  we can init a new Session and connect to it with  token :  // --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', (event) =  {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', (event) =  {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', (event) =  {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n// --- 4) Connect to the session passing the retrieved token and some more data from\n//        the client (in this case a JSON with the nickname chosen by the user) ---\n\nvar nickName = $( #nickName ).val();\nsession.connect(token, { clientData: nickName })\n    .then(() =  {\n\n        // --- 5) Set page layout for active call ---\n\n        var userName = $( #user ).val();\n        $('#session-title').text(sessionName);\n        $('#join').hide();\n        $('#session').show();\n\n\n        // Here we check somehow if the user has 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method is not recognized as 'PUBLIHSER' role by OpenVidu Server\n        if (isPublisher(userName)) {\n\n            // --- 6) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', (event) =  {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    })\n    .catch(error =  {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    });  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  server.js  executes controller at  /api-sessions/get-token . Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (mapSessions[sessionName]) {\n    // Session already exists\n    console.log('Existing session ' + sessionName);\n\n    // Get the existing Session from the collection\n    var mySession = mapSessions[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions)\n        .then(token =  {\n\n            // Store the new token in the collection of tokens\n            mapSessionNamesTokens[sessionName].push(token);\n\n            // Return the token to the client\n            res.status(200).send({\n                0: token\n            });\n        })\n        .catch(error =  {\n            console.error(error);\n        });\n}  The code executed in  app.js  would also be the same. After the  Session.publish()  method has been successful, both users will be seeing each other's video, as well as the username and nickname uppon it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  leaveSession()  (and therefore  session.disconnect() ) to destroy the connection on OpenVidu Server, we need to run the last POST operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up,  session.disconnect()  updates our OpenVidu Server and the POST operation updates our application's backend.\nFor the POST operation, in  app.js  we run:  function removeUser() {\n    httpPostRequest(\n        'api-sessions/remove-user',\n        {sessionName: sessionName, token: token},\n        'User couldn\\'t be removed from session', \n        (response) =  {\n            console.warn( You have been removed from session   + sessionName);\n        }\n    );\n}  And in  server.js  we update the collections in  /api-sessions/remove-user :  \napp.post('/api-sessions/remove-user', function (req, res) {\n\n    // ... check the user is logged with req.session and continue ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionName;\n    var token = req.body.token;\n\n    // If the session exists\n    if (mapSessions[sessionName]   mapSessionNamesTokens[sessionName]) {\n        var tokens = mapSessionNamesTokens[sessionName];\n        var index = tokens.indexOf(token);\n\n        // If the token exists\n        if (index !== -1) {\n            // Token removed\n            tokens.splice(index, 1);\n        } else {\n            res.status(500).send('Problems in the app server: the TOKEN wasn\\'t valid');\n        }\n        if (tokens.length == 0) {\n            // Last user left: session must be removed\n            delete mapSessions[sessionName];\n        }\n        res.status(200).send();\n    } else {\n        res.status(500).send('Problems in the app server: the SESSION does not exist');\n    }\n});  When the last user leaves the session  delete mapSessions[sessionName]  will be executed: this means the session is empty and that it has been closed in OpenVidu Server. All our Session objects and tokens associated to them will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .  The only actual requirements are getting a valid  token  from   openvidu-server  (by using  openvidu-java-client ,  openvidu-node-client  or the  REST API ) and use it in  openvidu-browser  to connect your clients to the sessions with  Session.connect(token)     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/", 
            "text": "openvidu-mvc-node\n\n\n Check it on GitHub\n\n\nA secure OpenVidu sample app with a Node backend and a traditional MVC frontend. It makes use of \nopenvidu-node-client\n to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to \nopenvidu-js-node\n. This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. \nEmbedded JavaScript\n is the template engine of choice for this tutorial.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-node-client\n: server SDK for Node. Quick alternative to REST API\n\n\nopenvidu-server\n: application to control Kurento Media Server\n\n\nKurento Media Server\n: handles low level operations of media flow transmissions\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n1) You will need \nnode\n to execute the app. You can install them with:\n\n\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\n\n\n\n\n3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute \nserver.js\n server passing two arguments: \"localhost:4443\" as the URL where \nopenvidu-server\n will be listening and \"MY_SECRET\" as the secret share with it:\n\n\ncd openvidu-tutorials/openvidu-mvc-node\nnpm install\nnode server.js localhost:4443 MY_SECRET\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with \nexpress\n that serves HTML files with a MVC approach, building the templates with the help of \nEmbedded JavaScript\n. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nexpress-session\n API.\n\n\n\n\n\n\nBackend\n: node server\n\n\n\n\nserver.js\n : single file which handles all operations of server. It returns HTML templates as response to HTTP requests.\n\n\n\n\n\n\n\n\nFrontend templates\n: Plain JS/HTML/CSS files served by the backend, with \n.ejs\n extension to support Embedded JavaScript (\n/views\n folder)\n\n\n\n\nindex.ejs\n : template with the login form\n\n\ndashboard.ejs\n : template with the form to join a video-call\n\n\nsession.ejs\n : template of the video-call itself\n\n\n\n\n\n\n\n\nFrontend static files\n (\n/public\n folder)\n\n\n\n\nopenvidu-browser-VERSION.js\n : openvidu-browser library. You don't have to manipulate this file\n\n\nstyle.css\n : some CSS classes to style the templates\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nAt path \n/\n a login form will be displayed:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/dashboard\n whenever \"Log in\" button is clicked, passing the username and the password:\n\n\nform class=\nform-group jumbotron\n action=\n/dashboard\n method=\npost\n\n    \np\n\n        \nlabel\nUser\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\nuser\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nPass\n/label\n\n        \ninput class=\nform-control\n type=\npassword\n name=\npass\n required=\ntrue\n/input\n\n    \n/p\n\n    \np class=\ntext-center\n\n        \nbutton class=\nbtn btn-lg btn-info\n type=\nsubmit\nLog in\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nserver.js\n at \n/dashboard\n first checks if the user is already logged (maybe he has just refreshed \n/dashboard\n page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets a new \nexpress-session\n for the newly logged user (adding a \nloggedUser\n property with its username in the \nreq.session\n object). Finally it returns \ndashboard.ejs\n template:\n\n\napp.post('/dashboard', dashboardController);\napp.get('/dashboard', dashboardController);\n\nfunction dashboardController(req, res) {\n\n    // Check if the user is already logged in\n    if (isLogged(req.session)) {\n        // User is already logged. Immediately return dashboard\n        user = req.session.loggedUser;\n        res.render('dashboard.ejs', {\n            user: user\n        });\n    } else {\n        // User wasn't logged and wants to\n\n        // Retrieve params from POST body\n        var user = req.body.user;\n        var pass = req.body.pass;\n\n        if (login(user, pass)) { // Correct user-pass\n            // Validate session and return OK \n            // Value stored in req.session allows us to identify the user in future requests\n            req.session.loggedUser = user;\n            res.render('dashboard.ejs', {\n                user: user\n            });\n        } else { // Wrong user-pass\n            // Invalidate session and return index template\n            req.session.destroy();\n            res.redirect('/');\n        }\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\ndashboard.ejs\n template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/session\n whenever \"Join!\" button is clicked, passing the nickname and the session name:\n\n\nform class=\nform-group\n action=\n/session\n method=\npost\n\n    \np\n\n        \nlabel\nParticipant\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\ndata\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nSession\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\nsessionname\n required=\ntrue\n/input\n\n    \n/p\n\n    \np class=\ntext-center\n\n        \nbutton class=\nbtn btn-lg btn-success\n type=\nsubmit\nJoin!\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nWhen \nserver.js\n receives a request at \n/session\n path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:\n\n\n// Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// Entrypoint to OpenVidu Node Client SDK\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names with OpenVidu Session objects\nvar mapSessions = {};\n// Collection to pair session names with tokens\nvar mapSessionNamesTokens = {};\n\n\n\n\nRest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: \ntokenOptions\n.\n\n\napp.post('/session', (req, res) =\n {\n    // Check the user is logged ...\n\n    // The nickname sent by the client\n    var clientData = req.body.data;\n    // The video-call to connect\n    var sessionName = req.body.sessionname;\n\n    // Role associated to this user\n    var role = users.find(u =\n (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = JSON.stringify({ serverData: req.session.loggedUser });\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = {\n        data: serverData,\n        role: role\n    };\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exist?\n\n\nif (mapSessions[sessionName]) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse {\n// Create a new OpenVidu Session asynchronously\nOV.createSession()\n    .then(session =\n {\n        // Store the new Session in the collection of Sessions\n        mapSessions[sessionName] = session;\n        // Store a new empty array in the collection of tokens\n        mapSessionNamesTokens[sessionName] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        session.generateToken(tokenOptions)\n            .then(token =\n {\n\n                // Store the new token in the collection of tokens\n                mapSessionNamesTokens[sessionName].push(token);\n\n                // Return session template with all the needed attributes\n                res.render('session.ejs', {\n                    sessionName: sessionName,\n                    token: token,\n                    nickName: clientData,\n                    userName: req.session.loggedUser,\n                });\n            })\n            .catch(error =\n {\n                console.error(error);\n            });\n    })\n    .catch(error =\n {\n        console.error(error);\n    });\n}\n\n\n\n\nWe are almost there! Now in \nsession.ejs\n JavaScript code (preceded by a tag \nscript\n) we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// Get all the attributes from the template in EJS style\nvar sessionName = \n%- JSON.stringify(sessionName) %\n;\nvar token = \n%- JSON.stringify(token) %\n;\nvar nickName = \n%- JSON.stringify(nickName) %\n;\nvar userName = \n%- JSON.stringify(userName) %\n;\n\n\n\n\n// --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', (event) =\n {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', (event) =\n {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', (event) =\n {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 4) Connect to the session passing the retrieved token and some more data from\n//        the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, { clientData: nickName })\n    .then(() =\n {\n\n        // --- 5) Set page layout for active call ---\n\n        $('#session-title').text(sessionName);\n        $('#join').hide();\n        $('#session').show();\n\n        // Here we check somehow if the user has 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method is not recognized as 'PUBLIHSER' role by OpenVidu Server\n        if (isPublisher()) {\n\n            // --- 6) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', (event) =\n {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    })\n    .catch(error =\n {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    });\n});\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nserver.js\n executes controller at \n/session\n. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (mapSessions[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessions[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions)\n        .then(token =\n {\n\n            // Store the new token in the collection of tokens\n            mapSessionNamesTokens[sessionName].push(token);\n\n            // Return session template with all the needed attributes\n            res.render('session.ejs', {\n                sessionId: mySession.getSessionId(),\n                token: token,\n                nickName: clientData,\n                userName: req.session.loggedUser,\n                sessionName: sessionName\n            });\n        })\n        .catch(error =\n {\n            console.error(error);\n        });\n}\n\n\n\n\nThe code executed in \nsession.ejs\n \n script \n tag would also be the same. After the \nSession.publish()\n method has been successful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nsession.disconnect()\n (triggered in \nleaveSession()\n \nonclick\n method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.\n\n\nIn \nsession.ejs\n template the \"Leave session\" button actually performs a POST operation to path \n/leave-session\n with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the \nleaveSession()\n method. First updates our backend. Second updates our openvidu-server.\n\n\nform action=\n/leave-session\n method=\npost\n\n    \ninput type=\nhidden\n name=\nsessionname\n value=\n%= sessionName %\n/input\n\n    \ninput type=\nhidden\n name=\ntoken\n value=\n%= token %\n/input\n\n    \nbutton id=\nbuttonLeaveSession\n class=\nbtn btn-large btn-danger\n type=\nsubmit\n onclick=\nleaveSession()\nLeave session\n/button\n\n\n/form\n\n\n\n\n\nIn \nserver.js\n we update the collections at \n/leave-session\n:\n\n\napp.post('/leave-session', (req, res) =\n {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionname;\n    var token = req.body.token;\n\n    // If the session exists\n    if (mapSessions[sessionName] \n mapSessionNamesTokens[sessionName]) {\n        var tokens = mapSessionNamesTokens[sessionName];\n        var index = tokens.indexOf(token);\n\n        // If the token exists\n        if (index !== -1) {\n            // Token removed\n            tokens.splice(index, 1);\n        } else {\n            console.log('Problems in the app server: the TOKEN wasn\\'t valid');\n            res.redirect('/dashboard');\n        }\n        if (tokens.length == 0) {\n            // Last user left: session must be removed\n            delete mapSessions[sessionName];\n        }\n        res.redirect('/dashboard');\n    } else {\n        var msg = 'Problems in the app server: the SESSION does not exist';\n        res.status(500).send(msg);\n    }\n\n\n\n\nWhen the last user leaves the session \ndelete mapSessions[sessionName]\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-mvc-node"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#openvidu-mvc-node", 
            "text": "Check it on GitHub  A secure OpenVidu sample app with a Node backend and a traditional MVC frontend. It makes use of  openvidu-node-client  to connect to OpenVidu Server. With regard to the use of OpenVidu, it is identical to  openvidu-js-node . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends.  Embedded JavaScript  is the template engine of choice for this tutorial.", 
            "title": "openvidu-mvc-node"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-node-client : server SDK for Node. Quick alternative to REST API  openvidu-server : application to control Kurento Media Server  Kurento Media Server : handles low level operations of media flow transmissions", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  1) You will need  node  to execute the app. You can install them with:  sudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs  3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute  server.js  server passing two arguments: \"localhost:4443\" as the URL where  openvidu-server  will be listening and \"MY_SECRET\" as the secret share with it:  cd openvidu-tutorials/openvidu-mvc-node\nnpm install\nnode server.js localhost:4443 MY_SECRET  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with  express  that serves HTML files with a MVC approach, building the templates with the help of  Embedded JavaScript . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  express-session  API.    Backend : node server   server.js  : single file which handles all operations of server. It returns HTML templates as response to HTTP requests.     Frontend templates : Plain JS/HTML/CSS files served by the backend, with  .ejs  extension to support Embedded JavaScript ( /views  folder)   index.ejs  : template with the login form  dashboard.ejs  : template with the form to join a video-call  session.ejs  : template of the video-call itself     Frontend static files  ( /public  folder)   openvidu-browser-VERSION.js  : openvidu-browser library. You don't have to manipulate this file  style.css  : some CSS classes to style the templates     Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#1-user-logs-in", 
            "text": "At path  /  a login form will be displayed:  \n     The form will execute a POST operation to path  /dashboard  whenever \"Log in\" button is clicked, passing the username and the password:  form class= form-group jumbotron  action= /dashboard  method= post \n     p \n         label User /label \n         input class= form-control  type= text  name= user  required= true /input \n     /p \n     p \n         label Pass /label \n         input class= form-control  type= password  name= pass  required= true /input \n     /p \n     p class= text-center \n         button class= btn btn-lg btn-info  type= submit Log in /button \n     /p  /form   server.js  at  /dashboard  first checks if the user is already logged (maybe he has just refreshed  /dashboard  page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets a new  express-session  for the newly logged user (adding a  loggedUser  property with its username in the  req.session  object). Finally it returns  dashboard.ejs  template:  app.post('/dashboard', dashboardController);\napp.get('/dashboard', dashboardController);\n\nfunction dashboardController(req, res) {\n\n    // Check if the user is already logged in\n    if (isLogged(req.session)) {\n        // User is already logged. Immediately return dashboard\n        user = req.session.loggedUser;\n        res.render('dashboard.ejs', {\n            user: user\n        });\n    } else {\n        // User wasn't logged and wants to\n\n        // Retrieve params from POST body\n        var user = req.body.user;\n        var pass = req.body.pass;\n\n        if (login(user, pass)) { // Correct user-pass\n            // Validate session and return OK \n            // Value stored in req.session allows us to identify the user in future requests\n            req.session.loggedUser = user;\n            res.render('dashboard.ejs', {\n                user: user\n            });\n        } else { // Wrong user-pass\n            // Invalidate session and return index template\n            req.session.destroy();\n            res.redirect('/');\n        }\n    }\n}", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#2-user-connects-to-tutorial-video-call", 
            "text": "dashboard.ejs  template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:  \n     The form will execute a POST operation to path  /session  whenever \"Join!\" button is clicked, passing the nickname and the session name:  form class= form-group  action= /session  method= post \n     p \n         label Participant /label \n         input class= form-control  type= text  name= data  required= true /input \n     /p \n     p \n         label Session /label \n         input class= form-control  type= text  name= sessionname  required= true /input \n     /p \n     p class= text-center \n         button class= btn btn-lg btn-success  type= submit Join! /button \n     /p  /form   When  server.js  receives a request at  /session  path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:  // Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// Entrypoint to OpenVidu Node Client SDK\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names with OpenVidu Session objects\nvar mapSessions = {};\n// Collection to pair session names with tokens\nvar mapSessionNamesTokens = {};  Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on:  tokenOptions .  app.post('/session', (req, res) =  {\n    // Check the user is logged ...\n\n    // The nickname sent by the client\n    var clientData = req.body.data;\n    // The video-call to connect\n    var sessionName = req.body.sessionname;\n\n    // Role associated to this user\n    var role = users.find(u =  (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = JSON.stringify({ serverData: req.session.loggedUser });\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = {\n        data: serverData,\n        role: role\n    };  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exist?  if (mapSessions[sessionName]) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else {\n// Create a new OpenVidu Session asynchronously\nOV.createSession()\n    .then(session =  {\n        // Store the new Session in the collection of Sessions\n        mapSessions[sessionName] = session;\n        // Store a new empty array in the collection of tokens\n        mapSessionNamesTokens[sessionName] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        session.generateToken(tokenOptions)\n            .then(token =  {\n\n                // Store the new token in the collection of tokens\n                mapSessionNamesTokens[sessionName].push(token);\n\n                // Return session template with all the needed attributes\n                res.render('session.ejs', {\n                    sessionName: sessionName,\n                    token: token,\n                    nickName: clientData,\n                    userName: req.session.loggedUser,\n                });\n            })\n            .catch(error =  {\n                console.error(error);\n            });\n    })\n    .catch(error =  {\n        console.error(error);\n    });\n}  We are almost there! Now in  session.ejs  JavaScript code (preceded by a tag  script ) we can init a new Session with  sessionId  and connect to it with  token :  // Get all the attributes from the template in EJS style\nvar sessionName =  %- JSON.stringify(sessionName) % ;\nvar token =  %- JSON.stringify(token) % ;\nvar nickName =  %- JSON.stringify(nickName) % ;\nvar userName =  %- JSON.stringify(userName) % ;  // --- 1) Get an OpenVidu object ---\n\nOV = new OpenVidu();\n\n// --- 2) Init a session ---\n\nsession = OV.initSession();\n\n\n// --- 3) Specify the actions when events take place in the session ---\n\n// On every new Stream received...\nsession.on('streamCreated', (event) =  {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', (event) =  {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', (event) =  {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 4) Connect to the session passing the retrieved token and some more data from\n//        the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, { clientData: nickName })\n    .then(() =  {\n\n        // --- 5) Set page layout for active call ---\n\n        $('#session-title').text(sessionName);\n        $('#join').hide();\n        $('#session').show();\n\n        // Here we check somehow if the user has 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method is not recognized as 'PUBLIHSER' role by OpenVidu Server\n        if (isPublisher()) {\n\n            // --- 6) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audioSource: undefined, // The source of audio. If undefined default microphone\n                videoSource: undefined, // The source of video. If undefined default webcam\n                publishAudio: true,     // Whether you want to start publishing with your audio unmuted or not\n                publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n                resolution: '640x480',  // The resolution of your video\n                frameRate: 30,          // The frame rate of your video\n                insertMode: 'APPEND',   // How the video is inserted in the target element 'video-container'\n                mirror: false           // Whether to mirror your local video or not\n            });\n\n            // --- 7) Specify the actions when events take place in our publisher ---\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', (event) =  {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 8) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    })\n    .catch(error =  {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    });\n});  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  server.js  executes controller at  /session . Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (mapSessions[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessions[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions)\n        .then(token =  {\n\n            // Store the new token in the collection of tokens\n            mapSessionNamesTokens[sessionName].push(token);\n\n            // Return session template with all the needed attributes\n            res.render('session.ejs', {\n                sessionId: mySession.getSessionId(),\n                token: token,\n                nickName: clientData,\n                userName: req.session.loggedUser,\n                sessionName: sessionName\n            });\n        })\n        .catch(error =  {\n            console.error(error);\n        });\n}  The code executed in  session.ejs    script   tag would also be the same. After the  Session.publish()  method has been successful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  session.disconnect()  (triggered in  leaveSession()   onclick  method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.  In  session.ejs  template the \"Leave session\" button actually performs a POST operation to path  /leave-session  with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the  leaveSession()  method. First updates our backend. Second updates our openvidu-server.  form action= /leave-session  method= post \n     input type= hidden  name= sessionname  value= %= sessionName % /input \n     input type= hidden  name= token  value= %= token % /input \n     button id= buttonLeaveSession  class= btn btn-large btn-danger  type= submit  onclick= leaveSession() Leave session /button  /form   In  server.js  we update the collections at  /leave-session :  app.post('/leave-session', (req, res) =  {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionname;\n    var token = req.body.token;\n\n    // If the session exists\n    if (mapSessions[sessionName]   mapSessionNamesTokens[sessionName]) {\n        var tokens = mapSessionNamesTokens[sessionName];\n        var index = tokens.indexOf(token);\n\n        // If the token exists\n        if (index !== -1) {\n            // Token removed\n            tokens.splice(index, 1);\n        } else {\n            console.log('Problems in the app server: the TOKEN wasn\\'t valid');\n            res.redirect('/dashboard');\n        }\n        if (tokens.length == 0) {\n            // Last user left: session must be removed\n            delete mapSessions[sessionName];\n        }\n        res.redirect('/dashboard');\n    } else {\n        var msg = 'Problems in the app server: the SESSION does not exist';\n        res.status(500).send(msg);\n    }  When the last user leaves the session  delete mapSessions[sessionName]  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/demos/openvidu-getaroom/", 
            "text": "openvidu-getaroom\n\n\n Check it on GitHub\n\n\nOpenVidu-Getaroom demo, \nbuilt with Vanilla JS, \n allows users to connect to a room and share the link with others, so they can connect to it straight away just by visiting that link. It is a frontend-only application and it makes use of OpenVidu the same way \nopenvidu-insecure-js\n does.\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flows transmission\n\n\n\n\nRunning this demo\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need an http web server installed in your development computer to execute the sample application. If you have \nnode.js\n installed, you can use \nhttp-server\n to serve application files. It can be installed with:\n\n\nnpm install -g http-server\n\n\n\n\n3) Run the tutorial:\n\n\nhttp-server openvidu-tutorials/openvidu-getaroom/web\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nlocalhost:8080\n{:target=\"\nblank\"} to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of _openvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis application is very simple. It has only 4 files:\n\n\n\n\nopenvidu-browser-VERSION.js\n: openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n: sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n. You can manipulate this file to suit your needs.\n\n\n\n\nindex.html\n: HTML code for the welcome page to join a new room and for the room itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files: \n\n\nscript src=\"openvidu-browser-VERSION.js.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n. You can manipulate this file to suit your needs. \nindex.html\n uses also Bootstrap as its main style framework.\n\n\n\n\n\n\nDown below we will describe the most important code snippets in \napp.js\n:\n\n\n\n\nDeclaration of variables\n\n\nWe will need some variables accesible from differents methods\n\n\nvar OV;                     // OpenVidu object to initialize a session\nvar session;                // Session object where the user will connect\nvar publisher;              // Publisher object which the user will publish\nvar sessionId;              // Unique identifier of the session\nvar audioEnabled = true;    // True if the audio track of publisher is active\nvar videoEnabled = true;    // True if the video track of publisher is active\nvar numOfVideos = 0;        // Keeps track of the number of videos that are being shown\n\n\n\n\n\n\nWindow callbacks\n\n\nOn \nload\n we will check if the user is connecting to an existing room or to a new one depending on the browser's location, on \nbeforeunload\n we will disconnect the user from the room\n\n\n// Check if the URL already has a room\nwindow.addEventListener('load', function () {\n    sessionId = window.location.hash.slice(1); // For 'https://myurl/#roomId', sessionId would be 'roomId'\n    if (sessionId) {\n        // The URL has a session id. Join the room right away\n        console.log(\nJoining to room \n + sessionId);\n        showSessionHideJoin();\n        joinRoom();\n    } else {\n        // The URL has not a session id. Show welcome page\n        showJoinHideSession();\n    }\n});\n\n// Disconnect participant on browser's window closed\nwindow.addEventListener('beforeunload', function () {\n    if (session) session.disconnect();\n});\n\n\n\n\n\n\njoinRoom\n method\n\n\nHere we initialize our session and set the events we need for the desired behaviuor. Then we connect to it and finally publish our own webcam to the session.\n\n\nfunction joinRoom() {\n\n    if (!sessionId) {\n        // If the user is joining to a new room\n        sessionId = randomString();\n    }\n\n    // --- 1) Get an OpenVidu object ---\n\n    OV = new OpenVidu();\n\n    // --- 2) Init a session ---\n\n    session = OV.initSession();\n\n\n    // --- 3) Specify the actions when events take place in the session ---\n\n    // On every new Stream received...\n    session.on('streamCreated', function (event) {\n        // Subscribe to the Stream to receive it. HTML video will be appended to element with 'subscriber' id\n        var subscriber = session.subscribe(event.stream, 'videos');\n        // When the new video is added to DOM, update the page layout to fit one more participant\n        subscriber.on('videoElementCreated', function (event) {\n            numOfVideos++;\n            updateLayout();\n        });\n    });\n\n    // On every new Stream destroyed...\n    session.on('streamDestroyed', function (event) {\n        // Update the page layout\n        numOfVideos--;\n        updateLayout();\n    });\n\n\n    // --- 4) Connect to the session with a valid user token ---\n\n    // 'getToken' method is simulating what your server-side should do.\n    // 'token' parameter should be retrieved and returned by your own backend\n    getToken(sessionId).then(token =\n {\n\n        // Connect with the token\n        session.connect(token)\n            .then(() =\n {\n\n                // --- 5) Set page layout for active call ---\n\n                // Update the URL shown in the browser's navigation bar to show the session id\n                var path = (location.pathname.slice(-1) == \n/\n ? location.pathname : location.pathname + \n/\n);\n                window.history.pushState(\n, \n, path + '#' + sessionId);\n\n                // Auxiliary methods to show the session's view\n                showSessionHideJoin();\n                initializeSessionView();\n\n                // --- 6) Get your own camera stream with the desired properties ---\n\n                publisher = OV.initPublisher('publisher', {\n                    audioSource: undefined, // The source of audio. If undefined default audio input\n                    videoSource: undefined, // The source of video. If undefined default video input\n                    publishAudio: true,     // Whether to start publishing with your audio unmuted or not\n                    publishVideo: true,     // Whether to start publishing with your video enabled or not\n                    resolution: '640x480',  // The resolution of your video\n                    frameRate: 30,          // The frame rate of your video\n                    insertMode: 'APPEND',   // How the video is inserted in target element 'video-container'\n                    mirror: true            // Whether to mirror your local video or not\n                });\n\n                // --- 7) Specify the actions when events take place in our publisher ---\n\n                // When our HTML video has been added to DOM...\n                publisher.on('videoElementCreated', function (event) {\n                    // When your own video is added to DOM, update the page layout to fit it\n                    numOfVideos++;\n                    updateLayout();\n                    $(event.element).prop('muted', true); // Mute local video to avoid feedback\n                });\n\n                // --- 8) Publish your stream ---\n\n                session.publish(publisher);\n            })\n            .catch(error =\n {\n                console.log('There was an error connecting to the session:', error.code, error.message);\n            });\n    });\n}\n\n\n\n\n\n\nleaveRoom\n method\n\n\nfunction leaveRoom() {\n\n    // --- 9) Leave the session by calling 'disconnect' method over the Session object ---\n\n    session.disconnect();\n\n    // Back to welcome page\n    window.location.href = window.location.origin + window.location.pathname;\n}\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-getaroom"
        }, 
        {
            "location": "/demos/openvidu-getaroom/#openvidu-getaroom", 
            "text": "Check it on GitHub  OpenVidu-Getaroom demo,  built with Vanilla JS,   allows users to connect to a room and share the link with others, so they can connect to it straight away just by visiting that link. It is a frontend-only application and it makes use of OpenVidu the same way  openvidu-insecure-js  does.  \n     OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flows transmission", 
            "title": "openvidu-getaroom"
        }, 
        {
            "location": "/demos/openvidu-getaroom/#running-this-demo", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need an http web server installed in your development computer to execute the sample application. If you have  node.js  installed, you can use  http-server  to serve application files. It can be installed with:  npm install -g http-server  3) Run the tutorial:  http-server openvidu-tutorials/openvidu-getaroom/web  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  localhost:8080 {:target=\" blank\"} to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of _openvidu-server  when you first try to join a video-call.    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Running this demo"
        }, 
        {
            "location": "/demos/openvidu-getaroom/#understanding-the-code", 
            "text": "This application is very simple. It has only 4 files:   openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file.   app.js : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js . You can manipulate this file to suit your needs.   index.html : HTML code for the welcome page to join a new room and for the room itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files:   script src=\"openvidu-browser-VERSION.js.js\" /script  script src=\"app.js\" /script     style.css : some CSS classes to style  index.html . You can manipulate this file to suit your needs.  index.html  uses also Bootstrap as its main style framework.    Down below we will describe the most important code snippets in  app.js :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/demos/openvidu-getaroom/#declaration-of-variables", 
            "text": "We will need some variables accesible from differents methods  var OV;                     // OpenVidu object to initialize a session\nvar session;                // Session object where the user will connect\nvar publisher;              // Publisher object which the user will publish\nvar sessionId;              // Unique identifier of the session\nvar audioEnabled = true;    // True if the audio track of publisher is active\nvar videoEnabled = true;    // True if the video track of publisher is active\nvar numOfVideos = 0;        // Keeps track of the number of videos that are being shown", 
            "title": "Declaration of variables"
        }, 
        {
            "location": "/demos/openvidu-getaroom/#window-callbacks", 
            "text": "On  load  we will check if the user is connecting to an existing room or to a new one depending on the browser's location, on  beforeunload  we will disconnect the user from the room  // Check if the URL already has a room\nwindow.addEventListener('load', function () {\n    sessionId = window.location.hash.slice(1); // For 'https://myurl/#roomId', sessionId would be 'roomId'\n    if (sessionId) {\n        // The URL has a session id. Join the room right away\n        console.log( Joining to room   + sessionId);\n        showSessionHideJoin();\n        joinRoom();\n    } else {\n        // The URL has not a session id. Show welcome page\n        showJoinHideSession();\n    }\n});\n\n// Disconnect participant on browser's window closed\nwindow.addEventListener('beforeunload', function () {\n    if (session) session.disconnect();\n});", 
            "title": "Window callbacks"
        }, 
        {
            "location": "/demos/openvidu-getaroom/#joinroom-method", 
            "text": "Here we initialize our session and set the events we need for the desired behaviuor. Then we connect to it and finally publish our own webcam to the session.  function joinRoom() {\n\n    if (!sessionId) {\n        // If the user is joining to a new room\n        sessionId = randomString();\n    }\n\n    // --- 1) Get an OpenVidu object ---\n\n    OV = new OpenVidu();\n\n    // --- 2) Init a session ---\n\n    session = OV.initSession();\n\n\n    // --- 3) Specify the actions when events take place in the session ---\n\n    // On every new Stream received...\n    session.on('streamCreated', function (event) {\n        // Subscribe to the Stream to receive it. HTML video will be appended to element with 'subscriber' id\n        var subscriber = session.subscribe(event.stream, 'videos');\n        // When the new video is added to DOM, update the page layout to fit one more participant\n        subscriber.on('videoElementCreated', function (event) {\n            numOfVideos++;\n            updateLayout();\n        });\n    });\n\n    // On every new Stream destroyed...\n    session.on('streamDestroyed', function (event) {\n        // Update the page layout\n        numOfVideos--;\n        updateLayout();\n    });\n\n\n    // --- 4) Connect to the session with a valid user token ---\n\n    // 'getToken' method is simulating what your server-side should do.\n    // 'token' parameter should be retrieved and returned by your own backend\n    getToken(sessionId).then(token =  {\n\n        // Connect with the token\n        session.connect(token)\n            .then(() =  {\n\n                // --- 5) Set page layout for active call ---\n\n                // Update the URL shown in the browser's navigation bar to show the session id\n                var path = (location.pathname.slice(-1) ==  /  ? location.pathname : location.pathname +  / );\n                window.history.pushState( ,  , path + '#' + sessionId);\n\n                // Auxiliary methods to show the session's view\n                showSessionHideJoin();\n                initializeSessionView();\n\n                // --- 6) Get your own camera stream with the desired properties ---\n\n                publisher = OV.initPublisher('publisher', {\n                    audioSource: undefined, // The source of audio. If undefined default audio input\n                    videoSource: undefined, // The source of video. If undefined default video input\n                    publishAudio: true,     // Whether to start publishing with your audio unmuted or not\n                    publishVideo: true,     // Whether to start publishing with your video enabled or not\n                    resolution: '640x480',  // The resolution of your video\n                    frameRate: 30,          // The frame rate of your video\n                    insertMode: 'APPEND',   // How the video is inserted in target element 'video-container'\n                    mirror: true            // Whether to mirror your local video or not\n                });\n\n                // --- 7) Specify the actions when events take place in our publisher ---\n\n                // When our HTML video has been added to DOM...\n                publisher.on('videoElementCreated', function (event) {\n                    // When your own video is added to DOM, update the page layout to fit it\n                    numOfVideos++;\n                    updateLayout();\n                    $(event.element).prop('muted', true); // Mute local video to avoid feedback\n                });\n\n                // --- 8) Publish your stream ---\n\n                session.publish(publisher);\n            })\n            .catch(error =  {\n                console.log('There was an error connecting to the session:', error.code, error.message);\n            });\n    });\n}", 
            "title": "joinRoom method"
        }, 
        {
            "location": "/demos/openvidu-getaroom/#leaveroom-method", 
            "text": "function leaveRoom() {\n\n    // --- 9) Leave the session by calling 'disconnect' method over the Session object ---\n\n    session.disconnect();\n\n    // Back to welcome page\n    window.location.href = window.location.origin + window.location.pathname;\n}    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "leaveRoom method"
        }, 
        {
            "location": "/demos/openvidu-call/", 
            "text": "openvidu-call\n\n\n Check it on GitHub\n\n\nOpenVidu Call demo, built with \nAngular 7\n,  allows users to make videoconference calls with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application.\n\n\nOpenVidu-Call is composed by the six Angular components displayed in the image below.\n\n\n\n\n\n  \n\n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \nLogin Component\n\n        \nThis component allows you to set the videocall name and login in that session. That session name can be shared with whomever the user wants to join the videoconference.\n\n    \n\n\n\n\n\n\n\n    \n\n        \nVideo-room Component\n\n        \nThis is the main component of \nOpenVidu-Call\n. It allows you to set up the session before join to the room. You will can check and set your microphone and your webcam device, create your own avatar or to choose the default avatar and to establish the nickname.\n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \nChat Component\n\n        \nThis component provides to Video-room Component a chatting system that allows users to type to each other.\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \nStream Component\n\n        \n With OpenVidu Layout, this component is the responsible of displaying the video stream of each user in a nice way. On the right, we can see four streams displayed in the same videoconference.\n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\nRunning this demo\n\n\nYou have several options to run OpenVidu Call:\n\n\nUsing Docker\n\n\nThe easiest way is running this Docker container (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 openvidu/openvidu-call\n\n\n\n\nCloning GitHub Repository\n\n\n1)  Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-call.git\n\n\n\n\n2) You will need node, NPM and angular-cli to execute the app. You can install them with:\n\n\nsudo apt-get update\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\nsudo npm install -g @angular/cli\n\n\n\n\n3)  \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n4)  Install NPM dependencies of Angular app:\n\n\ncd openvidu-call/front/openvidu-call\nnpm install\n\n\n\n\n5)  Launch the server:\n\n\nng serve --open\n\n\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\nUsing the Release\n\n\nHere\n are OpenVidu Call releases.\nThe \nopenvidu-call-X.X.X.tar.gz\n file contains the compiled app served in \n/\n and \nopenvidu-call-demos-X.X.X.tar.gz\n file contains the compiled app served in \n/openvidu-call/\n.\n\n\nTo run OpenVidu Call with the compiled files you will need:\n\n\n1) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n2) Download the release:\n\n\nwget https://github.com/OpenVidu/openvidu-call/releases/download/v2.8.0/openvidu-call-demos-2.8.0.tar.gz\n\n\n\n\n3) Decompress the downloaded file:\n\n\nmkdir openvidu-call\ntar -xvzf openvidu-call-2.8.0.tar.gz -C openvidu-call/\ncd openvidu-call\n\n\n\n\n4) You will need a HTTP server to display the app like \nNGINX\n or \nhttp-server\n.  We will use \nhttp-server\n:\n\n\nYou will need \nnode\n and \nNPM\n to install http-server. You can install them with:\n\n\nsudo apt-get update\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\n\n\n\n\nInstall \nhttp-server\n:\n\n\nnpm i http-server\n\n\n\n\n5) Serve the app:\n\n\nhttp-server\n\n\n\n\nWait until you see on the output a line IP address. \n\n\nBy default, the app will be served in \nlocalhost:8080\n address. You will need go to \nhttps://localhost:4443/\n to accept the self-signed certificate. Once accepted, you will be able to test OpenVidu Call in the default IP \nlocalhost:8080\n\n\nExtra features\n\n\nUsing the OpenVidu Call release, you can set up the address where you app will be served with \nhttp-server -a \"your_address\"\n. Moreover, includying a \nJSON\n file named \nov-settings.json\n in the root directory, you will can configure the \nopenvidu_url\n and \nopenvidu_secret\n on this way:\n\n\n{\n  \nopenviduCredentials\n: {\n    \nopenvidu_url\n: \nhttps://0.0.0.0:4443\n,\n    \nopenvidu_secret\n: \nMY_SECRET\n\n  }\n}\n\n\n\n\nNot only you can establish your own \nopenvidu_url\n and \nopenvidu_secret\n parameters but also, you can customize the session interface adding an extra JSON object named  \nopenviduSettings\n inside of the file. We have explained in detail how \nopenviduSettings\n object must be treated \nhere\n.\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-call"
        }, 
        {
            "location": "/demos/openvidu-call/#openvidu-call", 
            "text": "Check it on GitHub  OpenVidu Call demo, built with  Angular 7 ,  allows users to make videoconference calls with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application.  OpenVidu-Call is composed by the six Angular components displayed in the image below.   \n      \n     \n         \n             \n         \n     \n     \n         Login Component \n         This component allows you to set the videocall name and login in that session. That session name can be shared with whomever the user wants to join the videoconference. \n        \n     \n         Video-room Component \n         This is the main component of  OpenVidu-Call . It allows you to set up the session before join to the room. You will can check and set your microphone and your webcam device, create your own avatar or to choose the default avatar and to establish the nickname. \n     \n     \n         \n             \n         \n        \n     \n         \n             \n         \n     \n     \n         Chat Component \n         This component provides to Video-room Component a chatting system that allows users to type to each other.\n         \n        \n     \n         Stream Component \n          With OpenVidu Layout, this component is the responsible of displaying the video stream of each user in a nice way. On the right, we can see four streams displayed in the same videoconference.", 
            "title": "openvidu-call"
        }, 
        {
            "location": "/demos/openvidu-call/#running-this-demo", 
            "text": "You have several options to run OpenVidu Call:", 
            "title": "Running this demo"
        }, 
        {
            "location": "/demos/openvidu-call/#using-docker", 
            "text": "The easiest way is running this Docker container (you will need  Docker CE ):  docker run -p 4443:4443 openvidu/openvidu-call", 
            "title": "Using Docker"
        }, 
        {
            "location": "/demos/openvidu-call/#cloning-github-repository", 
            "text": "1)  Clone the repo:  git clone https://github.com/OpenVidu/openvidu-call.git  2) You will need node, NPM and angular-cli to execute the app. You can install them with:  sudo apt-get update\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\nsudo npm install -g @angular/cli  3)   openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  4)  Install NPM dependencies of Angular app:  cd openvidu-call/front/openvidu-call\nnpm install  5)  Launch the server:  ng serve --open    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Cloning GitHub Repository"
        }, 
        {
            "location": "/demos/openvidu-call/#using-the-release", 
            "text": "Here  are OpenVidu Call releases.\nThe  openvidu-call-X.X.X.tar.gz  file contains the compiled app served in  /  and  openvidu-call-demos-X.X.X.tar.gz  file contains the compiled app served in  /openvidu-call/ .  To run OpenVidu Call with the compiled files you will need:  1) openvidu-server and Kurento Media Server must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  2) Download the release:  wget https://github.com/OpenVidu/openvidu-call/releases/download/v2.8.0/openvidu-call-demos-2.8.0.tar.gz  3) Decompress the downloaded file:  mkdir openvidu-call\ntar -xvzf openvidu-call-2.8.0.tar.gz -C openvidu-call/\ncd openvidu-call  4) You will need a HTTP server to display the app like  NGINX  or  http-server .  We will use  http-server :  You will need  node  and  NPM  to install http-server. You can install them with:  sudo apt-get update\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs  Install  http-server :  npm i http-server  5) Serve the app:  http-server  Wait until you see on the output a line IP address.   By default, the app will be served in  localhost:8080  address. You will need go to  https://localhost:4443/  to accept the self-signed certificate. Once accepted, you will be able to test OpenVidu Call in the default IP  localhost:8080", 
            "title": "Using the Release"
        }, 
        {
            "location": "/demos/openvidu-call/#extra-features", 
            "text": "Using the OpenVidu Call release, you can set up the address where you app will be served with  http-server -a \"your_address\" . Moreover, includying a  JSON  file named  ov-settings.json  in the root directory, you will can configure the  openvidu_url  and  openvidu_secret  on this way:  {\n   openviduCredentials : {\n     openvidu_url :  https://0.0.0.0:4443 ,\n     openvidu_secret :  MY_SECRET \n  }\n}  Not only you can establish your own  openvidu_url  and  openvidu_secret  parameters but also, you can customize the session interface adding an extra JSON object named   openviduSettings  inside of the file. We have explained in detail how  openviduSettings  object must be treated  here .    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Extra features"
        }, 
        {
            "location": "/demos/openvidu-call-react/", 
            "text": "openvidu-call-react\n\n\n Check it on GitHub\n\n\nOpenVidu Call demo,\n built with React\n,  allows users to make videoconference calls with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application.\n\n\nOpenVidu-Call-React is composed by the five React components displayed in the image below.\n\n\n\n\n\n  \n\n\n\n\n\n\n\n    \n\n        \nVideoRoom Component\n\n        \nThis is the main component of \nOpenVidu-Call-React\n. It allows you to establish a connection with your video roommates. This component allows the user to mute the microphone, unpublish the webcam, share the screen, open the chat and leave the session.\n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \nChat Component\n\n        \nThis component provides to Video-room Component a chatting system, integrated with the layout, that allows users to type to each other.\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \nStream Component\n\n        \n With OpenVidu Layout, this component is the responsible of displaying the video stream of each user in a nice way. On the right, we can see four streams displayed in the same videoconference.\n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\nRunning this demo\n\n\nCloning GitHub Repository\n\n\n1)  Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-call-react.git\n\n\n\n\n2) You will need node, NPM and to execute the app. You can install them with:\n\n\nsudo apt-get update\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\n\n\n\n\n3)  \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n4)  Install NPM dependencies of Angular app:\n\n\ncd openvidu-call-react/front/openvidu-call-react\nnpm install\n\n\n\n\n5)  Launch the server:\n\n\nnpm start\n\n\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-call-react"
        }, 
        {
            "location": "/demos/openvidu-call-react/#openvidu-call-react", 
            "text": "Check it on GitHub  OpenVidu Call demo,  built with React ,  allows users to make videoconference calls with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application.  OpenVidu-Call-React is composed by the five React components displayed in the image below.   \n      \n     \n         VideoRoom Component \n         This is the main component of  OpenVidu-Call-React . It allows you to establish a connection with your video roommates. This component allows the user to mute the microphone, unpublish the webcam, share the screen, open the chat and leave the session. \n     \n     \n         \n             \n         \n        \n     \n         \n             \n         \n     \n     \n         Chat Component \n         This component provides to Video-room Component a chatting system, integrated with the layout, that allows users to type to each other.\n         \n        \n     \n         Stream Component \n          With OpenVidu Layout, this component is the responsible of displaying the video stream of each user in a nice way. On the right, we can see four streams displayed in the same videoconference.", 
            "title": "openvidu-call-react"
        }, 
        {
            "location": "/demos/openvidu-call-react/#running-this-demo", 
            "text": "", 
            "title": "Running this demo"
        }, 
        {
            "location": "/demos/openvidu-call-react/#cloning-github-repository", 
            "text": "1)  Clone the repo:  git clone https://github.com/OpenVidu/openvidu-call-react.git  2) You will need node, NPM and to execute the app. You can install them with:  sudo apt-get update\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs  3)   openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  4)  Install NPM dependencies of Angular app:  cd openvidu-call-react/front/openvidu-call-react\nnpm install  5)  Launch the server:  npm start    If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Cloning GitHub Repository"
        }, 
        {
            "location": "/demos/openvidu-call-ionic/", 
            "text": "openvidu-call-ionic\n\n\n Check it on GitHub\n\n\nOpenVidu Call Ionic demo, built with \nIonic v4 and Angular 7\n,  allows users to make videoconference calls in theirs devices with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application.\n\n\nOpenVidu-Call-Ionic is composed by the five Angular components displayed in the image below.\n\n\n\n    \n\n\n\n    Android 5 (Lollipop) and 6 (Marshmallow) will not work with Ionic v4 until \nthis issue\n is properly solved\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nRunning this demo\n\n\nUsing the browser\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-call-ionic.git\n\n\n\n\n2) You will need ionic-cli (and of course node 8.9 or greater) to serve the Ionic app. You can install it with the following command:\n\n\nnpm install -g ionic@latest\n\n\n\n\n3) Run the tutorial:\n\n\ncd openvidu-call-ionic\nnpm install\nionic serve\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Go to \nlocalhost:8100\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n6) To show the app with the device appearance, press \nF12\n button in your keyboard and the browser DevTool will be opened.\n\n\n7) Then, you can find a button with a device icon at the top of the browser page. Pressing this button, you should see the device appearance and it will allow you choose your favourite device.\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\n\n\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\n\n\nUsing the Android apk in an Android device\n\n\nTo deploy the apk Android not only you need to have \nJava JDK8\n, \nAndroid Studio\n and \nAndroid SDK\n installed but also you have to set up the specific \nenvironment variables\n. Fortunately, Ionic provide us a \ngreat guide\n to allows us to configure step by step all the requirements.\n\n\nAfter we have finished the Ionic tutorial, we must have to follow these steps:\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-call-ionic.git\n\n\n\n\n2) You will need ionic-cli (and of course node 8.9 or greater) to serve the Ionic app. You can install it with the following command:\n\n\nnpm install -g ionic@latest\n\n\n\n\n3) Connect the device to the same network as the PC. \n\n\n4) Establishing the same WIFI in both devices, you need to know IP of your PC in the network. For know that, you can execute \nifconfig\n in your command shell and you will can find something like \n192.168.0.105\n.\n\n\nYour \npublic_url\n will be \nhttps://192.168.0.105\n with the port \n4443\n (https://192.168.0.105:4443). \n\n\nFinally, you will must set the \nOPENVIDU_SERVER_URL\n variable \nin the app\n and the \nopenvidu.publicurl\n parameter used to run \nopenvidu-server\n with your \npublic_url\n and the \nport\n. \n\n\n5) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=\nyour_public_url\n:4443 openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n6) Connect the device to the PC. You can check if your device is authoriced with the \nadb devices\n command.\n\n\n7) Run the tutorial:\n\n\ncd openvidu-call-ionic\nnpm install\nionic cordova run android\n\n\n\n\n\n    \n\n\n\n    To deploy apps to an Android device and debug them, developer mode must be enabled and allow for USB debugging turned on. Check out \nthese instructions\n to do this on a device.\n\n\n\n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });\n\n\n\n\n\n\n\n\n\n\n    $('.screenshots-gallery').slick({\n      autoplay: false,\n      arrows: true,\n        prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>',\n      nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>',\n      autoplaySpeed: 4000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "openvidu-call-ionic"
        }, 
        {
            "location": "/demos/openvidu-call-ionic/#openvidu-call-ionic", 
            "text": "Check it on GitHub  OpenVidu Call Ionic demo, built with  Ionic v4 and Angular 7 ,  allows users to make videoconference calls in theirs devices with many of the capabilities integrated by OpenVidu platform. It is a frontend-only application.  OpenVidu-Call-Ionic is composed by the five Angular components displayed in the image below.  \n      \n    Android 5 (Lollipop) and 6 (Marshmallow) will not work with Ionic v4 until  this issue  is properly solved", 
            "title": "openvidu-call-ionic"
        }, 
        {
            "location": "/demos/openvidu-call-ionic/#running-this-demo", 
            "text": "", 
            "title": "Running this demo"
        }, 
        {
            "location": "/demos/openvidu-call-ionic/#using-the-browser", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-call-ionic.git  2) You will need ionic-cli (and of course node 8.9 or greater) to serve the Ionic app. You can install it with the following command:  npm install -g ionic@latest  3) Run the tutorial:  cd openvidu-call-ionic\nnpm install\nionic serve  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Go to  localhost:8100  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.  6) To show the app with the device appearance, press  F12  button in your keyboard and the browser DevTool will be opened.  7) Then, you can find a button with a device icon at the top of the browser page. Pressing this button, you should see the device appearance and it will allow you choose your favourite device.  \n     \n         \n         \n     \n     \n     \n         \n         \n     \n         If you are using  Windows , read this  FAQ  to properly run the tutorial  To learn  some tips  to develop with OpenVidu, check this  FAQ", 
            "title": "Using the browser"
        }, 
        {
            "location": "/demos/openvidu-call-ionic/#using-the-android-apk-in-an-android-device", 
            "text": "To deploy the apk Android not only you need to have  Java JDK8 ,  Android Studio  and  Android SDK  installed but also you have to set up the specific  environment variables . Fortunately, Ionic provide us a  great guide  to allows us to configure step by step all the requirements.  After we have finished the Ionic tutorial, we must have to follow these steps:  1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-call-ionic.git  2) You will need ionic-cli (and of course node 8.9 or greater) to serve the Ionic app. You can install it with the following command:  npm install -g ionic@latest  3) Connect the device to the same network as the PC.   4) Establishing the same WIFI in both devices, you need to know IP of your PC in the network. For know that, you can execute  ifconfig  in your command shell and you will can find something like  192.168.0.105 .  Your  public_url  will be  https://192.168.0.105  with the port  4443  (https://192.168.0.105:4443).   Finally, you will must set the  OPENVIDU_SERVER_URL  variable  in the app  and the  openvidu.publicurl  parameter used to run  openvidu-server  with your  public_url  and the  port .   5)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl= your_public_url :4443 openvidu/openvidu-server-kms:2.8.0  6) Connect the device to the PC. You can check if your device is authoriced with the  adb devices  command.  7) Run the tutorial:  cd openvidu-call-ionic\nnpm install\nionic cordova run android  \n      \n    To deploy apps to an Android device and debug them, developer mode must be enabled and allow for USB debugging turned on. Check out  these instructions  to do this on a device.    \n     \n         \n     \n     \n         \n     \n     \n         \n     \n     \n         \n     \n     \n         \n           \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });     \n    $('.screenshots-gallery').slick({\n      autoplay: false,\n      arrows: true,\n        prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>',\n      nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>',\n      autoplaySpeed: 4000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "Using the Android apk in an Android device"
        }, 
        {
            "location": "/demos/openvidu-classroom/", 
            "text": "openvidu-classroom\n\n\n Check it on GitHub\n\n\nThis is a fully functional application that makes use of the secure version of OpenVidu to connect teachers and students in video sessions. It has a frontend built with \nAngular 7\n, a backend built with \nSpring Boot\n and a \nMySQL\n database. There are two types of roles: teachers and students. First ones can create/edit/remove lessons and invite students to them. Only when a teacher initialize a lesson authorized students can connect to it.\n\n\nRunning this demo\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/classroom-demo.git\n\n\n\n\n2) You will need node, NPM and angular-cli to execute the app. You can install them with:\n\n\nsudo apt-get update\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\nsudo npm install -g @angular/cli\n\n\n\n\n3) This demo needs a MySQL database to store the info. Install MySQL:\n\n\nsudo apt-get install -y mysql-server\nsudo mysql_secure_installation\n\n\n\n\nAnd create a new database:\n\n\nmysql -u root -p\n\n\n\n\n(Enter the same password you set during the installation process)\n\n\nCREATE DATABASE openvidu_sample_app;\nexit\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n5) Install NPM dependencies of frontend:\n\n\ncd classroom-demo/src/angular/frontend\nnpm install\n\n\n\n\n6) Build the frontend, exporting the files to the static folder of the Java application:\n\n\nng build --output-path ../../main/resources/static\n\n\n\n\n7) Finally run the Spring Boot application:\n\n\ncd ../../../\nmvn clean package exec:java\n\n\n\n\nGo to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n  \n\n    \n\n      \n\n    \n\n  \n\n  \n\n    \n\n      \n\n    \n\n  \n\n  \n\n    \n\n      \n\n    \n\n  \n\n\n\n\n\n\n\nWithout going into greater detail, the backend has \none controller\n for the REST operations of the lessons (create new ones or edit/remove existing ones) and \none controller\n for handling the videoconferences. This controller is pretty similar to the one described in any of the secure tutorials. Basically it listens to the operations of creating a new session (returning a \nsessionId\n from \nopenvidu-server\n), generating a new user token (returning the \ntoken\n from \nopenvidu-server\n) and removing the users when they leave the session.\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-classroom"
        }, 
        {
            "location": "/demos/openvidu-classroom/#openvidu-classroom", 
            "text": "Check it on GitHub  This is a fully functional application that makes use of the secure version of OpenVidu to connect teachers and students in video sessions. It has a frontend built with  Angular 7 , a backend built with  Spring Boot  and a  MySQL  database. There are two types of roles: teachers and students. First ones can create/edit/remove lessons and invite students to them. Only when a teacher initialize a lesson authorized students can connect to it.", 
            "title": "openvidu-classroom"
        }, 
        {
            "location": "/demos/openvidu-classroom/#running-this-demo", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/classroom-demo.git  2) You will need node, NPM and angular-cli to execute the app. You can install them with:  sudo apt-get update\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\nsudo npm install -g @angular/cli  3) This demo needs a MySQL database to store the info. Install MySQL:  sudo apt-get install -y mysql-server\nsudo mysql_secure_installation  And create a new database:  mysql -u root -p  (Enter the same password you set during the installation process)  CREATE DATABASE openvidu_sample_app;\nexit  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  5) Install NPM dependencies of frontend:  cd classroom-demo/src/angular/frontend\nnpm install  6) Build the frontend, exporting the files to the static folder of the Java application:  ng build --output-path ../../main/resources/static  7) Finally run the Spring Boot application:  cd ../../../\nmvn clean package exec:java  Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.  \n   \n     \n       \n     \n   \n   \n     \n       \n     \n   \n   \n     \n       \n     \n      Without going into greater detail, the backend has  one controller  for the REST operations of the lessons (create new ones or edit/remove existing ones) and  one controller  for handling the videoconferences. This controller is pretty similar to the one described in any of the secure tutorials. Basically it listens to the operations of creating a new session (returning a  sessionId  from  openvidu-server ), generating a new user token (returning the  token  from  openvidu-server ) and removing the users when they leave the session.    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Running this demo"
        }, 
        {
            "location": "/cheatsheet/join-session/", 
            "text": "Join a session\n\n\nFirst initialize a Session object:\n\n\nvar OV = new OpenVidu();\nvar session = OV.initSession();\n\n\n\n\nThen by calling \nsession.connect\n method you can join a properly initialized session.\n\n\n// After retrieving a token from OpenVidu Server...\nsession.connect(token)\n    .then( ... )\n    .catch( ... );\n\n\n\n\n\nYou must ask OpenVidu Server for a user token. To do so:\n\n\n\n\n\n\nInitialize a Session in OpenVidu Server\n\n\n\n\nAPI REST\n\n\nopenvidu-java-client\n\n\nopenvidu-node-client\n\n\n\n\n\n\n\n\nGenerate a token for this session in OpenVidu Server\n\n\n\n\nAPI REST\n\n\nopenvidu-java-client\n\n\nopenvidu-node-client\n\n\n\n\n\n\n\n\nReturn this token to your client-side to use it on \nSession.connect()\n\n\n\n\n\n\nYou can add an optional second parameter to pass some user metadata that will be recieved by every other user connected to the same session (check \nShare data between users\n to learn more).\n\n\nsession.connect(token, DATA)\n    .then( ... )\n    .catch( ... );", 
            "title": "Join a session"
        }, 
        {
            "location": "/cheatsheet/join-session/#join-a-session", 
            "text": "First initialize a Session object:  var OV = new OpenVidu();\nvar session = OV.initSession();  Then by calling  session.connect  method you can join a properly initialized session.  // After retrieving a token from OpenVidu Server...\nsession.connect(token)\n    .then( ... )\n    .catch( ... );  \nYou must ask OpenVidu Server for a user token. To do so:    Initialize a Session in OpenVidu Server   API REST  openvidu-java-client  openvidu-node-client     Generate a token for this session in OpenVidu Server   API REST  openvidu-java-client  openvidu-node-client     Return this token to your client-side to use it on  Session.connect()    You can add an optional second parameter to pass some user metadata that will be recieved by every other user connected to the same session (check  Share data between users  to learn more).  session.connect(token, DATA)\n    .then( ... )\n    .catch( ... );", 
            "title": "Join a session"
        }, 
        {
            "location": "/cheatsheet/leave-session/", 
            "text": "Leave a session\n\n\nBy calling \nsession.disconnect\n method you can leave the session.\n\n\nsession.disconnect();\n\n\n\n\nThis action will trigger the following events:\n\n\n\n\nsessionDisconnected\n: dispatched by \nSession\n object of the local user that is leaving. Automatically cleans all remote videos.\n\n\nstreamDestroyed\n: dispatched by \nPublisher\n object of the local user that is leaving (only if publishing). Automatically cleans the local video.\n\n\nstreamDestroyed\n: dispatched by \nSession\n object of every other remote user connected to the session. Automatically cleans the remote video.\n\n\nconnectionDestroyed\n: dispatched by \nSession\n object of every other remote user connected to the session.", 
            "title": "Leave a session"
        }, 
        {
            "location": "/cheatsheet/leave-session/#leave-a-session", 
            "text": "By calling  session.disconnect  method you can leave the session.  session.disconnect();  This action will trigger the following events:   sessionDisconnected : dispatched by  Session  object of the local user that is leaving. Automatically cleans all remote videos.  streamDestroyed : dispatched by  Publisher  object of the local user that is leaving (only if publishing). Automatically cleans the local video.  streamDestroyed : dispatched by  Session  object of every other remote user connected to the session. Automatically cleans the remote video.  connectionDestroyed : dispatched by  Session  object of every other remote user connected to the session.", 
            "title": "Leave a session"
        }, 
        {
            "location": "/cheatsheet/subscribe-unsubscribe/", 
            "text": "Subscribe/Unsubscribe from other user's stream\n\n\nTo receive the stream of a publisher of the session:\n\n\nvar subscriber;\n\nsession.on('streamCreated', (event) =\n {\n    subscriber = session.subscribe(event.stream, targetElement);\n});\n\n\n\n\nA new HTML video element will be appended to DOM inside the element \ntargetElement\n. It can be an \nHTMLElement\n or its \nid\n attribute, and you can also indicate how to insert the video according to it (see \nSubscriberProperties.insertMode\n).\n\n\nTo cancel the subscription and stop receiving media:\n\n\nsession.unsubscribe(subscriber);\n\n\n\n\nAs long as you have the Subscriber object available, you can alternately call \nSession.subscribe\n and \nSession.unsubscribe\n as many times as you want.", 
            "title": "Subscribe/Unsubscribe from a stream"
        }, 
        {
            "location": "/cheatsheet/subscribe-unsubscribe/#subscribeunsubscribe-from-other-users-stream", 
            "text": "To receive the stream of a publisher of the session:  var subscriber;\n\nsession.on('streamCreated', (event) =  {\n    subscriber = session.subscribe(event.stream, targetElement);\n});  A new HTML video element will be appended to DOM inside the element  targetElement . It can be an  HTMLElement  or its  id  attribute, and you can also indicate how to insert the video according to it (see  SubscriberProperties.insertMode ).  To cancel the subscription and stop receiving media:  session.unsubscribe(subscriber);  As long as you have the Subscriber object available, you can alternately call  Session.subscribe  and  Session.unsubscribe  as many times as you want.", 
            "title": "Subscribe/Unsubscribe from other user's stream"
        }, 
        {
            "location": "/cheatsheet/publish-unpublish/", 
            "text": "Publish/Unpublish a stream\n\n\nYou can publish a stream after joining a session: get a \nPublisher\n object through OpenVidu object (\nOpenVidu.initPublisher\n) and publish it with \nSession\n object.\n\n\nvar publisher = OV.initPublisher(targetElement);\n// Register all the events you want with 'publisher.on(...)'\nsession.publish(publisher);\n// Method Session.publish must always be called after successfully connecting to session\n\n\n\n\n\n\n\n\nOpenVidu.initPublisher\n method will insert into DOM a new HTML video element inside the element \ntargetElement\n, showing your camera. This target element can be an \nHTMLElement\n or its \nid\n attribute, and you can also indicate how to insert the video according to it (see \nPublisherProperties.insertMode\n). You can then publish it to the session whenever you want (perhaps you want the user to confirm that the camera is working well before publishing it).\n\n\n\n\n\n\nSession.publish\n method will make \nPublisher\n object trigger \nstreamCreated\n event in the local user that is publishing and will make \nSession\n object trigger \nstreamCreated\n event in every other remote user connected to the session. \n\n\n\n\n\n\nYou can add two more parameters to \ninitPublisher\n method: an object with properties about your publisher stream and a callback function to be executed just after the method finishes and before the publisher object dispatches \naccessAllowed\n or \naccessDenied\n event:\n\n\nOV.initPublisher(\n    targetElement,\n    {\n        audioSource: undefined, // The source of audio. If undefined default audio input\n        videoSource: undefined, // The source of video. If undefined default video input\n        publishAudio: true,     // Whether you want to start the publishing with audio unmuted or muted\n        publishVideo: true,     // Whether you want to start the publishing with video enabled or disabled\n        resolution: '640x480',  // The resolution of your video\n        frameRate: 30,          // The frame rate of your video\n        insertMode: 'APPEND',   // How the video will be inserted according to targetElement\n        mirror: false           // Whether to mirror your local video or not\n    },\n    (error) =\n {                // Function to be executed when the method finishes\n        if (error) {\n            console.error('Error while initializing publisher: ', error);\n        } else {\n            console.log('Publisher successfully initialized');\n        }\n    }\n);\n\n\n\n\nTo unpublish the stream:\n\n\nsession.unpublish(publisher);\n\n\n\n\nAs long as you have the Publisher object available, you can alternately call \nSession.publish\n and \nSession.unpublish\n as many times as you want. It is also possible to change the Publisher dynamically (for example if you want to stop transmitting your webcam and start sharing your screen, all of it without leaving the session). To do so:\n\n\nsession.unpublish(oldPubliser);\nnewPublisher = OV.initPublisher(newOptions);\n// Register all the events you want with 'newPublisher.on(...)'\nsession.publish(newPublisher);\n\n\n\n\n\n\n\n\nNOTE\n: only users with Role \nPUBLISHER\n or \nMODERATOR\n can call \nSession.publish\n method. You can check \nOpenViduRole\n section of OpenVidu Node Client for a complete description", 
            "title": "Publish/Unpublish a stream"
        }, 
        {
            "location": "/cheatsheet/publish-unpublish/#publishunpublish-a-stream", 
            "text": "You can publish a stream after joining a session: get a  Publisher  object through OpenVidu object ( OpenVidu.initPublisher ) and publish it with  Session  object.  var publisher = OV.initPublisher(targetElement);\n// Register all the events you want with 'publisher.on(...)'\nsession.publish(publisher);\n// Method Session.publish must always be called after successfully connecting to session    OpenVidu.initPublisher  method will insert into DOM a new HTML video element inside the element  targetElement , showing your camera. This target element can be an  HTMLElement  or its  id  attribute, and you can also indicate how to insert the video according to it (see  PublisherProperties.insertMode ). You can then publish it to the session whenever you want (perhaps you want the user to confirm that the camera is working well before publishing it).    Session.publish  method will make  Publisher  object trigger  streamCreated  event in the local user that is publishing and will make  Session  object trigger  streamCreated  event in every other remote user connected to the session.     You can add two more parameters to  initPublisher  method: an object with properties about your publisher stream and a callback function to be executed just after the method finishes and before the publisher object dispatches  accessAllowed  or  accessDenied  event:  OV.initPublisher(\n    targetElement,\n    {\n        audioSource: undefined, // The source of audio. If undefined default audio input\n        videoSource: undefined, // The source of video. If undefined default video input\n        publishAudio: true,     // Whether you want to start the publishing with audio unmuted or muted\n        publishVideo: true,     // Whether you want to start the publishing with video enabled or disabled\n        resolution: '640x480',  // The resolution of your video\n        frameRate: 30,          // The frame rate of your video\n        insertMode: 'APPEND',   // How the video will be inserted according to targetElement\n        mirror: false           // Whether to mirror your local video or not\n    },\n    (error) =  {                // Function to be executed when the method finishes\n        if (error) {\n            console.error('Error while initializing publisher: ', error);\n        } else {\n            console.log('Publisher successfully initialized');\n        }\n    }\n);  To unpublish the stream:  session.unpublish(publisher);  As long as you have the Publisher object available, you can alternately call  Session.publish  and  Session.unpublish  as many times as you want. It is also possible to change the Publisher dynamically (for example if you want to stop transmitting your webcam and start sharing your screen, all of it without leaving the session). To do so:  session.unpublish(oldPubliser);\nnewPublisher = OV.initPublisher(newOptions);\n// Register all the events you want with 'newPublisher.on(...)'\nsession.publish(newPublisher);    NOTE : only users with Role  PUBLISHER  or  MODERATOR  can call  Session.publish  method. You can check  OpenViduRole  section of OpenVidu Node Client for a complete description", 
            "title": "Publish/Unpublish a stream"
        }, 
        {
            "location": "/cheatsheet/mute-audio-video/", 
            "text": "Mute/Unmute audio and video\n\n\nBy calling \nPublisher.publishAudio()\n or \nPublisher.publishVideo()\n method you can toggle audio and video of your Publisher object. Every user subscribed to its stream will stop receiving audio or video.\n\n\npublisher.publishAudio(audioEnabled);   // true to unmute the audio track, false to mute it\npublisher.publishVideo(videoEnabled);   // true to enable the video track, false to disable it\n\n\n\n\nBy calling \nSubscriber.subscribeToAudio()\n or \nSubscriber.subscribeToVideo()\n method you can toggle audio and video of any Subscriber object. You will stop receiving audio or video from it (only affects the client calling the method).\n\n\nsubscriber.subscribeToAudio(audioEnabled);  // true to unmute the audio track, false to mute it\nsubscriber.subscribeToVideo(videoEnabled);  // true to enable the video, false to disable it", 
            "title": "Mute/Unmute audio and video"
        }, 
        {
            "location": "/cheatsheet/mute-audio-video/#muteunmute-audio-and-video", 
            "text": "By calling  Publisher.publishAudio()  or  Publisher.publishVideo()  method you can toggle audio and video of your Publisher object. Every user subscribed to its stream will stop receiving audio or video.  publisher.publishAudio(audioEnabled);   // true to unmute the audio track, false to mute it\npublisher.publishVideo(videoEnabled);   // true to enable the video track, false to disable it  By calling  Subscriber.subscribeToAudio()  or  Subscriber.subscribeToVideo()  method you can toggle audio and video of any Subscriber object. You will stop receiving audio or video from it (only affects the client calling the method).  subscriber.subscribeToAudio(audioEnabled);  // true to unmute the audio track, false to mute it\nsubscriber.subscribeToVideo(videoEnabled);  // true to enable the video, false to disable it", 
            "title": "Mute/Unmute audio and video"
        }, 
        {
            "location": "/cheatsheet/manage-videos/", 
            "text": "Manage videos\n\n\nOpenVidu makes very easy the management of the video players. You can let OpenVidu take care of their lifecycle or you can use your own HTML video elements.\nEvery Publisher and Subscriber object can display a media stream in as many video players as you want.\n\n\nLet OpenVidu take care of the video players\n\n\n\n\nA) Publisher videos\n\n\n\n\n\n\nWhen initalizing a Publisher object, you can insert a video player by passing a valid \ntargetElement\n in method \nOpenVidu.initPublisher\n (can be an HTMLElement or its \nid\n attribute). Second parameter allows you to customize the publisher's stream, including how OpenVidu must insert the video player according to targetElement (more info in \nOpenVidu Browser Docs\n):\n\n\nvar publisher = OV.initPublisher(targetElement, {insertMode: 'APPEND'});\n\n\n\n\n\n\n\nAfter getting the Publisher object, you can create more video players to display its media stream just by calling \nPublisher.createVideoElement\n. Pass a valid \ntargetElement\n and the \ninsertMode\n:\n\n\npublisher.createVideoElement(targetElement, 'APPEND');\n\n\n\n\n\n\n\n\n\nB) Subscriber videos\n\n\n\n\n\n\nWhen subscribing to a Stream, you can insert a video player by passing a valid \ntargetElement\n in method \nSession.subscribe\n (can be an HTMLElement or its \nid\n attribute). Third parameter allows you to customize the subscriber's stream, including how OpenVidu must insert the video player according to targetElement (more info in \nOpenVidu Browser Docs\n):\n\n\nvar subscriber;\nsession.on('streamCreated', event =\n {\n    subscriber = session.subscribe(event.stream, targetElement, {insertMode: 'APPEND'});\n});\n\n\n\n\n\n\n\nAfter getting the Subscriber object, you can create more video players to display its media stream just by calling \nSubscriber.createVideoElement\n. Pass a valid \ntargetElement\n and the \ninsertMode\n:\n\n\nsubscriber.createVideoElement(targetElement, 'APPEND');\n\n\n\n\n\n\n\n\n\n\n\nPublisher and Subscriber objects will dispatch a \nvideoElementCreated\n event for every video inserted into DOM by these methods.\nAlso these videos will be automatically removed from DOM when required and Publisher and Subscriber objects will dispatch a\n\nvideoElementDestroyed\n event for every one of them\n\n\n\n\nYou take care of the video players\n\n\n\n\nA) Publisher videos\n\n\n\n\nPass \nundefined\n as \ntargetElement\n when initializing your Publisher and when you have it available just call method \nPublisher.addVideoElement\n, passing an already existing HTML video element of the DOM:\nvar publisher = OV.initPublisher(undefined, publisherProperties);\npublisher.addVideoElement(videoElement);\n\n\n\n\n\n\n\n\n\nB) Subscriber videos\n\n\n\n\nPass \nundefined\n as \ntargetElement\n when subscribing to a Stream and when you have Subscriber object available just call method \nSubscriber.addVideoElement\n, passing an already existing HTML video element of the DOM:\nvar subscriber;\nsession.on('streamCreated', event =\n {\n    subscriber = session.subscribe(event.stream, undefined);\n    subscriber.addVideoElement(videoElement);\n});\n\n\n\n\n\n\n\n\n\n\n\nThis way of managing the video players is very useful when developing your application with some frontend declarative framework such as \nAngular\n,\n\nReact\n or \nVue.js\n. It allows you to add to the proper \nPublisher\n or \nSubscriber\n any video element managed by the framework. Besides, it is possible to\ntreat both Publishers and Subscribers the same way regarding their rendering in the page, as they both inherit from the parent class \nStreamManager\n. If you are\ninterested in these concepts, you can check out our super simple \nAngular tutorial\n.", 
            "title": "Manage video players"
        }, 
        {
            "location": "/cheatsheet/manage-videos/#manage-videos", 
            "text": "OpenVidu makes very easy the management of the video players. You can let OpenVidu take care of their lifecycle or you can use your own HTML video elements.\nEvery Publisher and Subscriber object can display a media stream in as many video players as you want.", 
            "title": "Manage videos"
        }, 
        {
            "location": "/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players", 
            "text": "", 
            "title": "Let OpenVidu take care of the video players"
        }, 
        {
            "location": "/cheatsheet/manage-videos/#a-publisher-videos", 
            "text": "When initalizing a Publisher object, you can insert a video player by passing a valid  targetElement  in method  OpenVidu.initPublisher  (can be an HTMLElement or its  id  attribute). Second parameter allows you to customize the publisher's stream, including how OpenVidu must insert the video player according to targetElement (more info in  OpenVidu Browser Docs ):  var publisher = OV.initPublisher(targetElement, {insertMode: 'APPEND'});    After getting the Publisher object, you can create more video players to display its media stream just by calling  Publisher.createVideoElement . Pass a valid  targetElement  and the  insertMode :  publisher.createVideoElement(targetElement, 'APPEND');", 
            "title": "A) Publisher videos"
        }, 
        {
            "location": "/cheatsheet/manage-videos/#b-subscriber-videos", 
            "text": "When subscribing to a Stream, you can insert a video player by passing a valid  targetElement  in method  Session.subscribe  (can be an HTMLElement or its  id  attribute). Third parameter allows you to customize the subscriber's stream, including how OpenVidu must insert the video player according to targetElement (more info in  OpenVidu Browser Docs ):  var subscriber;\nsession.on('streamCreated', event =  {\n    subscriber = session.subscribe(event.stream, targetElement, {insertMode: 'APPEND'});\n});    After getting the Subscriber object, you can create more video players to display its media stream just by calling  Subscriber.createVideoElement . Pass a valid  targetElement  and the  insertMode :  subscriber.createVideoElement(targetElement, 'APPEND');      Publisher and Subscriber objects will dispatch a  videoElementCreated  event for every video inserted into DOM by these methods.\nAlso these videos will be automatically removed from DOM when required and Publisher and Subscriber objects will dispatch a videoElementDestroyed  event for every one of them", 
            "title": "B) Subscriber videos"
        }, 
        {
            "location": "/cheatsheet/manage-videos/#you-take-care-of-the-video-players", 
            "text": "", 
            "title": "You take care of the video players"
        }, 
        {
            "location": "/cheatsheet/manage-videos/#a-publisher-videos_1", 
            "text": "Pass  undefined  as  targetElement  when initializing your Publisher and when you have it available just call method  Publisher.addVideoElement , passing an already existing HTML video element of the DOM: var publisher = OV.initPublisher(undefined, publisherProperties);\npublisher.addVideoElement(videoElement);", 
            "title": "A) Publisher videos"
        }, 
        {
            "location": "/cheatsheet/manage-videos/#b-subscriber-videos_1", 
            "text": "Pass  undefined  as  targetElement  when subscribing to a Stream and when you have Subscriber object available just call method  Subscriber.addVideoElement , passing an already existing HTML video element of the DOM: var subscriber;\nsession.on('streamCreated', event =  {\n    subscriber = session.subscribe(event.stream, undefined);\n    subscriber.addVideoElement(videoElement);\n});      This way of managing the video players is very useful when developing your application with some frontend declarative framework such as  Angular , React  or  Vue.js . It allows you to add to the proper  Publisher  or  Subscriber  any video element managed by the framework. Besides, it is possible to\ntreat both Publishers and Subscribers the same way regarding their rendering in the page, as they both inherit from the parent class  StreamManager . If you are\ninterested in these concepts, you can check out our super simple  Angular tutorial .", 
            "title": "B) Subscriber videos"
        }, 
        {
            "location": "/cheatsheet/share-data/", 
            "text": "Share data between users\n\n\nWhatever app you are developing, chances are you will need to pass some data for each user, at least a nickname. You can do it in two different places:\n\n\n\n\nClient-Side\n: when calling \nSession.connect\n method in openvidu-browser:\n\n\n\n\nsession.connect(token, \nUSER_DATA\n)\n    .then( ... )\n    .catch( ... );\n\n\n\n\n\n\n\n\nServer-Side\n: when generating a token\n\n\n\n\nAPI REST\n: add body parameter \n\"data\"\n to the POST operation\n\n\nopenvidu-java-client\n: construct TokenOptions with \nTokenOptions.Builder().data(\"USER_DATA\").build()\n\n\nopenvidu-node-client\n: construct TokenOptions with \n{data: \"USER_DATA\"}\n \n\n\n\n\n\n\n\n\nThe result will be that in all clients, \nConnection\n objects will have in their \ndata\n property the pertinent value you have provided for each user. So, an easy way to get the data associated to any user would be:\n\n\nsession.on(\nstreamCreated\n, function (event) {\n    session.subscribe(event.stream, \nsubscriber\n);\n    console.log(\nUSER DATA: \n + event.stream.connection.data);\n});\n\n\n\n\n\nSome clarifications:\n\n\n\n\nUsing only first option is not secure, as clients could modify the value of the second parameter. It is intended for development environments or non critical data. If you want total control over shared data, please use the server-side way.\n\n\nConnection.data\n will be a simple string if you have provided data only with one of the methods, and will be a string with the following format if you provide data both from openvidu-browser and your backend: \n\"CLIENT_SIDE_DATA%/%SERVER_SIDE_DATA\"\n (both separated by string \n%/%\n).\n\n\nYou can choose whatever format you like for the data string, but if you are planning to share more than a simple field, maybe a standard format as JSON would be a wise choice. Method \nSession.connect\n in Openvidu Browser directly admits as data parameter a standard object (it will be finally stringified).", 
            "title": "Share data between users"
        }, 
        {
            "location": "/cheatsheet/share-data/#share-data-between-users", 
            "text": "Whatever app you are developing, chances are you will need to pass some data for each user, at least a nickname. You can do it in two different places:   Client-Side : when calling  Session.connect  method in openvidu-browser:   session.connect(token,  USER_DATA )\n    .then( ... )\n    .catch( ... );    Server-Side : when generating a token   API REST : add body parameter  \"data\"  to the POST operation  openvidu-java-client : construct TokenOptions with  TokenOptions.Builder().data(\"USER_DATA\").build()  openvidu-node-client : construct TokenOptions with  {data: \"USER_DATA\"}       The result will be that in all clients,  Connection  objects will have in their  data  property the pertinent value you have provided for each user. So, an easy way to get the data associated to any user would be:  session.on( streamCreated , function (event) {\n    session.subscribe(event.stream,  subscriber );\n    console.log( USER DATA:   + event.stream.connection.data);\n});  \nSome clarifications:   Using only first option is not secure, as clients could modify the value of the second parameter. It is intended for development environments or non critical data. If you want total control over shared data, please use the server-side way.  Connection.data  will be a simple string if you have provided data only with one of the methods, and will be a string with the following format if you provide data both from openvidu-browser and your backend:  \"CLIENT_SIDE_DATA%/%SERVER_SIDE_DATA\"  (both separated by string  %/% ).  You can choose whatever format you like for the data string, but if you are planning to share more than a simple field, maybe a standard format as JSON would be a wise choice. Method  Session.connect  in Openvidu Browser directly admits as data parameter a standard object (it will be finally stringified).", 
            "title": "Share data between users"
        }, 
        {
            "location": "/cheatsheet/send-messages/", 
            "text": "Send text messages between users\n\n\nAny user connected to a session can send messages to every other participant of the session, as a broadcast message for everyone or to one or more specific participants. To do so:\n\n\n// Sender of the message (after 'session.connect')\n\nsession.signal({\n      data: 'My custom message',  // Any string (optional)\n      to: [],                     // Array of Connection objects (optional. Broadcast to everyone if empty)\n      type: 'my-chat'             // The type of message (optional)\n    })\n    .then(() =\n {\n        console.log('Message successfully sent');\n    })\n    .catch(error =\n {\n        console.error(error);\n    });\n\n\n\n\nAny user subscribed to that \ntype\n will receive the message:\n\n\n// Receiver of the message (usually before calling 'session.connect')\n\nsession.on('signal:my-chat', (event) =\n {\n    console.log(event.data); // Message\n    console.log(event.from); // Connection object of the sender\n    console.log(event.type); // The type of message (\nmy-chat\n)\n});\n\n\n\n\nYou can subscribe to \nall signals\n just by calling:\n\n\n// Receiver of all messages (usually before calling 'session.connect')\n\nsession.on('signal', (event) =\n {\n    console.log(event.data); // Message\n    console.log(event.from); // Connection object of the sender\n    console.log(event.type); // The type of message\n});\n\n\n\n\nYou can send messages to specific users adding to \nto\n array the proper Connection objects:\n\n\n// Sender of the adressed message (after calling 'session.connect')\n\nsession.signal({\n    data: 'My private custom message',\n    to: [connection1, connection2],\n    type: 'my-private-chat'\n});\n\n\n\n\nIn this last case, only participants represented by \nconnection1\n and \nconnection2\n objects will receive the signal event (only if they are subscribed to it!). You can get Connection objects by subscribing to \nconnectionCreated\n event before connecting to a session:\n\n\nthis.session.on('connectionCreated', (event) =\n {\n    console.log(event.connection);\n});", 
            "title": "Send text messages"
        }, 
        {
            "location": "/cheatsheet/send-messages/#send-text-messages-between-users", 
            "text": "Any user connected to a session can send messages to every other participant of the session, as a broadcast message for everyone or to one or more specific participants. To do so:  // Sender of the message (after 'session.connect')\n\nsession.signal({\n      data: 'My custom message',  // Any string (optional)\n      to: [],                     // Array of Connection objects (optional. Broadcast to everyone if empty)\n      type: 'my-chat'             // The type of message (optional)\n    })\n    .then(() =  {\n        console.log('Message successfully sent');\n    })\n    .catch(error =  {\n        console.error(error);\n    });  Any user subscribed to that  type  will receive the message:  // Receiver of the message (usually before calling 'session.connect')\n\nsession.on('signal:my-chat', (event) =  {\n    console.log(event.data); // Message\n    console.log(event.from); // Connection object of the sender\n    console.log(event.type); // The type of message ( my-chat )\n});  You can subscribe to  all signals  just by calling:  // Receiver of all messages (usually before calling 'session.connect')\n\nsession.on('signal', (event) =  {\n    console.log(event.data); // Message\n    console.log(event.from); // Connection object of the sender\n    console.log(event.type); // The type of message\n});  You can send messages to specific users adding to  to  array the proper Connection objects:  // Sender of the adressed message (after calling 'session.connect')\n\nsession.signal({\n    data: 'My private custom message',\n    to: [connection1, connection2],\n    type: 'my-private-chat'\n});  In this last case, only participants represented by  connection1  and  connection2  objects will receive the signal event (only if they are subscribed to it!). You can get Connection objects by subscribing to  connectionCreated  event before connecting to a session:  this.session.on('connectionCreated', (event) =  {\n    console.log(event.connection);\n});", 
            "title": "Send text messages between users"
        }, 
        {
            "location": "/advanced-features/recording/", 
            "text": "Recording\n\n\n\n\nHow to record sessions\n\n\nComposed recording\n\n\nIndividual stream recording\n\n\nAudio-only and video-only recordings\n\n\nAutomatic stop of recordings\n\n\nCustom recording layouts\n\n\nLocal recording in the browser\n\n\n\n\n\n\n\n\nOpenVidu Server can be configured to record sessions. Two types of recordings are available:\n\n\n\n\n\n\nCOMPOSED\n: every publisher stream is composed in the same video file in a grid layout. You can use the default layout, that will evenly distribute each stream in the available space, or you can use your own custom layout.\n\n\n\n\n\n\nINDIVIDUAL\n: every publisher stream is recorded in its own file, generating a ZIP file containing all videos along with a text file for synchronization data.\n\n\n\n\n\n\n\n\n\n\nHow to record sessions\n\n\nTo start OpenVidu Server properly configured to allow session recording it is necessary to:\n\n\n1. Have Docker CE installed in the host machine\n\n\nOpenVidu recording module may use a Docker image that needs to be downloaded from the cloud. The process is \n100% automatic\n, but you will need \nDocker CE\n installed in your server. If you enable OpenVidu recording service but there's no Docker installed, OpenVidu Server will fail to init, throwing the following exception:\n\n\nException connecting to Docker daemon: you need Docker installed in this machine to enable OpenVidu recorder service\n\n\n\n\n\n\nOpenVidu AWS deployment\n already includes the Docker image for recording service and is always launched with recording module enabled. You don't need to install anything or wait during the first execution if you use this type of deployment for OpenVidu Server. You can go straight to \nstep 3\n\n\n\n\n\n\n\n\n2. Launch OpenVidu Server with new properties\n\n\nFor OpenVidu Server JAR\n\n\njava -jar \\\n    -Dopenvidu.recording=true \\\n    -Dopenvidu.recording.path=/PATH/TO/VIDEO/FILES \\\nopenvidu-server.jar\n\n\n\n\n\n\nopenvidu.recording\n: if \ntrue\n OpenVidu recording service is enabled and sessions can be configured to be recorded. During the first execution of \nopenvidu-server.jar\n, a Docker image (\nopenvidu/openvidu-recording\n) will be downloaded.\n\n\nopenvidu.recording.path\n: where to store the recorded video files on the host machine. OpenVidu Server must have write access to this path\n\n\n\n\n\n\n\n\nThere are other environment variables related to recordings configuration that may be set. To see the full list, visit \nOpenVidu Server configuration parameters\n\n\n\n\nFor OpenVidu Server Docker image \n(development environment)\n\n\ndocker run -p 4443:4443 --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording=true \\\n    -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\\nopenvidu/openvidu-server-kms:2.8.0\n\n\n\n\n\n\nopenvidu.recording\n: \nsame as in OpenVidu Server JAR\n\n\nopenvidu.recording.path\n: \nsame as in OpenVidu Server JAR\n\n\n\n\nIt is also necessary to mount 2 volumes:\n\n\n\n\n-v /var/run/docker.sock:/var/run/docker.sock\n: gives openvidu-server container access to the local Docker daemon\n\n\n-v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES\n: gives access to the recorded video files through the container\n\n\n\n\n\n\n\n\nIMPORTANT!\n \n/PATH/TO/VIDEO/FILES\n must be the same in property \nopenvidu.recording.path=/PATH/TO/VIDEO/FILES\n and in both sides of flag \n-v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES\n\n\n\n\n\n\n\n\n3. Configure your Sessions to be recorded\n\n\n\nRecording can be configured in two ways:\n\n\n\n\n\n\nALWAYS\n: the session will be automatically recorded from the moment the first participant starts publishing.\n\n\n\n\n\n\nMANUAL\n: you will have to tell openvidu-server when to start the recording of the session.\n\n\n\n\n\n\nIn both cases you can stop the recording manually, and every recording will always be automatically stopped if last user leaves the session and certain timeout elapses (see \nAutomatic stop of recordings\n).\n\n\n\n\nYou can use \nREST API\n or any of the server SDKs (\nopenvidu-java-client\n, \nopenvidu-node-client\n) to manage your recorded sessions.\n\n\n\n\n\n  \nREST API\n\n  \nJava\n\n  \nNode\n\n\n\n\n\n\n\n\n\n\n\nInitialize your sessions with this POST method: \nPOST /api/sessions\nYou may configure default values for recordings started for this session by sending params such as \ndefaultOutputMode\n or \ndefaultRecordingLayout\n. This way you can pre-configure recordings that will be automatically started (for sessions with \n{\"recordingMode\": \"ALWAYS\"}\n). For these sessions configured with \nALWAYS\n recording mode, no more steps are needed.\n\n\n\n\n\n\nIf you have configured your session with \n\"recordingMode\": \"MANUAL\"\n\n\n\n\n\n\nStart the recording with this POST method: \nPOST /api/recordings/start\nYou can pass parameters to override default recording configuration values set in step 1 and to further configure it with other available options\n\n\n\n\n\n\nStop the recording with this POST method: \nPOST /api/recordings/stop\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCall \nOpenVidu.createSession()\n passing as an optional parameter a \nSessionProperties\n object. You may configure default values for recordings started for this session with that object. This way you can pre-configure recordings that will be automatically started (for sessions with \nRecordingMode.ALWAYS\n)\n\n\nOpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nSessionProperties properties = new SessionProperties.Builder()\n    .recordingMode(RecordingMode.MANUAL) // RecordingMode.ALWAYS for automatic recording\n    .defaultOutputMode(Recording.OutputMode.INDIVIDUAL)\n    .build();\nSession session = openVidu.createSession(properties);\n\n\n\n\n\n\n\nIf Session is configured with \nRecordingMode.MANUAL\n, manually start and stop the recording whenever you want. You may pass a \nRecordingProperties\n object when calling \nOpenVidu.startRecording\n method to override default values configured in step 1 and to further configure it with other available options\n\n\nRecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.COMPOSED)\n    .name(\"MY_RECORDING_NAME\")\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties); // Starts recording\nrecording = openVidu.stopRecording(recording.getId()); // Stops recording\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCall \nOpenVidu.createSession()\n passing as an optional parameter a \nSessionProperties\n object. You may configure default values for recordings started for this session with that object. This way you can pre-configure recordings that will be automatically started (for sessions with \nRecordingMode.ALWAYS\n)\n\n\nvar openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nvar properties = {\n    recordingMode: RecordingMode.MANUAL, // RecordingMode.ALWAYS for automatic recording\n    defaultOutputMode: Recording.OutputMode.INDIVIDUAL\n};\nvar mySession = openvidu.createSession(properties);\n\n\n\n\n\n\n\nIf Session is configured with \nRecordingMode.MANUAL\n, manually start and stop the recording whenever you want. You may pass a \nRecordingProperties\n object when calling \nOpenVidu.startRecording\n method to override default values configured in step 1 and to further configure it with other available options\n\n\nvar recording;\n\n// Starts recording\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.COMPOSED,\n    name: \"MY_RECORDING_NAME\"\n})\n  .then(response =\n recording = response)\n  .catch(error =\n console.error(error));\n\n// Stops recording\nopenvidu.stopRecording(recording.id)\n  .then(response =\n recording = response)\n  .catch(error =\n console.error(error));\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComposed recording\n\n\nEvery publisher stream is composed in the same video file in a grid layout. This is the default recording mode, and it will generate as output an MP4 file.\n\n\nYou can use the default layout, that will evenly distribute each stream in the available space, or you can \nuse your own custom layout\n.\nTo use the default layout:\n\n\n\n\n\n  \nREST API\n\n  \nJava\n\n  \nNode\n\n\n\n\n\n\n\nWhen starting the recording of a session with method \nPOST /api/recordings/start\n pass parameters\n{\"outputMode: \"COMPOSED\", \"recordingLayout\": \"BEST_FIT\"}\n\n\n\n\n\n\nRecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.COMPOSED)\n    .recordingLayout(RecordingLayout.BEST_FIT)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);\n\n\n\n\n\n\n\n\nvar recording;\n\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.COMPOSED,\n    recordingLayout: RecordingLayout.BEST_FIT\n})\n    .then(response =\n recording = response)\n    .catch(error =\n console.error(error));\n\n\n\n\n\n\n\n\n \n\n\nFor example, for a session with two publishers the video file will look like this when using output mode \nCOMPOSED\n and recording layout \nBEST_FIT\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\nNotes on COMPOSED recordings\n\n\n\n\nIf a COMPOSED recording is configured to record video (that is, not being an \naudio-only recording\n), this type of grid recording \ncan be a pretty heavy consuming process\n. A maximum number of 4 publishers is recommended, and starting more than 2 recordings of this type at the same time can overload server CPUs. For these reasons, it is desirable to launch OpenVidu Server in a host with significant CPU power if COMPOSED video recordings are expected. In comparison, INDIVIDUAL stream recording (and COMPOSED audio-only recording) can be \n4x up to 10x more efficient\n\n\nYou can configure the resolution of the MP4 file for COMPOSED recordings by using \nresolution\n property when starting the recording\n\n\nA thumbnail got from the middle of the video will be generated for COMPOSED recordings that have video. They will be stored next to the MP4 file and named [RECORDING_ID].jpg\n\n\n\n\n\n\n\n\n\n\nIndividual stream recording\n\n\nEvery publisher stream is recorded in its own file. The final result is a ZIP file containing one WEBM file for each published stream during the recording (named after each stream identifier), along with a text file with synchronization information.\n\n\n\n\n\n  \nREST API\n\n  \nJava\n\n  \nNode\n\n\n\n\n\n\n\nWhen starting the recording of a session with method \nPOST /api/recordings/start\n pass parameter \n{\"outputMode:\"INDIVIDUAL\"}\n\n\n\n\n\n\nRecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.INDIVIDUAL)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);\n\n\n\n\n\n\n\n\nvar recording;\n\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.INDIVIDUAL\n})\n    .then(response =\n recording = response)\n    .catch(error =\n console.error(error));\n\n\n\n\n\n\n\n\n\n\nFor example, for a session with 2 publishers the final content of the ZIP file could be:\n\n\nMyRecording.zip\n+-- MyRecording.json\n+-- tzk08sgffcqqwpor_CAMERA_DFDAE.webm\n+-- ugkmpnz4bn6yewbi_CAMERA_PAHHB.webm\n\n\n\n\nAnd the content of the JSON synchronization file might be:\n\n\n{\n  \ncreatedAt\n: 1548947712287,\n  \nid\n: \nzfgmthb8jl9uellk\n,\n  \nname\n: \nMyRecording\n,\n  \nsessionId\n: \nzfgmthb8jl9uellk\n,\n  \nfiles\n: [\n    {\n      \nconnectionId\n: \nugkmpnz4bn6yewbi\n,\n      \nstreamId\n: \nugkmpnz4bn6yewbi_CAMERA_PAHHB\n,\n      \nsize\n: 4006190,\n      \nclientData\n: \n,\n      \nserverData\n: \nUserA\n,\n      \nhasAudio\n: true,\n      \nhasVideo\n: true,\n      \ntypeOfVideo\n: \nSCREEN\n,\n      \nstartTimeOffset\n: 95,\n      \nendTimeOffset\n: 56445\n    },\n    {\n      \nconnectionId\n: \ntzk08sgffcqqwpor\n,\n      \nstreamId\n: \ntzk08sgffcqqwpor_CAMERA_DFDAE\n,\n      \nsize\n: 2404760,\n      \nclientData\n: \n,\n      \nserverData\n: \nUserB\n,\n      \nhasAudio\n: false,\n      \nhasVideo\n: true,\n      \ntypeOfVideo\n: \nCAMERA\n,\n      \nstartTimeOffset\n: 148,\n      \nendTimeOffset\n: 56398\n    }\n  ]\n}\n\n\n\n\n\n\nThese are the properties in the JSON file\n\n\n\n\n\n\ncreatedAt\n: time when the recording was started in UTC milliseconds\n\n\nid\n: unique identifier of the recording\n\n\nname\n: custom name of the recording. You can set this parameter when starting the recording, and the final ZIP file will be named after it\n\n\nsessionId\n: unique identifier of the session that was recorded\n\n\nfiles\n: array containing one JSON object for each one of the WEBM videos inside the ZIP file\n\n\nconnectionId\n: unique identifier of the connection that published the stream\n\n\nstreamId\n: unique identifier of the recorded stream\n\n\nsize\n: size in bytes of this particular recorded file\n\n\nclientData\n: data associated to the connection that published the stream, in the client side. You can use this field to identify the user that published this particular recorded stream\n\n\nserverData\n: data associated to the connection that published the stream, in the server side. You can use this field to identify the user that published this particular recorded stream\n\n\nhasAudio\n: whether this recorded stream has an audio track or not\n\n\nhasVideo\n: whether this recorded stream has a video track or not\n\n\ntypeOfVideo\n: type of video (\"CAMERA\" or \"SCREEN\"). Only defined if \nhasVideo\n is true\n\n\nstartTimeOffset\n: the offset in milliseconds for when this particular stream started being recorded, from the \ncreatedAt\n property of the root element\n\n\nendTimeOffset\n: the offset in milliseconds for when this particular stream stopped being recorded, from the \ncreatedAt\n property of the root element\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAudio-only and video-only recordings\n\n\nBy default recordings will be generated with both audio and video, but you can configure them to record audio-only or video-only files.\n\n\n\n\n\n  \nREST API\n\n  \nJava\n\n  \nNode\n\n\n\n\n\n\n\nWhen starting the recording of a session with method \nPOST /api/recordings/start\n simply pass parameters \nhasAudio\n or \nhasVideo\n with the desired values.\n\n\n\n\n\n\nRecordingProperties properties = new RecordingProperties.Builder()\n    .hasAudio(true)\n    .hasVideo(false)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);\n\n\n\n\n\n\n\n\nvar recording;\n\nopenvidu.startRecording(sessionId, {\n    hasAudio: true,\n    hasVideo: false\n})\n    .then(response =\n recording = response)\n    .catch(error =\n console.error(error));\n\n\n\n\n\n\n\n\n\n\n\n\nNotes on audio/video only recordings\n\n\n\n\nRecordings configured to not record neither audio nor video will fail to start, returning a status error of 422\n\n\nCOMPOSED video-only recordings will generate an MP4 file. COMPOSED audio-only recordings will generate a WEBM file. INDIVIDUAL recordings will always generate a ZIP file containing one WEBM file for each recorded stream\n\n\nStreams published during a video-only recording that are audio-only won't be recorded: they won't be included in the grid layout for COMPOSED recordings and won't generate a WEBM file in INDIVIDUAL recordings. Same for audio-only recordings with video-only streams\n\n\nRecordings started automatically (with recording mode \nALWAYS\n) will record both audio and video\n\n\n\n\n\n\n\n\n\n\nAutomatic stop of recordings\n\n\nAny started recording will automatically be stopped when any of the following situations occur and certain timeout elapses. This timeout is by default 120 seconds, but you can configure it with \nsystem property \nopenvidu.recording.autostop-timeout\n. The automatic recording stop timout will start:\n\n\n\n\n\n\nFor any recorded session, if last user disconnects from the session\n\n\n\n\n\n\nFor sessions with recording mode \nMANUAL\n, if the recording is started and no user is publishing a stream\n\n\n\n\n\n\nThe only condition to abort the timeout is to have any user publishing a stream to the session within the timeout.\n\n\nSessions will always remain opened and the recording active during the timeout. If it elapses and no stream is being published to the session, the recording will be stopped. If in addition there's no user connected to the session, the session will also be automatically closed.\n\n\n\n\nYou can always manually stop any recording at any time:\n\n\n\n\n\n  \nREST API\n\n  \nJava\n\n  \nNode\n\n\n\n\n\n\n\nPOST /api/recordings/stop/\nRECORDING_ID\n\n\n\n\n\n\nRecording stoppedRecording = openVidu.stopRecording(recordingId);\n\n\n\n\n\n\n\n\nvar stoppedRecording;\nopenvidu.stopRecording(recordingId)\n    .then(response =\n stoppedRecording = response)\n    .catch(error =\n console.error(error));\n\n\n\n\n\n\n\n\n\n\n\n\nCustom recording layouts\n\n\nYou can create your own layouts for the session recording process. They are implemented with HTML/CSS/JS files, just as your OpenVidu application client-side.\n\n\n1. Create your layout with HTML/CSS/JS files\n\n\nPut them in a path accessible to openvidu-server. There must be an \nindex.html\n file as entrypoint for your custom layout:\n\n\n\n\n\n\n\n\nWHAT SHOULD YOUR JS CODE DO\n: by making use of \nopenvidu-browser.js\n library, you need to connect a \nrecorder\n participant to the session. This means:\n\n\n1) Your layout must connect to the session using a \ntoken\n like this:\n\n\n'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '\nsecret=' + SECRET + '\nrecorder=true';\n\n\n\nBeing \nSESSION_ID\n and \nSECRET\n two parameters that will be url-encoded under ids \nsessionId\n and \nsecret\n respectively. So, for example:\n\n\nvar url = new URL(window.location.href);\nvar SESSION_ID = url.searchParams.get(\"sessionId\");\nvar SECRET = url.searchParams.get(\"secret\");\nvar TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '\nsecret=' + SECRET + '\nrecorder=true';\nvar session = OV.initSession();\nsession.connect(TOKEN);\n\n\n\n2) You will need to subscribe to, at least, one event:\n \nstreamCreated\n of Session object. That way you can subscribe your recorder to every stream when any user starts publishing (by default, the video element will be automatically removed on every \nstreamDestroyed\n event). To sum up, this would be the simplest code you need to properly start your recorder participant:\n\n\nvar OV = new OpenVidu();\n\nvar url = new URL(window.location.href);\nvar SESSION_ID = url.searchParams.get(\"sessionId\");\nvar SECRET = url.searchParams.get(\"secret\");\nvar TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '\nsecret=' + SECRET + '\nrecorder=true';\nvar session = OV.initSession();\n\nsession.on(\"streamCreated\", (event) =\n {\n    session.subscribe(event.stream, 'html-id-where-insert-video');\n});\n\nsession.connect(TOKEN);\n\n\n\n\n\n\n\n\n\n\n\nHOW TO IDENTIFY YOUR USERS\n: you can identify them by making use of property \nStream.connection.data\n of the Stream object retrieved in Session event \"streamCreated\". That way you may know which particular user should be displayed in which particular HTML element of your layout. For example:\nsession.on(\"streamCreated\", (event) =\n {\n    var stream = event.stream;\n    if (stream.connection.data === 'userBigVideo') {\n        session.subscribe(stream, 'big-video-div');\n    } else if (stream.connection.data === 'userSmallVideo') {\n        session.subscribe(stream, 'small-video-div');\n    }\n});\n\n\n\n\n\n\n\n\n\n\n\n2. Add new properties when launching openvidu-server\n\n\nYou can configure where should OpenVidu Server look for your custom layout in the system.\nDefault path is \n/opt/openvidu/custom-layout\n, but you can configure it with system property \nopenvidu.recording.custom-layout\n. OpenVidu Server must have read access to that path.\n\n\n\n\nopenvidu-server.jar\n\n\njava -jar \\\n    -Dopenvidu.recording=true \\\n    -Dopenvidu.recording.path=/PATH/TO/VIDEO/FILES \\\n    -Dopenvidu.recording.custom-layout: /PATH/TO/INDEX/CUSTOM/LAYOUT \\\nopenvidu-server.jar\n\n\n\n\n\n\nopenvidu/openvidu-server-kms\n \n(development environment)\n\n\ndocker run -p 4443:4443 --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\\n    -v /PATH/TO/INDEX/CUSTOM/LAYOUT:/PATH/TO/INDEX/CUSTOM/LAYOUT \\\n    -e MY_UID=$(id -u $USER) \\\n    -e openvidu.recording=true \\\n    -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording.custom-layout=/PATH/TO/INDEX/CUSTOM/LAYOUT \\\nopenvidu/openvidu-server-kms:2.8.0\n\n\n\n\n\n\nWARNING\n: remember to add the \n-v\n option mounting the path defined with \nopenvidu.recording.custom-layout\n\n\n\n\n\n\nOpenVidu AWS deployment\n\n\nYou must store your custom layouts in the server under default path \n/opt/openvidu/custom-layout\n\n\n\n\n\n\n3. Configure your recordings to use your custom layout\n\n\n\n\n\n  \nREST API\n\n  \nJava\n\n  \nNode\n\n\n\n\n\n\n\nWhen starting the recording of a session with method \nPOST /api/recordings/start\n pass parameters\n{\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\"}\n\n\n\n\n\n\nRecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.COMPOSED)\n    .recordingLayout(RecordingLayout.CUSTOM)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);\n\n\n\n\n\n\n\n\nvar recording;\n\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.COMPOSED,\n    recordingLayout: RecordingLayout.CUSTOM\n})\n    .then(response =\n recording = response)\n    .catch(error =\n console.error(error));\n\n\n\n\n\n\n\n\n\n\n\n\nConfiguring multiple custom layouts\n\n\nYou can implement as many custom recording layouts as you want. Simply store each one of them (each one with its own \nindex.html\n entrypoint file) in a subfolder under path defined with system property \nopenvidu.recording.custom-layout\n (default value \n/opt/openvidu/custom-layout\n). Then, when configuring your sessions as stated above in point 3, just add a new parameter:\n\n\n\n\n\n  \nREST API\n\n  \nJava\n\n  \nNode\n\n\n\n\n\n\n\nWhen starting the recording of a session with method \nPOST /api/recordings/start\n pass parameters\n{\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\", \"customLayout\": \"RELATIVE/PATH/TO/INDEX\"}\n\n\n\n\n\n\nRecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.COMPOSED)\n    .recordingLayout(RecordingLayout.CUSTOM)\n    .customLayout(\nRELATIVE/PATH/TO/INDEX\n)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);\n\n\n\n\n\n\n\n\nvar recording;\n\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.COMPOSED,\n    recordingLayout: RecordingLayout.CUSTOM,\n    customLayout: \nRELATIVE/PATH/TO/INDEX\n\n})\n    .then(response =\n recording = response)\n    .catch(error =\n console.error(error));\n\n\n\n\n\n\n\n\n\n\nIn the snippets above, string \nRELATIVE/PATH/TO/INDEX\n is the path from openvidu-server configuration property \nopenvidu.recording.custom-layout\n to the specific \nindex.html\n you want to use for a particular recording. So, if you have the following folder tree structure in your OpenVidu Server host:\n\n\n/opt\n+-- /openvidu\n|   +-- /my_custom_layouts\n|       +-- index.html\n|       +-- /layout1\n|           +-- index.html\n|       +-- /layout2\n|           +-- index.html\n/etc\n    ...\n\n\n\n\nYou should start openvidu-server with property \nopenvidu.recording.custom-layout=/opt/openvidu/my_custom_layouts\n and you can use any of the 3 \nindex.html\n files for recording any of your sessions. To use the outer layout in a recording, just configure in recording properties \nrecordingLayout\n to \nCUSTOM\n. To use any of the inner layouts, also configure \ncustomLayout\n to \nlayout1\n or \nlayout2\n.\n\n\n\n\n\n\nSample custom layout\n\n\nThis is literally the simplest HTML for a custom recording layout. Use it as a template for building more complex ones (you will need \nlatest \nopenvidu-browser-VERSION.min.js\n file\n to be in the same folder)\n\n\nhtml\n\n\n\nhead\nscript src=\nopenvidu-browser-2.8.0.min.js\n/script\n/head\n\n\n\nbody\n\n    \ndiv id=\nvideos\n/div\n\n\n/body\n\n\n\nscript\n\n    var url = new URL(window.location.href);\n    var SESSION_ID = url.searchParams.get(\nsessionId\n);\n    var SECRET = url.searchParams.get(\nsecret\n);\n    var TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + '\nsecret=' + SECRET + '\nrecorder=true';\n\n    var OV = new OpenVidu();\n    var session = OV.initSession();\n\n    session.on(\nstreamCreated\n, (event) =\n {\n        session.subscribe(event.stream, 'videos');\n    });\n    session.connect(TOKEN)\n        .then(() =\n { console.log('Recorder participant connected') })\n        .catch(error =\n { console.error(error) });\n\n/script\n\n\n\n/html\n\n\n\n\n\n\n\n\n\nLocal recording in the browser\n\n\nOpenVidu Browser offers an extremely simple API to record Streams directly in the client's browser. Check it out \nhere\n.\n\n\n\n\n\nfunction changeLangTab(event) {\n  var parent = event.target.parentNode.parentNode;\n  var txt = event.target.textContent || event.target.innerText;\n  var txt = txt.replace(/\\s/g, \"-\").toLowerCase();\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n    // Change appearance of language buttons\n    if (child.classList.contains(\"lang-tabs-header\")) {\n        for (var j = 0; j < child.children.length; j++) {\n            var btn = child.children[j];\n            if (btn.classList.contains(\"lang-tabs-btn\")) {\n                btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9';\n                btn.style.fontWeight = btn === event.target ? 'bold' : 'normal';\n            }\n        }\n    }\n    // Change visibility of language content\n    if (child.classList.contains(\"lang-tabs-content\")) {\n        if (child.id === txt) {\n            child.style.display = \"block\";\n        } else {\n            child.style.display = \"none\";\n        }\n    }\n  }\n}", 
            "title": "Recording"
        }, 
        {
            "location": "/advanced-features/recording/#recording", 
            "text": "How to record sessions  Composed recording  Individual stream recording  Audio-only and video-only recordings  Automatic stop of recordings  Custom recording layouts  Local recording in the browser     OpenVidu Server can be configured to record sessions. Two types of recordings are available:    COMPOSED : every publisher stream is composed in the same video file in a grid layout. You can use the default layout, that will evenly distribute each stream in the available space, or you can use your own custom layout.    INDIVIDUAL : every publisher stream is recorded in its own file, generating a ZIP file containing all videos along with a text file for synchronization data.", 
            "title": "Recording"
        }, 
        {
            "location": "/advanced-features/recording/#how-to-record-sessions", 
            "text": "To start OpenVidu Server properly configured to allow session recording it is necessary to:", 
            "title": "How to record sessions"
        }, 
        {
            "location": "/advanced-features/recording/#1-have-docker-ce-installed-in-the-host-machine", 
            "text": "OpenVidu recording module may use a Docker image that needs to be downloaded from the cloud. The process is  100% automatic , but you will need  Docker CE  installed in your server. If you enable OpenVidu recording service but there's no Docker installed, OpenVidu Server will fail to init, throwing the following exception:  Exception connecting to Docker daemon: you need Docker installed in this machine to enable OpenVidu recorder service    OpenVidu AWS deployment  already includes the Docker image for recording service and is always launched with recording module enabled. You don't need to install anything or wait during the first execution if you use this type of deployment for OpenVidu Server. You can go straight to  step 3", 
            "title": "1. Have Docker CE installed in the host machine"
        }, 
        {
            "location": "/advanced-features/recording/#2-launch-openvidu-server-with-new-properties", 
            "text": "", 
            "title": "2. Launch OpenVidu Server with new properties"
        }, 
        {
            "location": "/advanced-features/recording/#for-openvidu-server-jar", 
            "text": "java -jar \\\n    -Dopenvidu.recording=true \\\n    -Dopenvidu.recording.path=/PATH/TO/VIDEO/FILES \\\nopenvidu-server.jar   openvidu.recording : if  true  OpenVidu recording service is enabled and sessions can be configured to be recorded. During the first execution of  openvidu-server.jar , a Docker image ( openvidu/openvidu-recording ) will be downloaded.  openvidu.recording.path : where to store the recorded video files on the host machine. OpenVidu Server must have write access to this path     There are other environment variables related to recordings configuration that may be set. To see the full list, visit  OpenVidu Server configuration parameters", 
            "title": "For OpenVidu Server JAR"
        }, 
        {
            "location": "/advanced-features/recording/#for-openvidu-server-docker-image-development-environment", 
            "text": "docker run -p 4443:4443 --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording=true \\\n    -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\\nopenvidu/openvidu-server-kms:2.8.0   openvidu.recording :  same as in OpenVidu Server JAR  openvidu.recording.path :  same as in OpenVidu Server JAR   It is also necessary to mount 2 volumes:   -v /var/run/docker.sock:/var/run/docker.sock : gives openvidu-server container access to the local Docker daemon  -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES : gives access to the recorded video files through the container     IMPORTANT!   /PATH/TO/VIDEO/FILES  must be the same in property  openvidu.recording.path=/PATH/TO/VIDEO/FILES  and in both sides of flag  -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES", 
            "title": "For OpenVidu Server Docker image (development environment)"
        }, 
        {
            "location": "/advanced-features/recording/#3-configure-your-sessions-to-be-recorded", 
            "text": "Recording can be configured in two ways:    ALWAYS : the session will be automatically recorded from the moment the first participant starts publishing.    MANUAL : you will have to tell openvidu-server when to start the recording of the session.    In both cases you can stop the recording manually, and every recording will always be automatically stopped if last user leaves the session and certain timeout elapses (see  Automatic stop of recordings ).   You can use  REST API  or any of the server SDKs ( openvidu-java-client ,  openvidu-node-client ) to manage your recorded sessions.   \n   REST API \n   Java \n   Node      Initialize your sessions with this POST method:  POST /api/sessions You may configure default values for recordings started for this session by sending params such as  defaultOutputMode  or  defaultRecordingLayout . This way you can pre-configure recordings that will be automatically started (for sessions with  {\"recordingMode\": \"ALWAYS\"} ). For these sessions configured with  ALWAYS  recording mode, no more steps are needed.    If you have configured your session with  \"recordingMode\": \"MANUAL\"    Start the recording with this POST method:  POST /api/recordings/start You can pass parameters to override default recording configuration values set in step 1 and to further configure it with other available options    Stop the recording with this POST method:  POST /api/recordings/stop          Call  OpenVidu.createSession()  passing as an optional parameter a  SessionProperties  object. You may configure default values for recordings started for this session with that object. This way you can pre-configure recordings that will be automatically started (for sessions with  RecordingMode.ALWAYS )  OpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nSessionProperties properties = new SessionProperties.Builder()\n    .recordingMode(RecordingMode.MANUAL) // RecordingMode.ALWAYS for automatic recording\n    .defaultOutputMode(Recording.OutputMode.INDIVIDUAL)\n    .build();\nSession session = openVidu.createSession(properties);    If Session is configured with  RecordingMode.MANUAL , manually start and stop the recording whenever you want. You may pass a  RecordingProperties  object when calling  OpenVidu.startRecording  method to override default values configured in step 1 and to further configure it with other available options  RecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.COMPOSED)\n    .name(\"MY_RECORDING_NAME\")\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties); // Starts recording\nrecording = openVidu.stopRecording(recording.getId()); // Stops recording        Call  OpenVidu.createSession()  passing as an optional parameter a  SessionProperties  object. You may configure default values for recordings started for this session with that object. This way you can pre-configure recordings that will be automatically started (for sessions with  RecordingMode.ALWAYS )  var openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nvar properties = {\n    recordingMode: RecordingMode.MANUAL, // RecordingMode.ALWAYS for automatic recording\n    defaultOutputMode: Recording.OutputMode.INDIVIDUAL\n};\nvar mySession = openvidu.createSession(properties);    If Session is configured with  RecordingMode.MANUAL , manually start and stop the recording whenever you want. You may pass a  RecordingProperties  object when calling  OpenVidu.startRecording  method to override default values configured in step 1 and to further configure it with other available options  var recording;\n\n// Starts recording\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.COMPOSED,\n    name: \"MY_RECORDING_NAME\"\n})\n  .then(response =  recording = response)\n  .catch(error =  console.error(error));\n\n// Stops recording\nopenvidu.stopRecording(recording.id)\n  .then(response =  recording = response)\n  .catch(error =  console.error(error));", 
            "title": "3. Configure your Sessions to be recorded"
        }, 
        {
            "location": "/advanced-features/recording/#composed-recording", 
            "text": "Every publisher stream is composed in the same video file in a grid layout. This is the default recording mode, and it will generate as output an MP4 file.  You can use the default layout, that will evenly distribute each stream in the available space, or you can  use your own custom layout . To use the default layout:   \n   REST API \n   Java \n   Node    When starting the recording of a session with method  POST /api/recordings/start  pass parameters {\"outputMode: \"COMPOSED\", \"recordingLayout\": \"BEST_FIT\"}    RecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.COMPOSED)\n    .recordingLayout(RecordingLayout.BEST_FIT)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);    var recording;\n\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.COMPOSED,\n    recordingLayout: RecordingLayout.BEST_FIT\n})\n    .then(response =  recording = response)\n    .catch(error =  console.error(error));       For example, for a session with two publishers the video file will look like this when using output mode  COMPOSED  and recording layout  BEST_FIT   \n         Notes on COMPOSED recordings   If a COMPOSED recording is configured to record video (that is, not being an  audio-only recording ), this type of grid recording  can be a pretty heavy consuming process . A maximum number of 4 publishers is recommended, and starting more than 2 recordings of this type at the same time can overload server CPUs. For these reasons, it is desirable to launch OpenVidu Server in a host with significant CPU power if COMPOSED video recordings are expected. In comparison, INDIVIDUAL stream recording (and COMPOSED audio-only recording) can be  4x up to 10x more efficient  You can configure the resolution of the MP4 file for COMPOSED recordings by using  resolution  property when starting the recording  A thumbnail got from the middle of the video will be generated for COMPOSED recordings that have video. They will be stored next to the MP4 file and named [RECORDING_ID].jpg", 
            "title": "Composed recording"
        }, 
        {
            "location": "/advanced-features/recording/#individual-stream-recording", 
            "text": "Every publisher stream is recorded in its own file. The final result is a ZIP file containing one WEBM file for each published stream during the recording (named after each stream identifier), along with a text file with synchronization information.   \n   REST API \n   Java \n   Node    When starting the recording of a session with method  POST /api/recordings/start  pass parameter  {\"outputMode:\"INDIVIDUAL\"}    RecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.INDIVIDUAL)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);    var recording;\n\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.INDIVIDUAL\n})\n    .then(response =  recording = response)\n    .catch(error =  console.error(error));     For example, for a session with 2 publishers the final content of the ZIP file could be:  MyRecording.zip\n+-- MyRecording.json\n+-- tzk08sgffcqqwpor_CAMERA_DFDAE.webm\n+-- ugkmpnz4bn6yewbi_CAMERA_PAHHB.webm  And the content of the JSON synchronization file might be:  {\n   createdAt : 1548947712287,\n   id :  zfgmthb8jl9uellk ,\n   name :  MyRecording ,\n   sessionId :  zfgmthb8jl9uellk ,\n   files : [\n    {\n       connectionId :  ugkmpnz4bn6yewbi ,\n       streamId :  ugkmpnz4bn6yewbi_CAMERA_PAHHB ,\n       size : 4006190,\n       clientData :  ,\n       serverData :  UserA ,\n       hasAudio : true,\n       hasVideo : true,\n       typeOfVideo :  SCREEN ,\n       startTimeOffset : 95,\n       endTimeOffset : 56445\n    },\n    {\n       connectionId :  tzk08sgffcqqwpor ,\n       streamId :  tzk08sgffcqqwpor_CAMERA_DFDAE ,\n       size : 2404760,\n       clientData :  ,\n       serverData :  UserB ,\n       hasAudio : false,\n       hasVideo : true,\n       typeOfVideo :  CAMERA ,\n       startTimeOffset : 148,\n       endTimeOffset : 56398\n    }\n  ]\n}   These are the properties in the JSON file    createdAt : time when the recording was started in UTC milliseconds  id : unique identifier of the recording  name : custom name of the recording. You can set this parameter when starting the recording, and the final ZIP file will be named after it  sessionId : unique identifier of the session that was recorded  files : array containing one JSON object for each one of the WEBM videos inside the ZIP file  connectionId : unique identifier of the connection that published the stream  streamId : unique identifier of the recorded stream  size : size in bytes of this particular recorded file  clientData : data associated to the connection that published the stream, in the client side. You can use this field to identify the user that published this particular recorded stream  serverData : data associated to the connection that published the stream, in the server side. You can use this field to identify the user that published this particular recorded stream  hasAudio : whether this recorded stream has an audio track or not  hasVideo : whether this recorded stream has a video track or not  typeOfVideo : type of video (\"CAMERA\" or \"SCREEN\"). Only defined if  hasVideo  is true  startTimeOffset : the offset in milliseconds for when this particular stream started being recorded, from the  createdAt  property of the root element  endTimeOffset : the offset in milliseconds for when this particular stream stopped being recorded, from the  createdAt  property of the root element", 
            "title": "Individual stream recording"
        }, 
        {
            "location": "/advanced-features/recording/#audio-only-and-video-only-recordings", 
            "text": "By default recordings will be generated with both audio and video, but you can configure them to record audio-only or video-only files.   \n   REST API \n   Java \n   Node    When starting the recording of a session with method  POST /api/recordings/start  simply pass parameters  hasAudio  or  hasVideo  with the desired values.    RecordingProperties properties = new RecordingProperties.Builder()\n    .hasAudio(true)\n    .hasVideo(false)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);    var recording;\n\nopenvidu.startRecording(sessionId, {\n    hasAudio: true,\n    hasVideo: false\n})\n    .then(response =  recording = response)\n    .catch(error =  console.error(error));      Notes on audio/video only recordings   Recordings configured to not record neither audio nor video will fail to start, returning a status error of 422  COMPOSED video-only recordings will generate an MP4 file. COMPOSED audio-only recordings will generate a WEBM file. INDIVIDUAL recordings will always generate a ZIP file containing one WEBM file for each recorded stream  Streams published during a video-only recording that are audio-only won't be recorded: they won't be included in the grid layout for COMPOSED recordings and won't generate a WEBM file in INDIVIDUAL recordings. Same for audio-only recordings with video-only streams  Recordings started automatically (with recording mode  ALWAYS ) will record both audio and video", 
            "title": "Audio-only and video-only recordings"
        }, 
        {
            "location": "/advanced-features/recording/#automatic-stop-of-recordings", 
            "text": "Any started recording will automatically be stopped when any of the following situations occur and certain timeout elapses. This timeout is by default 120 seconds, but you can configure it with  system property  openvidu.recording.autostop-timeout . The automatic recording stop timout will start:    For any recorded session, if last user disconnects from the session    For sessions with recording mode  MANUAL , if the recording is started and no user is publishing a stream    The only condition to abort the timeout is to have any user publishing a stream to the session within the timeout.  Sessions will always remain opened and the recording active during the timeout. If it elapses and no stream is being published to the session, the recording will be stopped. If in addition there's no user connected to the session, the session will also be automatically closed.   You can always manually stop any recording at any time:   \n   REST API \n   Java \n   Node    POST /api/recordings/stop/ RECORDING_ID    Recording stoppedRecording = openVidu.stopRecording(recordingId);    var stoppedRecording;\nopenvidu.stopRecording(recordingId)\n    .then(response =  stoppedRecording = response)\n    .catch(error =  console.error(error));", 
            "title": "Automatic stop of recordings"
        }, 
        {
            "location": "/advanced-features/recording/#custom-recording-layouts", 
            "text": "You can create your own layouts for the session recording process. They are implemented with HTML/CSS/JS files, just as your OpenVidu application client-side.", 
            "title": "Custom recording layouts"
        }, 
        {
            "location": "/advanced-features/recording/#1-create-your-layout-with-htmlcssjs-files", 
            "text": "Put them in a path accessible to openvidu-server. There must be an  index.html  file as entrypoint for your custom layout:     WHAT SHOULD YOUR JS CODE DO : by making use of  openvidu-browser.js  library, you need to connect a  recorder  participant to the session. This means:  1) Your layout must connect to the session using a  token  like this:  'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + ' secret=' + SECRET + ' recorder=true';  Being  SESSION_ID  and  SECRET  two parameters that will be url-encoded under ids  sessionId  and  secret  respectively. So, for example:  var url = new URL(window.location.href);\nvar SESSION_ID = url.searchParams.get(\"sessionId\");\nvar SECRET = url.searchParams.get(\"secret\");\nvar TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + ' secret=' + SECRET + ' recorder=true';\nvar session = OV.initSession();\nsession.connect(TOKEN);  2) You will need to subscribe to, at least, one event:   streamCreated  of Session object. That way you can subscribe your recorder to every stream when any user starts publishing (by default, the video element will be automatically removed on every  streamDestroyed  event). To sum up, this would be the simplest code you need to properly start your recorder participant:  var OV = new OpenVidu();\n\nvar url = new URL(window.location.href);\nvar SESSION_ID = url.searchParams.get(\"sessionId\");\nvar SECRET = url.searchParams.get(\"secret\");\nvar TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + ' secret=' + SECRET + ' recorder=true';\nvar session = OV.initSession();\n\nsession.on(\"streamCreated\", (event) =  {\n    session.subscribe(event.stream, 'html-id-where-insert-video');\n});\n\nsession.connect(TOKEN);      HOW TO IDENTIFY YOUR USERS : you can identify them by making use of property  Stream.connection.data  of the Stream object retrieved in Session event \"streamCreated\". That way you may know which particular user should be displayed in which particular HTML element of your layout. For example: session.on(\"streamCreated\", (event) =  {\n    var stream = event.stream;\n    if (stream.connection.data === 'userBigVideo') {\n        session.subscribe(stream, 'big-video-div');\n    } else if (stream.connection.data === 'userSmallVideo') {\n        session.subscribe(stream, 'small-video-div');\n    }\n});", 
            "title": "1. Create your layout with HTML/CSS/JS files"
        }, 
        {
            "location": "/advanced-features/recording/#2-add-new-properties-when-launching-openvidu-server", 
            "text": "You can configure where should OpenVidu Server look for your custom layout in the system. Default path is  /opt/openvidu/custom-layout , but you can configure it with system property  openvidu.recording.custom-layout . OpenVidu Server must have read access to that path.   openvidu-server.jar  java -jar \\\n    -Dopenvidu.recording=true \\\n    -Dopenvidu.recording.path=/PATH/TO/VIDEO/FILES \\\n    -Dopenvidu.recording.custom-layout: /PATH/TO/INDEX/CUSTOM/LAYOUT \\\nopenvidu-server.jar   openvidu/openvidu-server-kms   (development environment)  docker run -p 4443:4443 --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\\n    -v /PATH/TO/INDEX/CUSTOM/LAYOUT:/PATH/TO/INDEX/CUSTOM/LAYOUT \\\n    -e MY_UID=$(id -u $USER) \\\n    -e openvidu.recording=true \\\n    -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording.custom-layout=/PATH/TO/INDEX/CUSTOM/LAYOUT \\\nopenvidu/openvidu-server-kms:2.8.0   WARNING : remember to add the  -v  option mounting the path defined with  openvidu.recording.custom-layout    OpenVidu AWS deployment  You must store your custom layouts in the server under default path  /opt/openvidu/custom-layout", 
            "title": "2. Add new properties when launching openvidu-server"
        }, 
        {
            "location": "/advanced-features/recording/#3-configure-your-recordings-to-use-your-custom-layout", 
            "text": "REST API \n   Java \n   Node    When starting the recording of a session with method  POST /api/recordings/start  pass parameters {\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\"}    RecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.COMPOSED)\n    .recordingLayout(RecordingLayout.CUSTOM)\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);    var recording;\n\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.COMPOSED,\n    recordingLayout: RecordingLayout.CUSTOM\n})\n    .then(response =  recording = response)\n    .catch(error =  console.error(error));", 
            "title": "3. Configure your recordings to use your custom layout"
        }, 
        {
            "location": "/advanced-features/recording/#configuring-multiple-custom-layouts", 
            "text": "You can implement as many custom recording layouts as you want. Simply store each one of them (each one with its own  index.html  entrypoint file) in a subfolder under path defined with system property  openvidu.recording.custom-layout  (default value  /opt/openvidu/custom-layout ). Then, when configuring your sessions as stated above in point 3, just add a new parameter:   \n   REST API \n   Java \n   Node    When starting the recording of a session with method  POST /api/recordings/start  pass parameters {\"outputMode\": \"COMPOSED\", \"recordingLayout\": \"CUSTOM\", \"customLayout\": \"RELATIVE/PATH/TO/INDEX\"}    RecordingProperties properties = new RecordingProperties.Builder()\n    .outputMode(Recording.OutputMode.COMPOSED)\n    .recordingLayout(RecordingLayout.CUSTOM)\n    .customLayout( RELATIVE/PATH/TO/INDEX )\n    .build();\nRecording recording = openVidu.startRecording(session.getSessionId(), properties);    var recording;\n\nopenvidu.startRecording(sessionId, {\n    outputMode: Recording.OutputMode.COMPOSED,\n    recordingLayout: RecordingLayout.CUSTOM,\n    customLayout:  RELATIVE/PATH/TO/INDEX \n})\n    .then(response =  recording = response)\n    .catch(error =  console.error(error));     In the snippets above, string  RELATIVE/PATH/TO/INDEX  is the path from openvidu-server configuration property  openvidu.recording.custom-layout  to the specific  index.html  you want to use for a particular recording. So, if you have the following folder tree structure in your OpenVidu Server host:  /opt\n+-- /openvidu\n|   +-- /my_custom_layouts\n|       +-- index.html\n|       +-- /layout1\n|           +-- index.html\n|       +-- /layout2\n|           +-- index.html\n/etc\n    ...  You should start openvidu-server with property  openvidu.recording.custom-layout=/opt/openvidu/my_custom_layouts  and you can use any of the 3  index.html  files for recording any of your sessions. To use the outer layout in a recording, just configure in recording properties  recordingLayout  to  CUSTOM . To use any of the inner layouts, also configure  customLayout  to  layout1  or  layout2 .", 
            "title": "Configuring multiple custom layouts"
        }, 
        {
            "location": "/advanced-features/recording/#sample-custom-layout", 
            "text": "This is literally the simplest HTML for a custom recording layout. Use it as a template for building more complex ones (you will need  latest  openvidu-browser-VERSION.min.js  file  to be in the same folder)  html  head script src= openvidu-browser-2.8.0.min.js /script /head  body \n     div id= videos /div  /body  script \n    var url = new URL(window.location.href);\n    var SESSION_ID = url.searchParams.get( sessionId );\n    var SECRET = url.searchParams.get( secret );\n    var TOKEN = 'wss://' + location.hostname + ':4443?sessionId=' + SESSION_ID + ' secret=' + SECRET + ' recorder=true';\n\n    var OV = new OpenVidu();\n    var session = OV.initSession();\n\n    session.on( streamCreated , (event) =  {\n        session.subscribe(event.stream, 'videos');\n    });\n    session.connect(TOKEN)\n        .then(() =  { console.log('Recorder participant connected') })\n        .catch(error =  { console.error(error) }); /script  /html", 
            "title": "Sample custom layout"
        }, 
        {
            "location": "/advanced-features/recording/#local-recording-in-the-browser", 
            "text": "OpenVidu Browser offers an extremely simple API to record Streams directly in the client's browser. Check it out  here .   \nfunction changeLangTab(event) {\n  var parent = event.target.parentNode.parentNode;\n  var txt = event.target.textContent || event.target.innerText;\n  var txt = txt.replace(/\\s/g, \"-\").toLowerCase();\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n    // Change appearance of language buttons\n    if (child.classList.contains(\"lang-tabs-header\")) {\n        for (var j = 0; j < child.children.length; j++) {\n            var btn = child.children[j];\n            if (btn.classList.contains(\"lang-tabs-btn\")) {\n                btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9';\n                btn.style.fontWeight = btn === event.target ? 'bold' : 'normal';\n            }\n        }\n    }\n    // Change visibility of language content\n    if (child.classList.contains(\"lang-tabs-content\")) {\n        if (child.id === txt) {\n            child.style.display = \"block\";\n        } else {\n            child.style.display = \"none\";\n        }\n    }\n  }\n}", 
            "title": "Local recording in the browser"
        }, 
        {
            "location": "/advanced-features/screen-share/", 
            "text": "Screen share\n\n\nTo share your screen instead of your webcam, the process is exactly the same as stated in \nPublish a stream\n section, but setting to \n\"screen\"\n \nvideoSource\n property when initializing a Publisher object:\n\n\nOV.initPublisher(\nhtml-element-id\n, { videoSource: \nscreen\n });\n\n\n\n\nChrome\n, \nFirefox\n and \nOpera\n support screen sharing.\n\n\nChrome \n=72\n and \nFirefox \n=66\n support native screen sharing.\n\n\nChrome \n72 (and Opera based on Chrome \n72) need an extension. An OpenViduError object may be returned with the following \nOpenViduError.name\n property in the callback function:\n\n\n\n\nSCREEN_SHARING_NOT_SUPPORTED\n: if the client does not support screen sharing.\n\n\nSCREEN_EXTENSION_NOT_INSTALLED\n: Chrome \n72 needs an extension to allow screen sharing. \nerror.message\n has the URL of Chrome Web Store where to install the extension.\n\n\nSCREEN_EXTENSION_DISABLED\n: if Chrome's screen extension is installed but disabled\n\n\nSCREEN_CAPTURE_DENIED\n: if the user doesn't grant permissions to capture the screen when the browser asks to.\n\n\n\n\nOV.initPublisher('html-element-id', { videoSource: \nscreen\n }, function(error) {\n    if (error.name == 'SCREEN_EXTENSION_NOT_INSTALLED') {\n        showWarning(error.message);\n\n        // showWarning could show a button with href 'error.message',\n        // so the user can navigate to install the extension.\n        // A browser refresh is also needed after installation\n\n    } else if (error.name == 'SCREEN_SHARING_NOT_SUPPORTED') {\n        alert('Your browser does not support screen sharing');\n    } else if (error.name == 'SCREEN_EXTENSION_DISABLED') {\n        alert('You need to enable screen sharing extension');\n    } else if (error.name == 'SCREEN_CAPTURE_DENIED') {\n        alert('You need to choose a window or application to share');\n    }\n});\n\n\n\n\nFor \nFirefox \n66\n two different \nvideoSource\n strings are allowed in order to screen share:\n\n\n\n\n\"screen\"\n: entire screen\n\n\n\"window\"\n: specific application window\n\n\n\n\nIn Chrome and Opera both values will always give access to both entire screen and specific application windows.\n\n\n\n\n\n\nCustom Screen Sharing extension for Chrome\n\n\n\nWe provide a default extension that will work on any domain, but you can create your own Chrome extension always based on ours (\nOpenVidu Screen Sharing extension\n). This way your extension may have your own icon, name, description and custom valid domains.\n\n\nTo use your extension, just configure OpenVidu object like this after initializing it:\n\n\nvar OV = new OpenVidu();\nOV.setAdvancedConfiguration(\n    { screenShareChromeExtension: \nhttps://chrome.google.com/webstore/detail/EXTENSION_NAME/EXTENSION_ID\n }\n);\n\n\n\n\nCheck the \nGitHub README\n for further information.", 
            "title": "Screen share"
        }, 
        {
            "location": "/advanced-features/screen-share/#screen-share", 
            "text": "To share your screen instead of your webcam, the process is exactly the same as stated in  Publish a stream  section, but setting to  \"screen\"   videoSource  property when initializing a Publisher object:  OV.initPublisher( html-element-id , { videoSource:  screen  });  Chrome ,  Firefox  and  Opera  support screen sharing.  Chrome  =72  and  Firefox  =66  support native screen sharing.  Chrome  72 (and Opera based on Chrome  72) need an extension. An OpenViduError object may be returned with the following  OpenViduError.name  property in the callback function:   SCREEN_SHARING_NOT_SUPPORTED : if the client does not support screen sharing.  SCREEN_EXTENSION_NOT_INSTALLED : Chrome  72 needs an extension to allow screen sharing.  error.message  has the URL of Chrome Web Store where to install the extension.  SCREEN_EXTENSION_DISABLED : if Chrome's screen extension is installed but disabled  SCREEN_CAPTURE_DENIED : if the user doesn't grant permissions to capture the screen when the browser asks to.   OV.initPublisher('html-element-id', { videoSource:  screen  }, function(error) {\n    if (error.name == 'SCREEN_EXTENSION_NOT_INSTALLED') {\n        showWarning(error.message);\n\n        // showWarning could show a button with href 'error.message',\n        // so the user can navigate to install the extension.\n        // A browser refresh is also needed after installation\n\n    } else if (error.name == 'SCREEN_SHARING_NOT_SUPPORTED') {\n        alert('Your browser does not support screen sharing');\n    } else if (error.name == 'SCREEN_EXTENSION_DISABLED') {\n        alert('You need to enable screen sharing extension');\n    } else if (error.name == 'SCREEN_CAPTURE_DENIED') {\n        alert('You need to choose a window or application to share');\n    }\n});  For  Firefox  66  two different  videoSource  strings are allowed in order to screen share:   \"screen\" : entire screen  \"window\" : specific application window   In Chrome and Opera both values will always give access to both entire screen and specific application windows.", 
            "title": "Screen share"
        }, 
        {
            "location": "/advanced-features/screen-share/#custom-screen-sharing-extension-for-chrome", 
            "text": "We provide a default extension that will work on any domain, but you can create your own Chrome extension always based on ours ( OpenVidu Screen Sharing extension ). This way your extension may have your own icon, name, description and custom valid domains.  To use your extension, just configure OpenVidu object like this after initializing it:  var OV = new OpenVidu();\nOV.setAdvancedConfiguration(\n    { screenShareChromeExtension:  https://chrome.google.com/webstore/detail/EXTENSION_NAME/EXTENSION_ID  }\n);  Check the  GitHub README  for further information.", 
            "title": "Custom Screen Sharing extension for Chrome"
        }, 
        {
            "location": "/advanced-features/speech-detection/", 
            "text": "Speech detection\n\n\nA pretty common requested event is one that allows you to detect when a publisher starts and stops speaking. OpenVidu offers this ability through \nPublisherSpeakingEvents\n that can be configured for \nSession\n objects:\n\n\nsession.on('publisherStartSpeaking', (event) =\n {\n    console.log('Publisher ' + event.connection.connectionId + ' start speaking');\n});\n\nsession.on('publisherStopSpeaking', (event) =\n {\n    console.log('Publisher ' + event.connection.connectionId + ' stop speaking');\n});\n\n\n\n\nEvent \npublisherStopSpeaking\n for certain \nConnection\n object can only be triggered after \npublisherStartSpeaking\n has been called for that specific Connection object. In other words, none of these events can be triggered twice in a row for one Connection: they are always launched alternately.\n\n\nYou can further configure the behavior of these two events by using \nOpenVidu.setAdvancedConfiguration\n method:\n\n\nvar OV = new OpenVidu();\nOV.setAdvancedConfiguration({\n    publisherSpeakingEventsOptions: {\n        interval: 50,   // Frequency of the polling of audio streams in ms\n        threshold: -50  // Threshold volume in dB\n    }\n});\n\n\n\n\nWith these events it is really easy to build a layout that can make the main speaker video the bigger one, and alternate the main view between the participants of a session as they take the floor.\n\n\nAudio volume detection\n\n\nSince release 2.7.0, you have also available a new \nStreamManagerEvent\n called \nstreamAudioVolumeChange\n. You can get the audio volume (-100 being silence to 0 being max volume) of any Publisher or Subscriber by doing this:\n\n\npublisher.on('streamAudioVolumeChange', (event) =\n {\n    console.log('Publisher audio volume change from ' + event.value.oldValue + ' to' + event.value.newValue);\n});", 
            "title": "Speech detection"
        }, 
        {
            "location": "/advanced-features/speech-detection/#speech-detection", 
            "text": "A pretty common requested event is one that allows you to detect when a publisher starts and stops speaking. OpenVidu offers this ability through  PublisherSpeakingEvents  that can be configured for  Session  objects:  session.on('publisherStartSpeaking', (event) =  {\n    console.log('Publisher ' + event.connection.connectionId + ' start speaking');\n});\n\nsession.on('publisherStopSpeaking', (event) =  {\n    console.log('Publisher ' + event.connection.connectionId + ' stop speaking');\n});  Event  publisherStopSpeaking  for certain  Connection  object can only be triggered after  publisherStartSpeaking  has been called for that specific Connection object. In other words, none of these events can be triggered twice in a row for one Connection: they are always launched alternately.  You can further configure the behavior of these two events by using  OpenVidu.setAdvancedConfiguration  method:  var OV = new OpenVidu();\nOV.setAdvancedConfiguration({\n    publisherSpeakingEventsOptions: {\n        interval: 50,   // Frequency of the polling of audio streams in ms\n        threshold: -50  // Threshold volume in dB\n    }\n});  With these events it is really easy to build a layout that can make the main speaker video the bigger one, and alternate the main view between the participants of a session as they take the floor.", 
            "title": "Speech detection"
        }, 
        {
            "location": "/advanced-features/speech-detection/#audio-volume-detection", 
            "text": "Since release 2.7.0, you have also available a new  StreamManagerEvent  called  streamAudioVolumeChange . You can get the audio volume (-100 being silence to 0 being max volume) of any Publisher or Subscriber by doing this:  publisher.on('streamAudioVolumeChange', (event) =  {\n    console.log('Publisher audio volume change from ' + event.value.oldValue + ' to' + event.value.newValue);\n});", 
            "title": "Audio volume detection"
        }, 
        {
            "location": "/advanced-features/filters/", 
            "text": "Voice and video filters\n\n\nOpenVidu API offers a simple way of applying filters to video and audio streams in the server side by making use of Kurento Media Server capabilities. This is the current status of filter support in OpenVidu:\n\n\n\n\nYou can apply \none filter at a time to a published Stream\n. Every user subscribed to it will receive the modified stream.\n\n\nYou can \nremove an applied filter\n.\n\n\nYou can \ncall any remote method\n offered by an applied filter\n\n\nYou can \nadd and remove event listeners\n to any event dispatched by an applied filter.\n\n\nYou must configure in the participant token the allowed filters the user can apply.\n\n\n\n\n\n    \n\n\n\n    \nWARNING\n: experimental option. This feature may suffer breaking changes in the near future.\n\n\n\n\n\n\n\n\nStep by step\n\n\n\n\n1) Generate a token with the filters the user will be able to apply\n\n\nThis is a simple way of securing the ability of applying filters from OpenVidu Browser, so that not every user is able to apply any filter at any time.\n\n\n\n\n\n  \nREST API\n\n  \nJava\n\n  \nNode\n\n\n\n\n\n\n\nWhen generating a token with operation \nPOST /api/tokens\n include in the JSON body a parameter \nkurentoOptions\n with a property \nallowedFilters\n: a string array containing the name of the filters the user will be able to apply\n\n\n{\n    \nsession\n: \n6fpivlanw91qjy6n\n,\n    \ndata\n: \nuser_data\n,\n    \nrole\n: \nPUBLISHER\n,\n    \nkurentoOptions\n: {\n        \nallowedFilters\n: [\nGStreamerFilter\n, \nFaceOverlayFilter\n]\n    }\n}\n\n\n\n\n\n\n\n\nWhen generating a token, call \nTokenOptions.Builder#kurentoOptions(KurentoOptions)\n to set \nallowedFilters\n value with method \nKurentoOptions.Builder#allowedFilters(String[])\n. This method receives a string array containing the name of the filters the user will be able to apply\n\n\nTokenOptions tokenOptions = new TokenOptions.Builder()\n    .role(OpenViduRole.PUBLISHER)\n    .data(\nuser_data\n)\n    .kurentoOptions(\n        new KurentoOptions.Builder()\n            .allowedFilters(new String[]{\nGStreamerFilter\n, \nFaceOverlayFilter\n})\n            .build())\n    .build();\nString token = session.generateToken(tokenOptions);\n\n\n\n\n\n\n\n\nWhen generating a token, include in \nTokenOptions\n parameter a \nkurentoOptions\n object with \nallowedFiters\n property: a string array containing the name of the filters the user will be able to apply\n\n\nvar tokenOptions = {\n    role: \nPUBLISHER\n,\n    data: \nuser_data\n,\n    kurentoOptions: {\n        allowedFilters: [\nGStreamerFilter\n, \nFaceOverlayFilter\n]\n    }\n};\nsession.generateToken(tokenOptions).then(token =\n { ... });\n\n\n\n\n\n\n\n\n\n\n2.A) Initialize a Publisher object configured for using a filter from the beginning of the publishing ...\n\n\nUse \nPublisherProperties\n, specifically property \nfilter\n:\n\n\nvar OV = new OpenVidu();\nvar publisher = OV.initPublisher(\n    targetElement,\n    {filter: {type: \nGStreamerFilter\n, options: \nvideoflip method=vertical-flip\n}}\n);\n\n// ... user already connected to \nsession\n with the appropriate token\nsession.publish(publisher);\n\n\n\n\n\n\n2.B) ... or apply the filter dynamically after publishing the stream, whenever you want\n\n\n// ... user already connected to the session with the appropriate token\n// and successfully publishing the Publisher object\n\npublisher.stream.applyFilter(\nGStreamerFilter\n, \nvideoflip method=vertical-flip\n)\n    .then(() =\n {\n        console.log(\nVideo rotated!\n);\n    })\n    .catch(error =\n {\n        console.error(error);\n    });\n\n\n\n\n\n\n3) You can execute any method offered by the filter\n\n\n// ... user already connected to the session with the appropriate token,\n// successfully publishing the Publisher object and a filter being applied to its stream\n\npublisher.stream.filter.execMethod(\nsetElementProperty\n, {\npropertyName\n:\nmethod\n,\npropertyValue\n:\nhorizontal-flip\n})\n    .then(() =\n {\n        console.log(\nVideo rotation direction modified!\n);\n    })\n    .catch(error =\n {\n        console.error(error);\n    });\n\n\n\n\n\n\n4) You can also subscribe to any filter event (if it dispatches any), and later unsubscribe from it\n\n\n// ... user already connected to the session with the appropriate token,\n// successfully publishing the Publisher object and a filter being applied to its stream\n\npublisher.stream.filter.addEventListener(\nFooFilterEvent\n, filterEvent =\n {\n        console.log('Filter event received!. Data: ' + filterEvent.data);\n    });\n\n...\n\npublisher.stream.filter.removeEventListener(\nFooFilterEvent\n);\n\n\n\n\n\n\n4) To remove the filter\n\n\n// ... user already connected to the session with the appropriate token,\n// successfully publishing the Publisher object and a filter being applied to its stream\n\npublisher.stream.removeFilter()\n    .then(() =\n {\n        console.log(\nFilter removed\n);\n    })\n    .catch(error =\n {\n        console.error(error);\n    });\n\n\n\n\n\n\n\n\nModerators are not only able to call all of these methods over their \nPublisher.stream\n object, but also over any \nSubscriber.stream\n object. Also, they don't need any special token permission to apply filters and can bypass any token restriction set to other user tokens\n\n\n\n\n\n\n\n\nFilter samples\n\n\nKurento filters\n\n\n\n\n\n\nFaceOverlayFilter\n \n(overlay an image over detected faces)\npublisher.stream.applyFilter(\"FaceOverlayFilter\")\n    .then(filter =\n {\n        filter.execMethod(\n            \"setOverlayedImage\",\n            {\n                \"uri\":\"https://cdn.pixabay.com/photo/2013/07/12/14/14/derby-148046_960_720.png\",\n                \"offsetXPercent\":\"-0.2F\",\n                \"offsetYPercent\":\"-0.8F\",\n                \"widthPercent\":\"1.3F\",\n                \"heightPercent\":\"1.0F\"\n            });\n    });\n\n\n\n\n\n\n\n\n\n\n\nChromaFilter\n \n(set a chroma background)\npublisher.stream.applyFilter(\n    \"ChromaFilter\",\n    {\n        \"window\": {\n            \"topRightCornerX\": 0,\n            \"topRightCornerY\": 0,\n            \"width\": 50,\n            \"height\": 50\n        },\n        \"backgroundImage\": \"https://www.maxpixel.net/static/photo/1x/Cool-Blue-Liquid-Lake-Abstract-Background-Clear-316144.jpg\"\n    });\n\n\n\n\n\n\n\n\n\nYou must install Kurento ChromaFilter library in the same host as Kurento Media Server: \nsudo apt-get install kms-chroma\n\n\n\n\n\n\n\n\nZBarFilter\n \n(detect and read bar codes information)\npublisher.stream.applyFilter(\"ZBarFilter\")\n    .then(filter =\n {\n        filter.addEventListener(\"CodeFound\", filterEvent =\n {\n            console.log('Bar code found!. Data: ' + filterEvent.data);\n        }\n    });\n\n\n\n\n\n\n\nGStreamer filters\n\n\nThese filters are set with \ntype\n \nGStreamerFilter\n and an \noptions\n parameter like this:\n\n\npublisher.stream.applyFilter(\nGStreamerFilter\n, {\ncommand\n: \nGSTREAMER_COMMAND\n})\n\n\n\n\nA list of interesting values for \nGSTREAMER_COMMAND\n parameter is stated below. Replace \nGSTREAMER_COMMAND\n in the upper code snippet for any of the examples provided in the following list items:\n\n\n\n\ncoloreffects\n: apply different color filters to the video stream\nExample: \ncoloreffects preset=heat\n\n\nvideobalance\n: change different properties of the video stream such as brightness, contrast, hue or saturation\nExample: \nvideobalance saturation=0.0\n\n\nvideoflip\n: rotate the video stream\nExample: \nvideoflip method=vertical-flip\n\n\nvideobox\n: crop the video stream\nExample: \nvideobox fill=black top=20 bottom=20 left=-10 right=-10\n\n\ngamma\n: adjust gamma level of the video stream\nExample: \ngamma gamma=5.0\n\n\nvideomedian\n: add a median filter to the video stream\nExample: \nvideomedian filtersize=9 lum-only=false\n\n\ntextoverlay\n: add an embedded text to the video\nExample: \ntextoverlay text=\"Embedded text\" valignment=top halignment=right font-desc=\"Cantarell 25\"\n\n\ntimeoverlay\n: embed the time the video stream has been playing\nExample: \ntimeoverlay valignment=bottom halignment=right font-desc=\"Sans, 20\"\n\n\nclockoverlay\n: embed a clock with the local time (in OpenVidu Server)\nExample: \nclockoverlay valignment=bottom halignment=right shaded-background=true font-desc=\"Sans, 20\"\n\n\naudioecho\n: add reverb to the audio stream\nExample: \naudioecho delay=50000000 intensity=0.6 feedback=0.4\n\n\naudioamplify\n: amplifies an audio stream by a given factor\nExample: \naudioamplify amplification=1.5 clipping-method=wrap-positive\n\n\nOther audio filters: check them out in \nGStreamer site\n\n\nMany effects of \neffectv project\n : funny filters for the video stream like \nagingtv\n, \ndicetv\n, \noptv\n, \nquarktv\n, \nradioactv\n, \nrevtv\n, \nrippletv\n, \nshagadelictv\n, \nstreaktv\n, \nvertigotv\n, \nwarptv\nExample: \nradioactv\n\n\n\n\nAll available GStreamer plugins can be found in \nGStreamer site\n.\n\n\n\n\n\nfunction changeLangTab(event) {\n  var parent = event.target.parentNode.parentNode;\n  var txt = event.target.textContent || event.target.innerText;\n  var txt = txt.replace(/\\s/g, \"-\").toLowerCase();\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n    // Change appearance of language buttons\n    if (child.classList.contains(\"lang-tabs-header\")) {\n        for (var j = 0; j < child.children.length; j++) {\n            var btn = child.children[j];\n            if (btn.classList.contains(\"lang-tabs-btn\")) {\n                btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9';\n                btn.style.fontWeight = btn === event.target ? 'bold' : 'normal';\n            }\n        }\n    }\n    // Change visibility of language content\n    if (child.classList.contains(\"lang-tabs-content\")) {\n        if (child.id === txt) {\n            child.style.display = \"block\";\n        } else {\n            child.style.display = \"none\";\n        }\n    }\n  }\n}", 
            "title": "Voice and video filters"
        }, 
        {
            "location": "/advanced-features/filters/#voice-and-video-filters", 
            "text": "OpenVidu API offers a simple way of applying filters to video and audio streams in the server side by making use of Kurento Media Server capabilities. This is the current status of filter support in OpenVidu:   You can apply  one filter at a time to a published Stream . Every user subscribed to it will receive the modified stream.  You can  remove an applied filter .  You can  call any remote method  offered by an applied filter  You can  add and remove event listeners  to any event dispatched by an applied filter.  You must configure in the participant token the allowed filters the user can apply.   \n      \n     WARNING : experimental option. This feature may suffer breaking changes in the near future.", 
            "title": "Voice and video filters"
        }, 
        {
            "location": "/advanced-features/filters/#step-by-step", 
            "text": "", 
            "title": "Step by step"
        }, 
        {
            "location": "/advanced-features/filters/#1-generate-a-token-with-the-filters-the-user-will-be-able-to-apply", 
            "text": "This is a simple way of securing the ability of applying filters from OpenVidu Browser, so that not every user is able to apply any filter at any time.   \n   REST API \n   Java \n   Node    When generating a token with operation  POST /api/tokens  include in the JSON body a parameter  kurentoOptions  with a property  allowedFilters : a string array containing the name of the filters the user will be able to apply  {\n     session :  6fpivlanw91qjy6n ,\n     data :  user_data ,\n     role :  PUBLISHER ,\n     kurentoOptions : {\n         allowedFilters : [ GStreamerFilter ,  FaceOverlayFilter ]\n    }\n}    When generating a token, call  TokenOptions.Builder#kurentoOptions(KurentoOptions)  to set  allowedFilters  value with method  KurentoOptions.Builder#allowedFilters(String[]) . This method receives a string array containing the name of the filters the user will be able to apply  TokenOptions tokenOptions = new TokenOptions.Builder()\n    .role(OpenViduRole.PUBLISHER)\n    .data( user_data )\n    .kurentoOptions(\n        new KurentoOptions.Builder()\n            .allowedFilters(new String[]{ GStreamerFilter ,  FaceOverlayFilter })\n            .build())\n    .build();\nString token = session.generateToken(tokenOptions);    When generating a token, include in  TokenOptions  parameter a  kurentoOptions  object with  allowedFiters  property: a string array containing the name of the filters the user will be able to apply  var tokenOptions = {\n    role:  PUBLISHER ,\n    data:  user_data ,\n    kurentoOptions: {\n        allowedFilters: [ GStreamerFilter ,  FaceOverlayFilter ]\n    }\n};\nsession.generateToken(tokenOptions).then(token =  { ... });", 
            "title": "1) Generate a token with the filters the user will be able to apply"
        }, 
        {
            "location": "/advanced-features/filters/#2a-initialize-a-publisher-object-configured-for-using-a-filter-from-the-beginning-of-the-publishing", 
            "text": "Use  PublisherProperties , specifically property  filter :  var OV = new OpenVidu();\nvar publisher = OV.initPublisher(\n    targetElement,\n    {filter: {type:  GStreamerFilter , options:  videoflip method=vertical-flip }}\n);\n\n// ... user already connected to  session  with the appropriate token\nsession.publish(publisher);", 
            "title": "2.A) Initialize a Publisher object configured for using a filter from the beginning of the publishing ..."
        }, 
        {
            "location": "/advanced-features/filters/#2b-or-apply-the-filter-dynamically-after-publishing-the-stream-whenever-you-want", 
            "text": "// ... user already connected to the session with the appropriate token\n// and successfully publishing the Publisher object\n\npublisher.stream.applyFilter( GStreamerFilter ,  videoflip method=vertical-flip )\n    .then(() =  {\n        console.log( Video rotated! );\n    })\n    .catch(error =  {\n        console.error(error);\n    });", 
            "title": "2.B) ... or apply the filter dynamically after publishing the stream, whenever you want"
        }, 
        {
            "location": "/advanced-features/filters/#3-you-can-execute-any-method-offered-by-the-filter", 
            "text": "// ... user already connected to the session with the appropriate token,\n// successfully publishing the Publisher object and a filter being applied to its stream\n\npublisher.stream.filter.execMethod( setElementProperty , { propertyName : method , propertyValue : horizontal-flip })\n    .then(() =  {\n        console.log( Video rotation direction modified! );\n    })\n    .catch(error =  {\n        console.error(error);\n    });", 
            "title": "3) You can execute any method offered by the filter"
        }, 
        {
            "location": "/advanced-features/filters/#4-you-can-also-subscribe-to-any-filter-event-if-it-dispatches-any-and-later-unsubscribe-from-it", 
            "text": "// ... user already connected to the session with the appropriate token,\n// successfully publishing the Publisher object and a filter being applied to its stream\n\npublisher.stream.filter.addEventListener( FooFilterEvent , filterEvent =  {\n        console.log('Filter event received!. Data: ' + filterEvent.data);\n    });\n\n...\n\npublisher.stream.filter.removeEventListener( FooFilterEvent );", 
            "title": "4) You can also subscribe to any filter event (if it dispatches any), and later unsubscribe from it"
        }, 
        {
            "location": "/advanced-features/filters/#4-to-remove-the-filter", 
            "text": "// ... user already connected to the session with the appropriate token,\n// successfully publishing the Publisher object and a filter being applied to its stream\n\npublisher.stream.removeFilter()\n    .then(() =  {\n        console.log( Filter removed );\n    })\n    .catch(error =  {\n        console.error(error);\n    });    Moderators are not only able to call all of these methods over their  Publisher.stream  object, but also over any  Subscriber.stream  object. Also, they don't need any special token permission to apply filters and can bypass any token restriction set to other user tokens", 
            "title": "4) To remove the filter"
        }, 
        {
            "location": "/advanced-features/filters/#filter-samples", 
            "text": "", 
            "title": "Filter samples"
        }, 
        {
            "location": "/advanced-features/filters/#kurento-filters", 
            "text": "FaceOverlayFilter   (overlay an image over detected faces) publisher.stream.applyFilter(\"FaceOverlayFilter\")\n    .then(filter =  {\n        filter.execMethod(\n            \"setOverlayedImage\",\n            {\n                \"uri\":\"https://cdn.pixabay.com/photo/2013/07/12/14/14/derby-148046_960_720.png\",\n                \"offsetXPercent\":\"-0.2F\",\n                \"offsetYPercent\":\"-0.8F\",\n                \"widthPercent\":\"1.3F\",\n                \"heightPercent\":\"1.0F\"\n            });\n    });      ChromaFilter   (set a chroma background) publisher.stream.applyFilter(\n    \"ChromaFilter\",\n    {\n        \"window\": {\n            \"topRightCornerX\": 0,\n            \"topRightCornerY\": 0,\n            \"width\": 50,\n            \"height\": 50\n        },\n        \"backgroundImage\": \"https://www.maxpixel.net/static/photo/1x/Cool-Blue-Liquid-Lake-Abstract-Background-Clear-316144.jpg\"\n    });     You must install Kurento ChromaFilter library in the same host as Kurento Media Server:  sudo apt-get install kms-chroma     ZBarFilter   (detect and read bar codes information) publisher.stream.applyFilter(\"ZBarFilter\")\n    .then(filter =  {\n        filter.addEventListener(\"CodeFound\", filterEvent =  {\n            console.log('Bar code found!. Data: ' + filterEvent.data);\n        }\n    });", 
            "title": "Kurento filters"
        }, 
        {
            "location": "/advanced-features/filters/#gstreamer-filters", 
            "text": "These filters are set with  type   GStreamerFilter  and an  options  parameter like this:  publisher.stream.applyFilter( GStreamerFilter , { command :  GSTREAMER_COMMAND })  A list of interesting values for  GSTREAMER_COMMAND  parameter is stated below. Replace  GSTREAMER_COMMAND  in the upper code snippet for any of the examples provided in the following list items:   coloreffects : apply different color filters to the video stream Example:  coloreffects preset=heat  videobalance : change different properties of the video stream such as brightness, contrast, hue or saturation Example:  videobalance saturation=0.0  videoflip : rotate the video stream Example:  videoflip method=vertical-flip  videobox : crop the video stream Example:  videobox fill=black top=20 bottom=20 left=-10 right=-10  gamma : adjust gamma level of the video stream Example:  gamma gamma=5.0  videomedian : add a median filter to the video stream Example:  videomedian filtersize=9 lum-only=false  textoverlay : add an embedded text to the video Example:  textoverlay text=\"Embedded text\" valignment=top halignment=right font-desc=\"Cantarell 25\"  timeoverlay : embed the time the video stream has been playing Example:  timeoverlay valignment=bottom halignment=right font-desc=\"Sans, 20\"  clockoverlay : embed a clock with the local time (in OpenVidu Server) Example:  clockoverlay valignment=bottom halignment=right shaded-background=true font-desc=\"Sans, 20\"  audioecho : add reverb to the audio stream Example:  audioecho delay=50000000 intensity=0.6 feedback=0.4  audioamplify : amplifies an audio stream by a given factor Example:  audioamplify amplification=1.5 clipping-method=wrap-positive  Other audio filters: check them out in  GStreamer site  Many effects of  effectv project  : funny filters for the video stream like  agingtv ,  dicetv ,  optv ,  quarktv ,  radioactv ,  revtv ,  rippletv ,  shagadelictv ,  streaktv ,  vertigotv ,  warptv Example:  radioactv   All available GStreamer plugins can be found in  GStreamer site .   \nfunction changeLangTab(event) {\n  var parent = event.target.parentNode.parentNode;\n  var txt = event.target.textContent || event.target.innerText;\n  var txt = txt.replace(/\\s/g, \"-\").toLowerCase();\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n    // Change appearance of language buttons\n    if (child.classList.contains(\"lang-tabs-header\")) {\n        for (var j = 0; j < child.children.length; j++) {\n            var btn = child.children[j];\n            if (btn.classList.contains(\"lang-tabs-btn\")) {\n                btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9';\n                btn.style.fontWeight = btn === event.target ? 'bold' : 'normal';\n            }\n        }\n    }\n    // Change visibility of language content\n    if (child.classList.contains(\"lang-tabs-content\")) {\n        if (child.id === txt) {\n            child.style.display = \"block\";\n        } else {\n            child.style.display = \"none\";\n        }\n    }\n  }\n}", 
            "title": "GStreamer filters"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/", 
            "text": "openvidu-browser API\n\n\n\n\n\n\nCheck \nTypeDoc documentation", 
            "title": "openvidu-browser API"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/", 
            "text": "openvidu-java-client API\n\n\n\n\n\n\nThis is a Java library wrapping \nOpenVidu Server REST API\n\n\nCheck \nJavaDoc documentation\n\n\n\n\n\n\nCode samples\n\n\nCreate a session\n\n\nOpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nSessionProperties properties = new SessionProperties.Builder().build();\nSession session = openVidu.createSession(properties);\n\n\n\n\nGenerate a token\n\n\nTokenOptions tokenOptions = new TokenOptions.Builder()\n    .role(OpenViduRole.PUBLISHER)\n    .data(\nuser_data\n)\n    .build();\nString token = session.generateToken(tokenOptions);\n\n\n\n\nFetch session status\n\n\n// Fetch all session info from OpenVidu Server\nopenvidu.fetch():\nList\nSession\n activeSessions = openvidu.getActiveSessions();\n\n// Fetch one session info from OpenVidu Server\nsession.fetch();\nList\nConnection\n activeConnections = session.getActiveConnections();\n\n\n\n\nClose a session\n\n\nsession.close();\n\n\n\n\nDisconnect a user\n\n\n// Find the desired Connection object in the list returned by Session.getActiveConnections()\nsession.forceDisconnect(connection);\n\n\n\n\nUnpublish a user's stream\n\n\n// Find the desired Publisher object in the list returned by Connection.getPublishers()\nsession.forceUnpublish(publisher);\n\n\n\n\nManage recordings\n\n\n// Start recording\nString sessionId = session.getSessionId();\nRecordingProperties properties = new RecordingProperties.Builder().build();\nRecording recordingStarted = openVidu.startRecording(sessionId, properties);\n\n// Stop recording\nString recordingId = recordingStarted.getId();\nRecording recordingStopped = openvidu.stopRecording(recordingId);\n\n// Get recording\nRecording recordingRetrieved = openvidu.getRecording(recordingId);\n\n// List recordings\nList\nRecording\n recordingList = openVidu.listRecordings();\n\n// Delete recording\nopenVidu.deleteRecording(recordingId);", 
            "title": "openvidu-java-client API"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#code-samples", 
            "text": "", 
            "title": "Code samples"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#create-a-session", 
            "text": "OpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nSessionProperties properties = new SessionProperties.Builder().build();\nSession session = openVidu.createSession(properties);", 
            "title": "Create a session"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#generate-a-token", 
            "text": "TokenOptions tokenOptions = new TokenOptions.Builder()\n    .role(OpenViduRole.PUBLISHER)\n    .data( user_data )\n    .build();\nString token = session.generateToken(tokenOptions);", 
            "title": "Generate a token"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#fetch-session-status", 
            "text": "// Fetch all session info from OpenVidu Server\nopenvidu.fetch():\nList Session  activeSessions = openvidu.getActiveSessions();\n\n// Fetch one session info from OpenVidu Server\nsession.fetch();\nList Connection  activeConnections = session.getActiveConnections();", 
            "title": "Fetch session status"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#close-a-session", 
            "text": "session.close();", 
            "title": "Close a session"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#disconnect-a-user", 
            "text": "// Find the desired Connection object in the list returned by Session.getActiveConnections()\nsession.forceDisconnect(connection);", 
            "title": "Disconnect a user"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#unpublish-a-users-stream", 
            "text": "// Find the desired Publisher object in the list returned by Connection.getPublishers()\nsession.forceUnpublish(publisher);", 
            "title": "Unpublish a user's stream"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#manage-recordings", 
            "text": "// Start recording\nString sessionId = session.getSessionId();\nRecordingProperties properties = new RecordingProperties.Builder().build();\nRecording recordingStarted = openVidu.startRecording(sessionId, properties);\n\n// Stop recording\nString recordingId = recordingStarted.getId();\nRecording recordingStopped = openvidu.stopRecording(recordingId);\n\n// Get recording\nRecording recordingRetrieved = openvidu.getRecording(recordingId);\n\n// List recordings\nList Recording  recordingList = openVidu.listRecordings();\n\n// Delete recording\nopenVidu.deleteRecording(recordingId);", 
            "title": "Manage recordings"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/", 
            "text": "openvidu-node-client API\n\n\n\n\n\n\nThis is a Node library wrapping \nOpenVidu Server REST API\n\n\nCheck \nTypeDoc documentation\n\n\n\n\n\n\nCode samples\n\n\nCreate a session\n\n\nvar openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nvar properties = {};\nopenVidu.createSession(properties).then(session =\n { ... });\n\n\n\n\nGenerate a token\n\n\nvar tokenOptions = {\n    role: \nPUBLISHER\n,\n    data: \nuser_data\n\n};\nsession.generateToken(tokenOptions).then(token =\n { ... });\n\n\n\n\nFetch session status\n\n\n// Fetch all session info from OpenVidu Server\nopenvidu.fetch()\n  .then(anyChange =\n {\n      var activeSessions = openvidu.activeSessions;\n  }):\n\n// Fetch one session info from OpenVidu Server\nsession.fetch()\n  .then(anyChange =\n {\n      var activeConnections = session.activeSessions;\n  });\n\n\n\n\nClose a session\n\n\nsession.close().then(() =\n console.log('Session closed'));\n\n\n\n\nDisconnect a user\n\n\n// Find the desired Connection object in the array Session.activeConnections\nsession.forceDisconnect(connection);\n\n\n\n\nUnpublish a user's stream\n\n\n// Find the desired Publisher object in the array Connection.publishers\nsession.forceUnpublish(publisher);\n\n\n\n\nManage recordings\n\n\n// Start recording\nvar sessionId = session.getSessionId();\nopenVidu.startRecording(sessionId).then(recordingStarted =\n ... );\n\n// Stop recording\nvar recordingId = recordingStarted.id;\nopenvidu.stopRecording(recordingId).then(recordingStopped =\n ... );\n\n// Get recording\nopenvidu.getRecording(recordingId).then(recordingRetrieved =\n ... );\n\n// List recordings\nopenVidu.listRecordings().then(recordingList =\n ... );\n\n// Delete recording\nopenVidu.deleteRecording(recordingId);", 
            "title": "openvidu-node-client API"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#code-samples", 
            "text": "", 
            "title": "Code samples"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#create-a-session", 
            "text": "var openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nvar properties = {};\nopenVidu.createSession(properties).then(session =  { ... });", 
            "title": "Create a session"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#generate-a-token", 
            "text": "var tokenOptions = {\n    role:  PUBLISHER ,\n    data:  user_data \n};\nsession.generateToken(tokenOptions).then(token =  { ... });", 
            "title": "Generate a token"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#fetch-session-status", 
            "text": "// Fetch all session info from OpenVidu Server\nopenvidu.fetch()\n  .then(anyChange =  {\n      var activeSessions = openvidu.activeSessions;\n  }):\n\n// Fetch one session info from OpenVidu Server\nsession.fetch()\n  .then(anyChange =  {\n      var activeConnections = session.activeSessions;\n  });", 
            "title": "Fetch session status"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#close-a-session", 
            "text": "session.close().then(() =  console.log('Session closed'));", 
            "title": "Close a session"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#disconnect-a-user", 
            "text": "// Find the desired Connection object in the array Session.activeConnections\nsession.forceDisconnect(connection);", 
            "title": "Disconnect a user"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#unpublish-a-users-stream", 
            "text": "// Find the desired Publisher object in the array Connection.publishers\nsession.forceUnpublish(publisher);", 
            "title": "Unpublish a user's stream"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#manage-recordings", 
            "text": "// Start recording\nvar sessionId = session.getSessionId();\nopenVidu.startRecording(sessionId).then(recordingStarted =  ... );\n\n// Stop recording\nvar recordingId = recordingStarted.id;\nopenvidu.stopRecording(recordingId).then(recordingStopped =  ... );\n\n// Get recording\nopenvidu.getRecording(recordingId).then(recordingRetrieved =  ... );\n\n// List recordings\nopenVidu.listRecordings().then(recordingList =  ... );\n\n// Delete recording\nopenVidu.deleteRecording(recordingId);", 
            "title": "Manage recordings"
        }, 
        {
            "location": "/reference-docs/REST-API/", 
            "text": "REST API\n\n\n\n\n\n\nAll REST operations have in common the header referred to authorization. It is implemented via Basic Auth, and it is as simple as applying Base64 encoding to the username (always \"OPENVIDUAPP\") and the password (your \nsecret\n shared with openvidu-server). If authorization header is wrong, every call to any REST API operation will return HTTP status \n401\n.\n\n\nFor example, for secret \"MY_SECRET\", the final valid HTTP header would be\n\n\n\n\nAuthorization: Basic T1BFTlZJRFVBUFA6TVlfU0VDUkVU\n\n\n\n\nList of available operations\n\n\n\n\n\n\nInitialize a session: \nPOST /api/sessions\n\n\nGenerate a token: \nPOST /api/tokens\n\n\nRetrieve active session info: \nGET /api/sessions/\nSESSION_ID\n\n\nRetrieve all active sessions info: \nGET /api/sessions\n\n\nClose a session: \nDELETE /api/sessions/\nSESSION_ID\n\n\nForce the disconnection of a user from a session: \nDELETE /api/sessions/\nSESSION_ID\n/connection/\nCONNECTION_ID\n\n\nForce the unpublishing of a user's stream from a session: \nDELETE /api/sessions/\nSESSION_ID\n/stream/\nSTREAM_ID\n\n\nStart the recording of a session: \nPOST /api/recordings/start\n\n\nStop the recording of a session: \nPOST/api/recordings/stop/\nRECORDING_ID\n\n\nGet recording info: \nGET /api/recordings/\nRECORDING_ID\n\n\nGet all recordings info: \nGET /api/recordings\n\n\nDelete a recording: \nDELETE /api/recordings/\nRECORDING_ID\n\n\nGet OpenVidu active configuration: \nGET /config\n\n\n\n\n\n\nPOST \n/api/sessions\n\n\n\n\n\n\n\n\nNEW SESSIONID\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nPOST\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/sessions\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/json\n\n\n\n\n\n\nBody\n\n\n{\"mediaMode\": \"MEDIA_MODE\", \"recordingMode\": \"RECORDING_MODE\", \"customSessionId\": \"CUSTOM_SESSION_ID\", \"defaultOutputMode\": \"OUTPUT_MODE\", \"defaultRecordingLayout\": \"RECORDING_LAYOUT\", \"defaultCustomLayout\": \"CUSTOM_LAYOUT\"}\n\n\n\n\n\n\nSample return\n\n\n{\"id\": \"zfgmthb8jl9uellk\", \"createdAt\": 1538481996019}\n\n\n\n\n\n\n\n\n\n\nBody parameters\n\n\n\n\n\n\nmediaMode\n \n(optional string)\n\n\nROUTED\n \n(default)\n : Media streams will be routed through OpenVidu Server. This Media Mode is mandatory for session recording\n\n\nNot available yet: \nRELAYED\n\n\n\n\n\n\nrecordingMode\n \n(optional string)\n\n\nALWAYS\n: Automatic recording from the first user publishing until the last participant leaves the session\n\n\nMANUAL\n \n(default)\n : If you want to manage when start and stop the recording\n\n\n\n\n\n\ncustomSessionId\n \n(optional string)\n\n\nYou can fix the \nsessionId\n that will be assigned to the session with this parameter. If you make another request with the exact same \ncustomSessionId\n while previous session already exists, no session will be created and a \n409\n http response will be returned. If this parameter is an empty string or not sent at all, OpenVidu Server will generate a random sessionId for you\n\n\n\n\n\n\ndefaultOutputMode\n \n(optional string)\n\n\nCOMPOSED\n(default)\n : when recording the session, all streams will be composed in the same file in a grid layout\n\n\nINDIVIDUAL\n: when recording the session, every stream is recorded in its own file\n\n\n\n\n\n\ndefaultRecordingLayout\n \n(optional string. Only applies if \ndefaultOutputMode\n is set to \nCOMPOSED\n)\n\n\nBEST_FIT\n(default)\n : A grid layout where all the videos are evenly distributed\n\n\nCUSTOM\n: Use your own custom layout. See \nCustom recording layouts\n section to learn how\n\n\nNot available yet: \nPICTURE_IN_PICTURE\n, \nVERTICAL_PRESENTATION\n, \nHORIZONTAL_PRESENTATION\n\n\n\n\n\n\ndefaultCustomLayout\n \n(optional string. Only applies if \ndefaultRecordingLayout\n is set to \nCUSTOM\n)\n\n\nA relative path indicating the custom recording layout to be used if more than one is available. Default to empty string (if so custom layout expected under path set with \nopenvidu-server configuration\n property \nopenvidu.recording.custom-layout\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\nid\n: session identifier. Store it for performing future operations onto this session\n\n\ncreatedAt\n: time when the session was created in UTC milliseconds\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: session successfully created and sessionId ready to be used\n\n\n400\n: problem with some body parameter\n\n\n409\n: parameter \ncustomSessionId\n corresponds to an existing session. There has been no change at all in the state of OpenVidu Server. You can proceed to use the rejected custom sessionId as usual without a problem\n\n\n\n\n\n\n\n\nPOST \n/api/tokens\n\n\n\n\n\n\n\n\nNEW TOKEN\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nPOST\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/tokens\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/json\n\n\n\n\n\n\nBody\n\n\n{\"session\": \"SESSION_ID\", \"role\": \"ROLE\", \"data\": \"DATA\", \"kurentoOptions\": KURENTO_OPTIONS}\n\n\n\n\n\n\nSample return\n\n\n{\"id\":\"wss://localhost:4443?sessionId=zfgmthb8jl9uellk\ntoken=lnlrtnkwm4v8l7uc\nrole=PUBLISHER\nturnUsername=FYYNRC\nturnCredential=yfxxs3\", \"session\": \"zfgmthb8jl9uellk\", \"role\": \"PUBLISHER\", \"data\": \"User Data\", \"token\":\"wss://localhost:4443?sessionId=zfgmthb8jl9uellk\ntoken=lnlrtnkwm4v8l7uc\nrole=PUBLISHER\nturnUsername=FYYNRC\nturnCredential=yfxxs3\", \"kurentoOptions\": {\"videoMaxSendBandwidth\": 700, \"allowedFilters\": [\"GStreamerFilter\", \"ZBarFilter\"]}}\n\n\n\n\n\n\n\n\n\n\nBody parameters\n\n\n\n\n\n\nsession\n \n(mandatory string)\n: the sessionId for which the token should be associated\n\n\nrole\n \n(optional string. Check \nOpenViduRole\n section of OpenVidu Node Client for a complete description)\n\n\nSUBSCRIBER\n\n\nPUBLISHER\n \n(default)\n\n\nMODERATOR\n\n\n\n\n\n\ndata\n \n(optional string)\n : metadata associated to this token (usually participant's information)\n\n\nkurentoOptions\n \n(optional JSON object)\n : you can set some configuration properties for the participant owning this token regarding Kurento. This is a JSON object with the following optional properties:\n\n\nvideoMaxRecvBandwidth\n: maximum number of Kbps that the client owning the token will be able to receive from Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in \nOpenVidu Server configuration\n (parameter \nopenvidu.streams.video.max-recv-bandwidth\n) for every incoming stream of the user owning the token. \nWARNING\n: the lower value set to this property limits every other bandwidth of the WebRTC pipeline this server-to-client stream belongs to. This includes the user publishing the stream and every other user subscribed to the same stream.\n\n\nvideoMinRecvBandwidth\n: minimum number of Kbps that the client owning the token will try to receive from Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in \nOpenVidu Server configuration\n (parameter \nopenvidu.streams.video.min-recv-bandwidth\n) for every incoming stream of the user owning the token.\n\n\nvideoMaxSendBandwidth\n: maximum number of Kbps that the client owning the token will be able to send to Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in \nOpenVidu Server configuration\n (parameter \nopenvidu.streams.video.max-send-bandwidth\n) for every outgoing stream of the user owning the token. \nWARNING\n: this value limits every other bandwidth of the WebRTC pipeline this client-to-server stream belongs to. This includes every other user subscribed to the stream.\n\n\nvideoMinSendBandwidth\n: minimum number of Kbps that the client owning the token will try to send to Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in \nOpenVidu Server configuration\n (parameter \nopenvidu.streams.video.min-send-bandwidth\n) for every outgoing stream of the user owning the token.\n\n\nallowedFilters\n: array of strings containing the names of the filters the user owning the token will be able to apply (see \nVoice and video filters\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\ntoken\n: token value. Send it to one client to pass it as a parameter in openvidu-browser method \nSession.connect\n\n\nsession\n: same as in the body request\n\n\nrole\n: same as in the body request\n\n\ndata\n: same as in the body request\n\n\nid\n: same value as \ntoken\n\n\nkurentoOptions\n: object with Kurento configuration if provided, same as in the body request\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: token successfully created and ready to be used by one client to connect to the associated session\n\n\n400\n: problem with some body parameter\n\n\n404\n: provided value for \nsession\n parameter was not found in OpenVidu Server. You must first call \nPOST /api/sessions\n to get a session id\n\n\n\n\n\n\n\n\nGET \n/api/sessions/\nSESSION_ID\n\n\n\n\n\n\n\n\nGET SESSION INFO\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nGET\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/sessions/\nSESSION_ID\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/x-www-form-urlencoded\n\n\n\n\n\n\nSample return\n\n\n{\"sessionId\":\"TestSession\",\"createdAt\":1538482606338,\"mediaMode\":\"ROUTED\",\"recordingMode\":\"MANUAL\",\"defaultOutputMode\":\"COMPOSED\",\"defaultRecordingLayout\":\"BEST_FIT\",\"customSessionId\":\"TestSession\",\"connections\":{\"numberOfElements\":2,\"content\":[{\"connectionId\":\"vhdxz7abbfirh2lh\",\"createdAt\":1538482606412,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession\ntoken=2ezkertrimk6nttk\nrole=PUBLISHER\nturnUsername=H0EQLL\nturnCredential=kjh48u\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient1\",\"publishers\":[{\"createdAt\":1538482606976,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"mediaOptions\":{\"hasAudio\":true,\"audioActive\":true,\"hasVideo\":true,\"videoActive\":true,\"typeOfVideo\":\"CAMERA\",\"frameRate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"filter\":{}}}],\"subscribers\":[]},{\"connectionId\":\"maxawd3ysuj1rxvq\",\"createdAt\":1538482607659,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession\ntoken=ovj1b4ysuqmcirti\nrole=PUBLISHER\nturnUsername=INOAHN\nturnCredential=oujrqd\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient2\",\"publishers\":[],\"subscribers\":[{\"createdAt\":1538482607799,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"publisher\":\"vhdxz7abbfirh2lh\"}]}]},\"recording\":false}\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\nsessionId\n: identifier of the session (identical to \nSESSION_ID\n url parameter)\n\n\ncreatedAt\n: time when the session was created in UTC milliseconds\n\n\nmediaMode\n: media mode configured for the session (\nROUTED\n or \nRELAYED\n)\n\n\nrecording\n: whether the session is being recorded or not at this moment\n\n\nrecordingMode\n: recording mode configured for the session (\nALWAYS\n or \nMANUAL\n)\n\n\ndefaultOutputMode\n: the default output mode for the recordings of the session (\nCOMPOSED\n or \nINDIVIDUAL\n)\n\n\ndefaultRecordingLayout\n: the default recording layout configured for the recordings of the session. Only defined if field \ndefaultOutputMode\n is set to \nCOMPOSED\n\n\ndefaultCustomLayout\n: the default custom layout configured for the recordings of the session. Its format is a relative path. Only defined if field \ndefaultRecordingLayout\n is set to \nCUSTOM\n\n\ncustomSessionId\n: custom session identifier. Only defined if the session was initialized passing a \ncustomSessionId\n field (see \nPOST /api/sessions\n)\n\n\nconnections\n: collection of active connections in the session. This object is defined by a \nnumberOfElements\n property counting the total number of active connections and a \ncontent\n array with the actual connections. Each object of this array has this structure:\n\n\nconnectionId\n: identifier of the user's connection\n\n\ncreatedAt\n: time when the connection was established in UTC milliseconds\n\n\nlocation\n: geo location of the participant \nPRO\n\n\nplatform\n: complete description of the platform used by the participant to connect to the session\n\n\nrole\n: role of the connection\n\n\nclientData\n: data defined in OpenVidu Browser when calling \nSession.connect\n (\nmetadata\n parameter)\n\n\nserverData\n: data assigned to the user's token when generating the token in OpenVidu Server\n\n\ntoken\n: user's token\n\n\npublishers\n: array of Publisher objects (streams the user is publishing). Each one is defined by the unique \nstreamId\n property, has a \ncreatedAt\n property indicating the time it was created in UTC milliseconds and has a \nmediaOptions\n object with the current properties of the published stream (\"hasVideo\",\"hasAudio\",\"videoActive\",\"audioActive\",\"frameRate\",\"videoDimensions\",\"typeOfVideo\", \"filter\")\n\n\nsubscribers\n: array of Subscriber objects (streams the user is subscribed to). Each on is defined by the unique \nstreamId\n and a \npublisher\n property with the \nconnectionId\n to identify the connection publishing the stream (must be present inside the \nconnections.content\n array of the session)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: the session information has been successfully retrieved\n\n\n404\n: no session exists for the passed SESSION_ID\n\n\n\n\n\n\n\n\nGET \n/api/sessions\n\n\n\n\n\n\n\n\nGET ALL SESSION INFO\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nGET\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/sessions\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\n\n\n\n\n\n\nSample return\n\n\n{\"numberOfElements\":1,\"content\":[{\"sessionId\":\"TestSession\",\"createdAt\":1538482606338,\"mediaMode\":\"ROUTED\",\"recordingMode\":\"MANUAL\",\"defaultOutputMode\":\"COMPOSED\",\"defaultRecordingLayout\":\"BEST_FIT\",\"customSessionId\":\"TestSession\",\"connections\":{\"numberOfElements\":2,\"content\":[{\"connectionId\":\"vhdxz7abbfirh2lh\",\"createdAt\":1538482606412,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession\ntoken=2ezkertrimk6nttk\nrole=PUBLISHER\nturnUsername=H0EQLL\nturnCredential=kjh48u\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient1\",\"publishers\":[{\"createdAt\":1538482606976,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"mediaOptions\":{\"hasAudio\":true,\"audioActive\":true,\"hasVideo\":true,\"videoActive\":true,\"typeOfVideo\":\"CAMERA\",\"frameRate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"filter\":{}}}],\"subscribers\":[]},{\"connectionId\":\"maxawd3ysuj1rxvq\",\"createdAt\":1538482607659,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession\ntoken=ovj1b4ysuqmcirti\nrole=PUBLISHER\nturnUsername=INOAHN\nturnCredential=oujrqd\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient2\",\"publishers\":[],\"subscribers\":[{\"createdAt\":1538482607799,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"publisher\":\"vhdxz7abbfirh2lh\"}]}]},\"recording\":false}]}\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\nnumberOfElements\n: total number of active sessions\n\n\ncontent\n: array of sessions. Each object has the same structure as defined in the returned JSON of \nGET /api/sessions/\nSESSION_ID\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: all the session information has been successfully retrieved\n\n\n\n\n\n\n\n\nDELETE \n/api/sessions/\nSESSION_ID\n\n\n\n\n\n\n\n\nCLOSE SESSION\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nDELETE\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/sessions/\nSESSION_ID\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/x-www-form-urlencoded\n\n\n\n\n\n\nSample return\n\n\nReturns nothing\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n204\n: the session has been successfully closed. Every participant will have received the proper events in OpenVidu Browser: \nstreamDestroyed\n, \nconnectionDestroyed\n and \nsessionDisconnected\n, all of them with \"reason\" property set to \"sessionClosedByServer\". Depending on the order of eviction of the users, some of them will receive more events than the others (the first one will only receive the events related to himself, last one will receive every possible event)\n\n\n404\n: no session exists for the passed SESSION_ID\n\n\n\n\n\n\n\n\nDELETE \n/api/sessions/\nSESSION_ID\n/connection/\nCONNECTION_ID\n\n\n\n\n\n\n\n\nFORCE DISCONNECTION\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nDELETE\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/sessions/\nSESSION_ID\n/connection/\nCONNECTION_ID\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/x-www-form-urlencoded\n\n\n\n\n\n\nSample return\n\n\nReturns nothing\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n204\n: the user has been successfully evicted from the session. Every participant will have received the proper events in OpenVidu Browser: \nstreamDestroyed\n if the user was publishing, \nconnectionDestroyed\n for the remaining users and \nsessionDisconnected\n for the evicted user. All of them with \"reason\" property set to \"forceDisconnectByServer\"\n\n\n400\n: no session exists for the passed SESSION_ID\n\n\n404\n: no connection exists for the passed CONNECTION_ID\n\n\n\n\n\n\n\n\nDELETE \n/api/sessions/\nSESSION_ID\n/stream/\nSTREAM_ID\n\n\n\n\n\n\n\n\nFORCE UNPUBLISHING\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nDELETE\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/sessions/\nSESSION_ID\n/stream/\nSTREAM_ID\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/x-www-form-urlencoded\n\n\n\n\n\n\nSample return\n\n\nReturns nothing\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n204\n: the stream has been successfully unpublished. Every participant will have received the proper \nstreamDestroyed\n event in OpenVidu Browser with \"reason\" property set to \"forceUnpublishByServer\"\n\n\n400\n: no session exists for the passed SESSION_ID\n\n\n404\n: no stream exists for the passed STREAM_ID\n\n\n\n\n\n\n\n\nPOST \n/api/recordings/start\n\n\n\n\n\n\n\n\nSTART SESSION RECORDING\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nPOST\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/recordings/start\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/json\n\n\n\n\n\n\nBody\n\n\n{\"session\": \"SESSION_ID\", \"name\": \"NAME\", \"outputMode\": \"OUTPUT_MODE\", \"hasAudio\": \"HAS_AUDIO\", \"hasVideo\": \"HAS_VIDEO\", \"resolution\": \"RESOLUTION\", \"recordingLayout\": \"RECORDING_LAYOUT\", \"customLayout\": \"CUSTOM_LAYOUT\"}\n\n\n\n\n\n\nSample return\n\n\n{\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\":true, \"hasVideo\":false,\"createdAt\":1538483606521, \"size\":3205004, \"duration\":12.92, \"url\":null, \"status\": \"started\"}\n\n\n\n\n\n\n\n\n\n\nBody parameters\n\n\n\n\n\n\nsession\n \n(mandatory string)\n: the sessionId belonging to the session you want to start recording\n\n\nname\n \n(optional string)\n : the name you want to give to the video file. You can access this same property in openvidu-browser on recordingEvents. If no name is provided, the video file will be named after \nid\n property of the recording\n\n\noutputMode\n \n(optional string)\n : record all streams in a single file in a grid layout or record each stream in its own separate file. This property will override the \ndefaultOutputMode\n property set on \nPOST /api/sessions\n for this particular recording\n\n\nCOMPOSED\n(default)\n : when recording the session, all streams will be composed in the same file in a grid layout\n\n\nINDIVIDUAL\n: when recording the session, every stream is recorded in its own file\n\n\n\n\n\n\nhasAudio\n \n(optional boolean)\n : whether to record audio or not. Default to true\n\n\nhasVideo\n \n(optional boolean)\n : whether to record video or not. Default to true \n\n\nrecordingLayout\n \n(optional string. Only applies if \noutputMode\n is set to \nCOMPOSED\n and \nhasVideo\n to true)\n : the layout to be used in this recording. This property will override the \ndefaultRecordingLayout\n property set on \nPOST /api/sessions\n for this particular recording.\n\n\nBEST_FIT\n(default)\n : A grid layout where all the videos are evenly distributed\n\n\nCUSTOM\n: Use your own custom layout. See \nCustom recording layouts\n section to learn how\n\n\nNot available yet: \nPICTURE_IN_PICTURE\n, \nVERTICAL_PRESENTATION\n, \nHORIZONTAL_PRESENTATION\n\n\n\n\n\n\ncustomLayout\n \n(optional string. Only applies if \nrecordingLayout\n is set to \nCUSTOM\n)\n : a relative path indicating the custom recording layout to be used if more than one is available. Default to empty string (if so custom layout expected under path set with \nopenvidu-server system property\n \nopenvidu.recording.custom-layout\n) . This property will override the \ndefaultCustomLayout\n property set on \nPOST /api/sessions\n for this particular recording\n\n\nresolution\n \n(optional string. Only applies if \noutputMode\n is set to \nCOMPOSED\n and \nhasVideo\n to true)\n : the resolution of the recorded video file. It is a string indicating the width and height in pixels like this: \n\"1920x1080\"\n. Values for both width and height must be between 100 and 1999\n\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\nid\n: recording identifier. Store it to perform other operations such as stop, get or delete the recording\n\n\nsessionId\n: session associated to the recording (same value as \nsession\n in the body request)\n\n\nname\n: name of the recording. If no \nname\n parameter is passed in the POST operation, will be equal to \nid\n field\n\n\noutputMode\n: output mode of the recording\n\n\nhasAudio\n: true if the recording has an audio track, false otherwise\n\n\nhasVideo\n: true if the recording has a video track, false otherwise\n\n\nrecordingLayout\n: the recording layout that is being used. Only defined if \noutputMode\n is set to \nCOMPOSED\n and \nhasVideo\n to true\n\n\ncustomLayout\n: the custom layout that is being used. Only defined if \nrecordingLayout\n is set to \nCUSTOM\n\n\nresolution\n: resolution of the video file. Only defined if \noutputMode\n is set to \nCOMPOSED\n and \nhasVideo\n to true\n\n\ncreatedAt\n: time when the recording started in UTC milliseconds\n\n\nsize\n: size in bytes of the video file (0 until stop operation is called)\n\n\nduration\n: duration of the video file in seconds (0 until stop operation is called)\n\n\nurl\n: set to \nnull\n\n\nstatus\n: set to \n\"started\"\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: the session has started to be recorded. The moment this response is retrieved, it means that the video file is already created and contains proper data, and that the recording can be stopped with guarantees\n\n\n400\n: problem with some body parameter\n\n\n422\n: \nresolution\n parameter exceeds acceptable values (for both width and height, min 100px and max 1999px) or trying to start a recording with both \nhasAudio\n and \nhasVideo\n to false\n\n\n404\n: no session exists for the passed \nsessionId\n parameter\n\n\n406\n: the session has no connected participants\n\n\n409\n: the session is not configured for using MediaMode \nROUTED\n or it is already being recorded\n\n\n501\n: OpenVidu Server recording module is disabled (\nopenvidu.recording\n property set to \nfalse\n)\n\n\n\n\n\n\n\n\nPOST \n/api/recordings/stop/\nRECORDING_ID\n\n\n\n\n\n\n\n\nSTOP SESSION RECORDING\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nPOST\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/recordings/stop/\nRECORDING_ID\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/x-www-form-urlencoded\n\n\n\n\n\n\nSample return\n\n\n{\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": null, \"status\": \"stopped\"}\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\nid\n: recording identifier\n\n\nsessionId\n: session associated to the recording\n\n\nname\n: name of the recording. If no \nname\n parameter is passed when starting the recording, will be equal to \nid\n field\n\n\noutputMode\n: output mode of the recording\n\n\nhasAudio\n: true if the recording has an audio track, false otherwise\n\n\nhasVideo\n: true if the recording has a video track, false otherwise\n\n\nrecordingLayout\n: the recording layout used in the recording. Only defined if \noutputMode\n is set to \nCOMPOSED\n and \nhasVideo\n to true\n\n\ncustomLayout\n: the custom layout used in the recording. Only defined if \nrecordingLayout\n is set to \nCUSTOM\n\n\nresolution\n: resolution of the video file. Only defined if \noutputMode\n is set to \nCOMPOSED\n and \nhasVideo\n to true\n\n\ncreatedAt\n: time when the recording started in UTC milliseconds\n\n\nsize\n: size in bytes of the video file\n\n\nduration\n: duration of the video file in seconds\n\n\nurl\n: set to \nnull\n or \n\"https://YOUR_OPENVIDUSERVER_IP/recordings/\nRECORDING_ID\n/\nRECORDING_NAME\n.\nEXTENSION\n\"\n depending on whether \nopenvidu-server system property \nopenvidu.recording.public-access\n is false or true\n\n\nstatus\n: set to \n\"stopped\"\n or \n\"available\"\n depending on whether \nopenvidu-server system property \nopenvidu.recording.public-access\n is false or true\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: the session has successfully stopped from being recorded. The video file is ready to be reproduced\n\n\n404\n: no recording exists for the passed RECORDING_ID\n\n\n406\n: recording has \nstarting\n status. Wait until \nstarted\n status before stopping the recording\n\n\n\n\n\n\n\n\nGET \n/api/recordings/\nRECORDING_ID\n\n\n\n\n\n\n\n\nGET RECORDING INFO\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nGET\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/recordings/\nRECORDING_ID\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/x-www-form-urlencoded\n\n\n\n\n\n\nSample return\n\n\n{\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": null, \"status\": \"stopped\"}\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\nid\n: recording identifier\n\n\nsessionId\n: session associated to the recording\n\n\nname\n: name of the recording. If no \nname\n parameter is passed when starting the recording, will be equal to \nid\n field\n\n\noutputMode\n: output mode of the recording\n\n\nhasAudio\n: true if the recording has an audio track, false otherwise\n\n\nhasVideo\n: true if the recording has a video track, false otherwise\n\n\nrecordingLayout\n: the recording layout used in the recording. Only defined if \noutputMode\n is set to \nCOMPOSED\n and \nhasVideo\n to true\n\n\ncustomLayout\n: the custom layout used in the recording. Only defined if \nrecordingLayout\n is set to \nCUSTOM\n\n\nresolution\n: resolution of the video file. Only defined if \noutputMode\n is set to \nCOMPOSED\n and \nhasVideo\n to true\n\n\ncreatedAt\n: time when the recording started in UTC milliseconds\n\n\nsize\n: size in bytes of the video file (0 until stop operation is called)\n\n\nduration\n: duration of the video file in seconds (0 until stop operation is called)\n\n\nurl\n: set to \nnull\n until stop operation is called. Then can be \nnull\n or \n\"https://YOUR_OPENVIDUSERVER_IP/recordings/\nRECORDING_ID\n/\nRECORDING_NAME\n.\nEXTENSION\n\"\n depending on whether \nopenvidu-server system property \nopenvidu.recording.public-access\n is false or true.\n\n\nstatus\n: status of the recording (\n\"starting\"\n, \n\"started\"\n, \n\"stopped\"\n, \n\"available\"\n, \n\"failed\"\n)\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: the recording information has been successfully retrieved\n\n\n404\n: no recording exists for the passed RECORDING_ID\n\n\n\n\n\n\n\n\nGET \n/api/recordings\n\n\n\n\n\n\n\n\nLIST RECORDINGS INFO\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nGET\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/recordings\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\n\n\n\n\n\n\nSample return\n\n\n{\"count\": 2, \"items\": [{\"id\": \"n0kcws1evvn3esmo\", \"sessionId\": \"n0kcws1evvn3esmo\", \"name\": \"n0kcws1evvn3esmo\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": true, \"recordingLayout\": \"BEST_FIT\", \"resolution\": \"1920x1080\", \"createdAt\": 1521202349460, \"size\": 22887561, \"duration\": 132.08, \"url\": \"https://localhost:4443/recordings/n0kcws1evvn3esmo/n0kcws1evvn3esmo.mp4\", \"status\": \"available\"}, {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": \"https://localhost:4443/recordings/fds4e07mdug1ga3h/MyRecording.webm\", \"status\": \"available\"}]}\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\ncount\n: number of total recordings\n\n\nitems\n: array of recording information in JSON format. Each item has the same properties as stated in the return value of method \nGET /api/recordings/\nRECORDING_ID\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: all of the available recording information has been successfully retrieved\n\n\n\n\n\n\n\n\nDELETE \n/api/recordings/\nRECORDING_ID\n\n\n\n\n\n\n\n\nDELETE RECORDING\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nDELETE\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/api/recordings/\nRECORDING_ID\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/x-www-form-urlencoded\n\n\n\n\n\n\nSample return\n\n\nReturns nothing\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n204\n: the video file and all of its metadata has been successfully deleted from the host\n\n\n404\n: no recording exists for the passed RECORDING_ID\n\n\n409\n: the recording has \n\"started\"\n status. Stop it before deletion\n\n\n\n\n\n\n\n\nGET \n/config\n\n\n\n\n\n\n\n\nGET OPENVIDU CONFIGURATION\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nGET\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/config\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\n\n\n\n\n\n\nSample return\n\n\n{\"version\": \"2.7.0\", \"openviduPublicurl\": \"https://localhost:4443/\", \"openviduCdr\": false, \"maxRecvBandwidth\": 1000, \"minRecvBandwidth\": 300, \"maxSendBandwidth\": 1000, \"minSendBandwidth\": 300, \"openviduRecording\": true, \"openviduRecordingVersion\": \"2.8.0\", \"openviduRecordingPath\": \"/opt/openvidu/recordings/\", \"openviduRecordingPublicAccess\": true, \"openviduRecordingNotification\": \"publisher_moderator\", \"openviduRecordingCustomLayout\": \"/opt/openvidu/custom-layout/\"}\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\nversion\n: version of OpenVidu Server\n\n\nRest of properties\n: values given to \nsystem properties\n on OpenVidu Server launch", 
            "title": "REST  API"
        }, 
        {
            "location": "/reference-docs/REST-API/#list-of-available-operations", 
            "text": "Initialize a session:  POST /api/sessions  Generate a token:  POST /api/tokens  Retrieve active session info:  GET /api/sessions/ SESSION_ID  Retrieve all active sessions info:  GET /api/sessions  Close a session:  DELETE /api/sessions/ SESSION_ID  Force the disconnection of a user from a session:  DELETE /api/sessions/ SESSION_ID /connection/ CONNECTION_ID  Force the unpublishing of a user's stream from a session:  DELETE /api/sessions/ SESSION_ID /stream/ STREAM_ID  Start the recording of a session:  POST /api/recordings/start  Stop the recording of a session:  POST/api/recordings/stop/ RECORDING_ID  Get recording info:  GET /api/recordings/ RECORDING_ID  Get all recordings info:  GET /api/recordings  Delete a recording:  DELETE /api/recordings/ RECORDING_ID  Get OpenVidu active configuration:  GET /config", 
            "title": "List of available operations"
        }, 
        {
            "location": "/reference-docs/REST-API/#post-apisessions", 
            "text": "NEW SESSIONID  PARAMETERS      Operation  POST    URL  https:// YOUR_OPENVIDUSERVER_IP /api/sessions    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/json    Body  {\"mediaMode\": \"MEDIA_MODE\", \"recordingMode\": \"RECORDING_MODE\", \"customSessionId\": \"CUSTOM_SESSION_ID\", \"defaultOutputMode\": \"OUTPUT_MODE\", \"defaultRecordingLayout\": \"RECORDING_LAYOUT\", \"defaultCustomLayout\": \"CUSTOM_LAYOUT\"}    Sample return  {\"id\": \"zfgmthb8jl9uellk\", \"createdAt\": 1538481996019}      Body parameters    mediaMode   (optional string)  ROUTED   (default)  : Media streams will be routed through OpenVidu Server. This Media Mode is mandatory for session recording  Not available yet:  RELAYED    recordingMode   (optional string)  ALWAYS : Automatic recording from the first user publishing until the last participant leaves the session  MANUAL   (default)  : If you want to manage when start and stop the recording    customSessionId   (optional string)  You can fix the  sessionId  that will be assigned to the session with this parameter. If you make another request with the exact same  customSessionId  while previous session already exists, no session will be created and a  409  http response will be returned. If this parameter is an empty string or not sent at all, OpenVidu Server will generate a random sessionId for you    defaultOutputMode   (optional string)  COMPOSED (default)  : when recording the session, all streams will be composed in the same file in a grid layout  INDIVIDUAL : when recording the session, every stream is recorded in its own file    defaultRecordingLayout   (optional string. Only applies if  defaultOutputMode  is set to  COMPOSED )  BEST_FIT (default)  : A grid layout where all the videos are evenly distributed  CUSTOM : Use your own custom layout. See  Custom recording layouts  section to learn how  Not available yet:  PICTURE_IN_PICTURE ,  VERTICAL_PRESENTATION ,  HORIZONTAL_PRESENTATION    defaultCustomLayout   (optional string. Only applies if  defaultRecordingLayout  is set to  CUSTOM )  A relative path indicating the custom recording layout to be used if more than one is available. Default to empty string (if so custom layout expected under path set with  openvidu-server configuration  property  openvidu.recording.custom-layout )        Returned JSON   id : session identifier. Store it for performing future operations onto this session  createdAt : time when the session was created in UTC milliseconds      HTTP responses   200 : session successfully created and sessionId ready to be used  400 : problem with some body parameter  409 : parameter  customSessionId  corresponds to an existing session. There has been no change at all in the state of OpenVidu Server. You can proceed to use the rejected custom sessionId as usual without a problem", 
            "title": "POST /api/sessions"
        }, 
        {
            "location": "/reference-docs/REST-API/#post-apitokens", 
            "text": "NEW TOKEN  PARAMETERS      Operation  POST    URL  https:// YOUR_OPENVIDUSERVER_IP /api/tokens    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/json    Body  {\"session\": \"SESSION_ID\", \"role\": \"ROLE\", \"data\": \"DATA\", \"kurentoOptions\": KURENTO_OPTIONS}    Sample return  {\"id\":\"wss://localhost:4443?sessionId=zfgmthb8jl9uellk token=lnlrtnkwm4v8l7uc role=PUBLISHER turnUsername=FYYNRC turnCredential=yfxxs3\", \"session\": \"zfgmthb8jl9uellk\", \"role\": \"PUBLISHER\", \"data\": \"User Data\", \"token\":\"wss://localhost:4443?sessionId=zfgmthb8jl9uellk token=lnlrtnkwm4v8l7uc role=PUBLISHER turnUsername=FYYNRC turnCredential=yfxxs3\", \"kurentoOptions\": {\"videoMaxSendBandwidth\": 700, \"allowedFilters\": [\"GStreamerFilter\", \"ZBarFilter\"]}}      Body parameters    session   (mandatory string) : the sessionId for which the token should be associated  role   (optional string. Check  OpenViduRole  section of OpenVidu Node Client for a complete description)  SUBSCRIBER  PUBLISHER   (default)  MODERATOR    data   (optional string)  : metadata associated to this token (usually participant's information)  kurentoOptions   (optional JSON object)  : you can set some configuration properties for the participant owning this token regarding Kurento. This is a JSON object with the following optional properties:  videoMaxRecvBandwidth : maximum number of Kbps that the client owning the token will be able to receive from Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in  OpenVidu Server configuration  (parameter  openvidu.streams.video.max-recv-bandwidth ) for every incoming stream of the user owning the token.  WARNING : the lower value set to this property limits every other bandwidth of the WebRTC pipeline this server-to-client stream belongs to. This includes the user publishing the stream and every other user subscribed to the same stream.  videoMinRecvBandwidth : minimum number of Kbps that the client owning the token will try to receive from Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in  OpenVidu Server configuration  (parameter  openvidu.streams.video.min-recv-bandwidth ) for every incoming stream of the user owning the token.  videoMaxSendBandwidth : maximum number of Kbps that the client owning the token will be able to send to Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in  OpenVidu Server configuration  (parameter  openvidu.streams.video.max-send-bandwidth ) for every outgoing stream of the user owning the token.  WARNING : this value limits every other bandwidth of the WebRTC pipeline this client-to-server stream belongs to. This includes every other user subscribed to the stream.  videoMinSendBandwidth : minimum number of Kbps that the client owning the token will try to send to Kurento Media Server. 0 means unconstrained. Giving a value to this property will override the global configuration set in  OpenVidu Server configuration  (parameter  openvidu.streams.video.min-send-bandwidth ) for every outgoing stream of the user owning the token.  allowedFilters : array of strings containing the names of the filters the user owning the token will be able to apply (see  Voice and video filters )        Returned JSON   token : token value. Send it to one client to pass it as a parameter in openvidu-browser method  Session.connect  session : same as in the body request  role : same as in the body request  data : same as in the body request  id : same value as  token  kurentoOptions : object with Kurento configuration if provided, same as in the body request      HTTP responses   200 : token successfully created and ready to be used by one client to connect to the associated session  400 : problem with some body parameter  404 : provided value for  session  parameter was not found in OpenVidu Server. You must first call  POST /api/sessions  to get a session id", 
            "title": "POST /api/tokens"
        }, 
        {
            "location": "/reference-docs/REST-API/#get-apisessionssession_id", 
            "text": "GET SESSION INFO  PARAMETERS      Operation  GET    URL  https:// YOUR_OPENVIDUSERVER_IP /api/sessions/ SESSION_ID    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/x-www-form-urlencoded    Sample return  {\"sessionId\":\"TestSession\",\"createdAt\":1538482606338,\"mediaMode\":\"ROUTED\",\"recordingMode\":\"MANUAL\",\"defaultOutputMode\":\"COMPOSED\",\"defaultRecordingLayout\":\"BEST_FIT\",\"customSessionId\":\"TestSession\",\"connections\":{\"numberOfElements\":2,\"content\":[{\"connectionId\":\"vhdxz7abbfirh2lh\",\"createdAt\":1538482606412,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession token=2ezkertrimk6nttk role=PUBLISHER turnUsername=H0EQLL turnCredential=kjh48u\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient1\",\"publishers\":[{\"createdAt\":1538482606976,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"mediaOptions\":{\"hasAudio\":true,\"audioActive\":true,\"hasVideo\":true,\"videoActive\":true,\"typeOfVideo\":\"CAMERA\",\"frameRate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"filter\":{}}}],\"subscribers\":[]},{\"connectionId\":\"maxawd3ysuj1rxvq\",\"createdAt\":1538482607659,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession token=ovj1b4ysuqmcirti role=PUBLISHER turnUsername=INOAHN turnCredential=oujrqd\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient2\",\"publishers\":[],\"subscribers\":[{\"createdAt\":1538482607799,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"publisher\":\"vhdxz7abbfirh2lh\"}]}]},\"recording\":false}      Returned JSON   sessionId : identifier of the session (identical to  SESSION_ID  url parameter)  createdAt : time when the session was created in UTC milliseconds  mediaMode : media mode configured for the session ( ROUTED  or  RELAYED )  recording : whether the session is being recorded or not at this moment  recordingMode : recording mode configured for the session ( ALWAYS  or  MANUAL )  defaultOutputMode : the default output mode for the recordings of the session ( COMPOSED  or  INDIVIDUAL )  defaultRecordingLayout : the default recording layout configured for the recordings of the session. Only defined if field  defaultOutputMode  is set to  COMPOSED  defaultCustomLayout : the default custom layout configured for the recordings of the session. Its format is a relative path. Only defined if field  defaultRecordingLayout  is set to  CUSTOM  customSessionId : custom session identifier. Only defined if the session was initialized passing a  customSessionId  field (see  POST /api/sessions )  connections : collection of active connections in the session. This object is defined by a  numberOfElements  property counting the total number of active connections and a  content  array with the actual connections. Each object of this array has this structure:  connectionId : identifier of the user's connection  createdAt : time when the connection was established in UTC milliseconds  location : geo location of the participant  PRO  platform : complete description of the platform used by the participant to connect to the session  role : role of the connection  clientData : data defined in OpenVidu Browser when calling  Session.connect  ( metadata  parameter)  serverData : data assigned to the user's token when generating the token in OpenVidu Server  token : user's token  publishers : array of Publisher objects (streams the user is publishing). Each one is defined by the unique  streamId  property, has a  createdAt  property indicating the time it was created in UTC milliseconds and has a  mediaOptions  object with the current properties of the published stream (\"hasVideo\",\"hasAudio\",\"videoActive\",\"audioActive\",\"frameRate\",\"videoDimensions\",\"typeOfVideo\", \"filter\")  subscribers : array of Subscriber objects (streams the user is subscribed to). Each on is defined by the unique  streamId  and a  publisher  property with the  connectionId  to identify the connection publishing the stream (must be present inside the  connections.content  array of the session)        HTTP responses   200 : the session information has been successfully retrieved  404 : no session exists for the passed SESSION_ID", 
            "title": "GET /api/sessions/&lt;SESSION_ID&gt;"
        }, 
        {
            "location": "/reference-docs/REST-API/#get-apisessions", 
            "text": "GET ALL SESSION INFO  PARAMETERS      Operation  GET    URL  https:// YOUR_OPENVIDUSERVER_IP /api/sessions    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET )    Sample return  {\"numberOfElements\":1,\"content\":[{\"sessionId\":\"TestSession\",\"createdAt\":1538482606338,\"mediaMode\":\"ROUTED\",\"recordingMode\":\"MANUAL\",\"defaultOutputMode\":\"COMPOSED\",\"defaultRecordingLayout\":\"BEST_FIT\",\"customSessionId\":\"TestSession\",\"connections\":{\"numberOfElements\":2,\"content\":[{\"connectionId\":\"vhdxz7abbfirh2lh\",\"createdAt\":1538482606412,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession token=2ezkertrimk6nttk role=PUBLISHER turnUsername=H0EQLL turnCredential=kjh48u\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient1\",\"publishers\":[{\"createdAt\":1538482606976,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"mediaOptions\":{\"hasAudio\":true,\"audioActive\":true,\"hasVideo\":true,\"videoActive\":true,\"typeOfVideo\":\"CAMERA\",\"frameRate\":30,\"videoDimensions\":\"{\\\"width\\\":640,\\\"height\\\":480}\",\"filter\":{}}}],\"subscribers\":[]},{\"connectionId\":\"maxawd3ysuj1rxvq\",\"createdAt\":1538482607659,\"location\":\"\",\"platform\":\"Chrome 69.0.3497.100 on Linux 64-bit\",\"token\":\"wss://localhost:4443?sessionId=TestSession token=ovj1b4ysuqmcirti role=PUBLISHER turnUsername=INOAHN turnCredential=oujrqd\",\"role\":\"PUBLISHER\",\"serverData\":\"\",\"clientData\":\"TestClient2\",\"publishers\":[],\"subscribers\":[{\"createdAt\":1538482607799,\"streamId\":\"vhdxz7abbfirh2lh_CAMERA_CLVAU\",\"publisher\":\"vhdxz7abbfirh2lh\"}]}]},\"recording\":false}]}      Returned JSON   numberOfElements : total number of active sessions  content : array of sessions. Each object has the same structure as defined in the returned JSON of  GET /api/sessions/ SESSION_ID      HTTP responses   200 : all the session information has been successfully retrieved", 
            "title": "GET /api/sessions"
        }, 
        {
            "location": "/reference-docs/REST-API/#delete-apisessionssession_id", 
            "text": "CLOSE SESSION  PARAMETERS      Operation  DELETE    URL  https:// YOUR_OPENVIDUSERVER_IP /api/sessions/ SESSION_ID    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/x-www-form-urlencoded    Sample return  Returns nothing      HTTP responses   204 : the session has been successfully closed. Every participant will have received the proper events in OpenVidu Browser:  streamDestroyed ,  connectionDestroyed  and  sessionDisconnected , all of them with \"reason\" property set to \"sessionClosedByServer\". Depending on the order of eviction of the users, some of them will receive more events than the others (the first one will only receive the events related to himself, last one will receive every possible event)  404 : no session exists for the passed SESSION_ID", 
            "title": "DELETE /api/sessions/&lt;SESSION_ID&gt;"
        }, 
        {
            "location": "/reference-docs/REST-API/#delete-apisessionssession_idconnectionconnection_id", 
            "text": "FORCE DISCONNECTION  PARAMETERS      Operation  DELETE    URL  https:// YOUR_OPENVIDUSERVER_IP /api/sessions/ SESSION_ID /connection/ CONNECTION_ID    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/x-www-form-urlencoded    Sample return  Returns nothing      HTTP responses   204 : the user has been successfully evicted from the session. Every participant will have received the proper events in OpenVidu Browser:  streamDestroyed  if the user was publishing,  connectionDestroyed  for the remaining users and  sessionDisconnected  for the evicted user. All of them with \"reason\" property set to \"forceDisconnectByServer\"  400 : no session exists for the passed SESSION_ID  404 : no connection exists for the passed CONNECTION_ID", 
            "title": "DELETE /api/sessions/&lt;SESSION_ID&gt;/connection/&lt;CONNECTION_ID&gt;"
        }, 
        {
            "location": "/reference-docs/REST-API/#delete-apisessionssession_idstreamstream_id", 
            "text": "FORCE UNPUBLISHING  PARAMETERS      Operation  DELETE    URL  https:// YOUR_OPENVIDUSERVER_IP /api/sessions/ SESSION_ID /stream/ STREAM_ID    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/x-www-form-urlencoded    Sample return  Returns nothing      HTTP responses   204 : the stream has been successfully unpublished. Every participant will have received the proper  streamDestroyed  event in OpenVidu Browser with \"reason\" property set to \"forceUnpublishByServer\"  400 : no session exists for the passed SESSION_ID  404 : no stream exists for the passed STREAM_ID", 
            "title": "DELETE /api/sessions/&lt;SESSION_ID&gt;/stream/&lt;STREAM_ID&gt;"
        }, 
        {
            "location": "/reference-docs/REST-API/#post-apirecordingsstart", 
            "text": "START SESSION RECORDING  PARAMETERS      Operation  POST    URL  https:// YOUR_OPENVIDUSERVER_IP /api/recordings/start    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/json    Body  {\"session\": \"SESSION_ID\", \"name\": \"NAME\", \"outputMode\": \"OUTPUT_MODE\", \"hasAudio\": \"HAS_AUDIO\", \"hasVideo\": \"HAS_VIDEO\", \"resolution\": \"RESOLUTION\", \"recordingLayout\": \"RECORDING_LAYOUT\", \"customLayout\": \"CUSTOM_LAYOUT\"}    Sample return  {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\":true, \"hasVideo\":false,\"createdAt\":1538483606521, \"size\":3205004, \"duration\":12.92, \"url\":null, \"status\": \"started\"}      Body parameters    session   (mandatory string) : the sessionId belonging to the session you want to start recording  name   (optional string)  : the name you want to give to the video file. You can access this same property in openvidu-browser on recordingEvents. If no name is provided, the video file will be named after  id  property of the recording  outputMode   (optional string)  : record all streams in a single file in a grid layout or record each stream in its own separate file. This property will override the  defaultOutputMode  property set on  POST /api/sessions  for this particular recording  COMPOSED (default)  : when recording the session, all streams will be composed in the same file in a grid layout  INDIVIDUAL : when recording the session, every stream is recorded in its own file    hasAudio   (optional boolean)  : whether to record audio or not. Default to true  hasVideo   (optional boolean)  : whether to record video or not. Default to true   recordingLayout   (optional string. Only applies if  outputMode  is set to  COMPOSED  and  hasVideo  to true)  : the layout to be used in this recording. This property will override the  defaultRecordingLayout  property set on  POST /api/sessions  for this particular recording.  BEST_FIT (default)  : A grid layout where all the videos are evenly distributed  CUSTOM : Use your own custom layout. See  Custom recording layouts  section to learn how  Not available yet:  PICTURE_IN_PICTURE ,  VERTICAL_PRESENTATION ,  HORIZONTAL_PRESENTATION    customLayout   (optional string. Only applies if  recordingLayout  is set to  CUSTOM )  : a relative path indicating the custom recording layout to be used if more than one is available. Default to empty string (if so custom layout expected under path set with  openvidu-server system property   openvidu.recording.custom-layout ) . This property will override the  defaultCustomLayout  property set on  POST /api/sessions  for this particular recording  resolution   (optional string. Only applies if  outputMode  is set to  COMPOSED  and  hasVideo  to true)  : the resolution of the recorded video file. It is a string indicating the width and height in pixels like this:  \"1920x1080\" . Values for both width and height must be between 100 and 1999      Returned JSON   id : recording identifier. Store it to perform other operations such as stop, get or delete the recording  sessionId : session associated to the recording (same value as  session  in the body request)  name : name of the recording. If no  name  parameter is passed in the POST operation, will be equal to  id  field  outputMode : output mode of the recording  hasAudio : true if the recording has an audio track, false otherwise  hasVideo : true if the recording has a video track, false otherwise  recordingLayout : the recording layout that is being used. Only defined if  outputMode  is set to  COMPOSED  and  hasVideo  to true  customLayout : the custom layout that is being used. Only defined if  recordingLayout  is set to  CUSTOM  resolution : resolution of the video file. Only defined if  outputMode  is set to  COMPOSED  and  hasVideo  to true  createdAt : time when the recording started in UTC milliseconds  size : size in bytes of the video file (0 until stop operation is called)  duration : duration of the video file in seconds (0 until stop operation is called)  url : set to  null  status : set to  \"started\"      HTTP responses   200 : the session has started to be recorded. The moment this response is retrieved, it means that the video file is already created and contains proper data, and that the recording can be stopped with guarantees  400 : problem with some body parameter  422 :  resolution  parameter exceeds acceptable values (for both width and height, min 100px and max 1999px) or trying to start a recording with both  hasAudio  and  hasVideo  to false  404 : no session exists for the passed  sessionId  parameter  406 : the session has no connected participants  409 : the session is not configured for using MediaMode  ROUTED  or it is already being recorded  501 : OpenVidu Server recording module is disabled ( openvidu.recording  property set to  false )", 
            "title": "POST /api/recordings/start"
        }, 
        {
            "location": "/reference-docs/REST-API/#post-apirecordingsstoprecording_id", 
            "text": "STOP SESSION RECORDING  PARAMETERS      Operation  POST    URL  https:// YOUR_OPENVIDUSERVER_IP /api/recordings/stop/ RECORDING_ID    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/x-www-form-urlencoded    Sample return  {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": null, \"status\": \"stopped\"}      Returned JSON   id : recording identifier  sessionId : session associated to the recording  name : name of the recording. If no  name  parameter is passed when starting the recording, will be equal to  id  field  outputMode : output mode of the recording  hasAudio : true if the recording has an audio track, false otherwise  hasVideo : true if the recording has a video track, false otherwise  recordingLayout : the recording layout used in the recording. Only defined if  outputMode  is set to  COMPOSED  and  hasVideo  to true  customLayout : the custom layout used in the recording. Only defined if  recordingLayout  is set to  CUSTOM  resolution : resolution of the video file. Only defined if  outputMode  is set to  COMPOSED  and  hasVideo  to true  createdAt : time when the recording started in UTC milliseconds  size : size in bytes of the video file  duration : duration of the video file in seconds  url : set to  null  or  \"https://YOUR_OPENVIDUSERVER_IP/recordings/ RECORDING_ID / RECORDING_NAME . EXTENSION \"  depending on whether  openvidu-server system property  openvidu.recording.public-access  is false or true  status : set to  \"stopped\"  or  \"available\"  depending on whether  openvidu-server system property  openvidu.recording.public-access  is false or true      HTTP responses   200 : the session has successfully stopped from being recorded. The video file is ready to be reproduced  404 : no recording exists for the passed RECORDING_ID  406 : recording has  starting  status. Wait until  started  status before stopping the recording", 
            "title": "POST /api/recordings/stop/&lt;RECORDING_ID&gt;"
        }, 
        {
            "location": "/reference-docs/REST-API/#get-apirecordingsrecording_id", 
            "text": "GET RECORDING INFO  PARAMETERS      Operation  GET    URL  https:// YOUR_OPENVIDUSERVER_IP /api/recordings/ RECORDING_ID    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/x-www-form-urlencoded    Sample return  {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": null, \"status\": \"stopped\"}      Returned JSON   id : recording identifier  sessionId : session associated to the recording  name : name of the recording. If no  name  parameter is passed when starting the recording, will be equal to  id  field  outputMode : output mode of the recording  hasAudio : true if the recording has an audio track, false otherwise  hasVideo : true if the recording has a video track, false otherwise  recordingLayout : the recording layout used in the recording. Only defined if  outputMode  is set to  COMPOSED  and  hasVideo  to true  customLayout : the custom layout used in the recording. Only defined if  recordingLayout  is set to  CUSTOM  resolution : resolution of the video file. Only defined if  outputMode  is set to  COMPOSED  and  hasVideo  to true  createdAt : time when the recording started in UTC milliseconds  size : size in bytes of the video file (0 until stop operation is called)  duration : duration of the video file in seconds (0 until stop operation is called)  url : set to  null  until stop operation is called. Then can be  null  or  \"https://YOUR_OPENVIDUSERVER_IP/recordings/ RECORDING_ID / RECORDING_NAME . EXTENSION \"  depending on whether  openvidu-server system property  openvidu.recording.public-access  is false or true.  status : status of the recording ( \"starting\" ,  \"started\" ,  \"stopped\" ,  \"available\" ,  \"failed\" )      HTTP responses   200 : the recording information has been successfully retrieved  404 : no recording exists for the passed RECORDING_ID", 
            "title": "GET /api/recordings/&lt;RECORDING_ID&gt;"
        }, 
        {
            "location": "/reference-docs/REST-API/#get-apirecordings", 
            "text": "LIST RECORDINGS INFO  PARAMETERS      Operation  GET    URL  https:// YOUR_OPENVIDUSERVER_IP /api/recordings    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET )    Sample return  {\"count\": 2, \"items\": [{\"id\": \"n0kcws1evvn3esmo\", \"sessionId\": \"n0kcws1evvn3esmo\", \"name\": \"n0kcws1evvn3esmo\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": true, \"recordingLayout\": \"BEST_FIT\", \"resolution\": \"1920x1080\", \"createdAt\": 1521202349460, \"size\": 22887561, \"duration\": 132.08, \"url\": \"https://localhost:4443/recordings/n0kcws1evvn3esmo/n0kcws1evvn3esmo.mp4\", \"status\": \"available\"}, {\"id\": \"fds4e07mdug1ga3h\", \"sessionId\": \"fds4e07mdug1ga3h\", \"name\": \"MyRecording\", \"outputMode\": \"COMPOSED\", \"hasAudio\": true, \"hasVideo\": false, \"createdAt\": 1538483606521, \"size\": 3205004, \"duration\": 12.92, \"url\": \"https://localhost:4443/recordings/fds4e07mdug1ga3h/MyRecording.webm\", \"status\": \"available\"}]}      Returned JSON   count : number of total recordings  items : array of recording information in JSON format. Each item has the same properties as stated in the return value of method  GET /api/recordings/ RECORDING_ID      HTTP responses   200 : all of the available recording information has been successfully retrieved", 
            "title": "GET /api/recordings"
        }, 
        {
            "location": "/reference-docs/REST-API/#delete-apirecordingsrecording_id", 
            "text": "DELETE RECORDING  PARAMETERS      Operation  DELETE    URL  https:// YOUR_OPENVIDUSERVER_IP /api/recordings/ RECORDING_ID    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/x-www-form-urlencoded    Sample return  Returns nothing      HTTP responses   204 : the video file and all of its metadata has been successfully deleted from the host  404 : no recording exists for the passed RECORDING_ID  409 : the recording has  \"started\"  status. Stop it before deletion", 
            "title": "DELETE /api/recordings/&lt;RECORDING_ID&gt;"
        }, 
        {
            "location": "/reference-docs/REST-API/#get-config", 
            "text": "GET OPENVIDU CONFIGURATION  PARAMETERS      Operation  GET    URL  https:// YOUR_OPENVIDUSERVER_IP /config    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET )    Sample return  {\"version\": \"2.7.0\", \"openviduPublicurl\": \"https://localhost:4443/\", \"openviduCdr\": false, \"maxRecvBandwidth\": 1000, \"minRecvBandwidth\": 300, \"maxSendBandwidth\": 1000, \"minSendBandwidth\": 300, \"openviduRecording\": true, \"openviduRecordingVersion\": \"2.8.0\", \"openviduRecordingPath\": \"/opt/openvidu/recordings/\", \"openviduRecordingPublicAccess\": true, \"openviduRecordingNotification\": \"publisher_moderator\", \"openviduRecordingCustomLayout\": \"/opt/openvidu/custom-layout/\"}      Returned JSON   version : version of OpenVidu Server  Rest of properties : values given to  system properties  on OpenVidu Server launch", 
            "title": "GET /config"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/", 
            "text": "OpenVidu Server configuration parameters\n\n\n\n\n\n\nList of configuration parameters when launching openvidu-server\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nserver.port\n\n\nPort where OpenVidu Server will listen to client's connections\n\n\n4443\n\n\n\n\n\n\nkms.uris\n\n\nKMS URL's to which OpenVidu Server will try to connect. They are tested in order until a valid one is found\n\n\n[\\\"ws://localhost:8888/kurento\\\"]\n(default value for a KMS running in the same machine as OpenVidu Server)\n\n\n\n\n\n\nopenvidu.secret\n\n\nSecret used to connect to OpenVidu Server. This value is required when using the \nREST API\n or any server client (\nopenvidu-java-client\n, \nopenvidu-node-client\n), as well as when connecting to openvidu-server dashboard\n\n\nMY_SECRET\n\n\n\n\n\n\nopenvidu.publicurl\n\n\nURL to connect clients to OpenVidu Server. This can be the full IP (protocol, host and port) or just a domain name if you have configured it. For example:\n\u2022 \nhttps://my.openvidu.server.com\n\u2022 \nhttps://12.34.56.78:4443/\n\n\nlocal\n(with default value \nlocal\n this parameter will be set to \nlocalhost:PORT\n, being \nPORT\n the param \nserver.port\n)\n\n\n\n\n\n\nopenvidu.cdr\n\n\nWhether to enable Call Detail Record or not (check \nCall Detail Record\n)\n\n\nfalse\n\n\n\n\n\n\nopenvidu.recording\n\n\nWhether to enable recording module or not (check \nRecording\n)\n\n\nfalse\n\n\n\n\n\n\nopenvidu.recording.path\n\n\nSystem path where to store the video files of recorded sessions\n\n\n/opt/openvidu/recordings\n\n\n\n\n\n\nopenvidu.recording.public-access\n\n\nWhether to allow free http access to recorded sessions or not.\nIf \ntrue\n path \nhttps://OPENVIDU_IP:[server.port]/[openvidu.recording.path]\n will be publicly accessible through \nhttps://OPENVIDU_IP:[server.port]/recordings\n path. That means any client can connect to\nhttps://OPENVIDU_IP:[server.port]/recordings/\nRECORDING_ID\n/\nRECORDING_NAME\n.\nEXTENSION\nand access the recorded video file.\nIf \nfalse\n this path will be secured with \nopenvidu.secret\n.\nFor example, for OpenVidu Server launched in \nmy.url.com\n and configured with \nserver.port=5000\n, \nopenvidu.recording=true\n, \nopenvidu.recording-path=/my/path\n and \nopenvidu.recording.public-access=true\n :\nA session with id \nfoo\n that has been recorded may generate a video file locally stored in the host machine under \n/my/path/foo/foo.mp4\n and accesible by any client connecting to \nhttps://my.url.com:5000/recordings/foo/foo.mp4\n\n\nfalse\n\n\n\n\n\n\nopenvidu.recording.notification\n\n\nWhich users should receive the recording events in the client side (\nrecordingStarted\n, \nrecordingStopped\n). Can be \nall\n (every user connected to the session), \npublisher_moderator\n (users with role 'PUBLISHER' or 'MODERATOR'), \nmoderator\n (only users with role 'MODERATOR') or \nnone\n (no user will receive these events)\n\n\npublisher_moderator\n\n\n\n\n\n\nopenvidu.recording.custom-layout\n\n\nSystem path where OpenVidu Server should look for custom recording layouts\n\n\n/opt/openvidu/custom-layout\n\n\n\n\n\n\nopenvidu.recording.autostop-timeout\n\n\nTimeout in seconds for recordings to automatically stop (and the session involved to be closed) when conditions are met: a session recording is started but no user is publishing to it or a session is being recorded and last user disconnects. If a user publishes within the timeout in either case, the automatic stop of the recording is cancelled\n\n\n120\n\n\n\n\n\n\nopenvidu.streams.video.max-recv-bandwidth\n\n\nMaximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained\n\n\n1000\n\n\n\n\n\n\nopenvidu.streams.video.min-recv-bandwidth\n\n\nMinimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained\n\n\n300\n\n\n\n\n\n\nopenvidu.streams.video.max-send-bandwidth\n\n\nMaximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained\n\n\n1000\n\n\n\n\n\n\nopenvidu.streams.video.min-send-bandwidth\n\n\nMinimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained\n\n\n300\n\n\n\n\n\n\nserver.ssl.key-store\n\n\nPath for using custom JKS certificate\n\n\n(selfsigned OpenVidu key-store)\n\n\n\n\n\n\nserver.ssl.key-store-password\n\n\nPassword for the custom JKS\n\n\n(selfsigned OpenVidu password)\n\n\n\n\n\n\nserver.ssl.key-alias\n\n\nAlias for the custom JKS\n\n\n(selfsigned OpenVidu alias)\n\n\n\n\n\n\n\n\nExamples:\n\n\njava -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://my.openvidu.server.ip:3333 -Dopenvidu.cdr=true -Dserver.port=3333 -Dkms.uris=[\\\nws://my.kms.ip:8888/kurento\\\n] -jar openvidu-server.jar\n\n\n\n\ndocker run -d -p 3333:3333 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://my.openvidu.server.ip:3333 -e openvidu.cdr=true -e server.port=3333 -e kms.uris=[\\\nws://my.kms.ip:8888/kurento\\\n] openvidu/openvidu-server:2.6.0\n\n\n\n\n\n\nList of additional configuration parameters when launching \nopenvidu-server-kms\n Docker container\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nSample value\n\n\n\n\n\n\n\n\n\n\nKMS_STUN_IP\n\n\nIP of STUN server used by KMS\n\n\nstun.l.google.com\n (free STUN server from Google)\n\n\n\n\n\n\nKMS_STUN_PORT\n\n\nPORT of STUN server used by KMS\n\n\n19302\n (free STUN server from Google)\n\n\n\n\n\n\nKMS_TURN_URL\n\n\nConfiguration for TURN server used by KMS\n\n\nuser:pass@turn_public_ip:turn_port\n (\nuser\n and \npass\n of the TURN server, \nturn_public_ip\n its publicly accessible url and \nturn_port\n the port the TURN server listens to\n\n\n\n\n\n\n\n\nExample:\n\n\ndocker run -d -p 3333:3333 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://my.openvidu.server.ip:3333 -e openvidu.cdr=true -e server.port=3333 -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e KMS_TURN_URL=myuser:mypass@54.54.54.54:3478 openvidu/openvidu-server-kms:2.8.0", 
            "title": "OpenVidu Server configuration"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#list-of-configuration-parameters-when-launching-openvidu-server", 
            "text": "Parameter  Description  Default value      server.port  Port where OpenVidu Server will listen to client's connections  4443    kms.uris  KMS URL's to which OpenVidu Server will try to connect. They are tested in order until a valid one is found  [\\\"ws://localhost:8888/kurento\\\"] (default value for a KMS running in the same machine as OpenVidu Server)    openvidu.secret  Secret used to connect to OpenVidu Server. This value is required when using the  REST API  or any server client ( openvidu-java-client ,  openvidu-node-client ), as well as when connecting to openvidu-server dashboard  MY_SECRET    openvidu.publicurl  URL to connect clients to OpenVidu Server. This can be the full IP (protocol, host and port) or just a domain name if you have configured it. For example: \u2022  https://my.openvidu.server.com \u2022  https://12.34.56.78:4443/  local (with default value  local  this parameter will be set to  localhost:PORT , being  PORT  the param  server.port )    openvidu.cdr  Whether to enable Call Detail Record or not (check  Call Detail Record )  false    openvidu.recording  Whether to enable recording module or not (check  Recording )  false    openvidu.recording.path  System path where to store the video files of recorded sessions  /opt/openvidu/recordings    openvidu.recording.public-access  Whether to allow free http access to recorded sessions or not. If  true  path  https://OPENVIDU_IP:[server.port]/[openvidu.recording.path]  will be publicly accessible through  https://OPENVIDU_IP:[server.port]/recordings  path. That means any client can connect to https://OPENVIDU_IP:[server.port]/recordings/ RECORDING_ID / RECORDING_NAME . EXTENSION and access the recorded video file. If  false  this path will be secured with  openvidu.secret . For example, for OpenVidu Server launched in  my.url.com  and configured with  server.port=5000 ,  openvidu.recording=true ,  openvidu.recording-path=/my/path  and  openvidu.recording.public-access=true  : A session with id  foo  that has been recorded may generate a video file locally stored in the host machine under  /my/path/foo/foo.mp4  and accesible by any client connecting to  https://my.url.com:5000/recordings/foo/foo.mp4  false    openvidu.recording.notification  Which users should receive the recording events in the client side ( recordingStarted ,  recordingStopped ). Can be  all  (every user connected to the session),  publisher_moderator  (users with role 'PUBLISHER' or 'MODERATOR'),  moderator  (only users with role 'MODERATOR') or  none  (no user will receive these events)  publisher_moderator    openvidu.recording.custom-layout  System path where OpenVidu Server should look for custom recording layouts  /opt/openvidu/custom-layout    openvidu.recording.autostop-timeout  Timeout in seconds for recordings to automatically stop (and the session involved to be closed) when conditions are met: a session recording is started but no user is publishing to it or a session is being recorded and last user disconnects. If a user publishes within the timeout in either case, the automatic stop of the recording is cancelled  120    openvidu.streams.video.max-recv-bandwidth  Maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained  1000    openvidu.streams.video.min-recv-bandwidth  Minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained  300    openvidu.streams.video.max-send-bandwidth  Maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained  1000    openvidu.streams.video.min-send-bandwidth  Minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained  300    server.ssl.key-store  Path for using custom JKS certificate  (selfsigned OpenVidu key-store)    server.ssl.key-store-password  Password for the custom JKS  (selfsigned OpenVidu password)    server.ssl.key-alias  Alias for the custom JKS  (selfsigned OpenVidu alias)     Examples:  java -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://my.openvidu.server.ip:3333 -Dopenvidu.cdr=true -Dserver.port=3333 -Dkms.uris=[\\ ws://my.kms.ip:8888/kurento\\ ] -jar openvidu-server.jar  docker run -d -p 3333:3333 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://my.openvidu.server.ip:3333 -e openvidu.cdr=true -e server.port=3333 -e kms.uris=[\\ ws://my.kms.ip:8888/kurento\\ ] openvidu/openvidu-server:2.6.0", 
            "title": "List of configuration parameters when launching openvidu-server"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#list-of-additional-configuration-parameters-when-launching-openvidu-server-kms-docker-container", 
            "text": "Parameter  Description  Sample value      KMS_STUN_IP  IP of STUN server used by KMS  stun.l.google.com  (free STUN server from Google)    KMS_STUN_PORT  PORT of STUN server used by KMS  19302  (free STUN server from Google)    KMS_TURN_URL  Configuration for TURN server used by KMS  user:pass@turn_public_ip:turn_port  ( user  and  pass  of the TURN server,  turn_public_ip  its publicly accessible url and  turn_port  the port the TURN server listens to     Example:  docker run -d -p 3333:3333 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://my.openvidu.server.ip:3333 -e openvidu.cdr=true -e server.port=3333 -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e KMS_TURN_URL=myuser:mypass@54.54.54.54:3478 openvidu/openvidu-server-kms:2.8.0", 
            "title": "List of additional configuration parameters when launching openvidu-server-kms Docker container"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/", 
            "text": "OpenVidu Server Call Detail Record\n\n\n\n\n\n\nOpenVidu Server offers a CDR logging system, so you can easily keep record of every session, every user connecting to them and every media connection established by each one of the users (sending or receiving). To start OpenVidu Server with CDR enabled, launch it with option \nopenvidu.cdr=true\n. The CDR file will be located under \nlog/\n folder in the same path as your Java executable.\n\n\nThe record is a plain text file containing one standard JSON entry for each line. All JSON entries have the following structure:\n\n\n{\"EVENT_NAME\": {\"sessionId\": \"SESSION_ID\", \"timestamp\": TIMESTAMP, \"PROP_1\": \"VALUE_1\",\"PROP_2\": \"VALUE_2\", ... }}\n\n\nSo every entry is a JSON object identified by a specific event name, and all of them have as properties the \nsessionId\n identifying the video-session for which this event was registered and the \ntimestamp\n. Besides this two common properties, there are custom properties for every specific event with useful information. The complete list of possible JSON entries is available below:\n\n\nList of events in OpenVidu CDR\n\n\n\n\nsessionCreated\n\n\nsessionDestroyed\n\n\nparticipantJoined\n\n\nparticipantLeft\n\n\nwebrtcConnectionCreated\n\n\nwebrtcConnectionDestroyed\n\n\nrecordingStarted\n\n\nrecordingStopped\n\n\n\n\n\n\n\n\nsessionCreated\n\n\nRecorded when a new session has been created.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nsessionCreated\n:{\nsessionId\n:\nfds4e07mdug1ga3h\n,\ntimestamp\n:1538481330577}}\n\n\n\n\n\n\n\nsessionDestroyed\n\n\nRecorded when a session has finished.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nstartTime\n\n\nTime when the session started\n\n\nUTC milliseconds\n\n\n\n\n\n\nduration\n\n\nTotal duration of the session\n\n\nSeconds\n\n\n\n\n\n\nreason\n\n\nWhy the session was destroyed\n\n\n[\n\"lastParticipantLeft\"\n,\n\"sessionClosedByServer\"\n,\n\"openviduServerStopped\"\n]\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nsessionDestroyed\n:{\nsessionId\n:\nfds4e07mdug1ga3h\n,\ntimestamp\n:1538481699154,\nstartTime\n:1538481330577,\nduration\n:368,\nreason\n:\nlastParticipantLeft\n}}\n\n\n\n\n\n\n\nparticipantJoined\n\n\nRecorded when a user has connected to a session.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nparticipantId\n\n\nIdentifier of the participant\n\n\nA string with the participant unique identifier\n\n\n\n\n\n\nlocation\n\n\nGeo location of the participant \nPRO\n\n\nA string with format \n\"CITY, COUNTRY\"\n (or \n\"unknown\"\n)\n\n\n\n\n\n\nplatform\n\n\nComplete description of the platform used by the participant to connect to the session\n\n\nA string with the platform description\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nparticipantJoined\n:{\nsessionId\n:\nfds4e07mdug1ga3h\n,\ntimestamp\n:1538481330760,\nparticipantId\n:\nwsalcr1r72goj8sk\n,\nlocation\n:\nBerlin, Germany\n,\nplatform\n:\nChrome 69.0.3497.81 on OS X 10.13.6 64-bit\n}}\n\n\n\n\n\n\n\nparticipantLeft\n\n\nRecorded when a user has left a session.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nparticipantId\n\n\nIdentifier of the participant\n\n\nA string with the participant unique identifier\n\n\n\n\n\n\nlocation\n\n\nGeo location of the participant \nPRO\n\n\nA string with format \n\"CITY, COUNTRY\"\n (or \n\"unknown\"\n)\n\n\n\n\n\n\nplatform\n\n\nComplete description of the platform used by the participant to connect to the session\n\n\nA string with the platform description\n\n\n\n\n\n\nstartTime\n\n\nTime when the participant joined the session\n\n\nUTC milliseconds\n\n\n\n\n\n\nduration\n\n\nTotal duration of the participant's connection to the session\n\n\nSeconds\n\n\n\n\n\n\nreason\n\n\nHow the participant left the session\n\n\n[\n\"disconnect\"\n,\n\"forceDisconnectByUser\"\n,\n\"forceDisconnectByServer\"\n,\n\"sessionClosedByServer\"\n,\n\"networkDisconnect\"\n,\n\"openviduServerStopped\"\n]\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nparticipantLeft\n:{\nsessionId\n:\nfds4e07mdug1ga3h\n,\ntimestamp\n:1538481597612,\nstartTime\n:1538481532507,\nduration\n:65,\nreason\n:\ndisconnect\n,\nparticipantId\n:\nlgge40niviipjzwg\n,\nlocation\n:\nBerlin, Germany\n,\nplatform\n:\nChrome 69.0.3497.81 on OS X 10.13.6 64-bit\n}}\n\n\n\n\n\n\n\nwebrtcConnectionCreated\n\n\nRecorded when a new media stream has been established. Can be an \"INBOUND\" connection (the user is receiving a stream from a publisher of the session) or an \"OUTBOUND\" connection (the user is a publishing a stream to the session).\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nparticipantId\n\n\nIdentifier of the participant\n\n\nA string with the participant unique identifier\n\n\n\n\n\n\nconnection\n\n\nWhether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu)\n\n\n[\n\"INBOUND\"\n,\n\"OUTBOUND\"\n]\n\n\n\n\n\n\nreceivingFrom\n\n\nIf \nconnection\n is \n\"INBOUND\"\n, the participant from whom the media stream is being received\n\n\nA string with the participant (sender) unique identifier\n\n\n\n\n\n\naudioEnabled\n\n\nWhether the media connection has negotiated audio or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nvideoEnabled\n\n\nWhether the media connection has negotiated video or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nvideoSource\n\n\nIf \nvideoEnabled\n is \ntrue\n, the type of video that is being transmitted\n\n\n[\n\"CAMERA\"\n,\n\"SCREEN\"\n]\n\n\n\n\n\n\nvideoFramerate\n\n\nIf \nvideoEnabled\n is \ntrue\n, the framerate of the transmitted video\n\n\nNumber of fps\n\n\n\n\n\n\nvideoDimensions\n\n\nIf \nvideoEnabled\n is \ntrue\n, the dimensions transmitted video\n\n\nString with the dimensions (e.g. \n\"1920x1080\"\n)\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nwebrtcConnectionCreated\n:{\nsessionId\n:\nfds4e07mdug1ga3h\n,\ntimestamp\n:1538481419726,\nparticipantId\n:\nges2furjsjjmyi0b\n,\nconnection\n:\nINBOUND\n,\nreceivingFrom\n:\nwsalcr1r72goj8sk\n,\nvideoSource\n:\nCAMERA\n,\nvideoFramerate\n:30,\nvideoDimensions\n:\n{\\\nwidth\\\n:640,\\\nheight\\\n:480}\n,\naudioEnabled\n:true,\nvideoEnabled\n:true}}\n\n\n\n\n\n\n\nwebrtcConnectionDestroyed\n\n\nRecorded when any media stream connection is closed.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nparticipantId\n\n\nIdentifier of the participant\n\n\nA string with the participant unique identifier\n\n\n\n\n\n\nconnection\n\n\nWhether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu)\n\n\n[\n\"INBOUND\"\n,\n\"OUTBOUND\"\n]\n\n\n\n\n\n\nreceivingFrom\n\n\nIf \nconnection\n is \n\"INBOUND\"\n, the participant from whom the media stream is being received\n\n\nA string with the participant (sender) unique identifier\n\n\n\n\n\n\naudioEnabled\n\n\nWhether the media connection has negotiated audio or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nvideoEnabled\n\n\nWhether the media connection has negotiated video or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nvideoSource\n\n\nIf \nvideoEnabled\n is \ntrue\n, the type of video that is being transmitted\n\n\n[\n\"CAMERA\"\n,\n\"SCREEN\"\n]\n\n\n\n\n\n\nvideoFramerate\n\n\nIf \nvideoEnabled\n is \ntrue\n, the framerate of the transmitted video\n\n\nNumber of fps\n\n\n\n\n\n\nvideoDimensions\n\n\nIf \nvideoEnabled\n is \ntrue\n, the dimensions transmitted video\n\n\nString with the dimensions (e.g. \n\"1920x1080\"\n)\n\n\n\n\n\n\nstartTime\n\n\nTime when the media connection was established\n\n\nUTC milliseconds\n\n\n\n\n\n\nduration\n\n\nTotal duration of the media connection\n\n\nSeconds\n\n\n\n\n\n\nreason\n\n\nHow the WebRTC connection was destroyed\n\n\n[\n\"unsubscribe\"\n,\n\"unpublish\"\n,\n\"disconnect\"\n,\n\"forceUnpublishByUser\"\n,\n\"forceUnpublishByServer\"\n,\n\"forceDisconnectByUser\"\n,\n\"forceDisconnectByServer\"\n,\n\"sessionClosedByServer\"\n,\n\"networkDisconnect\"\n,\n\"openviduServerStopped\"\n,\n\"mediaServerDisconnect\"\n]\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nwebrtcConnectionDestroyed\n:{\nsessionId\n:\nfds4e07mdug1ga3h\n,\ntimestamp\n:1538481449060,\nstartTime\n:1538481419726,\nduration\n:29,\nreason\n:\ndisconnect\n,\nparticipantId\n:\nges2furjsjjmyi0b\n,\nconnection\n:\nINBOUND\n,\nreceivingFrom\n:\nwsalcr1r72goj8sk\n,\nvideoSource\n:\nCAMERA\n,\nvideoFramerate\n:30,\nvideoDimensions\n:\n{\\\nwidth\\\n:640,\\\nheight\\\n:480}\n,\naudioEnabled\n:true,\nvideoEnabled\n:true}}\n\n\n\n\n\n\n\nrecordingStarted\n\n\nRecorded when a new session has started to be recorded\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nid\n\n\nUnique identifier of the recording\n\n\nA string with the recording unique identifier\n\n\n\n\n\n\nname\n\n\nName given to the recording file\n\n\nA string with the recording name\n\n\n\n\n\n\noutputMode\n\n\nOutput mode of the recording (\nCOMPOSED\n or \nINDIVIDUAL\n)\n\n\nA string with the recording output mode\n\n\n\n\n\n\nhasAudio\n\n\nWheter the recording file has audio or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nhasVideo\n\n\nWheter the recording file has video or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nrecordingLayout\n\n\nThe type of layout used in the recording. Only defined if \noutputMode\n is \nCOMPOSED\n and \nhasVideo\n is true\n\n\nA \nRecordingLayout\n value\n (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...)\n\n\n\n\n\n\nresolution\n\n\nResolution of the recorded file. Only defined if \noutputMode\n is \nCOMPOSED\n and \nhasVideo\n is true\n\n\nA string with the width and height of the video file in pixels. e.g. \n\"1280x720\"\n\n\n\n\n\n\nsize\n\n\nThe size of the video file\n\n\n0\n\n\n\n\n\n\nduration\n\n\nDuration of the video file\n\n\n0\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nrecordingStarted\n:{\nsessionId\n:\nTestSession\n,\ntimestamp\n:1549015630563,\nid\n:\nTestSession\n,\nname\n:\nMyRecording\n,\noutputMode\n:\nCOMPOSED\n,\nhasAudio\n:false,\nhasVideo\n:true,\nrecordingLayout\n:\nBEST_FIT\n,\nresolution\n:\n1920x1080\n,\nsize\n:0,\nduration\n:0.0}}\n\n\n\n\n\n\n\nrecordingStopped\n\n\nRecorded when a new session has stopped being recorded\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nstartTime\n\n\nTime when the stopped recording started\n\n\nUTC milliseconds\n\n\n\n\n\n\nid\n\n\nUnique identifier of the recording\n\n\nA string with the recording unique identifier\n\n\n\n\n\n\nname\n\n\nName given to the recording file\n\n\nA string with the recording name\n\n\n\n\n\n\noutputMode\n\n\nOutput mode of the recording (\nCOMPOSED\n or \nINDIVIDUAL\n)\n\n\nA string with the recording output mode\n\n\n\n\n\n\nhasAudio\n\n\nWheter the recording file has audio or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nhasVideo\n\n\nWheter the recording file has video or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nrecordingLayout\n\n\nThe type of layout used in the recording. Only defined if \noutputMode\n is \nCOMPOSED\n and \nhasVideo\n is true\n\n\nA \nRecordingLayout\n value\n (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...)\n\n\n\n\n\n\nresolution\n\n\nResolution of the recorded file. Only defined if \noutputMode\n is \nCOMPOSED\n and \nhasVideo\n is true\n\n\nA string with the width and height of the video file in pixels. e.g. \n\"1280x720\"\n\n\n\n\n\n\nsize\n\n\nThe size of the video file\n\n\nBytes\n\n\n\n\n\n\nduration\n\n\nDuration of the video file\n\n\nSeconds\n\n\n\n\n\n\nreason\n\n\nWhy the recording stopped\n\n\n[\n\"recordingStoppedByServer\"\n,\n\"lastParticipantLeft\"\n,\n\"sessionClosedByServer\"\n,\n\"automaticStop\"\n,\n\"openviduServerStopped\"\n, \n\"mediaServerDisconnect\"\n]\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nrecordingStopped\n:{\nsessionId\n:\nTestSession\n,\ntimestamp\n:1549015640859,\nstartTime\n:1549015630563,\nid\n:\nTestSession\n,\nname\n:\nMyRecording\n,\noutputMode\n:\nCOMPOSED\n,\nhasAudio\n:false,\nhasVideo\n:true,\nrecordingLayout\n:\nBEST_FIT\n,\nresolution\n:\n1920x1080\n,\nsize\n:617509,\nduration\n:5.967,\nreason\n:\nrecordingStoppedByServer\n}}", 
            "title": "OpenVidu Server CDR"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#list-of-events-in-openvidu-cdr", 
            "text": "sessionCreated  sessionDestroyed  participantJoined  participantLeft  webrtcConnectionCreated  webrtcConnectionDestroyed  recordingStarted  recordingStopped", 
            "title": "List of events in OpenVidu CDR"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#sessioncreated", 
            "text": "Recorded when a new session has been created.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds     Example:  { sessionCreated :{ sessionId : fds4e07mdug1ga3h , timestamp :1538481330577}}", 
            "title": "sessionCreated"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#sessiondestroyed", 
            "text": "Recorded when a session has finished.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    startTime  Time when the session started  UTC milliseconds    duration  Total duration of the session  Seconds    reason  Why the session was destroyed  [ \"lastParticipantLeft\" , \"sessionClosedByServer\" , \"openviduServerStopped\" ]     Example:  { sessionDestroyed :{ sessionId : fds4e07mdug1ga3h , timestamp :1538481699154, startTime :1538481330577, duration :368, reason : lastParticipantLeft }}", 
            "title": "sessionDestroyed"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#participantjoined", 
            "text": "Recorded when a user has connected to a session.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    participantId  Identifier of the participant  A string with the participant unique identifier    location  Geo location of the participant  PRO  A string with format  \"CITY, COUNTRY\"  (or  \"unknown\" )    platform  Complete description of the platform used by the participant to connect to the session  A string with the platform description     Example:  { participantJoined :{ sessionId : fds4e07mdug1ga3h , timestamp :1538481330760, participantId : wsalcr1r72goj8sk , location : Berlin, Germany , platform : Chrome 69.0.3497.81 on OS X 10.13.6 64-bit }}", 
            "title": "participantJoined"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#participantleft", 
            "text": "Recorded when a user has left a session.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    participantId  Identifier of the participant  A string with the participant unique identifier    location  Geo location of the participant  PRO  A string with format  \"CITY, COUNTRY\"  (or  \"unknown\" )    platform  Complete description of the platform used by the participant to connect to the session  A string with the platform description    startTime  Time when the participant joined the session  UTC milliseconds    duration  Total duration of the participant's connection to the session  Seconds    reason  How the participant left the session  [ \"disconnect\" , \"forceDisconnectByUser\" , \"forceDisconnectByServer\" , \"sessionClosedByServer\" , \"networkDisconnect\" , \"openviduServerStopped\" ]     Example:  { participantLeft :{ sessionId : fds4e07mdug1ga3h , timestamp :1538481597612, startTime :1538481532507, duration :65, reason : disconnect , participantId : lgge40niviipjzwg , location : Berlin, Germany , platform : Chrome 69.0.3497.81 on OS X 10.13.6 64-bit }}", 
            "title": "participantLeft"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#webrtcconnectioncreated", 
            "text": "Recorded when a new media stream has been established. Can be an \"INBOUND\" connection (the user is receiving a stream from a publisher of the session) or an \"OUTBOUND\" connection (the user is a publishing a stream to the session).     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    participantId  Identifier of the participant  A string with the participant unique identifier    connection  Whether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu)  [ \"INBOUND\" , \"OUTBOUND\" ]    receivingFrom  If  connection  is  \"INBOUND\" , the participant from whom the media stream is being received  A string with the participant (sender) unique identifier    audioEnabled  Whether the media connection has negotiated audio or not  [ true , false ]    videoEnabled  Whether the media connection has negotiated video or not  [ true , false ]    videoSource  If  videoEnabled  is  true , the type of video that is being transmitted  [ \"CAMERA\" , \"SCREEN\" ]    videoFramerate  If  videoEnabled  is  true , the framerate of the transmitted video  Number of fps    videoDimensions  If  videoEnabled  is  true , the dimensions transmitted video  String with the dimensions (e.g.  \"1920x1080\" )     Example:  { webrtcConnectionCreated :{ sessionId : fds4e07mdug1ga3h , timestamp :1538481419726, participantId : ges2furjsjjmyi0b , connection : INBOUND , receivingFrom : wsalcr1r72goj8sk , videoSource : CAMERA , videoFramerate :30, videoDimensions : {\\ width\\ :640,\\ height\\ :480} , audioEnabled :true, videoEnabled :true}}", 
            "title": "webrtcConnectionCreated"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#webrtcconnectiondestroyed", 
            "text": "Recorded when any media stream connection is closed.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    participantId  Identifier of the participant  A string with the participant unique identifier    connection  Whether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu)  [ \"INBOUND\" , \"OUTBOUND\" ]    receivingFrom  If  connection  is  \"INBOUND\" , the participant from whom the media stream is being received  A string with the participant (sender) unique identifier    audioEnabled  Whether the media connection has negotiated audio or not  [ true , false ]    videoEnabled  Whether the media connection has negotiated video or not  [ true , false ]    videoSource  If  videoEnabled  is  true , the type of video that is being transmitted  [ \"CAMERA\" , \"SCREEN\" ]    videoFramerate  If  videoEnabled  is  true , the framerate of the transmitted video  Number of fps    videoDimensions  If  videoEnabled  is  true , the dimensions transmitted video  String with the dimensions (e.g.  \"1920x1080\" )    startTime  Time when the media connection was established  UTC milliseconds    duration  Total duration of the media connection  Seconds    reason  How the WebRTC connection was destroyed  [ \"unsubscribe\" , \"unpublish\" , \"disconnect\" , \"forceUnpublishByUser\" , \"forceUnpublishByServer\" , \"forceDisconnectByUser\" , \"forceDisconnectByServer\" , \"sessionClosedByServer\" , \"networkDisconnect\" , \"openviduServerStopped\" , \"mediaServerDisconnect\" ]     Example:  { webrtcConnectionDestroyed :{ sessionId : fds4e07mdug1ga3h , timestamp :1538481449060, startTime :1538481419726, duration :29, reason : disconnect , participantId : ges2furjsjjmyi0b , connection : INBOUND , receivingFrom : wsalcr1r72goj8sk , videoSource : CAMERA , videoFramerate :30, videoDimensions : {\\ width\\ :640,\\ height\\ :480} , audioEnabled :true, videoEnabled :true}}", 
            "title": "webrtcConnectionDestroyed"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#recordingstarted", 
            "text": "Recorded when a new session has started to be recorded     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    id  Unique identifier of the recording  A string with the recording unique identifier    name  Name given to the recording file  A string with the recording name    outputMode  Output mode of the recording ( COMPOSED  or  INDIVIDUAL )  A string with the recording output mode    hasAudio  Wheter the recording file has audio or not  [ true , false ]    hasVideo  Wheter the recording file has video or not  [ true , false ]    recordingLayout  The type of layout used in the recording. Only defined if  outputMode  is  COMPOSED  and  hasVideo  is true  A  RecordingLayout  value  (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...)    resolution  Resolution of the recorded file. Only defined if  outputMode  is  COMPOSED  and  hasVideo  is true  A string with the width and height of the video file in pixels. e.g.  \"1280x720\"    size  The size of the video file  0    duration  Duration of the video file  0     Example:  { recordingStarted :{ sessionId : TestSession , timestamp :1549015630563, id : TestSession , name : MyRecording , outputMode : COMPOSED , hasAudio :false, hasVideo :true, recordingLayout : BEST_FIT , resolution : 1920x1080 , size :0, duration :0.0}}", 
            "title": "recordingStarted"
        }, 
        {
            "location": "/reference-docs/openvidu-server-cdr/#recordingstopped", 
            "text": "Recorded when a new session has stopped being recorded     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    startTime  Time when the stopped recording started  UTC milliseconds    id  Unique identifier of the recording  A string with the recording unique identifier    name  Name given to the recording file  A string with the recording name    outputMode  Output mode of the recording ( COMPOSED  or  INDIVIDUAL )  A string with the recording output mode    hasAudio  Wheter the recording file has audio or not  [ true , false ]    hasVideo  Wheter the recording file has video or not  [ true , false ]    recordingLayout  The type of layout used in the recording. Only defined if  outputMode  is  COMPOSED  and  hasVideo  is true  A  RecordingLayout  value  (BEST_FIT, PICTURE_IN_PICTURE, CUSTOM ...)    resolution  Resolution of the recorded file. Only defined if  outputMode  is  COMPOSED  and  hasVideo  is true  A string with the width and height of the video file in pixels. e.g.  \"1280x720\"    size  The size of the video file  Bytes    duration  Duration of the video file  Seconds    reason  Why the recording stopped  [ \"recordingStoppedByServer\" , \"lastParticipantLeft\" , \"sessionClosedByServer\" , \"automaticStop\" , \"openviduServerStopped\" ,  \"mediaServerDisconnect\" ]     Example:  { recordingStopped :{ sessionId : TestSession , timestamp :1549015640859, startTime :1549015630563, id : TestSession , name : MyRecording , outputMode : COMPOSED , hasAudio :false, hasVideo :true, recordingLayout : BEST_FIT , resolution : 1920x1080 , size :617509, duration :5.967, reason : recordingStoppedByServer }}", 
            "title": "recordingStopped"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/", 
            "text": "Deploying OpenVidu Demos on AWS (TUTORIAL)\n\n\n\n\n\n\nDeploying on AWS with Cloud Formation\n\n\nWe have packed all our demos in one single template for AWS CloudFormation. You can follow these steps and see how easy it is to deploy OpenVidu in the cloud.\n\n\n1. Access to the console of AWS Cloud Formation\n\n\nGo to CloudFormation\n\n\n2. Click on \nCreate Stack\n\n\n\n    \n\n  \n\n\n3. Option \nSpecify an Amazon S3 template URL\n with the following URL\n\n\nhttps://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-Demos-latest.json\n\n  \nCopy\n\n\n\n    \n\n  \n\n\n4. Complete the configuration fields\n\n\nWe provide 3 different scenarios: you can use the default \nSELF-SIGNED CERTIFICATE\n stored in the application (users will need to accept the security alert) or if you have a custom domain, either allow \nLET'S ENCRYPT\n to automatically generate a valid and free certificate for your domain or use your own \nCUSTOM CERTIFICATE\n if you already have one.\n\n\n\n  \n\n    \n\n      \n\n      \nSelf-Signed certificate\n\n      \nLet's Encrypt\n certificate\n\n      \nCustom certificate\n\n    \n\n    \n\n      \nStack name\n\n      \nYour choice\n\n      \nYour choice\n\n      \nYour choice\n\n    \n\n    \n\n      \nType of SSL Certificate\n\n      \nselfsigned\n\n      \nletsencrypt\n\n      \nowncert\n\n    \n\n    \n\n      \nEmail\n\n      \n\n      \nYour choice\n\n      \n\n    \n\n    \n\n      \nFully qualified domain name\n\n      \n\n      \nYour custom domain\nFor example: if your full URL is \nhttps://openvidu.io/\n  then this is \nopenvidu.io\n\n      \nYour custom domain\nFor example: if your full URL is \nhttps://openvidu.io/\n  then this is \nopenvidu.io\n\n    \n\n    \n\n      \nElastic IP\n\n      \n\n      \nOne AWS Elastic IP you generated\n(check \nAWS Docs\n to generate a new one)\n\n      \nOne AWS Elastic IP you generated\n(check \nAWS Docs\n to generate a new one)\n\n    \n\n    \n\n      \nCRT File\n\n      \n\n      \n\n      \nContent of your \n.crt\n file\n-----BEGIN CERTIFICATE-----\nfooFOOfooFOOfooFOOfoo...\n-----END CERTIFICATE-----\n\n    \n\n    \n\n      \nKEY File\n\n      \n\n      \n\n      \nContent of your \n.key\n file\n-----BEGIN RSA PRIVATE KEY-----\nfooFOOfooFOOfooFOOfoo...\n-----END RSA PRIVATE KEY-----\n\n    \n\n    \n\n      \nInstance Type\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n    \n\n    \n\n      \nKeyName\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n    \n\n  \n\n\n\n\n\n\n\nIf you are using \nLET'S ENCRYPT CERTIFICATE\n, of course you will need to register your ElasticIP in your DNS hosting service and associate it with the fully qualified domain name.\n\n\n\n\n5. Create your Stack\n\n\nNo extra options are necessary. Click on  \nNext\n \u279e \nNext\n \u279e \nCreate\n\n\nCREATE_IN_PROGRESS\n status will show up. You will now have to wait for a few minutes.\n\n\nDespite saying \nCREATE_COMPLETE\n, it can take up to 7 minutes to fully deploy the Demo Software, so please be patient.\n\n\n6. Access the demos through your new IP\n\n\nGo to \nOutputs\n tab to get your brand new IP and click on it (or if you have deployed the demos with Let's Encrypt under your own custom domain, then you should access through it).", 
            "title": "Deploying OpenVidu Demos on AWS (TUTORIAL)"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#deploying-on-aws-with-cloud-formation", 
            "text": "We have packed all our demos in one single template for AWS CloudFormation. You can follow these steps and see how easy it is to deploy OpenVidu in the cloud.", 
            "title": "Deploying on AWS with Cloud Formation"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#1-access-to-the-console-of-aws-cloud-formation", 
            "text": "Go to CloudFormation", 
            "title": "1. Access to the console of AWS Cloud Formation"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#2-click-on-create-stack", 
            "text": "", 
            "title": "2. Click on Create Stack"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#3-option-specify-an-amazon-s3-template-url-with-the-following-url", 
            "text": "https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-Demos-latest.json \n   Copy", 
            "title": "3. Option Specify an Amazon S3 template URL with the following URL"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#4-complete-the-configuration-fields", 
            "text": "We provide 3 different scenarios: you can use the default  SELF-SIGNED CERTIFICATE  stored in the application (users will need to accept the security alert) or if you have a custom domain, either allow  LET'S ENCRYPT  to automatically generate a valid and free certificate for your domain or use your own  CUSTOM CERTIFICATE  if you already have one.  \n   \n     \n       \n       Self-Signed certificate \n       Let's Encrypt  certificate \n       Custom certificate \n     \n     \n       Stack name \n       Your choice \n       Your choice \n       Your choice \n     \n     \n       Type of SSL Certificate \n       selfsigned \n       letsencrypt \n       owncert \n     \n     \n       Email \n       \n       Your choice \n       \n     \n     \n       Fully qualified domain name \n       \n       Your custom domain For example: if your full URL is  https://openvidu.io/   then this is  openvidu.io \n       Your custom domain For example: if your full URL is  https://openvidu.io/   then this is  openvidu.io \n     \n     \n       Elastic IP \n       \n       One AWS Elastic IP you generated (check  AWS Docs  to generate a new one) \n       One AWS Elastic IP you generated (check  AWS Docs  to generate a new one) \n     \n     \n       CRT File \n       \n       \n       Content of your  .crt  file -----BEGIN CERTIFICATE----- fooFOOfooFOOfooFOOfoo... -----END CERTIFICATE----- \n     \n     \n       KEY File \n       \n       \n       Content of your  .key  file -----BEGIN RSA PRIVATE KEY----- fooFOOfooFOOfooFOOfoo... -----END RSA PRIVATE KEY----- \n     \n     \n       Instance Type \n       Your choice (at least  t2.medium  recommended) \n       Your choice (at least  t2.medium  recommended) \n       Your choice (at least  t2.medium  recommended) \n     \n     \n       KeyName \n       Your choice (check  AWS Docs  to create a new one) \n       Your choice (check  AWS Docs  to create a new one) \n       Your choice (check  AWS Docs  to create a new one) \n     \n      If you are using  LET'S ENCRYPT CERTIFICATE , of course you will need to register your ElasticIP in your DNS hosting service and associate it with the fully qualified domain name.", 
            "title": "4. Complete the configuration fields"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#5-create-your-stack", 
            "text": "No extra options are necessary. Click on   Next  \u279e  Next  \u279e  Create  CREATE_IN_PROGRESS  status will show up. You will now have to wait for a few minutes.  Despite saying  CREATE_COMPLETE , it can take up to 7 minutes to fully deploy the Demo Software, so please be patient.", 
            "title": "5. Create your Stack"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#6-access-the-demos-through-your-new-ip", 
            "text": "Go to  Outputs  tab to get your brand new IP and click on it (or if you have deployed the demos with Let's Encrypt under your own custom domain, then you should access through it).", 
            "title": "6. Access the demos through your new IP"
        }, 
        {
            "location": "/deployment/deploying-aws/", 
            "text": "Deploying OpenVidu on AWS\n\n\n\n\n\n\nDeploying OpenVidu Server on AWS with Cloud Formation\n\n\nThe deployment of OpenVidu can be a piece of cake if you have an AWS account. Just follow these steps:\n\n\n1. Access to the console of AWS Cloud Formation\n\n\nGo to CloudFormation\n\n\n2. Click on \nCreate Stack\n\n\n\n    \n\n  \n\n\n3. Option \nSpecify an Amazon S3 template URL\n with the following URL\n\n\nhttps://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-latest.json\n\n  \nCopy\n\n\n\n    \n\n  \n\n\n4. Complete the configuration fields\n\n\nWe provide 3 different scenarios: you can use the default \nSELF-SIGNED CERTIFICATE\n stored in the application (users will need to accept the security alert) or if you have a custom domain, either allow \nLET'S ENCRYPT\n to automatically generate a valid and free certificate for your domain or use your own \nCUSTOM CERTIFICATE\n if you already have one.\n\n\n\n  \n\n    \n\n      \n\n      \nSelf-Signed certificate\n\n      \nLet's Encrypt\n certificate\n\n      \nCustom certificate\n\n    \n\n    \n\n      \nStack name\n\n      \nYour choice\n\n      \nYour choice\n\n      \nYour choice\n\n    \n\n    \n\n      \nType of SSL Certificate\n\n      \nselfsigned\n\n      \nletsencrypt\n\n      \nowncert\n\n    \n\n    \n\n      \nEmail\n\n      \n\n      \nYour choice\n\n      \n\n    \n\n    \n\n      \nFully qualified domain name\n\n      \n\n      \nYour custom domain\nFor example: if your full URL is \nhttps://openvidu.io/\n  then this is \nopenvidu.io\n\n      \nYour custom domain\nFor example: if your full URL is \nhttps://openvidu.io/\n  then this is \nopenvidu.io\n\n    \n\n    \n\n      \nElastic IP\n\n      \n\n      \nOne AWS Elastic IP you generated\n(check \nAWS Docs\n to generate a new one)\n\n      \nOne AWS Elastic IP you generated\n(check \nAWS Docs\n to generate a new one)\n\n    \n\n    \n\n      \nCRT File\n\n      \n\n      \n\n      \nContent of your \n.crt\n file\n-----BEGIN CERTIFICATE-----\nfooFOOfooFOOfooFOOfoo...\n-----END CERTIFICATE-----\n\n    \n\n    \n\n      \nKEY File\n\n      \n\n      \n\n      \nContent of your \n.key\n file\n-----BEGIN RSA PRIVATE KEY-----\nfooFOOfooFOOfooFOOfoo...\n-----END RSA PRIVATE KEY-----\n\n    \n\n    \n\n      \nOpenVidu Secret\n\n      \nYour choice\n\n      \nYour choice\n\n      \nYour choice\n\n    \n\n    \n\n      \nFree HTTP access to recorded videos\n(see \nopenvidu.recording.public-access\n property \nhere\n)\n\n      \ntrue / false\n\n      \ntrue / false\n\n      \ntrue / false\n\n    \n\n    \n\n      \nInstance Type\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n    \n\n    \n\n      \nKeyName\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n    \n\n  \n\n\n\n\n\n\n\nIf you are using \nLET'S ENCRYPT CERTIFICATE\n, of course you will need to register your ElasticIP in your DNS hosting service and associate it with the fully qualified domain name.\n\n\n\n\n5. Create your Stack\n\n\nNo extra options are necessary. Click on  \nNext\n \u279e \nNext\n \u279e \nCreate\n\n\nCREATE_IN_PROGRESS\n status will show up. You will now have to wait for a few minutes until it shows \nCREATE_COMPLETE\n (between 6-10 minutes).\n\n\n6. Access and test your OpenVidu Server through your new IP\n\n\nAfter status changes to \nCREATE_COMPLETE\n, go to \nOutputs\n tab to get your brand new IP and click on it (or if you have deployed under your own custom domain, then you should access through it).\n\n\n\n    \n\n  \n\n\nYou will connect to your OpenVidu dashboard. To access to it use:\n\n\n\n\nOPENVIDUAPP\n as username\n\n\nThe secret you chose on \nStep 4\n as password (field \nOpenVidu Secret\n in the table). \n\n\n\n\nAt OpenVidu dashboard you can test the video transmission. You can now add your own application to your instance. To learn how check the \nnext section\n.", 
            "title": "Deploying OpenVidu on AWS"
        }, 
        {
            "location": "/deployment/deploying-aws/#deploying-openvidu-server-on-aws-with-cloud-formation", 
            "text": "The deployment of OpenVidu can be a piece of cake if you have an AWS account. Just follow these steps:", 
            "title": "Deploying OpenVidu Server on AWS with Cloud Formation"
        }, 
        {
            "location": "/deployment/deploying-aws/#1-access-to-the-console-of-aws-cloud-formation", 
            "text": "Go to CloudFormation", 
            "title": "1. Access to the console of AWS Cloud Formation"
        }, 
        {
            "location": "/deployment/deploying-aws/#2-click-on-create-stack", 
            "text": "", 
            "title": "2. Click on Create Stack"
        }, 
        {
            "location": "/deployment/deploying-aws/#3-option-specify-an-amazon-s3-template-url-with-the-following-url", 
            "text": "https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-latest.json \n   Copy", 
            "title": "3. Option Specify an Amazon S3 template URL with the following URL"
        }, 
        {
            "location": "/deployment/deploying-aws/#4-complete-the-configuration-fields", 
            "text": "We provide 3 different scenarios: you can use the default  SELF-SIGNED CERTIFICATE  stored in the application (users will need to accept the security alert) or if you have a custom domain, either allow  LET'S ENCRYPT  to automatically generate a valid and free certificate for your domain or use your own  CUSTOM CERTIFICATE  if you already have one.  \n   \n     \n       \n       Self-Signed certificate \n       Let's Encrypt  certificate \n       Custom certificate \n     \n     \n       Stack name \n       Your choice \n       Your choice \n       Your choice \n     \n     \n       Type of SSL Certificate \n       selfsigned \n       letsencrypt \n       owncert \n     \n     \n       Email \n       \n       Your choice \n       \n     \n     \n       Fully qualified domain name \n       \n       Your custom domain For example: if your full URL is  https://openvidu.io/   then this is  openvidu.io \n       Your custom domain For example: if your full URL is  https://openvidu.io/   then this is  openvidu.io \n     \n     \n       Elastic IP \n       \n       One AWS Elastic IP you generated (check  AWS Docs  to generate a new one) \n       One AWS Elastic IP you generated (check  AWS Docs  to generate a new one) \n     \n     \n       CRT File \n       \n       \n       Content of your  .crt  file -----BEGIN CERTIFICATE----- fooFOOfooFOOfooFOOfoo... -----END CERTIFICATE----- \n     \n     \n       KEY File \n       \n       \n       Content of your  .key  file -----BEGIN RSA PRIVATE KEY----- fooFOOfooFOOfooFOOfoo... -----END RSA PRIVATE KEY----- \n     \n     \n       OpenVidu Secret \n       Your choice \n       Your choice \n       Your choice \n     \n     \n       Free HTTP access to recorded videos (see  openvidu.recording.public-access  property  here ) \n       true / false \n       true / false \n       true / false \n     \n     \n       Instance Type \n       Your choice (at least  t2.medium  recommended) \n       Your choice (at least  t2.medium  recommended) \n       Your choice (at least  t2.medium  recommended) \n     \n     \n       KeyName \n       Your choice (check  AWS Docs  to create a new one) \n       Your choice (check  AWS Docs  to create a new one) \n       Your choice (check  AWS Docs  to create a new one) \n     \n      If you are using  LET'S ENCRYPT CERTIFICATE , of course you will need to register your ElasticIP in your DNS hosting service and associate it with the fully qualified domain name.", 
            "title": "4. Complete the configuration fields"
        }, 
        {
            "location": "/deployment/deploying-aws/#5-create-your-stack", 
            "text": "No extra options are necessary. Click on   Next  \u279e  Next  \u279e  Create  CREATE_IN_PROGRESS  status will show up. You will now have to wait for a few minutes until it shows  CREATE_COMPLETE  (between 6-10 minutes).", 
            "title": "5. Create your Stack"
        }, 
        {
            "location": "/deployment/deploying-aws/#6-access-and-test-your-openvidu-server-through-your-new-ip", 
            "text": "After status changes to  CREATE_COMPLETE , go to  Outputs  tab to get your brand new IP and click on it (or if you have deployed under your own custom domain, then you should access through it).  \n     \n    You will connect to your OpenVidu dashboard. To access to it use:   OPENVIDUAPP  as username  The secret you chose on  Step 4  as password (field  OpenVidu Secret  in the table).    At OpenVidu dashboard you can test the video transmission. You can now add your own application to your instance. To learn how check the  next section .", 
            "title": "6. Access and test your OpenVidu Server through your new IP"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/", 
            "text": "Deploying OpenVidu on Ubuntu\n\n\n\n\n\n\nInstallation process\n\n\nUbuntu Xenial 16.04\n and \nUbuntu Bionic 18.04\n are supported (see \nUbuntu Bionic limitations\n).\n\n\n1. Install KMS\n\n\nUbuntu Xenial 16.04\n\n\nsudo echo \ndeb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 xenial kms6\n | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83\nsudo apt-get update\nsudo apt-get -y install kurento-media-server\n\n\n\n\nUbuntu Bionic 18.04\n\n\nsudo echo \ndeb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 bionic kms6\n | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83\nsudo apt-get update\nsudo apt-get -y install kurento-media-server\n\n\n\n\nAfter installing KMS, it is necessary to change the default user running it to the current one with this line:\n\n\nsudo sed -i \ns/DAEMON_USER=\\\nkurento\\\n/DAEMON_USER=\\\n${USER}\\\n/g\n /etc/default/kurento-media-server\n\n\n\n\n2. Install COTURN\n\n\nsudo apt-get -y install coturn\n\n\n\n\n\n\nThis is a great implementation of a STUN/TURN server, necessary for connecting your users under some complicated circumstances. You can check its documentation \nhere\n.\n\n\n\n\n3. Install Redis\n\n\nsudo apt-get -y install redis-server\n\n\n\n\n4. File \n/etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini\n\n\nstunServerAddress=YOUR_MACHINE_PUBLIC_IP\nstunServerPort=3478\n\n\n\n\n5. File \n/etc/turnserver.conf\n\n\nexternal-ip=YOUR_MACHINE_PUBLIC_IP\nlistening-port=3478\nfingerprint\nlt-cred-mech\nmax-port=65535\nmin-port=49152\npidfile=\n/var/run/turnserver.pid\n\nrealm=openvidu\nsimple-log\nredis-userdb=\nip=127.0.0.1 dbname=0 password=turn connect_timeout=30\n\nverbose\n\n\n\n\n6. File \n/etc/default/coturn\n\n\nTURNSERVER_ENABLED=1\n\n\n\n\n7. Init services\n\n\nsudo service redis-server restart\nsudo service coturn restart\nsudo service kurento-media-server restart\n\n\n\n\n8. Init Openvidu Server JAR executable\n\n\njava -jar -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:4443/ openvidu-server-{VERSION}.jar\n\n\n\n\nBeing \nYOUR_SECRET\n the password you want for securing your OpenVidu Server. This will be needed for connecting to OpenVidu Server dashboard and for consuming OpenVidu Server REST API. Keep it safe!\n\n\n\n\n\n\n1)\n You will need Java 8 to run OpenVidu Server:\n\n\nsudo apt-get install -y openjdk-8-jre\n\n\n2)\n You can get any \nversion\n of OpenVidu Server running:\n\n\nwget https://github.com/OpenVidu/openvidu/releases/download/v{VERSION}/openvidu-server-{VERSION}.jar\n\n\n3)\n If you want to enable recording module of OpenVidu Server to record your sessions, you must install \nDocker CE\n and add \nsome more system properties\n to the \njava -jar\n command. Check out \nRecording\n section to learn more\n\n\n\n\n\nGo to \nUsing your own certificate\n to add your certificate to the JAR instead of using the self-signed default one (which will launch a security warning on the user's browser).\n\n\n9. Finally check your server\n\n\nYou can connect to OpenVidu dashboard through \nhttps://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:4443\n (authorization is \nOPENVIDUAPP:YOUR_SECRET\n). Make sure you allow TCP and UDP inbound connections to your machine!\n\n\nTo connect your application to OpenVidu Server, use the same URL \nhttps://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:4443\n. To learn more, check out \nConnecting your app to OpenVidu\n.\n\n\n\n\n\n\nServer network requirements\n\n\nIn order for this deployment to work, you will have to meet 2 sets of needs in the machine hosting your services:\n\n\n\n\n\n\nFirst of all, you certainly need the machine to have a \npublic, reachable IP\n. The reason is pretty simple: we are precisely installing \nCOTURN\n service to cover those situations where the final users are hidden behind NATs or complex networks (\nlearn more\n). If the \nCOTURN\n itself is running inside an unreachable machine, your video transmission will probably fail.\n\n\n\n\n\n\nBesides, the server needs some \nports\n opened in the firewall:\n\n\n\n\n4443 TCP\n (\nOpenVidu Server\n listens on port 4443 by default)\n\n\n3478 TCP\n (\nCOTURN\n listens on port 3478 by default)\n\n\n49152 - 65535 UDP\n (these ports are strongly recommended to be opened, as WebRTC randomly exchanges media through any of them)\n\n\n\n\n\n\n\n\n\n\nIf you were still in trouble, we provide a ready-to-use Amazon CloudFormation Stack to easily deploy OpenVidu in just a few minutes \nhere\n.\n\n\n\n\n\n\n\n\nUsing your own certificate\n\n\nOpenVidu Server is a Java application and therefore needs a Java keystore (\n.jks\n) for providing security certificates. If you don't have it, you can easily obtain a \n.jks\n file from your certificate and private key files (\n.crt\n and \n.key\n respectively, or maybe both of them being \n.pem\n). You do so by using \nopenssl\n and \nkeytool\n :\n\n\n# Export certificate in p12 format (password will be asked)\n# YOUR_CRT.crt and YOUR_KEY.key files may be YOUR_CRT.pem and YOUR_KEY.pem files instead\nopenssl pkcs12 -export -name YOUR_KEYSTORE_ALIAS -in YOUR_CRT.crt -inkey YOUR_PRIVATE_KEY.key -out p12keystore.p12\n\n# Generate jks (password will be asked again)\nkeytool -importkeystore -srckeystore p12keystore.p12 -srcstoretype pkcs12 -deststoretype pkcs12 -alias YOUR_KEYSTORE_ALIAS -destkeystore YOUR_KEYSTORE_NAME.jks\n\n\n\n\n\nIn order to use your JKS, just give the proper value to the following OpenVidu Server properties on launch:\n\n\n\n\nserver.ssl.key-store\n=/PATH/TO/YOUR_KEYSTORE_NAME.jks\n\n\nserver.ssl.key-store-password\n=value_provided_when_generating_jks\n\n\nserver.ssl.key-alias\n=YOUR_KEYSTORE_ALIAS\n\n\n\n\n\n\nExample\n\n\njava -jar -Dopenvidu.secret=MY_SECRET -Dserver.ssl.key-store=/opt/openvidu/my_keystore.jks -Dserver.ssl.key-store-password=MY_KEYSTORE_SECRET -Dserver.ssl.key-alias=my_cert_alias openvidu-server-2.5.0.jar\n\n\n\n\n\n\n\n\nRemember we provide a super simple way of using a \nFREE\n, \nAUTOMATIC\n and 100% \nVALID\n certificate thanks to Let's Encrypt technology: when deploying your CloudFormation Stack, just fill in the form fields with the values from the column \nLET'S ENCRYPT CERTIFICATE\n\n\n\n\n\n\n\n\nUbuntu Bionic limitations\n\n\nOpenVidu supports \nUbuntu Xenial 16.04\n and \nUbuntu Bionic 18.04\n. OpenCV filters will not work in Bionic.\n\n\nRegarding filters explained in \nVoice and video filters\n section, this will affect \nFaceOverlayFilter\n and \nChromaFilter\n. In fact, no built-in module explained in \nKurento Docs\n will work in Ubuntu Bionic (\nPointerDetectorFilter\n, \nCrowdDetectorFilter\n, \nPlateDetectorFIlter\n).\n\n\nZBarFilter\n and \nGStreamer\n filters work fine in Ubuntu Bionic.", 
            "title": "Deploying OpenVidu on Ubuntu"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#installation-process", 
            "text": "Ubuntu Xenial 16.04  and  Ubuntu Bionic 18.04  are supported (see  Ubuntu Bionic limitations ).", 
            "title": "Installation process"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#1-install-kms", 
            "text": "Ubuntu Xenial 16.04  sudo echo  deb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 xenial kms6  | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83\nsudo apt-get update\nsudo apt-get -y install kurento-media-server  Ubuntu Bionic 18.04  sudo echo  deb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 bionic kms6  | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83\nsudo apt-get update\nsudo apt-get -y install kurento-media-server  After installing KMS, it is necessary to change the default user running it to the current one with this line:  sudo sed -i  s/DAEMON_USER=\\ kurento\\ /DAEMON_USER=\\ ${USER}\\ /g  /etc/default/kurento-media-server", 
            "title": "1. Install KMS"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#2-install-coturn", 
            "text": "sudo apt-get -y install coturn   This is a great implementation of a STUN/TURN server, necessary for connecting your users under some complicated circumstances. You can check its documentation  here .", 
            "title": "2. Install COTURN"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#3-install-redis", 
            "text": "sudo apt-get -y install redis-server", 
            "title": "3. Install Redis"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#4-file-etckurentomoduleskurentowebrtcendpointconfini", 
            "text": "stunServerAddress=YOUR_MACHINE_PUBLIC_IP\nstunServerPort=3478", 
            "title": "4. File /etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#5-file-etcturnserverconf", 
            "text": "external-ip=YOUR_MACHINE_PUBLIC_IP\nlistening-port=3478\nfingerprint\nlt-cred-mech\nmax-port=65535\nmin-port=49152\npidfile= /var/run/turnserver.pid \nrealm=openvidu\nsimple-log\nredis-userdb= ip=127.0.0.1 dbname=0 password=turn connect_timeout=30 \nverbose", 
            "title": "5. File /etc/turnserver.conf"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#6-file-etcdefaultcoturn", 
            "text": "TURNSERVER_ENABLED=1", 
            "title": "6. File /etc/default/coturn"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#7-init-services", 
            "text": "sudo service redis-server restart\nsudo service coturn restart\nsudo service kurento-media-server restart", 
            "title": "7. Init services"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#8-init-openvidu-server-jar-executable", 
            "text": "java -jar -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:4443/ openvidu-server-{VERSION}.jar  Being  YOUR_SECRET  the password you want for securing your OpenVidu Server. This will be needed for connecting to OpenVidu Server dashboard and for consuming OpenVidu Server REST API. Keep it safe!    1)  You will need Java 8 to run OpenVidu Server:  sudo apt-get install -y openjdk-8-jre  2)  You can get any  version  of OpenVidu Server running:  wget https://github.com/OpenVidu/openvidu/releases/download/v{VERSION}/openvidu-server-{VERSION}.jar  3)  If you want to enable recording module of OpenVidu Server to record your sessions, you must install  Docker CE  and add  some more system properties  to the  java -jar  command. Check out  Recording  section to learn more   \nGo to  Using your own certificate  to add your certificate to the JAR instead of using the self-signed default one (which will launch a security warning on the user's browser).", 
            "title": "8. Init Openvidu Server JAR executable"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#9-finally-check-your-server", 
            "text": "You can connect to OpenVidu dashboard through  https://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:4443  (authorization is  OPENVIDUAPP:YOUR_SECRET ). Make sure you allow TCP and UDP inbound connections to your machine!  To connect your application to OpenVidu Server, use the same URL  https://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:4443 . To learn more, check out  Connecting your app to OpenVidu .", 
            "title": "9. Finally check your server"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#server-network-requirements", 
            "text": "In order for this deployment to work, you will have to meet 2 sets of needs in the machine hosting your services:    First of all, you certainly need the machine to have a  public, reachable IP . The reason is pretty simple: we are precisely installing  COTURN  service to cover those situations where the final users are hidden behind NATs or complex networks ( learn more ). If the  COTURN  itself is running inside an unreachable machine, your video transmission will probably fail.    Besides, the server needs some  ports  opened in the firewall:   4443 TCP  ( OpenVidu Server  listens on port 4443 by default)  3478 TCP  ( COTURN  listens on port 3478 by default)  49152 - 65535 UDP  (these ports are strongly recommended to be opened, as WebRTC randomly exchanges media through any of them)      If you were still in trouble, we provide a ready-to-use Amazon CloudFormation Stack to easily deploy OpenVidu in just a few minutes  here .", 
            "title": "Server network requirements"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#using-your-own-certificate", 
            "text": "OpenVidu Server is a Java application and therefore needs a Java keystore ( .jks ) for providing security certificates. If you don't have it, you can easily obtain a  .jks  file from your certificate and private key files ( .crt  and  .key  respectively, or maybe both of them being  .pem ). You do so by using  openssl  and  keytool  :  # Export certificate in p12 format (password will be asked)\n# YOUR_CRT.crt and YOUR_KEY.key files may be YOUR_CRT.pem and YOUR_KEY.pem files instead\nopenssl pkcs12 -export -name YOUR_KEYSTORE_ALIAS -in YOUR_CRT.crt -inkey YOUR_PRIVATE_KEY.key -out p12keystore.p12\n\n# Generate jks (password will be asked again)\nkeytool -importkeystore -srckeystore p12keystore.p12 -srcstoretype pkcs12 -deststoretype pkcs12 -alias YOUR_KEYSTORE_ALIAS -destkeystore YOUR_KEYSTORE_NAME.jks  \nIn order to use your JKS, just give the proper value to the following OpenVidu Server properties on launch:   server.ssl.key-store =/PATH/TO/YOUR_KEYSTORE_NAME.jks  server.ssl.key-store-password =value_provided_when_generating_jks  server.ssl.key-alias =YOUR_KEYSTORE_ALIAS", 
            "title": "Using your own certificate"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#example", 
            "text": "java -jar -Dopenvidu.secret=MY_SECRET -Dserver.ssl.key-store=/opt/openvidu/my_keystore.jks -Dserver.ssl.key-store-password=MY_KEYSTORE_SECRET -Dserver.ssl.key-alias=my_cert_alias openvidu-server-2.5.0.jar    Remember we provide a super simple way of using a  FREE ,  AUTOMATIC  and 100%  VALID  certificate thanks to Let's Encrypt technology: when deploying your CloudFormation Stack, just fill in the form fields with the values from the column  LET'S ENCRYPT CERTIFICATE", 
            "title": "Example"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#ubuntu-bionic-limitations", 
            "text": "OpenVidu supports  Ubuntu Xenial 16.04  and  Ubuntu Bionic 18.04 . OpenCV filters will not work in Bionic.  Regarding filters explained in  Voice and video filters  section, this will affect  FaceOverlayFilter  and  ChromaFilter . In fact, no built-in module explained in  Kurento Docs  will work in Ubuntu Bionic ( PointerDetectorFilter ,  CrowdDetectorFilter ,  PlateDetectorFIlter ).  ZBarFilter  and  GStreamer  filters work fine in Ubuntu Bionic.", 
            "title": "Ubuntu Bionic limitations"
        }, 
        {
            "location": "/deployment/deploying-app/", 
            "text": "Deploying your OpenVidu application\n\n\n\n\n\n\nAdding your own app to OpenVidu AWS deployment\n\n\nIn order to show how an application that makes use of OpenVidu might be deployed, here you have a guide to do so in AWS after launching it with \nCloudFormation OpenVidu\n.\n\n\nOnce you have checked that your AWS OpenVidu Server is up and running, adding your own application to the same instance is not hard. Follow these steps:\n\n\n1. Upload your app to your EC2 instance\n\n\nIn Linux/Mac you can use \nscp\n command. In Windows (or If you prefer a more friendly GUI) you can use \nFileZilla\n. Furthermore, if your app is stored in a GitHub repo, you can directly clone it once you connect to your instance.\n\n\nRemember that the key will be the same you indicated when configuring the \nCloudFormation fields\n. \n\n\n2. Connect to your EC2 instance through SSH\n\n\nRemember that the key will be the same you indicated when configuring the \nCloudFormation fields\n. In case of doubt, check \nAWS docs\n.\n\n\n3. Configure your app\n\n\nDepending on the framework of your app:\n\n\n\n\nPlain HTML/CSS/JS\n\n\n\n\n\n\nIf your app doesn't have a server-side and it is plain HTML, CSS and JavaScript, you just have to add your web files into \n/var/www/html/\n. You will have instant access to it through \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/\n\n\n\n\nIf you want to test the deployment of a plain HTML/CSS/JS app, you can use \nopenvidu-insecure-js\n\n\n\n\n\n\n\n\n\n\nJava\n\n\n\n\n\n\nCopy your JAR or WAR into \n/opt/\n\n\n\n\n\n\nWrite a script to launch your app with all the parameters it needs, and store it under \n/opt/\n. For example, a file \n/opt/YOUR_LAUNCHER.sh\n containing:\n\n\ncd /opt\njava -jar -Dserver.port=4040 myapp.jar\n\n\n\n\n\nIMPORTANT 1\n: It is crucial to navigate to \n/opt\n before the launching command. Otherwise, the system will surely have some problems for finding your files\n\n\nIMPORTANT 2\n: Obviously your app will need Java to run. You must install the correct version of Java in your machine (check version: \njava -version\n)\n\n\nIMPORTANT 3\n: Make sure the script you made is executable (\nchmod +x YOUR_LAUNCHER.sh\n)\n\n\n\n\n\n\n\n\nConfigure Nginx: add a new \nlocation\n directive to the file \n/etc/nginx/sites-enabled/default\n, inside the \nserver { }\n group:\n\n\n  location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:PORT;\n  }\n\n\n\nFor example\n\n\n  location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:4040;\n  }\n\n\n\n\n\n\n\nConfigure Supervisor: add the script you wrote in the second step to the file \n/etc/supervisor/conf.d/openvidu.conf\n like this:\n\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true\n\n\n\nNow your \n/etc/supervisor/conf.d/openvidu.conf\n must look like this:\n\n\n  [supervisord]\n  nodaemon=true\n  logfile=/var/log/supervisor/supervisord.log\n  pidfile=/var/run/supervisord.pid\n  loglevel=debug\n\n  [program:openvidu-server]\n  command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true\n\n\n\n\n\nTo connect your Java app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the \nREST API\n or \nopenvidu-java-client\n)\n, you will need to use the URL \nhttps://localhost:4443\n. \nlocalhost\n because in this case both your app and OpenVidu Server run in the same machine. \n4443\n because there's where OpenVidu Server listens for petitions. For example, our tutorial \nopenvidu-js-java\n sets this parameter as an environment variable \nright here\n\n\n\n\n\n\n\n\nRestart Nginx: \nsystemctl restart nginx\n\n\n\n\n\n\nRestart Supervisor: \nsystemctl restart supervisor\n\n\n\n\n\n\nYou will have access to your app through \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/\n\n\n\n\n\n\nTroubleshooting: If your app is not working as expected, there are a few files you should check for debugging: \n/var/log/nginx/\n (info about the proxy), \n/var/log/supervisor/\n (output of your app). You can also try to connect to your app directly through the port like \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT\n\n\n\n\nIf you want to test the deployment of a Java app, you can use \nopenvidu-js-java\n or \nopenvidu-mvc-java\n (\nrelease here\n)\n\n\n\n\n\n\n\n\n\n\nNode\n\n\n\n\n\n\nAdd your web files into \n/opt/\n\n\n\n\n\n\nWrite a script to launch your app with all the parameters it needs, and store it under \n/opt/\n. For example, a file \n/opt/YOUR_LAUNCHER.sh\n containing:\n\n\ncd /opt\nnode myserver.js 4040\n\n\n\n\n\nIMPORTANT 1\n: It is crucial to navigate to \n/opt\n before the launching command. Otherwise, the system will surely have some problems for finding your files\n\n\nIMPORTANT 2\n: Obviously your app will need Node to run. You must install the correct version of Node in your machine (check version: \nnodejs -v\n)\n\n\nIMPORTANT 3\n: Make sure the script you made is executable (\nchmod +x YOUR_LAUNCHER.sh\n)\n\n\n\n\n\n\n\n\nConfigure Nginx: add a new \nlocation\n directive to the file \n/etc/nginx/sites-enabled/default\n, inside the \nserver { }\n group::\n\n\n  location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:PORT;\n  }\n\n\n\nFor example\n\n\n  location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:4040;\n  }\n\n\n\n\n\n\n\nRestart Nginx: \nsystemctl restart nginx\n\n\n\n\n\n\nConfigure Supervisor: add the script you wrote in the second step to \n/etc/supervisor/conf.d/openvidu.conf\n like this:\n\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true\n\n\n\nNow your \n/etc/supervisor/conf.d/openvidu.conf\n must look like this:\n\n\n  [supervisord]\n  nodaemon=true\n  logfile=/var/log/supervisor/supervisord.log\n  pidfile=/var/run/supervisord.pid\n  loglevel=debug\n\n  [program:openvidu-server]\n  command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true\n\n\n\n\n\nTo connect your Node app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the \nREST API\n or \nopenvidu-node-client\n), you will need to use the URL \nhttps://localhost:4443\n. \nlocalhost\n because in this case both your app and OpenVidu Server run in the same machine. \n4443\n because there's where OpenVidu Server listens for petitions. For example, our tutorial \nopenvidu-js-node\n expects this parameter as the first argument on launch command \nright here\n\n\n\n\n\n\n\n\nRestart Supervisor: \nsystemctl restart supervisor\n\n\n\n\n\n\nYou will have access to your app through \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/\n\n\n\n\n\n\nTroubleshooting: If your app is not working as expected, there are a few files you should check for debugging: \n/var/log/nginx/\n (info about the proxy), \n/var/log/supervisor/\n (output of your app). You can also try to connect to your app directly through the port like \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT\n\n\n\n\nIf you want to test the deployment of a Node app, you can use \nopenvidu-js-node\n\n\n\n\n\n\n\n\n\n\nPHP, Ruby, Python, .NET...\n\n\nWe are not going to spell out in detail what is to be done with the rest of backend technologies, but you can get the idea from the Java and Node steps above. It is always the same process: take your app to your instance, place it under \n/opt/\n, configure Nginx and Supervisor (this last with the necessary launching script depending on your technology) and relaunch both services. Be sure that your machine has all the necessary dependencies and technologies to execute your application, depending on the framework (Java for a Java app, Node for a Node app, Ruby for a Ruby app...)\n\n\nVoil\u00e0! It is really this simple.\n\n\nPS: Multiple apps in the same instance\n\n\nTo launch multiple apps in the same instance, just store each one of them inside its own folder under \n/opt/\n. For example:\n\n\n\n\n/opt/YOUR_APP_1\n : will be available at \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_1/\n\n\n/opt/YOUR_APP_2\n : will be available at \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_2/\n\n\n\n\nThe other steps explained above also need some adjustments related to paths:\n\n\n\n\n\n\nConfigure Nginx: now it would be...\n\n\nlocation /YOUR_APP_1 {\n  rewrite /YOUR_APP_1(.*) /$1 break;\n  proxy_pass https://localhost:PORT1;\n}\n\nlocation /YOUR_APP_2 {\n  rewrite /YOUR_APP_2(.*) /$1 break;\n  proxy_pass https://localhost:PORT2;\n}\n\n\n\n\n\n\n\nConfigure Supervisor: now...\n\n\n  [program:YOUR_APP_1]\n  command=/bin/bash /opt/YOUR_APP_1/YOUR_LAUNCHER_1.sh YOUR_APP1_PARAM_1 YOUR_APP1_PARAM_2 ...\n  redirect_stderr=true\n\n  [program:YOUR_APP_2]\n  command=/bin/bash /opt/YOUR_APP_2/YOUR_LAUNCHER_2.sh YOUR_APP2_PARAM_1 YOUR_APP2_PARAM_2 ...\n  redirect_stderr=true\n\n\n\n\n\n\n\n\n\n\n\n\nConnecting your external app to OpenVidu\n\n\nThe best production setup for OpenVidu is having your application deployed in a different dedicated server. That is, not being included in the same host as OpenVidu, which is the scenario explained in the \nprevious section\n (that all-in-one scenario is easier for the first approach to the deployment of your OpenVidu app. Try it if you want detailed instructions on how to deploy your app).\n\n\nOnce you have deployed OpenVidu and checked that it is up and running, and after setting up your own application in its dedicated server:\n\n\n\n\nMake sure you know your \nOpenVidu Server public IP\n. That includes the protocol (\nhttps\n), the location and the port. For example: \nhttps://OPENVIDUSERVER_PUBLIC_IP:4443/\n. Or if you have set up a domain name you can use it instead of the public ip (this is highly recommended for production setups)\n\n\nUse it in your application server to perform the \nREST\n operations, or to initialize your OpenVidu object if you are making use of \nopenvdiu-java-client\n or \nopenvidu-node-client\n :\n\n\nREST\n operations to \nhttps://OPENVIDUSERVER_PUBLIC_IP:4443/api/METHOD\n \n\n\nopenvidu-java-client\n entrypoint is \nnew OpenVidu(https://OPENVIDUSERVER_PUBLIC_IP:4443/, OPENVIDU_SECRET)\n\n\nopenvidu-node-client\n entrypoint is \nnew OpenVidu(https://OPENVIDUSERVER_PUBLIC_IP:4443/, OPENVIDU_SECRET)\n \n\n\n\n\n\n\n\n\n\n\n\n\nIn the one-server-scenario of the \nprevious section\n the OpenVidu Server public IP would be \nhttps://localhost:4443\n, as both OpenVidu Server and your app live in the same host.", 
            "title": "Deploying your OpenVidu app"
        }, 
        {
            "location": "/deployment/deploying-app/#adding-your-own-app-to-openvidu-aws-deployment", 
            "text": "In order to show how an application that makes use of OpenVidu might be deployed, here you have a guide to do so in AWS after launching it with  CloudFormation OpenVidu .  Once you have checked that your AWS OpenVidu Server is up and running, adding your own application to the same instance is not hard. Follow these steps:", 
            "title": "Adding your own app to OpenVidu AWS deployment"
        }, 
        {
            "location": "/deployment/deploying-app/#1-upload-your-app-to-your-ec2-instance", 
            "text": "In Linux/Mac you can use  scp  command. In Windows (or If you prefer a more friendly GUI) you can use  FileZilla . Furthermore, if your app is stored in a GitHub repo, you can directly clone it once you connect to your instance.  Remember that the key will be the same you indicated when configuring the  CloudFormation fields .", 
            "title": "1. Upload your app to your EC2 instance"
        }, 
        {
            "location": "/deployment/deploying-app/#2-connect-to-your-ec2-instance-through-ssh", 
            "text": "Remember that the key will be the same you indicated when configuring the  CloudFormation fields . In case of doubt, check  AWS docs .", 
            "title": "2. Connect to your EC2 instance through SSH"
        }, 
        {
            "location": "/deployment/deploying-app/#3-configure-your-app", 
            "text": "Depending on the framework of your app:", 
            "title": "3. Configure your app"
        }, 
        {
            "location": "/deployment/deploying-app/#plain-htmlcssjs", 
            "text": "If your app doesn't have a server-side and it is plain HTML, CSS and JavaScript, you just have to add your web files into  /var/www/html/ . You will have instant access to it through  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/   If you want to test the deployment of a plain HTML/CSS/JS app, you can use  openvidu-insecure-js", 
            "title": "Plain HTML/CSS/JS"
        }, 
        {
            "location": "/deployment/deploying-app/#java", 
            "text": "Copy your JAR or WAR into  /opt/    Write a script to launch your app with all the parameters it needs, and store it under  /opt/ . For example, a file  /opt/YOUR_LAUNCHER.sh  containing:  cd /opt\njava -jar -Dserver.port=4040 myapp.jar   IMPORTANT 1 : It is crucial to navigate to  /opt  before the launching command. Otherwise, the system will surely have some problems for finding your files  IMPORTANT 2 : Obviously your app will need Java to run. You must install the correct version of Java in your machine (check version:  java -version )  IMPORTANT 3 : Make sure the script you made is executable ( chmod +x YOUR_LAUNCHER.sh )     Configure Nginx: add a new  location  directive to the file  /etc/nginx/sites-enabled/default , inside the  server { }  group:    location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:PORT;\n  }  For example    location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:4040;\n  }    Configure Supervisor: add the script you wrote in the second step to the file  /etc/supervisor/conf.d/openvidu.conf  like this:    [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true  Now your  /etc/supervisor/conf.d/openvidu.conf  must look like this:    [supervisord]\n  nodaemon=true\n  logfile=/var/log/supervisor/supervisord.log\n  pidfile=/var/run/supervisord.pid\n  loglevel=debug\n\n  [program:openvidu-server]\n  command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true   To connect your Java app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the  REST API  or  openvidu-java-client ) , you will need to use the URL  https://localhost:4443 .  localhost  because in this case both your app and OpenVidu Server run in the same machine.  4443  because there's where OpenVidu Server listens for petitions. For example, our tutorial  openvidu-js-java  sets this parameter as an environment variable  right here     Restart Nginx:  systemctl restart nginx    Restart Supervisor:  systemctl restart supervisor    You will have access to your app through  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/    Troubleshooting: If your app is not working as expected, there are a few files you should check for debugging:  /var/log/nginx/  (info about the proxy),  /var/log/supervisor/  (output of your app). You can also try to connect to your app directly through the port like  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT   If you want to test the deployment of a Java app, you can use  openvidu-js-java  or  openvidu-mvc-java  ( release here )", 
            "title": "Java"
        }, 
        {
            "location": "/deployment/deploying-app/#node", 
            "text": "Add your web files into  /opt/    Write a script to launch your app with all the parameters it needs, and store it under  /opt/ . For example, a file  /opt/YOUR_LAUNCHER.sh  containing:  cd /opt\nnode myserver.js 4040   IMPORTANT 1 : It is crucial to navigate to  /opt  before the launching command. Otherwise, the system will surely have some problems for finding your files  IMPORTANT 2 : Obviously your app will need Node to run. You must install the correct version of Node in your machine (check version:  nodejs -v )  IMPORTANT 3 : Make sure the script you made is executable ( chmod +x YOUR_LAUNCHER.sh )     Configure Nginx: add a new  location  directive to the file  /etc/nginx/sites-enabled/default , inside the  server { }  group::    location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:PORT;\n  }  For example    location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:4040;\n  }    Restart Nginx:  systemctl restart nginx    Configure Supervisor: add the script you wrote in the second step to  /etc/supervisor/conf.d/openvidu.conf  like this:    [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true  Now your  /etc/supervisor/conf.d/openvidu.conf  must look like this:    [supervisord]\n  nodaemon=true\n  logfile=/var/log/supervisor/supervisord.log\n  pidfile=/var/run/supervisord.pid\n  loglevel=debug\n\n  [program:openvidu-server]\n  command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true   To connect your Node app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the  REST API  or  openvidu-node-client ), you will need to use the URL  https://localhost:4443 .  localhost  because in this case both your app and OpenVidu Server run in the same machine.  4443  because there's where OpenVidu Server listens for petitions. For example, our tutorial  openvidu-js-node  expects this parameter as the first argument on launch command  right here     Restart Supervisor:  systemctl restart supervisor    You will have access to your app through  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/    Troubleshooting: If your app is not working as expected, there are a few files you should check for debugging:  /var/log/nginx/  (info about the proxy),  /var/log/supervisor/  (output of your app). You can also try to connect to your app directly through the port like  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT   If you want to test the deployment of a Node app, you can use  openvidu-js-node", 
            "title": "Node"
        }, 
        {
            "location": "/deployment/deploying-app/#php-ruby-python-net", 
            "text": "We are not going to spell out in detail what is to be done with the rest of backend technologies, but you can get the idea from the Java and Node steps above. It is always the same process: take your app to your instance, place it under  /opt/ , configure Nginx and Supervisor (this last with the necessary launching script depending on your technology) and relaunch both services. Be sure that your machine has all the necessary dependencies and technologies to execute your application, depending on the framework (Java for a Java app, Node for a Node app, Ruby for a Ruby app...)  Voil\u00e0! It is really this simple.", 
            "title": "PHP, Ruby, Python, .NET..."
        }, 
        {
            "location": "/deployment/deploying-app/#ps-multiple-apps-in-the-same-instance", 
            "text": "To launch multiple apps in the same instance, just store each one of them inside its own folder under  /opt/ . For example:   /opt/YOUR_APP_1  : will be available at  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_1/  /opt/YOUR_APP_2  : will be available at  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_2/   The other steps explained above also need some adjustments related to paths:    Configure Nginx: now it would be...  location /YOUR_APP_1 {\n  rewrite /YOUR_APP_1(.*) /$1 break;\n  proxy_pass https://localhost:PORT1;\n}\n\nlocation /YOUR_APP_2 {\n  rewrite /YOUR_APP_2(.*) /$1 break;\n  proxy_pass https://localhost:PORT2;\n}    Configure Supervisor: now...    [program:YOUR_APP_1]\n  command=/bin/bash /opt/YOUR_APP_1/YOUR_LAUNCHER_1.sh YOUR_APP1_PARAM_1 YOUR_APP1_PARAM_2 ...\n  redirect_stderr=true\n\n  [program:YOUR_APP_2]\n  command=/bin/bash /opt/YOUR_APP_2/YOUR_LAUNCHER_2.sh YOUR_APP2_PARAM_1 YOUR_APP2_PARAM_2 ...\n  redirect_stderr=true", 
            "title": "PS: Multiple apps in the same instance"
        }, 
        {
            "location": "/deployment/deploying-app/#connecting-your-external-app-to-openvidu", 
            "text": "The best production setup for OpenVidu is having your application deployed in a different dedicated server. That is, not being included in the same host as OpenVidu, which is the scenario explained in the  previous section  (that all-in-one scenario is easier for the first approach to the deployment of your OpenVidu app. Try it if you want detailed instructions on how to deploy your app).  Once you have deployed OpenVidu and checked that it is up and running, and after setting up your own application in its dedicated server:   Make sure you know your  OpenVidu Server public IP . That includes the protocol ( https ), the location and the port. For example:  https://OPENVIDUSERVER_PUBLIC_IP:4443/ . Or if you have set up a domain name you can use it instead of the public ip (this is highly recommended for production setups)  Use it in your application server to perform the  REST  operations, or to initialize your OpenVidu object if you are making use of  openvdiu-java-client  or  openvidu-node-client  :  REST  operations to  https://OPENVIDUSERVER_PUBLIC_IP:4443/api/METHOD    openvidu-java-client  entrypoint is  new OpenVidu(https://OPENVIDUSERVER_PUBLIC_IP:4443/, OPENVIDU_SECRET)  openvidu-node-client  entrypoint is  new OpenVidu(https://OPENVIDUSERVER_PUBLIC_IP:4443/, OPENVIDU_SECRET)         In the one-server-scenario of the  previous section  the OpenVidu Server public IP would be  https://localhost:4443 , as both OpenVidu Server and your app live in the same host.", 
            "title": "Connecting your external app to OpenVidu"
        }, 
        {
            "location": "/deployment/upgrading/", 
            "text": "Upgrading OpenVidu\n\n\n\n\n\n\n\n    \n\n\n\n    \n\n        \nThese instructions are only compatible for \nOpenVidu >= 2.6.0\n\n        \nUpgrading or downgrading OpenVidu by following these steps may cause your application to fail if there are any \nAPI breaking changes\n between the old and new versions of OpenVidu. Carefully read the \nrelease notes\n of the related versions before upgrading OpenVidu, be sure to try your application with the new OpenVidu version in your development environment before upgrading and always do so at your own risk\n\n    \n\n\n\n\n\n\n\nFor AWS deployments\n\n\nWe provide an automated script to easily update the OpenVidu version of your AWS deployment.\n\n\n1) Connect through \nssh\n to your AWS instance\n\n\nssh -i /path/to/your/private/key/file.pem ubuntu@12.34.56.78\n\n\n\n\n2) Download the script from GitHub\n\n\nwget https://raw.githubusercontent.com/OpenVidu/adm-scripts/master/scripts/openvidu_update_stack.sh\nsudo chmod 777 openvidu_update_stack.sh\n\n\n\n\n3) Run the script, indicating the OpenVidu version you want to upgrade to\n\n\nBetter do this as the \nroot\n user. \nWARNING\n: running the script will stop OpenVidu Server. After upgrading all the services, it will be automatically restarted.\n\n\nsudo -s\nexport OV_NEW_VERSION=2.8.0\n./openvidu_update_stack.sh\n\n\n\n\n\n\n\n\nFor Ubuntu deployments\n\n\nYou must perform the following general steps, that may vary depending on how you have configured your services:\n\n\n1) Stop OpenVidu Server and Kurento Media Server services\n\n\nFirst one is a Java process that may be killed with a simple \nkill -9 PID_NUMBER\n command, and second one is usually stopped with \nsudo service kurento-media-server stop\n\n\n2) Upgrade kurento-media-server package and replace openvidu-server JAR file for the new version\n\n\nIt is mandatory to comply version compatibility between OpenVidu and Kurento Media Server. Check it out in \nReleases\n page.\nYou should be able to reinstall a new version of KMS while maintaining all the configuration files with these commands:\n\n\n# Change version number in url http://ubuntu.openvidu.io/6.9.0 to the proper one depending on OpenVidu version\nsudo echo \ndeb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 xenial kms6\n | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-get update\nsudo apt-get remove --auto-remove --yes kurento-media-server\nsudo apt-get install --yes -o Dpkg::Options::=\n--force-confold\n kurento-media-server\n\n\n\n\nYou can download any openvidu-server JAR file with this command:\n\n\n# Change {VERSION} for the desired one. e.g. /v2.8.0/openvidu-server-2.8.0.jar\nwget https://github.com/OpenVidu/openvidu/releases/download/v{VERSION}/openvidu-server-{VERSION}.jar\n\n\n\n\n3) Restart OpenVidu Server and Kurento Media Server services\n\n\nRun Kurento Media Server with \nsudo service kurento-media-server start\n and launch openvidu-server JAR file as stated in \nDeploying OpenVidu in Ubuntu\n section.", 
            "title": "Upgrading OpenVidu"
        }, 
        {
            "location": "/deployment/upgrading/#for-aws-deployments", 
            "text": "We provide an automated script to easily update the OpenVidu version of your AWS deployment.", 
            "title": "For AWS deployments"
        }, 
        {
            "location": "/deployment/upgrading/#1-connect-through-ssh-to-your-aws-instance", 
            "text": "ssh -i /path/to/your/private/key/file.pem ubuntu@12.34.56.78", 
            "title": "1) Connect through ssh to your AWS instance"
        }, 
        {
            "location": "/deployment/upgrading/#2-download-the-script-from-github", 
            "text": "wget https://raw.githubusercontent.com/OpenVidu/adm-scripts/master/scripts/openvidu_update_stack.sh\nsudo chmod 777 openvidu_update_stack.sh", 
            "title": "2) Download the script from GitHub"
        }, 
        {
            "location": "/deployment/upgrading/#3-run-the-script-indicating-the-openvidu-version-you-want-to-upgrade-to", 
            "text": "Better do this as the  root  user.  WARNING : running the script will stop OpenVidu Server. After upgrading all the services, it will be automatically restarted.  sudo -s\nexport OV_NEW_VERSION=2.8.0\n./openvidu_update_stack.sh", 
            "title": "3) Run the script, indicating the OpenVidu version you want to upgrade to"
        }, 
        {
            "location": "/deployment/upgrading/#for-ubuntu-deployments", 
            "text": "You must perform the following general steps, that may vary depending on how you have configured your services:", 
            "title": "For Ubuntu deployments"
        }, 
        {
            "location": "/deployment/upgrading/#1-stop-openvidu-server-and-kurento-media-server-services", 
            "text": "First one is a Java process that may be killed with a simple  kill -9 PID_NUMBER  command, and second one is usually stopped with  sudo service kurento-media-server stop", 
            "title": "1) Stop OpenVidu Server and Kurento Media Server services"
        }, 
        {
            "location": "/deployment/upgrading/#2-upgrade-kurento-media-server-package-and-replace-openvidu-server-jar-file-for-the-new-version", 
            "text": "It is mandatory to comply version compatibility between OpenVidu and Kurento Media Server. Check it out in  Releases  page.\nYou should be able to reinstall a new version of KMS while maintaining all the configuration files with these commands:  # Change version number in url http://ubuntu.openvidu.io/6.9.0 to the proper one depending on OpenVidu version\nsudo echo  deb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 xenial kms6  | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-get update\nsudo apt-get remove --auto-remove --yes kurento-media-server\nsudo apt-get install --yes -o Dpkg::Options::= --force-confold  kurento-media-server  You can download any openvidu-server JAR file with this command:  # Change {VERSION} for the desired one. e.g. /v2.8.0/openvidu-server-2.8.0.jar\nwget https://github.com/OpenVidu/openvidu/releases/download/v{VERSION}/openvidu-server-{VERSION}.jar", 
            "title": "2) Upgrade kurento-media-server package and replace openvidu-server JAR file for the new version"
        }, 
        {
            "location": "/deployment/upgrading/#3-restart-openvidu-server-and-kurento-media-server-services", 
            "text": "Run Kurento Media Server with  sudo service kurento-media-server start  and launch openvidu-server JAR file as stated in  Deploying OpenVidu in Ubuntu  section.", 
            "title": "3) Restart OpenVidu Server and Kurento Media Server services"
        }, 
        {
            "location": "/developing/", 
            "text": "Developing OpenVidu\n\n\n\n\n\n\n\n\nDependecy\n\n\nCheck version\n\n\nInstall\n\n\n\n\n\n\n\n\n\n\njava 8 JDK\n\n\njava -version\n\n\nsudo apt-get install -y openjdk-8-jdk\n\n\n\n\n\n\nnode\n\n\nnode -v\n\n\nsudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -\nsudo apt-get install -y nodejs\n\n\n\n\n\n\nmaven\n\n\nmvn -v\n\n\nsudo apt-get install -y maven\n\n\n\n\n\n\nangular-cli\n\n\nng -v\n\n\nsudo npm install -g @angular/cli\n\n\n\n\n\n\n\n\nSetup for development\n\n\nHere we show how to develop an Angular app (\nopenvidu-testapp\n) with \nopenvidu-browser\n and \nopenvidu-server\n as local dependencies, waiting to be modified as you want.\n\n\n1)\n Run Kurento Media Server Docker container (\ndocker run -d -p 8888:8888 kurento/kurento-media-server:latest\n) or \ninstall and run KMS\n (only for Ubuntu 16.04)\n\n\n2)\n Clone repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu.git\n\n\n\n\n3)\n \nopenvidu/openvidu-browser/\n\n\nnpm install\nnpm run build\nsudo npm link\n\n\n\n\n4)\n \nopenvidu/\n\n\nmvn -DskipTests=true clean install\n\n\n\n\n5)\n \nopenvidu/openvidu-testapp/\n\n\nnpm install\nnpm link openvidu-browser\nng serve\n\n\n\n\n6)\n \nopenvidu/openvidu-server/\n\n\nmvn exec:java\n\n\n\n\n(or if you prefer you can just run the Java application in your favourite IDE)\n\n\n\n\nAt these point, you can start modifying \nopenvidu-testapp\n, \nopenvidu-browser\n or \nopenvidu-server\n.\n\n\n\n\n\n\nopenvidu-testapp\n :  the \"ng serve\" command will take care of refreshing the browser's page whenever any change takes place\n\n\n\n\n\n\nopenvidu-browser\n : after modifying any typescript file, you will need to run the following command to update your changes:\n\n\n/openvidu/openvidu-browser\n:  \nnpm run build\n\n\n\n\n\n\nopenvidu-server\n : after modifying any file, there is no other alternative but to re-launch the java application if you want to update your changes\n\n\n/openvidu/openvidu-server\n: \nmvn clean exec:java\n\n\n(or re-launch the Java application in your IDE. Some IDE's support automatic re-launch in response to changes)\n\n\n\n\n\n\n\n\nSetup for advanced development: share the app through your network\n\n\nYou can also use \ndifferent machines\n in the \nsame network\n to build a more advanced development environment, so you can test the application in different devices at the same time. It's very similar to the process outlined above:\n\n\nRun exactly the same commands as the process above, but:\n\n\n\n\n\n\nOn step \n5)\n extend \nng serve\n command with:\n\n\nng serve --host 0.0.0.0 --ssl true\n\n\n\n\n\n\n\nOn step \n6)\n extend \nmvn exec:java\n command with:\n\n\nmvn -Dopenvidu.publicurl=https://HOST_LOCAL_IP:4443/ exec:java\n# Being HOST_LOCAL_IP the local IP that your machine serving the app has in your WiFi network\n\n\n\n\n\n\n\nThis way we first tell AngularCLI to serve our app through https and to expose the port in our WiFi network, and secondly we set OpenVidu Server public url to the public IP of the machine in our WiFi network. This way our devices will be able to reach it as long as they are connected to the same network.\n\n\nTo connect to the application from any device, be sure to be connected to the same WiFi network and navigate to \nhttps://HOST_LOCAL_IP:4200\n (being \nHOST_LOCAL_IP\n the local IP that your machine serving the app has in your WiFi network).\n\n\n\n\nInstalling KMS\n\n\nHow to \ninstall\n and \nrun\n KMS in your development machine (Ubuntu 16.04):\n\n\nsudo echo \ndeb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 xenial kms6\n | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83\nsudo apt-get update\nsudo apt-get -y install kurento-media-server\n\n\n\n\nChange the default user running KMS to your current user with this line:\n\n\nsudo sed -i \ns/DAEMON_USER=\\\nkurento\\\n/DAEMON_USER=\\\n${USER}\\\n/g\n /etc/default/kurento-media-server\n\n\n\n\nTo start and stop KMS service:\n\n\nsudo service kurento-media-server start\nsudo service kurento-media-server stop\n\n\n\n\nHere\n you can check Kurento's official documentation.", 
            "title": "Developing OpenVidu"
        }, 
        {
            "location": "/developing/#developing-openvidu", 
            "text": "Dependecy  Check version  Install      java 8 JDK  java -version  sudo apt-get install -y openjdk-8-jdk    node  node -v  sudo curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - sudo apt-get install -y nodejs    maven  mvn -v  sudo apt-get install -y maven    angular-cli  ng -v  sudo npm install -g @angular/cli", 
            "title": "Developing OpenVidu"
        }, 
        {
            "location": "/developing/#setup-for-development", 
            "text": "Here we show how to develop an Angular app ( openvidu-testapp ) with  openvidu-browser  and  openvidu-server  as local dependencies, waiting to be modified as you want.  1)  Run Kurento Media Server Docker container ( docker run -d -p 8888:8888 kurento/kurento-media-server:latest ) or  install and run KMS  (only for Ubuntu 16.04)  2)  Clone repo:  git clone https://github.com/OpenVidu/openvidu.git  3)   openvidu/openvidu-browser/  npm install\nnpm run build\nsudo npm link  4)   openvidu/  mvn -DskipTests=true clean install  5)   openvidu/openvidu-testapp/  npm install\nnpm link openvidu-browser\nng serve  6)   openvidu/openvidu-server/  mvn exec:java  (or if you prefer you can just run the Java application in your favourite IDE)   At these point, you can start modifying  openvidu-testapp ,  openvidu-browser  or  openvidu-server .    openvidu-testapp  :  the \"ng serve\" command will take care of refreshing the browser's page whenever any change takes place    openvidu-browser  : after modifying any typescript file, you will need to run the following command to update your changes:  /openvidu/openvidu-browser :   npm run build    openvidu-server  : after modifying any file, there is no other alternative but to re-launch the java application if you want to update your changes  /openvidu/openvidu-server :  mvn clean exec:java  (or re-launch the Java application in your IDE. Some IDE's support automatic re-launch in response to changes)", 
            "title": "Setup for development"
        }, 
        {
            "location": "/developing/#setup-for-advanced-development-share-the-app-through-your-network", 
            "text": "You can also use  different machines  in the  same network  to build a more advanced development environment, so you can test the application in different devices at the same time. It's very similar to the process outlined above:  Run exactly the same commands as the process above, but:    On step  5)  extend  ng serve  command with:  ng serve --host 0.0.0.0 --ssl true    On step  6)  extend  mvn exec:java  command with:  mvn -Dopenvidu.publicurl=https://HOST_LOCAL_IP:4443/ exec:java\n# Being HOST_LOCAL_IP the local IP that your machine serving the app has in your WiFi network    This way we first tell AngularCLI to serve our app through https and to expose the port in our WiFi network, and secondly we set OpenVidu Server public url to the public IP of the machine in our WiFi network. This way our devices will be able to reach it as long as they are connected to the same network.  To connect to the application from any device, be sure to be connected to the same WiFi network and navigate to  https://HOST_LOCAL_IP:4200  (being  HOST_LOCAL_IP  the local IP that your machine serving the app has in your WiFi network).", 
            "title": "Setup for advanced development: share the app through your network"
        }, 
        {
            "location": "/developing/#installing-kms", 
            "text": "How to  install  and  run  KMS in your development machine (Ubuntu 16.04):  sudo echo  deb [arch=amd64] http://ubuntu.openvidu.io/6.9.0 xenial kms6  | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83\nsudo apt-get update\nsudo apt-get -y install kurento-media-server  Change the default user running KMS to your current user with this line:  sudo sed -i  s/DAEMON_USER=\\ kurento\\ /DAEMON_USER=\\ ${USER}\\ /g  /etc/default/kurento-media-server  To start and stop KMS service:  sudo service kurento-media-server start\nsudo service kurento-media-server stop  Here  you can check Kurento's official documentation.", 
            "title": "Installing KMS"
        }, 
        {
            "location": "/troubleshooting/", 
            "text": "Troubleshooting and FAQ\n\n\n\n\n\n\n1. Everything looks alright, but I cannot see any remote video\n\n\nYou have an app that uses OpenVidu to stream some video user-to-user, and the process looks perfectly okey. No errors on the console and all the OpenVidu events you are subscribed to are correctly triggered. So what's happening?\n\n\n99% of the time this is a problem related with \nOPENVIDU SERVER NOT HAVING A PUBLIC IP\n. To learn more about it, you can check \nthis FAQ\n. The quickest solution to this problem is to deploy our ready-to-use \nOpenVidu Server in Amazon\n.\n\n\nIf you are a bit reluctant to this quick solution with Amazon CloudFormation, you can always deploy OpenVidu by yourself in Ubuntu 16.04. Check \nDeploying OpenVidu on Ubuntu\n section to learn how to properly do it.\n\n\nBesides that, these are the recommended steps to follow when videos are not received:\n\n\n\n\nAccess your OpenVidu dashboard (\nhttps://YOUR_OPENVIDU_IP:4443\n) to quickly test the video transmission (user: \nOPENVIDUAPP\n, pass: \n[your private secret]\n)\n\n\nPlease be sure that your OpenVidu Server host meets the \nnetwork requirements\n.\n\n\n\n\nThe other 1% of the time this can be an attempt of \naccessing the same camera from two different browsers at the same time\n. Remember that Chrome, Firefox, Opera and Safari are distinct processes which cannot generally access the same physical resource (as a webcam) at the same time on your computer. On the other hand, accessing the camera from different tabs of the same browser is tipically possible.\n\n\n\n\n2. Any tips to make easier the development of my app with OpenVidu?\n\n\nYou can do some things to improve your efficiency while using OpenVidu:\n\n\n\n\nMultiple tabs to test the video transmission\n\n\nYou can use multiple tabs in the same browser to test your video streams.\n\n\nWARNING\n: you may have trouble for testing with tabs from different browsers at the same time, as they compete for the camera access.\n\n\n\n\nBe very aware of the browser's console\n\n\nThere you can find logs reporting important stuff. Error messages can help you to solve many issues.\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \n\n  \n\n  \n\n    \n\n      OpenVidu Browser is developed with both \nChrome\n (first image) and \nFirefox\n (second image) in mind in terms of logging. By default the browser's console displays OpenVidu's high-level messages (that's when the option 'Info' is enabled, as seen in the images). This means logs about OpenVidu objects being created and destroyed and logs for each triggered event (only for those you are subscribed to).\n    \n\n    \n\n    \n\n      Warn and Error messages are specifically reserved for unwanted situations, and you should check your code in case you spot one of them.\n    \n\n    \n\n    \n\n      If you enable the lowest level of logging you can see all the messages concerning the WebRTC negotiation process (generally not very interesting for an OpenVidu user).\n    \n\n  \n\n\n\n\n\n\n\nRemember the browser's cache\n\n\nIf you have changed your HTML, JavaScript or CSS code, refreshed the page and cannot see the changes on the browser, probably the cache is still serving the old files. To perform a hard reload of your page on the browser, press \nCtrl + Shift + R\n\n\n\n\nShare your app through your network to test with multiple devices\n\n\nMaking your app accessible to any device connected to your WiFi is very useful for quickly testing your app with different devices at the same time. To achieve this, you just have to indicate OpenVidu Server to use your dev machine LAN IP address as public url. For example, let's say that your machine has assigned ip \n192.168.0.107\n in your network:\n\n\ndocker run -p 4443:4443 -e openvidu.publicurl=https://192.168.0.107:4443/ openvidu/openvidu-server-kms:6.9.0\n\n\nThen you just have to configure your app (REST API address / OpenVidu Java Client / OpenVidu Node Client) to connect to OpenVidu through \nhttps://192.168.0.107:4443/\n. Any user connecting to your app through \nhttps://192.168.0.107:WHICHEVER_PORT_YOUR_APP_IS_LISTENING_THROUGH\n will be able to send and receive video.\n\n\n\n\n3. I am using Windows to run the tutorials / develop my app. Anything I should know?\n\n\nYes, some little changes are needed because of the way Docker runs on Windows. In Linux/Mac, Docker containers are easily accesible through \nlocalhost\n, but in Windows you will have to use the specific IP allocated to your container (usually \n192.168.99.100\n). \n\n\nFirst of all, you must launch the developing Docker container of OpenVidu Server (\nopenvidu/openvidu-server-kms\n) setting paramater \nopenvidu.publicurl\n to the IP allocated for Docker in your Windows machine.\n\n\nWhat in Linux/Mac is... \n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0\n\n\n\n\n...in Windows is...\n\n\ndocker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=https://192.168.99.100:4443/ openvidu/openvidu-server-kms:2.8.0\n\n\n\n\nThen, to let your applications know how to connect to OpenVidu Server:\n\n\nApplications \nClient-Side Only\n\n\n(For example \nopenvidu-hello-world\n, \nopenvidu-insecure-js\n, \nopenvidu-insecure-angular\n, \nopenvidu-getaroom\n)\n\n\nWhen consuming openvidu-server REST api, change \nlocation.hostname\n to the IP of the Docker container running openvidu-server (usually \n192.168.99.100\n). For every one of the insecure tutorials listed above, the url where to send the REST operations ...\n\n\n\"https://\" + location.hostname + \":4443/api/\nOPERATION\n\"\n\n\n\n... in Windows is ...\n\n\n\"https://192.168.99.100:4443/api/\nOPERATION\n\"\n\n\n\nChange this url in every insecure tutorial right here:\n\n\n\n\nopenvidu-hello-world\n: \nhere\n\n\nopenvidu-insecure-js\n: \nhere\n\n\nopenvidu-insecure-angular\n: \nhere\n\n\nopenvidu-getaroom\n: \nhere\n\n\n\n\n\n\n\n\nAlso you will need to serve your apps over \nhttps\n. Browsers only accept camera usage on http when the address is \nlocalhost\n, and here it will be \n192.168.99.100\n or the one that Docker picks up for you. To serve over https with \nhttp-server\n, generate a self-signed certificate and run with \n-S\n flag on the root path of your app:\n\n\nGenerate a selfsigned certificate (run in your Docker console)\n\n\nopenssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '//CN=www.mydom.com\\O=My Company LTD.\\C=US' -keyout key.pem -out cert.pem\n\n\nRun with SSL flag\n\n\nhttp-server -S\n\n\n\n\nApplications \nClient-Side + Server-Side\n\n\n(Tutorials \nopenvidu-js-java\n, \nopenvidu-mvc-java\n, \nopenvidu-js-node\n, \nopenvidu-mvc-node\n)\n\n\nYou must let know your app/tutorial how to initialize \nopenvidu-java-client\n or \nopenvidu-node-client\n (or where to send your REST API operations in case you are not using any of these clients). For example:\n\n\n\n\n\n\nJava tutorials\n (tutorials \nopenvidu-js-java\n, \nopenvidu-mvc-java\n): override the default value of the property \nopenvidu.url\n:\n\n\nmvn package exec:java\n\n\n\nin Windows is...\n\n\nmvn -Dopenvidu.url=https://192.168.99.100:4443/ package exec:java\n\n\n\n\n\nWith this change we are simply changing the param \nurlOpenViduServer\n that our OpenVidu object from \nopenvidu-java-client\n will receive in \nits constructor\n. This change is something related to these specific applications.\n\n\n\n\n\n\n\n\nNode tutorials\n (tutorials \nopenvidu-js-node\n, \nopenvidu-mvc-node\n): change the URL param passed on launch:\n\n\nnode server.js https://localhost:4443/ MY_SECRET\n\n\n\nin Windows is...\n\n\nnode server.js https://192.168.99.100:4443/ MY_SECRET\n\n\n\n\n\nWith this change we are simply changing the param \nurlOpenViduServer\n that our OpenVidu object from \nopenvidu-node-client\n will receive in \nits constructor\n. This change is something related to these specific applications.\n\n\n\n\n\n\n\n\n\n\n4. Does my app need a server-side?\n\n\nFirst of all, let's differentiate between OpenVidu server-side and your application's server-side. \n\n\n\n\nYou will always need OpenVidu Server deployed at some place on the Internet (check the \nDeployment section\n to learn how to do it in 5 minutes). For now, OpenVidu doesn't support p2p direct connections between two users, so all the traffic must flow to OpenVidu Server or from OpenVidu Server.\n\n\nYou will generally want your application to have its own server-side. Why?\n\n\n\n\nWell, it is really not necessary. You can have a pure client-side application if you want. Just check any of these tutorials:\nopenvidu-hello-world\n, \nopenvidu-insecure-js\n, \nopenvidu-getaroom\n\n\nThe problem here is pretty evident: if you don't have any kind of server side to control your users, anyone can use your app. In fact, you can respectively see \nhere\n, \nhere\n and \nhere\n a comment warning about this matter in every insecure tutorial. Due to the lack of a server-side in these tutorials, we have no choice but to embed the REST API consumption methods in our JavaScript code, which includes hardcoding our secret in the JS client code.\n\n\n\n\n\n\nIMPORTANT\n: Do NOT include your SECRET in your JavaScript or HTML files in a production environment!\n\n\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \n\n  \n\n  \n\n    \n\n      \nFirst an OpenVidu app Client-Side Only.\n\n    \n\n    \n\n    \n\n      \nSecond an OpenVidu app Client-Side + Server-Side.\n\n    \n\n    \n\n    \n\n      \nIn production you will usually want the second option to avoid unwanted users.\n\n    \n\n  \n\n\n\n\n\n\n\n5. The CloudFormation Stack is a nice option for Amazon, but I don't like it. I want more control\n\n\nYou can always deploy everything by yourself. To do so, check \nDeploying OpenVidu on Ubuntu\n section.\n\n\n\n\n6. What are STUN and TURN servers and why do I need them?\n\n\nIf the user's devices don't have a public and reachable IP, WebRTC connections cannot be established and therefore, video streams cannot be sent or received. This occurs when the users are behind NAT's and Firewalls. In brief, when they are hidden under complex networks.\n\n\nIn order to support these circumstances, WebRTC relies on \nSTUN and TURN\n servers:\n\n\n\n\nSTUN\n can easily provide to the user's devices their own public IP (the IP that other devices on the Internet use to connect to it), so they can tell OpenVidu where to send the video streams. Only with a STUN server, around \n86%\n of the time the connection will be successful.\n\n\nTURN\n is an extension of STUN, and covers the most extreme cases of complex networks (symmetric NATs). It acts as a gateway, passing all the media streams from one side to the other. This situation will occur with a probability of around \n8%\n.\n\n\n\n\nFor all purposes, OpenVidu Server acts as a final user, and your connections may fail if it is hosted behind a complex network. To provide a a solid service you definitely need both STUN and TURN servers. There are many public, free-to-use STUN servers (\nSTUN server list\n), but because TURN always faces a much larger load when coming into play, no one offers it free of charge. The good news is that it is very easy to install a COTURN server, which offers both STUN and TURN:\n\n\n\n\nOur ready-to-use \nCloudFormation stack\n already includes a properly configured COTURN server.\n\n\n\n\nIf you are deploying OpenVidu Server by your own, there are detailed instructions in the \nDeploying OpenVidu on Ubuntu\n section, which explains how to install, configure and run COTURN on Ubuntu.\n\n\n\n\nYou can test your \nCOTURN\n server on this website: \nTrickle ICE\n. To do so, remove the default Google server from the list and add your own following this format: \nturn:YOUR_TURN_IP:YOUR_TURN_PORT\n (add your TURN username and password below)\n\n\n\n\n\n\n\n\n\n\n7. What does OpenVidu not integrate regarding WebRTC and Kurento yet?\n\n\nAs the main goal OpenVidu has is to make as simple as possible the integration of video-call capabilities in applications, it would make little sense to support all the features provided by Kurento: why would most of developers want visual recognition or augmented reality capabilities when adding video-calls to their apps?\n\n\nBut there's also a bunch of features supported by Kurento or WebRTC that will be part of OpenVidu as well:\n\n\n\n\nVideo composing\n: right now OpenVidu streams are always sent and received without any processing in Kurento Media Server, so every subscription to a video stream in a video-session implies its own WebRTC connection. We intend to provide the possibility of configuring video-sessions to be processed and send as only one video, composed in a grid by all the published streams (MCU architecture).\n\n\nDirect p2p connections between users\n: OpenVidu will offer the possibility of connecting users without having to use Kurento Media Server as central node. This can be very advantegeous for certain use-cases, as will reduce the need of infraestructure.\n\n\n\n\n\n\n8. Does OpenVidu support Android and iOS?\n\n\nSince release 2.7.0 \nAndroid\n and \niOS\n are supported through \nIonic\n. You can try \nopenvidu-ionic\n tutorial and you will have an OpenVidu native application compatible with both Android ang iOS working in minutes.\n\n\nIn the future OpenVidu team plans to support \nReact Native\n and \nNative Script\n frameworks in the same manner.\n\n\n\n\n9. Which is the current status of OpenVidu on scalability and fault tolerance?\n\n\nOpenVidu load testing process is described in detail in this \nMedium post\n. Results are the following for 7-to-7 sessions were every participant sends one audio-video stream (540x360, 30 fps) and receives 6 remote streams (same video). The table states the maximum number of entities that can be established until CPU reaches 100% use.\n\n\n\n  \n\n\n\n\n\nThat said, one of the most important features OpenVidu will offer is the possibility of automated scalability and fault tolerance. We intend to provide an easy-to-use service integrated with most popular cloud providers to allow the automated launching and shutdown of servers depending on the workload of your application.\n\n\n\n\n10. I am getting an \"Error accessing the camera\" and I have already granted permissions on the browser\n\n\nIf you are using \nChrome\n: you \ncannot access the camera or microphone from a \nhttp\n URL if it is not \nlocalhost\n or \n127.0.0.1\n. In a nutshell: in Chrome accessing the webcam on \nhttp://localhost:8080\n or \nhttp://127.0.0.1:8080\n is perfectly OK. But, for example, on \nhttp://172.17.0.1:8080\n it will through an error saying \"\nOnly secure origins are allowed\n\". If for any reason you want to serve your app locally on a custom URL, the only solution is to serve it over \nhttps\n with a certificate. If you are making use of the web server we have strongly suggested over the documentation (\nnpm install -g http-server\n), you can do this with the following commands on your application's root path:\n\n\n\n\n\n\nGenerate a selfsigned certificate with \nopenssl\n\n\nopenssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem\n\n\n\n\n\n\n\nRun \nhttp-server\n with SSL flag\n\n\nhttp-server -S\n\n\n\n\n\n\n\n\n\n11. My Safari users with role \nSUBSCRIBER\n are not able to receive any remote video\n\n\nSafari needs a user gesture to allow videos to automatically start playing if they have audio. This applies to users with role \nSUBSCRIBER\n: that is, users that don't need to perform a call to \nOpenVidu.initPublisher\n. If a user access its camera or microphone, then there's no need of user gestures at all (as soon as they accept camera permissions, remote videos will automatically start playing).\n\n\nSo, in this particular case developers must show a button their SUBSCRIBER users must click (any other action that counts as user-gesture is also suitable), and the action executed upon click event should include a call to \nvideo.play()\n. The actual video element is completely irrelevant. It can be hidden and with no media attached at all. For example:\n\n\n!-- This can be placed anywhere in the DOM. For example, as last child of \nbody\n element --\n\n\nvideo id=\nhidden-video\n/video\n\n\n\n\n\n// Javascript code run upon any user gesture\nvar video = document.getElementById(\nhidden-video\n).play();\n\n\n\n\nAfter this JavaScript line has been executed any remote video will start playing. This process is not necessary for future subscribed videos, when there is already some audio being played in the DOM.\n\n\n\n\n12. Videos are freezing on Safari for iOS\n\n\nAgain, Apple's browser has \"special\" needs when it comes to video playback. In iPhones and iPads, Safari doesn't support out of the box the playback of multiple videos at the same time if they have audio tracks. Here you have a \nlink\n to a bug related to this behavior.\n\n\nPossible solutions to this issue? Tweaking muted property on videos to have only one playing audio at a time. Maybe using user gestures to directly play videos can help too. There is not a clear solution to this problem, and depending on the web application some workarounds can succeed and some may not. On our tests we have even seen different behaviors in video playback from one execution to another, breaking the supposed consistency of the browser. It is really a matter of testing different approaches until you find a good enough solution.\n\n\nUsually any other WebRTC based service we have tested redirected to a native application when trying to connect through iOS Safari. You can implement your native OpenVidu app for both iOS and Android with Ionic (\nsee the tutorial\n)", 
            "title": "Troubleshooting / FAQ"
        }, 
        {
            "location": "/troubleshooting/#1-everything-looks-alright-but-i-cannot-see-any-remote-video", 
            "text": "You have an app that uses OpenVidu to stream some video user-to-user, and the process looks perfectly okey. No errors on the console and all the OpenVidu events you are subscribed to are correctly triggered. So what's happening?  99% of the time this is a problem related with  OPENVIDU SERVER NOT HAVING A PUBLIC IP . To learn more about it, you can check  this FAQ . The quickest solution to this problem is to deploy our ready-to-use  OpenVidu Server in Amazon .  If you are a bit reluctant to this quick solution with Amazon CloudFormation, you can always deploy OpenVidu by yourself in Ubuntu 16.04. Check  Deploying OpenVidu on Ubuntu  section to learn how to properly do it.  Besides that, these are the recommended steps to follow when videos are not received:   Access your OpenVidu dashboard ( https://YOUR_OPENVIDU_IP:4443 ) to quickly test the video transmission (user:  OPENVIDUAPP , pass:  [your private secret] )  Please be sure that your OpenVidu Server host meets the  network requirements .   The other 1% of the time this can be an attempt of  accessing the same camera from two different browsers at the same time . Remember that Chrome, Firefox, Opera and Safari are distinct processes which cannot generally access the same physical resource (as a webcam) at the same time on your computer. On the other hand, accessing the camera from different tabs of the same browser is tipically possible.", 
            "title": "1. Everything looks alright, but I cannot see any remote video"
        }, 
        {
            "location": "/troubleshooting/#2-any-tips-to-make-easier-the-development-of-my-app-with-openvidu", 
            "text": "You can do some things to improve your efficiency while using OpenVidu:", 
            "title": "2. Any tips to make easier the development of my app with OpenVidu?"
        }, 
        {
            "location": "/troubleshooting/#multiple-tabs-to-test-the-video-transmission", 
            "text": "You can use multiple tabs in the same browser to test your video streams.  WARNING : you may have trouble for testing with tabs from different browsers at the same time, as they compete for the camera access.", 
            "title": "Multiple tabs to test the video transmission"
        }, 
        {
            "location": "/troubleshooting/#be-very-aware-of-the-browsers-console", 
            "text": "There you can find logs reporting important stuff. Error messages can help you to solve many issues.  \n   \n     \n   \n   \n     \n   \n   \n     \n      OpenVidu Browser is developed with both  Chrome  (first image) and  Firefox  (second image) in mind in terms of logging. By default the browser's console displays OpenVidu's high-level messages (that's when the option 'Info' is enabled, as seen in the images). This means logs about OpenVidu objects being created and destroyed and logs for each triggered event (only for those you are subscribed to).\n     \n     \n     \n      Warn and Error messages are specifically reserved for unwanted situations, and you should check your code in case you spot one of them.\n     \n     \n     \n      If you enable the lowest level of logging you can see all the messages concerning the WebRTC negotiation process (generally not very interesting for an OpenVidu user).", 
            "title": "Be very aware of the browser's console"
        }, 
        {
            "location": "/troubleshooting/#remember-the-browsers-cache", 
            "text": "If you have changed your HTML, JavaScript or CSS code, refreshed the page and cannot see the changes on the browser, probably the cache is still serving the old files. To perform a hard reload of your page on the browser, press  Ctrl + Shift + R", 
            "title": "Remember the browser's cache"
        }, 
        {
            "location": "/troubleshooting/#share-your-app-through-your-network-to-test-with-multiple-devices", 
            "text": "Making your app accessible to any device connected to your WiFi is very useful for quickly testing your app with different devices at the same time. To achieve this, you just have to indicate OpenVidu Server to use your dev machine LAN IP address as public url. For example, let's say that your machine has assigned ip  192.168.0.107  in your network:  docker run -p 4443:4443 -e openvidu.publicurl=https://192.168.0.107:4443/ openvidu/openvidu-server-kms:6.9.0  Then you just have to configure your app (REST API address / OpenVidu Java Client / OpenVidu Node Client) to connect to OpenVidu through  https://192.168.0.107:4443/ . Any user connecting to your app through  https://192.168.0.107:WHICHEVER_PORT_YOUR_APP_IS_LISTENING_THROUGH  will be able to send and receive video.", 
            "title": "Share your app through your network to test with multiple devices"
        }, 
        {
            "location": "/troubleshooting/#3-i-am-using-windows-to-run-the-tutorials-develop-my-app-anything-i-should-know", 
            "text": "Yes, some little changes are needed because of the way Docker runs on Windows. In Linux/Mac, Docker containers are easily accesible through  localhost , but in Windows you will have to use the specific IP allocated to your container (usually  192.168.99.100 ).   First of all, you must launch the developing Docker container of OpenVidu Server ( openvidu/openvidu-server-kms ) setting paramater  openvidu.publicurl  to the IP allocated for Docker in your Windows machine.  What in Linux/Mac is...   docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms:2.8.0  ...in Windows is...  docker run -p 4443:4443 --rm -e openvidu.secret=MY_SECRET -e openvidu.publicurl=https://192.168.99.100:4443/ openvidu/openvidu-server-kms:2.8.0  Then, to let your applications know how to connect to OpenVidu Server:", 
            "title": "3. I am using Windows to run the tutorials / develop my app. Anything I should know?"
        }, 
        {
            "location": "/troubleshooting/#applications-client-side-only", 
            "text": "(For example  openvidu-hello-world ,  openvidu-insecure-js ,  openvidu-insecure-angular ,  openvidu-getaroom )  When consuming openvidu-server REST api, change  location.hostname  to the IP of the Docker container running openvidu-server (usually  192.168.99.100 ). For every one of the insecure tutorials listed above, the url where to send the REST operations ...  \"https://\" + location.hostname + \":4443/api/ OPERATION \"  ... in Windows is ...  \"https://192.168.99.100:4443/api/ OPERATION \"  Change this url in every insecure tutorial right here:   openvidu-hello-world :  here  openvidu-insecure-js :  here  openvidu-insecure-angular :  here  openvidu-getaroom :  here     Also you will need to serve your apps over  https . Browsers only accept camera usage on http when the address is  localhost , and here it will be  192.168.99.100  or the one that Docker picks up for you. To serve over https with  http-server , generate a self-signed certificate and run with  -S  flag on the root path of your app:  Generate a selfsigned certificate (run in your Docker console)  openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '//CN=www.mydom.com\\O=My Company LTD.\\C=US' -keyout key.pem -out cert.pem  Run with SSL flag  http-server -S", 
            "title": "Applications Client-Side Only"
        }, 
        {
            "location": "/troubleshooting/#applications-client-side-server-side", 
            "text": "(Tutorials  openvidu-js-java ,  openvidu-mvc-java ,  openvidu-js-node ,  openvidu-mvc-node )  You must let know your app/tutorial how to initialize  openvidu-java-client  or  openvidu-node-client  (or where to send your REST API operations in case you are not using any of these clients). For example:    Java tutorials  (tutorials  openvidu-js-java ,  openvidu-mvc-java ): override the default value of the property  openvidu.url :  mvn package exec:java  in Windows is...  mvn -Dopenvidu.url=https://192.168.99.100:4443/ package exec:java   With this change we are simply changing the param  urlOpenViduServer  that our OpenVidu object from  openvidu-java-client  will receive in  its constructor . This change is something related to these specific applications.     Node tutorials  (tutorials  openvidu-js-node ,  openvidu-mvc-node ): change the URL param passed on launch:  node server.js https://localhost:4443/ MY_SECRET  in Windows is...  node server.js https://192.168.99.100:4443/ MY_SECRET   With this change we are simply changing the param  urlOpenViduServer  that our OpenVidu object from  openvidu-node-client  will receive in  its constructor . This change is something related to these specific applications.", 
            "title": "Applications Client-Side + Server-Side"
        }, 
        {
            "location": "/troubleshooting/#4-does-my-app-need-a-server-side", 
            "text": "First of all, let's differentiate between OpenVidu server-side and your application's server-side.    You will always need OpenVidu Server deployed at some place on the Internet (check the  Deployment section  to learn how to do it in 5 minutes). For now, OpenVidu doesn't support p2p direct connections between two users, so all the traffic must flow to OpenVidu Server or from OpenVidu Server.  You will generally want your application to have its own server-side. Why?   Well, it is really not necessary. You can have a pure client-side application if you want. Just check any of these tutorials: openvidu-hello-world ,  openvidu-insecure-js ,  openvidu-getaroom  The problem here is pretty evident: if you don't have any kind of server side to control your users, anyone can use your app. In fact, you can respectively see  here ,  here  and  here  a comment warning about this matter in every insecure tutorial. Due to the lack of a server-side in these tutorials, we have no choice but to embed the REST API consumption methods in our JavaScript code, which includes hardcoding our secret in the JS client code.    IMPORTANT : Do NOT include your SECRET in your JavaScript or HTML files in a production environment!   \n   \n     \n   \n   \n     \n   \n   \n     \n       First an OpenVidu app Client-Side Only. \n     \n     \n     \n       Second an OpenVidu app Client-Side + Server-Side. \n     \n     \n     \n       In production you will usually want the second option to avoid unwanted users.", 
            "title": "4. Does my app need a server-side?"
        }, 
        {
            "location": "/troubleshooting/#5-the-cloudformation-stack-is-a-nice-option-for-amazon-but-i-dont-like-it-i-want-more-control", 
            "text": "You can always deploy everything by yourself. To do so, check  Deploying OpenVidu on Ubuntu  section.", 
            "title": "5. The CloudFormation Stack is a nice option for Amazon, but I don't like it. I want more control"
        }, 
        {
            "location": "/troubleshooting/#6-what-are-stun-and-turn-servers-and-why-do-i-need-them", 
            "text": "If the user's devices don't have a public and reachable IP, WebRTC connections cannot be established and therefore, video streams cannot be sent or received. This occurs when the users are behind NAT's and Firewalls. In brief, when they are hidden under complex networks.  In order to support these circumstances, WebRTC relies on  STUN and TURN  servers:   STUN  can easily provide to the user's devices their own public IP (the IP that other devices on the Internet use to connect to it), so they can tell OpenVidu where to send the video streams. Only with a STUN server, around  86%  of the time the connection will be successful.  TURN  is an extension of STUN, and covers the most extreme cases of complex networks (symmetric NATs). It acts as a gateway, passing all the media streams from one side to the other. This situation will occur with a probability of around  8% .   For all purposes, OpenVidu Server acts as a final user, and your connections may fail if it is hosted behind a complex network. To provide a a solid service you definitely need both STUN and TURN servers. There are many public, free-to-use STUN servers ( STUN server list ), but because TURN always faces a much larger load when coming into play, no one offers it free of charge. The good news is that it is very easy to install a COTURN server, which offers both STUN and TURN:   Our ready-to-use  CloudFormation stack  already includes a properly configured COTURN server.   If you are deploying OpenVidu Server by your own, there are detailed instructions in the  Deploying OpenVidu on Ubuntu  section, which explains how to install, configure and run COTURN on Ubuntu.   You can test your  COTURN  server on this website:  Trickle ICE . To do so, remove the default Google server from the list and add your own following this format:  turn:YOUR_TURN_IP:YOUR_TURN_PORT  (add your TURN username and password below)", 
            "title": "6. What are STUN and TURN servers and why do I need them?"
        }, 
        {
            "location": "/troubleshooting/#7-what-does-openvidu-not-integrate-regarding-webrtc-and-kurento-yet", 
            "text": "As the main goal OpenVidu has is to make as simple as possible the integration of video-call capabilities in applications, it would make little sense to support all the features provided by Kurento: why would most of developers want visual recognition or augmented reality capabilities when adding video-calls to their apps?  But there's also a bunch of features supported by Kurento or WebRTC that will be part of OpenVidu as well:   Video composing : right now OpenVidu streams are always sent and received without any processing in Kurento Media Server, so every subscription to a video stream in a video-session implies its own WebRTC connection. We intend to provide the possibility of configuring video-sessions to be processed and send as only one video, composed in a grid by all the published streams (MCU architecture).  Direct p2p connections between users : OpenVidu will offer the possibility of connecting users without having to use Kurento Media Server as central node. This can be very advantegeous for certain use-cases, as will reduce the need of infraestructure.", 
            "title": "7. What does OpenVidu not integrate regarding WebRTC and Kurento yet?"
        }, 
        {
            "location": "/troubleshooting/#8-does-openvidu-support-android-and-ios", 
            "text": "Since release 2.7.0  Android  and  iOS  are supported through  Ionic . You can try  openvidu-ionic  tutorial and you will have an OpenVidu native application compatible with both Android ang iOS working in minutes.  In the future OpenVidu team plans to support  React Native  and  Native Script  frameworks in the same manner.", 
            "title": "8. Does OpenVidu support Android and iOS?"
        }, 
        {
            "location": "/troubleshooting/#9-which-is-the-current-status-of-openvidu-on-scalability-and-fault-tolerance", 
            "text": "OpenVidu load testing process is described in detail in this  Medium post . Results are the following for 7-to-7 sessions were every participant sends one audio-video stream (540x360, 30 fps) and receives 6 remote streams (same video). The table states the maximum number of entities that can be established until CPU reaches 100% use.  \n     That said, one of the most important features OpenVidu will offer is the possibility of automated scalability and fault tolerance. We intend to provide an easy-to-use service integrated with most popular cloud providers to allow the automated launching and shutdown of servers depending on the workload of your application.", 
            "title": "9. Which is the current status of OpenVidu on scalability and fault tolerance?"
        }, 
        {
            "location": "/troubleshooting/#10-i-am-getting-an-error-accessing-the-camera-and-i-have-already-granted-permissions-on-the-browser", 
            "text": "If you are using  Chrome : you  cannot access the camera or microphone from a  http  URL if it is not  localhost  or  127.0.0.1 . In a nutshell: in Chrome accessing the webcam on  http://localhost:8080  or  http://127.0.0.1:8080  is perfectly OK. But, for example, on  http://172.17.0.1:8080  it will through an error saying \" Only secure origins are allowed \". If for any reason you want to serve your app locally on a custom URL, the only solution is to serve it over  https  with a certificate. If you are making use of the web server we have strongly suggested over the documentation ( npm install -g http-server ), you can do this with the following commands on your application's root path:    Generate a selfsigned certificate with  openssl  openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem    Run  http-server  with SSL flag  http-server -S", 
            "title": "10. I am getting an \"Error accessing the camera\" and I have already granted permissions on the browser"
        }, 
        {
            "location": "/troubleshooting/#11-my-safari-users-with-role-subscriber-are-not-able-to-receive-any-remote-video", 
            "text": "Safari needs a user gesture to allow videos to automatically start playing if they have audio. This applies to users with role  SUBSCRIBER : that is, users that don't need to perform a call to  OpenVidu.initPublisher . If a user access its camera or microphone, then there's no need of user gestures at all (as soon as they accept camera permissions, remote videos will automatically start playing).  So, in this particular case developers must show a button their SUBSCRIBER users must click (any other action that counts as user-gesture is also suitable), and the action executed upon click event should include a call to  video.play() . The actual video element is completely irrelevant. It can be hidden and with no media attached at all. For example:  !-- This can be placed anywhere in the DOM. For example, as last child of  body  element --  video id= hidden-video /video   // Javascript code run upon any user gesture\nvar video = document.getElementById( hidden-video ).play();  After this JavaScript line has been executed any remote video will start playing. This process is not necessary for future subscribed videos, when there is already some audio being played in the DOM.", 
            "title": "11. My Safari users with role SUBSCRIBER are not able to receive any remote video"
        }, 
        {
            "location": "/troubleshooting/#12-videos-are-freezing-on-safari-for-ios", 
            "text": "Again, Apple's browser has \"special\" needs when it comes to video playback. In iPhones and iPads, Safari doesn't support out of the box the playback of multiple videos at the same time if they have audio tracks. Here you have a  link  to a bug related to this behavior.  Possible solutions to this issue? Tweaking muted property on videos to have only one playing audio at a time. Maybe using user gestures to directly play videos can help too. There is not a clear solution to this problem, and depending on the web application some workarounds can succeed and some may not. On our tests we have even seen different behaviors in video playback from one execution to another, breaking the supposed consistency of the browser. It is really a matter of testing different approaches until you find a good enough solution.  Usually any other WebRTC based service we have tested redirected to a native application when trying to connect through iOS Safari. You can implement your native OpenVidu app for both iOS and Android with Ionic ( see the tutorial )", 
            "title": "12. Videos are freezing on Safari for iOS"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\n\n\n\n\n\n\n2.9.0\n\n\n2.8.0\n\n\n2.7.0\n\n\n2.6.0\n\n\n2.5.0\n\n\n2.4.0\n\n\n2.3.0\n\n\n2.2.0\n\n\n2.1.0\n\n\n2.0.0\n\n\n1.9.0-beta-1\n\n\n\n\n\n\n2.9.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.9.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.9.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.9.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.9.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.9.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.9.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.9.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-webcomponent\n\n    \nZIP\n\n    \n2.9.0\n\n    \nGitHub\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-angular\n\n    \nNPM package\n\n    \n2.9.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-react\n\n    \nNPM package\n\n    \n2.9.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nKurento Media Server\n\n    \nUbuntu package\n\n    \n6.10.0\n\n    \nKurento Docs\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\nNEW FEATURES\n\n\n\n\nUbuntu 18.04 bionic\u00a0support\n\n\nOur team has released Kurento 6.10.0, which can now be installed in Ubuntu 18.04 systems. This is a milestone we've been working on for quite some time, and we finally believe we're ready to launch official support for the newest Ubuntu LTS version. Deployment section in OpenVidu Docs is properly updated to inform about this.\n\n\nWe still consider Ubuntu Bionic to be in a preliminary support state, and some bugs may appear. In fact, we know for sure there's one limitation: no OpenCV filters will work in Ubuntu 18.04 at this moment. OpenVidu has supported audio and video filters for a long time now, and it is a cool feature that allows developers to implement some advanced audio and video real-time processing in the server side. But unfortunately Kurento has not been updated yet to support it in Bionic, so no FaceOverlayFilter or ChromaFilter will work in new Ubuntu version. But you can still use GStreamer filters!\n\n\n\n\nOpenVidu Server boot process greatly\u00a0improved\n\n\nOpenVidu Server now checks all requiered conditions at boot time, which helps solving missconfiguration problems when deploying on Ubuntu. This includes every requirement related to permissions and installed software. If something is missing, wrong or there are not enough permissions in certain path, the OpenVidu Server process immediately exits with a clear description about what happened and a possible solution to fix it.\n\n\nIn our experience, this makes the process of installing OpenVidu Server directly in Ubuntu so much easier and manageable.\n\n\n\n\nOpenVidu reconnection to Kurento Media\u00a0Server\n\n\nIf OpenVidu Server loses its connection to Kurento Media Server, now it will try to reconnect automatically. When it does so, if it is a new instance of Kurento, every stream of every previously active session will be destroyed with reason mediaServerDisconnect and every active recording will be stopped with same reason, but your users will not be disconnected from your sessions. This way you can directly re-publish and re-subscribe any desired stream right away.\n\n\nThis may help in case Kurento crashes: your users will have lost their media connections, but they will still be connected to their OpenVidu sessions and will only have to re-establish streams once OpenVidu Server is connected to a new Kurento instance.\n\n\n\n\nOpenVidu upgrade\u00a0process\n\n\nDo you want to upgrade your OpenVidu deployment? Now you have a section entirely dedicated to it in the documentation. If you have deployed OpenVidu in AWS, it's as easy as launching a single command. If you have chosen Ubuntu deployment, then you will have to manually run some commands. Either way, you have available proper instructions now.\n\n\n\n\nNative screen-sharing for\u00a0Chrome\n\n\nOpenVidu has supported native screen-sharing for Firefox since its inception, but Google decided to have Chrome require an extension to allow screen-sharing. Finally they changed their mind and brought Chrome up to the standard, supporting getDisplayMedia API.\n\n\nSo, our client library openvidu-browser now supports native screen-sharing for Chrome\u226572. No extension needed for these browsers!\n\n\n\n\nOpenVidu Call improvements\n\n\nOur best demo application has been updated with some exciting new features:\n\n\n\n\nUsers can now share their webcam and their screen at the same time.\n\n\nThe chat is better integrated now.\n\n\nYou can enlarge as many videos as you want, not just one. Available space will be automatically managed by the application for best fit.\n\n\nPreview window for camera and mic selection has undergone many necessary fixes. Now it works fine in every OS and client supported by OpenVidu.\nopenvidu-call-ionic (Ionic version of OpenVidu Call for mobile devices) now supports Ionic 4 and works fine in iOS.ready to\n\n\n\n\n\n\nBUG FIXES\n\n\n\n\nFor COMPOSED recording with video, when multiple screen sharing streams were being published it crashed. Now it doesn't.\n\n\nFor COMPOSED recordings with video, when stopping them immediatley after started, sometimes the generated video file would not be playable. Now in this cases failed status is set to this recordings, so you can take care of them properly.\n\n\nAfter manually stopping ALWAYS recordings (sessions that are automatically recorded once first publisher starts) in an ongoing session, now publishing a stream when no publishers are active in the session won't start automatically a new recording.\n\n\nActive sessions retrieval now returns sessions created with REST API or server SDKs that have not received any client connection (before this fix they would not be returned until some user had connected to it)\n\n\nCall Detail Record: recordingStopped event for INDIVIDUAL recordings wasn't updating their duration and size values (both properties had value 0)\n\n\nstreamPropertyChanged event was firing an exception in the browser for streams for which a user wasn't subscribed to.\n\n\nAvoid 500 error when sending no body on POST operations of the REST API, such as POST /api/sessions\n\n\nMinor bug fixes in openvidu-java-client.\n\n\n\n\n\n\nOpenVidu Pro\n\n\nWe are excited to announce OpenVidu Pro: a commercial tier for OpenVidu platform. Check it out \nhere\n.\n\n\n\n\n\n\n2.8.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.8.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.8.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.8.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.8.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.8.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.8.1\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.8.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-webcomponent\n\n    \nZIP\n\n    \n2.8.0\n\n    \nGitHub\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-angular\n\n    \nNPM package\n\n    \n2.8.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-react\n\n    \nNPM package\n\n    \n2.8.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nKurento Media Server\n\n    \nUbuntu package\n\n    \n6.9.0\n\n    \nKurento Docs\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\nNEW FEATURES\n\n\n\n\nIndividual stream recording\n\n\nFinally individual stream recording is available in OpenVidu. When recording a session you can now configure it to store each published stream in its own file.\n\n\nThis, on the one hand, gives developers lots of freedom to compose any kind of layout and achieve any kind of result once the recording has stopped, by using some post-processing video tool. On the other hand, this type of recording has proven to be 4x more efficient in comparison with previous grid recording in our first tests, allowing a better quality and a higher number of streams per recording, and more simultaneous recordings.\n\n\nWe have entirely rewritten \nRecording documentation\n explaining all these new features. Take a look at it!\n\n\n\n\nAudio-only and video-only recording\n\n\nConfigure your recordings to be audio-only or video-only. This is available for both \nCOMPOSED\n and \nINDIVIDUAL\n recordings. It is worth mentioning that audio-only \nCOMPOSED\n recordings takes advantage of the new recording capabilities introduced in this release to make it an extremley efficient process. Check out the \nfull documentation\n on this subject.\n\n\n\n\nOther improvements\n\n\n\n\nNew property \nresolution\n when starting recordings. With it you can set the width and height in pixels of the recorded file. This is only available for \nCOMPOSED\n recordings. \nINDIVIDUAL\n recordings will always record the video files with the native resolution of each video stream\n\n\nAutomatic stop of recordings is greatly improved. Check it out \nhere\n\n\nNew property \nStream.creationTime\n in OpenVidu Browser. This is the time when a stream was created in OpenVidu Server. Reflects the real starting time of the media stream transmission on the server side.\n\n\nOpenVidu Server now destroys any stranded recording container left on the host on start up. This allows keeping the host machine clean when restarting the service\n\n\nNew REST method available in OpenVidu Server: \nGET /config\n. You can consult OpenVidu Server version and all active configuration properties with it. Check it out \nhere\n.\n\n\n\n\n\n\nBUG FIXES\n\n\n\n\nFixed a problem that was causing unexpected websocket disconnections from OpenVidu Server due to HttpSessions expiring after half an hour. It has been fixed by adding real reconnection capailities to websockets established from clients. This also fixes a problem with recordings longer than 30 minutes sometimes failing. \nIssue \n#146\n\n\nRecording layout improved: default BEST_FIT layout used in COMPOSED recordings was including small black bars in the upper and left margins of the layout, that were visible in the final video file. This is now fixed.\n\n\nopenvidu-browser: property \nConnection.creationTime\n now has real value (brought from OpenVidu Server) instead of a local value. Now it reflects the real time some user connected to the Session. \nIssue \n#170\n\n\nopenvidu-call: now when setting a screen-share stream in full-screen mode, aspect ratio is preserved to avoid loss of information\n\n\n\n\n\n\nBREAKING CHANGES\n\n\nEven though this is not a major update with incompatibility changes according to \nsemver\n, there are in fact a couple of changes that are worth mentioning:\n\n\n\n\nRecorded files folder structure has changed: each recording is stored now in its own folder, named after the unique recording id. This doesn't affect the recordings management through REST API, openvidu-java-client or openvidu-node-client. But if you were locally managing the recordings, then a new folder structure is expected now.\n\n\nopenvidu-node-client: Recording properties \nRecording.hasAudio\n, \nRecording.hasVideo\n and  \nRecording.name\n have been included into new \nRecording.properties\n attribute: \nRecording.properties.hasAudio\n, \nRecording.properties.hasVideo\n and \nRecording.properties.name\n\n\n\n\n\n\n\n\n\n\n2.7.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.7.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.7.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.7.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.7.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.7.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.5.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.5.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-webcomponent\n\n    \nZIP\n\n    \n2.7.0\n\n    \nGitHub\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-angular\n\n    \nNPM package\n\n    \n2.7.1\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-react\n\n    \nNPM package\n\n    \n2.7.1\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nKurento Media Server\n\n    \nUbuntu package\n\n    \n6.8.1\n\n    \nKurento Docs\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\nNEW FEATURES\n\n\n\n\nSafari support\n\n\nOpenVidu finally brings Safari to its collection of supported platforms. Two things to take into account when developing a Safari compatible application:\n\n\n\n\nIf there are gonna be other types of clients rather than Safari connecting to the same session, then transcoding will be necessary in OpenVidu Server. This will bring up CPU load significantly. This behavior is due to Safari not supporting any other codec than H264, when rest of platforms usually prefer VP8. Good news is this is a problem that will soon fix on its own: Safari will support VP8 in the near future (see \nRelease 68 Notes\n)\n\n\nA little hack is needed in your app if your Safari users are gonna have \nSUBSCRIBER\n role (only receiving video, without accessing their microphone or camera). \nLearn more here\n\n\n\n\n\n\nIonic support for iOS\n\n\nApple support is completed with Ionic platform for iOS. Now you can implement an Ionic app that will compile OK into an iOS native application. Our \nopenvidu-ionic\n tutorial is now fully compatible with iPhones and iPads. We recommend to use it as a starting point for your Android/iOS application, but in openvidu-ionic tutorial you also have everything you need to integrate OpenVidu in any Ionic app. Take a look at it!\n\n\n\n\nNew event \nstreamAudioVolumeChange\n\n\nYou can now listen to volume changes in any Publisher or Subscriber object. You can, for example, add a real-time audio wave or perform some action when certain level of noise or silence is reached. More details \nhere\n.\n\n\nBUG FIXES\n\n\n\n\n\n\nRecording layout now internally hides cursor (no need of styling the layout with \ncursor:none\n). \nIssue \n#138\n\n\nRecording stopping process reinforced to terminate and gracefully generate video files for failed recording containers (those that do not receive any video from the session caused by a misconfiguration or a wrong custom recording layout). This will help getting rid off dead containers and keeping OpenVidu Server clean. \nIssue \n#148\n\n\nMirroring local video fix: when changing to screen-share, local video is now un-mirrored, and viceversa. \nIssue \n#13\n\n\nSessions configured with \nRecording.MANUAL\n now automatically stop their recording if last participant left the session and no user published to the same session in 2 minutes. \nIssue \n#149\n\n\nPublisher.publishAudio\n and \nPublisher.publishVideo\n may be called without having initialized a Session or having called \nSession.publish(Publisher)\n\n\n\n\n\n\n\n\n\n\n2.6.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.6.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.6.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.6.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.6.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.6.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.5.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.5.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-webcomponent\n\n    \nZIP\n\n    \n2.6.0\n\n    \nGitHub\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-angular\n\n    \nNPM package\n\n    \n2.6.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-react\n\n    \nNPM package\n\n    \n2.6.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nKurento Media Server\n\n    \nUbuntu package\n\n    \n6.8.1\n\n    \nKurento Docs\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\nNEW FEATURES\n\n\n\n\nIonic support\n\n\nThere's a \ncomplete tutorial\n in OpenVidu Docs to get a native Android app working with OpenVidu in just a few steps. You can just clone and use our sample application as a starting point or maybe you want to add OpenVidu to your existing Ionic app. \nHere you have\n the necessary configuration steps to do so (basically Android permissions stuff).\n\n\nWe are currently working on making OpenVidu work on iOS with Ionic.\n\n\n\n\nNew types of filters supported\n\n\nOpenVidu 2.5.0 brought a fantastic and a differentiating element: \nreal time audio and video filters\n. Now we have extended this capability to support new GStreamer based filters such as \ntextoverlay\n, \ntimeoverlay\n or \nclockoverlay\n.\n\n\nYou can embed any text, the timestamp of the video or the current time, easily customizing its position and format. Check these filters in \nGStreamer section\n of filters documentation.\n\n\n\n\nRecording service now generates a thumbnail when stopping the recording\n\n\nWhenever you stop the recording of a session, OpenVidu will automatically generate a thumbnail for the video, getting it from the middle of the video timeline. You can access it from\u00a0\nhttps://OPENVIDU_SERVER_IP:4443/recordings/RECORDING_NAME.jpg\n\n\nDo not worry about their lifecycle: they are linked to the video file itself. If you decide to delete the recording, thumbnail will also be deleted.\n\n\nBUG FIXES\n\n\n\n\nImportant fix for increasing success rate in establishing media connections\n\n\nTime ago we ran into a pretty ugly bug that was causing some problems during WebRTC negotiation, resulting in some clients located in complex networks (like a company's WiFi network) not being able to connect to OpenVidu Server. What developers perceived was that in certain scenarios some users simply couldn't receive or send any media connection.\n\n\nThis bug has been completely solved in OpenVidu 2.6.0. Now media connections will work fine in almost every client network configuration.\n\n\n\n\n\n\n\n\n2.5.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.5.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.5.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.5.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.5.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.5.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.5.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.5.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-webcomponent\n\n    \nZIP\n\n    \n2.5.0\n\n    \nGitHub\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-angular\n\n    \nNPM package\n\n    \n2.5.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-react\n\n    \nNPM package\n\n    \n2.5.0\n\n    \nNPM\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\nNEW FEATURES\n\n\n\n\nKurento filters support\n\n\nOpenVidu API offers a simple way of applying filters to video and audio streams in the server side by making use of Kurento Media Server capabilities. See \nVoice and video filters\n section to learn more.\n\n\n\n\nIndividual user configuration for maximum/minimum bandwidth\n\n\nIn version 2.3.0 we introduced \n4 new configuration parameters for OpenVidu Server\n that allow the limitation of the video bandwidth both sent and received to/from OpenVidu Server, affecting all video streams in a global manner. Now it is possible to specifically configure certain input and output bandwidth for every user connected to a session. This way you can customize the bandwidth for each Publisher and Subscriber object of each Connection object. Users with no specific configuration will use the global values.\n\n\nYou can set custom bandwidths by using \nREST API\n, \nopenvidu-java-client\n or \nopenvidu-node-client\n:\n\n\n\n\n\n\nREST API\n: in \nPOST /api/tokens\n append a property in the json body like this\n\n\n\"kurentoOptions\": {\n  \"videoMaxRecvBandwidth\": 1000,\n  \"videoMinRecvBandwidth\": 1000,\n  \"videoMaxSendBandwidth\": 1000,\n  \"videoMinSendBandwidth\": 1000\n}\n\n\n\n\n\n\n\nopenvidu-java-client\n: build your tokens like this\n\n\nKurentoOptions kurentoOptions = new KurentoOptions.Builder()\n  .videoMaxRecvBandwidth(1000)\n  .videoMinRecvBandwidth(1000)\n  .videoMaxSendBandwidth(1000)\n  .videoMinSendBandwidth(1000)\n  .build();\nTokenOptions tokenOptions = new TokenOptions.Builder()\n  .data(\"User data\")\n  .role(OpenViduRole.PUBLISHER)\n  .kurentoOptions(kurentoOptions)\n  .build();\nString myToken = mySession.generateToken(tokenOptions);\n\n\n\n\n\n\n\nopenvidu-node-client\n: build your tokens like this\n\n\nvar tokenOptions = {\n    data: \"User data\",\n    role: OpenViduRole.PUBLISHER,\n    kurentoOptions: {\n      videoMaxRecvBandwidth: 1000,\n      videoMinRecvBandwidth: 1000,\n      videoMaxSendBandwidth: 1000,\n      videoMinSendBandwidth: 1000\n    }\n};\nmySession.generateToken(tokenOptions).then(token =\n { ... } );\n\n\n\n\n\n\n\n\n\nREST API and Server SDKs improvements\n\n\n\n\n\n\nConnection\n objects have a brand new property very useful for session analysis: \nplatform\n. It carries a complete description of the platform used by the client to connect to your session. For example: \n\"Chrome 69.0.3497.81 on OS X 10.13.6 64-bit\"\n or \n\"Firefox Mobile 62.0 on Mobile (Android 8.1.0)\"\n\n\nYou can get this information by retrieving session information with the REST api (\nGET /api/sessions\n or \nGET /api/sessions/SESSION_ID\n) or inspecting \nopenvidu-java-client\n and \nopenvidu-node-client\n Session objects: calling \nSession.fetch()\n or \nOpenVidu.fetch()\n will update the status of their \nactiveConnections\n property. Then you can check it out in \nopenvidu-node-client\n (property \nSession.activeConnections\n) or \nopenvidu-java-client\n (method \nSession.getActiveConnections()\n)\n\n\n\n\n\n\nSession\n, \nConnection\n and \nPublisher\n objects now have \ncreatedAt\n property, indicating when these objects where initialized in OpenVidu Server. This property has been integrated to maintain consistency with OpenVidu Server Call Detail Record, which has already been storing it in previous versions (check \n\"timestamp\"\n property of every \nCDR entry\n).\n\n\n\n\n\n\n\n\nOpenVidu Browser improvements\n\n\n\n\nNew method \nOpenVidu.checkScreenSharingCapabilities()\n. It allows developers to know if the client platform supports screen sharing (see its declaration in \nOpenVidu Documentation\n)\n\n\n\n\n\n\nNew OpenVidu Angular and OpenVidu React libraries\n\n\nWe introduced OpenVidu Web Component in release \n2.3.0\n. Now we offer native libraries for both Angular and React (latest versions) to insert the same powerful component in your applications by making use of each framework capabilities. You can check a tutorial for OpenVidu Angular (\nopenvidu-library-angular\n) and  for OpenVidu React (\nopenvidu-library-react\n) right now.\n\n\nOf course you can keep using OpenVidu Browser library instead of these components in any frontend framework. These tutorials show a basic use of OpenVidu Browser in an Angular app (\nopenvidu-insecure-angular\n) and in a React app (\nopenvidu-insecure-react\n).\n\n\nBUG FIXES\n\n\n\n\nLocal tracks now are not stopped on stream disposal if property \nPublisherProperties.videoSource\n was of type MediaStreamTrack (custom stream got with \nOpenVidu.getUserMedia()\n). \nIssue \n#107\n, PR \n#108\n\n\nDeprecated \nRTCPeerConnection.getRemoteStreams\n and \nRTCPeerConnection.getLocalStreams\n to \nRTCPeerConnection.getReceivers\n and \nRTCPeerConnection.getSenders\n. \nIssue \n#54\n\n\nAllow full screen sharing in Firefox. \nIssue \n#103\n, PR \n#105\n\n\nFixed duplicated camera permissions in Firefox if \nPublisherProperties.videoSource/audioSource\n are provided as MediaStreamTracks. \nPR \n#109\n\n\nopenvidu-node-client now rejects with Error object upon OpenVidu Server unreachable. \nIssue \n#116\n, PR \n#117\n\n\n\n\n\n\n\n\n\n\n2.4.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.4.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.4.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.4.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.4.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.4.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.4.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.4.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-webcomponent\n\n    \nZIP\n\n    \n2.4.0\n\n    \nGitHub\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\nNEW FEATURES\n\n\n\n\nOpenVidu Java Client and OpenVidu Node Client REST API support for v2.3.0\n\n\nBackend clients are now compatible with REST API 2.3.0, adding methods:\n\n\n\n\nSession.close()\n: close a Session from your backend\n\n\nSession.forceDisconnect()\n: force some user to leave a Session\n\n\nSession.forceUnpublish()\n: force some user to unpublish a Publisher from a Session\n\n\nSession.fetch()\n: bring Session information from OpenVidu Server\n\n\nOpenVidu.fetch()\n: bring information from every active Session from OpenVidu Server\n\n\n\n\nYou can call methods \nSession.fetch()\n and \nOpenVidu.fetch()\n to bring the current status of sessions from OpenVidu Server. You can consult now directly from \nOpenVidu Java Client\n / \nOpenVidu Node Client\n all the active sessions with \nOpenVidu.getActiveSessions()\n / \nOpenVidu.activeSessions\n and the active connections of a session with \nSession.getActiveConnections()\n / \nSession.activeConnections\n.\n\n\n\n\nOpenVidu CDR extended\n\n\nEvent \nrecordingStopped\n event now has \nreason\n property. Can be: \n\n\n\n\n\"recordingStoppedByServer\"\n: the recording was stopped by the application (using REST API, OpenVidu Java Client or OpenVidu Node Client)\n\n\n\"lastParticipantLeft\"\n: if the Session was configured for automatic recording (\nRecordingMode.ALWAYS\n, check \nOpenVidu Node Client\n docs for more info), then it stopped because the last participant left the session\n\n\n\"sessionClosedByServer\"\n: the recording stopped because the session was forcibly closed by the application (using REST API, OpenVidu Java Client or OpenVidu Node Client)\n\n\n\"openviduServerStopped\"\n: the recording stopped because OpenVidu Server process unexpectedly stopped (cannot be guaranteed)\n\n\n\n\n\n\nOpenVidu WebComponent improvements\n\n\n\n\nAdded a generic fullscreen button which will set as fullscreen element the entire component\n\n\nLocal video toolbar shown on fullscreen\n\n\nUser's nickname update process is now less intrusive (pop-up removed, simple text input instead)\n\n\nUpdated every dialog: now they appear inside of the component (center position), instead of appended to DOM body\n\n\nThe chat component is integrated in the layout for a better experience\n\n\nNew close chat button (top right corner)\n\n\nNew send button (bottom right corner)\n\n\nNew avatar user in each message. A new snapshot image will be displayed with each new message\n\n\n\n\nBUG FIXES\n\n\n\n\nOpenVidu Server dashboard test could sometimes fail because of a misuse of TURN server\n\n\nOpenVidu Java Client: pending requests bug fixed\n\n\nRemote Stream status properties are now properly updated when calling \nSession.publish\n, \nSession.unpublish\n and \nSession.publish\n for the same Publisher object (having unpublished audio or video in between the calls)\n\n\n\n\n\n\n\n\n\n\n2.3.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.3.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.3.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.3.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.3.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.3.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.2.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.2.0\n\n    \nNPM\n\n    \n\n  \n\nmedium\n  \n\n    \nopenvidu-webcomponent\n\n    \nZIP\n\n    \n2.3.0\n\n    \nGitHub\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\nOPENVIDU WEB COMPONENT\n\n\nOpenVidu platform now offers an easier way to get started: just include our new Web Component into your web and start enjoying video call capabilities with just 3 new lines of code:\n\n\nAdd to your \nindex.html\n OpenVidu Web Component files:\n\n\nlink rel=\nstylesheet\n href=\nopenvidu-webcomponent.css\n /\n\n\nscript src=\nopenvidu-webcomponent.js\n/script\n\n\n\n\n\nAnd add your video-call element wherever you want in your application:\n\n\nopenvidu-webcomponent session-config='{\nuser\n:\nNICKNAME\n, \ntoken\n:\nTOKEN\n}' theme=\ndark\n/openvidu-webcomponent\n\n\n\n\n\nBeing \nNICKNAME\n the user's name during the call and \nTOKEN\n one token generated in OpenVidu Server. Of course, if you want to connect users to the same session, the tokens should be generated for the same session.\nAttribute \ntheme\n can be \ndark\n or \nlight\n. Use the one that better fits your application.\n\n\nOpenVidu Web Component supports a reasonable amount of different dimensions, and every video displayed inside of it will be automatically relocated and resized for its optimal position upon window resizing. You can set the position, width and height of the component by styling it like this:\n\n\n\n\nSetting its property \nposition\n to \nabsolute\n or \nfixed\n, depending on your web layout and the desired behavior you want the component to have.\n\n\nPlaying with values:\n\n\nwidth\n\n\nheight\n\n\ntop\n or \nbottom\n\n\nright\n or \nleft\n\n\n\n\n\n\n\n\nFor example, the following CSS rule would position the upper OpenVidu Web Component in the bottom-right corner of your web, taking up half of the height of the page and a third of its width.\n\n\nopenvidu-webcomponent {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  width: 33vw;\n  height: 50vh;\n}\n\n\n\n\nIf you give enough width to the component (at least \n700px\n), users can communicate through an integrated chat.\n\n\n\n\nTo see some images of OpenVidu Web Component in action, check this post on \nMedium\n. If you want to learn more about OpenVidu Web Component, visit \nTutorials section\n\n\n\n\n\n\nNEW FEATURES\n\n\n\n\nStreamPropertyChangedEvent (See \nhere\n)\n\n\nOpenVidu Browser now lets users connected to a Session know when any Stream they are subscribed to undergoes any possible change in its properties. Every Session object will dispatch this new event (you can subscribe to it to every Publisher or Subscriber object too). This event can refer to the following Stream properties:\n\n\n\n\nStream.audioActive\n: this property may change if the user publishing the Stream calls \nPublisher.pusblishAudio(bool)\n.\n\n\nStream.videoActive\n: this property may change if the user publishing the Stream calls \nPublisher.publishVideo(bool)\n.\n\n\nStream.videoDimensions\n: this property may change if...\n\n\n...the user publishing the stream is screen-sharing and the shared window changes its dimensions.\n\n\n...the user is publishing from a mobile device and it is rotated (every camera from a phone will invert the resolution in the output video when rotated).\n\n\n\n\n\n\n\n\nSo, for example, now you can do:\n\n\nvar OV = new OpenVidu();\nvar session = OV.initSession();\nsession.on('streamPropertyChanged', event =\n {\n    if (event.changedProperty === 'audioActive') {\n        console.log('The state of the audio of the publisher has changed. Is enabled? -\n ' + event.newValue);\n    } else if (event.changedProperty === 'videoActive') {\n        console.log('The state of the video of the publisher has changed. Is enabled? -\n ' + event.newValue);\n    } else if (event.changedProperty === 'videoDimensions') {\n        console.log('The video dimensions of the publisher has changed. New dimensions: ' + event.newValue);\n    }\n});\n\n\n\n\nThis way you can react more easily upon this variations in the published streams and update your application's layout accordingly.\n\n\n\n\nSession.capabilities (See \nhere\n)\n\n\nYou can check capabilities property of Session object to know which methods are able to invoke each one of your clients, depending on their role. Also, if a client tries to call a method for which he has no permissions, now an OpenViduError is thrown with property \nname\n being \nOPENVIDU_PERMISSION_DENIED\n.\n\n\n\n\nNew MODERATOR role\n\n\nAt last developers have available the new role that has been in our roadmap for a long time. Users connecting to a session with a token configured with MODERATOR role can call every method granted for SUBSCRIBER and PUBLISHER roles, but also:\n\n\n\n\nSession.forceDisconnect\n: you can evict any user from the Session (force the method \nSession.disconnect\n)\n\n\nSession.forceUnpublish\n: you can stop the Publisher of any user publishing in the Session (force the method \nSession.unpublish\n)\n\n\n\n\n\n\nREST API extended\n\n\n5 new methods join the \nREST API of OpenVidu Server\n:\n\n\n\n\nRetrieve active session info: \nGET /api/sessions/\nSESSION_ID\n\n\nRetrieve all active sessions info: \nGET /api/sessions\n\n\nClose a session: \nDELETE /api/sessions/\nSESSION_ID\n\n\nForce the disconnection of a user from a session: \nDELETE /api/sessions/\nSESSION_ID\n/connection/\nCONNECTION_ID\n\n\nForce the unpublishing of a user's stream from a session: \nDELETE /api/sessions/\nSESSION_ID\n/stream/\nSTREAM_ID\n\n\n\n\n\n\nFuture iterations will add this capabilities to \nopenvidu-java-client\n and \nopenvidu-node-client\n libraries\n\n\n\n\n\n\nConfigure global bandwidth for your WebRTC connections\n\n\nWe have included a first way to set the maximum and minimum bandwidths for the media connections established between browsers and OpenVidu Server. You can configure it with the following system properties, as stated in \nOpenVidu Server configuration\n sections:\n\n\n\n\nopenvidu.streams.video.max-recv-bandwidth\n: Maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained (default 1000)\n\n\nopenvidu.streams.video.min-recv-bandwidth\n: Minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained (default 300)\n\n\nopenvidu.streams.video.max-send-bandwidth\n: Maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained (default 1000)\n\n\nopenvidu.streams.video.min-send-bandwidth\n: Minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained (default 300)\n\n\n\n\n\n\nFuture iterations will study the possibility of configuring this same parameters for each session individually or even for each incoming or outgoing WebRTC connection (maybe as part of \nPublisherProperties\n or \nSubscriberProperties\n)\n\n\n\n\n\n\n\n\n\n\n2.2.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.2.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.2.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.2.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.2.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.2.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.2.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.2.0\n\n    \nNPM\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\n\n\nOpenVidu now offers \nintegrated and automated support for TURN server\n. We encourage developers to check out our \npost on Medium\n to learn more about it.\n\n\nThe platform now integrates by default a COTURN server as part of its ecosystem. This means that media connections will work OK even when clients are located on restricted networks. When \ndeploying OpenVidu Server in Amazon Web Services\n with our Cloud Formation template no changes are required at all. If you are deploying OpenVidu Server on your own in an Ubuntu machine, installation instructions have changed a little bit. You have them properly updated \nhere\n.\n\n\n\n\n\n\n\n\n2.1.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.1.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.1.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.1.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.1.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.1.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.0.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.0.0\n\n    \nNPM\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\n\n\nNEW FEATURES\n\n\nOpenVidu Browser support for video management\n\n\nWe have implemented a new class in OpenVidu Browser aimed to better support declarative frontend frameworks such as Angular, React or Vue.js.\n\n\nNow Publisher and Subscriber objects both inherit from \nStreamManager\n, which provides 2 different methods to tell OpenVidu what DOM video players should display each specific stream (\naddVideoElement\n and \ncreateVideoElement\n). This allows us to let OpenVidu take control of the video elements (even if our framework dynamically creates them) and do not worry about its internals. This is all explained in detail in \nManage video players\n section.\n\n\nIf you want to check out a real example of this behavior, explore our renovated \nOpenVidu Angular tutorial\n.\n\n\n\n\n\n\n\n\n2.0.0\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible Version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n2.0.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n2.0.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n2.0.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n2.0.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n2.0.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n2.0.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n2.0.0\n\n    \nNPM\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\n\n\nThis is the first breaking change update for OpenVidu, which brings in lots of new features and internal improvements.\n\n\nNEW FEATURES\n\n\n\n\n\n\nOpenVidu Browser new methods\n\n\n\n\nSession.publish()\n: now returns a Promise so you can tell if the method was successful or not.\n\n\nSession.signal()\n: now returns a Promise so you can tell if the method was successful or not.\n\n\nSubcriber.subscribeToAudio()\n and \nSubscriber.subscribeToVideo()\n: new methods that allows you to mute the audio or video tracks of a remote stream.\n\n\n\n\nOpenVidu.initPublisher()\n: now expects properties as interface \nPublisherProperties\n. They include:\n\n\n{\n    audioSource: undefined, // The source of audio. If undefined default audio input\n    videoSource: undefined, // The source of video. If undefined default video input\n    publishAudio: true,     // Whether you want to start publishing with your audio unmuted or muted\n    publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n    resolution: '640x480',  // The resolution of your video\n    frameRate: 30,          // The frame rate of your video\n    insertMode: 'APPEND',   // How the video will be inserted in the target element\n    mirror: false           // Whether to mirror your local video or not\n}\n\n\n\n\n\n\n\nSession.subscribe()\n: now expects properties as interface \nSubscriberProperties\n. They include:\n\n\n{\n    insertMode: 'APPEND',   // How the video will be inserted in the target element\n    subscribeToAudio: true, // Whether to initially subscribe to the stream's audio track or not\n    subscribeToVideo: true  // Whether to initially subscribe to the stream's video track or not\n}\n\n\n\n\n\n\n\nOpenVidu.getDevices()\n: now you can use certain video or audio input device when calling \nOpenVidu.initPublisher()\n, thanks to properties \naudioSource\n or \nvideoSource\n of \nPublisherProperties\n object. Just set these variables to the property \ndeviceId\n of any of the devices returned by this method.\n\n\n\n\nOpenVidu.getUserMedia()\n: method improved. Now devs can customize a MediaStream object before calling \nOpenVidu.initPublisher()\n method, setting property \naudioSource\n or \nvideoSource\n to a MediaStreamTrack object (see \ndocs\n for further information)\n\n\n\n\n\n\n\n\nOpenVidu Browser new properties\n\n\n\n\nStream.frameRate\n: new property defining the frame rate of video streams. This property will only have value if the Publisher owning the stream has set property \nframeRate\n of \nPublisherProperties\n when calling \nOpenVidu.initPublisher()\n\n\n\n\n\n\n\n\nOpenVidu Browser events\n\n\n\n\nNew events \naccessDialogOpened\n and \naccessDialogClosed\n: dispatched by Publisher objects when the browser asks the user to grant permissions to camera or michrophone by opening a pop-up. You can use them to warn your users about it.\n\n\nNew events \nrecordingStarted\n and \nrecordingStopped\n: dispatched by Session object when the recording of a Session starts and stops. You can customize which clients will receive this event thanks to new property \nopenvidu.recording.notification\n (see \nOpenVidu Server configuration\n)\n\n\nEvents \npublisherStartSpeaking\n and \npublisherStopSpeaking\n improved: more customizable thanks to \nOpenVidu.setAdvancedConfiguration()\n and better overall performance.\n\n\nEvents \nstreamDestroyed\n, \nconnectionDestroyed\n and \nsessionDisconnected\n have new property \nreason\n. This gives more information about why the events have been dispatched so you can take specific actions depending on the context: maybe a stream has been destroyed because the user publishing has deliberately diposed it or maybe the network connection has unexpectedly closed (see docs for \nStreamEvent\n, \nConnectionEvent\n and \nSessionDisconnectedEvent\n)\n\n\n\n\n\n\n\n\nOther improvements in OpenVidu Browser\n\n\n\n\nSupport for \ncustom screen sharing extensions for Chrome\n\n\nSupport for custom STUN and TURN servers in openvidu-browser. Use \nOpenVidu.setAdvancedConfiguration()\n\n\nLibrary size decreased in almost 30% (\nopenvidu-browser.min.js\n from 300 KB to 216 KB)\n\n\n\n\n\n\n\n\nOpenVidu Server new features\n\n\n\n\nNew property \nname\n for recordings: you can now specify which name should OpenVidu Server give to each one of your recording files. You can do it by using the \nREST API\n (by setting \nbody parameter \"name\" in POST /api/recordings/start\n), \nopenvidu-java-client\n (by using \nRecordingProperties.Builder.name()\n) or \nopenvidu-node-client\n (by setting property \nRecordingProperties.name\n)\n\n\nNow support for initializing sessions with a custom \nsessionId\n. You can take advantage of this new property to facilitate the mapping between OpenVidu Server 'session' entities and your own 'session' entities. You can set it by using the \nREST API\n (by setting \nbody parameter \"customSessionId\" in POST /api/sessions\n), \nopenvidu-java-client\n (by using \nSessionProperties.Builder.customSessionId()\n) or \nopenvidu-node-client\n (by setting property \nSessionProperties.customSessionId\n)\n\n\nCall Detail Record extended: new events \nrecordingStarted\n and \nrecordingStopped\n, property \nreason\n for events \nsessionDestroyed\n, \nparticipantLeft\n and \nwebrtcConnectionDestroyed\n.\n\n\n\n\n\n\n\n\nBUG FIXES\n\n\n\n\nNow when any participant unexpectedly disconnects from a session (for example, due to a network failure), \nconnectionDestroyed\n event is sent to the rest of participants with property \nreason\n set to \nnetworkDisconnect\n.\n\n\nWhen OpenVidu Server is stopped, it will try to gracefully finish every in progress session and recording. This way no recording file will end corrupted upon OpenVidu Server termination (this cannot be granted if the process crashes or is forcibly terminated)\n\n\nNow both STUN and TURN \nOpenVidu Server configuration parameters\n can be set up at the same time with no overwritings.\n\n\nTons of small fixes and code refactoring that makes OpenVidu more stable and easy to test and develop\n\n\n\n\nBREAKING CHANGES LIST\n\n\n\n\n\n\nOpenVidu Browser\n\n\n\n\nOpenVidu.initSession\n now doesn't receive any input parameter.\n\n\nOpenVidu.initPublisher\n input parameters have changed. Now \nproperties\n parameter must match \nPublisherProperties\n interface.\n\n\nSession.connect\n method has been promisified. Change the last mandatory \ncallback\n parameter for a Promise implementation: \nsession.connect(token, (error) =\n { ... })\n to \nsession.connect(token).then(() =\n {...}).catch(error =\n {...});\n \n\n\n\n\n\n\n\n\nOpenVidu Java Client\n\n\n\n\nAll \nArchive\n entities are now called \nRecording\n. This includes: class \nArchive\n to \nRecording\n, class \nArchiveMode\n to \nRecordingMode\n, class \nArchiveLayout\n to \nRecordingLayout\n, method \nSessionProperties.archiveLayout()\n to \nSessionProperties.recordingLayout()\n, method \nSessionProperties.archiveMode()\n to \nSessionProperties.recordingMode()\n, method \nSessionProperties.Builder.archiveLayout()\n to \nSessionProperties.Builder.recordingLayout()\n, method \nSessionProperties.Builder.archiveMode()\n to \nSessionProperties.Builder.recordingMode()\n\n\nRecordingLayout\n property in \nSessionProperties.Builder\n is now configured calling method \ndefaultRecordingLayout()\n instead of \nrecordingLayout()\n. This means that if one Session is gonna be recorded more than once, each recording layout may be customize with \nRecordingProperties.Builder.recordingLayout()\n, which will overwrite the default one globally configured in SessionProperties object. \n\n\n\n\n\n\n\n\nOpenVidu Node Client\n\n\n\n\nWe have removed the builder pattern in all openvidu-node-client classes. Now objects are used instead, which includes classes \nTokenOptions\n, \nSessionProperties\n and \nRecordingProperties\n. For example, instead of getting a TokenOptions object like this: \nvar tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build()\n now it must be like this: \nvar tokenOptions = {data: serverData, role: role}\n\n\nThere has been a simple change in certain asynchronous call. Method \nSession.getSessionId()\n is now synchronous, but method \nOpenVidu.createSession()\n is now asynchronous (the reason is pretty simple: now method \ncreateSession\n implements the behavior that \ngetSessionId\n was providing the first time it was called for certain \nSession\n object).\n\n\nAll callback methods have been promisified. This includes method \nSession.generateToken(tokenOptions?, callback): void\n (now  \nSession.generateToken(tokenOptions?): Promise\nstring\n) and method \nSession.getSessionId(callback): void\n (now \nOpenVidu.createSession(): Promise\nSession\n, take also into account that the async call has changed from one method to the other as stated in the previous point).\n\n\nAll \nArchive\n entities are now called \nRecording\n. This includes: object \nArchive\n to \nRecording\n, object \nArchiveMode\n to \nRecordingMode\n, object \nArchiveLayout\n to \nRecordingLayout\n, method \nSessionProperties.archiveLayout()\n to \nSessionProperties.recordingLayout()\n, method \nSessionProperties.archiveMode()\n to \nSessionProperties.recordingMode()\n, method \nSessionProperties.Builder.archiveLayout()\n to \nSessionProperties.Builder.recordingLayout()\n, method \nSessionProperties.Builder.archiveMode()\n to \nSessionProperties.Builder.recordingMode()\n\n\nrecordingLayout\n property in \nSessionProperties\n has changed to \ndefaultRecordingLayout\n. This means that if one Session is gonna be recorded more than once, each recording layout may be customize with \nrecordingLayout\n property (of \nRecordingProperties\n interface, which will overwrite the default one globally configured in SessionProperties object. \n\n\n\n\n\n\n\n\nREST API\n\n\n\n\nAll \nArchive\n entities are now called \nRecording\n in API REST. For example: \n{\"archiveMode\": \"ARCHIVE_MODE\", \"archiveLayout\": \"ARCHIVE_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"}\n now is \n{\"recordingMode\": \"RECORDING_MODE\", \"recordingLayout\": \"RECORDING_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"}\n.\n\n\nField \nrecordingLayout\n is now called \ndefaultRecordingLayout\n in operation \nPOST /api/sessions\n. This means that if one Session is gonna be recorded more than once, each recording layout may be customize adding a new field \nrecordingLayout\n in the call to \nPOST /api/recordings/start\n of the API REST, which will overwrite the default one globally configured during \nPOST /api/sessions\n \n\n\n\n\n\n\n\n\nOther breaking changes\n\n\n\n\nOpenVidu Server default port from \n8443\n to \n4443\n\n\nOpenVidu Server configuration property \nopenvidu.recording.free-access\n is now \nopenvidu.recording.public-access\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.9.0-beta-1\n\n\nArtifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nCompatible version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n1.9.0-beta-1\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n1.9.0-beta-1\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n1.9.0-beta-1\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n1.9.0-beta-1\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n1.9.0-beta-1\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n1.8.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n1.8.0\n\n    \nNPM\n\n    \n\n  \n\n\n\n\n\n\nRelease Notes\n\n\n\n\n\n\nSafari support\n: now OpenVidu is compatible with the most recent versions of Safari in Mac and iOS. It is necessary to use Kurento Media Server 6.7.0:\n\n\nopenvidu/openvidu-server-kms:1.9.0-beta-1\n Docker image already incorporates KMS 6.7.0\n\n\nopenvidu/openvidu-server:1.9.0-beta-1\n Docker image and \nopenvidu-server-1.9.0-beta-1.jar\n need KMS 6.7.0. To install it, first be sure to completely uninstall and clean any previous version of KMS and then:\n\n\n\n\n\n\n\n\n# In first command: xenial for Ubuntu 16.04, trusty for Ubuntu 14.04\nsudo echo \"deb http://ubuntu.openvidu.io/6.7.0 xenial kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83\nsudo apt-get update\nsudo apt-get -y dist-upgrade\nsudo apt-get -y install kurento-media-server\nsudo apt-get -y install openh264-gst-plugins-bad-1.5\n\n\n\n\nTo start and stop KMS 6.7.0:\n\n\n\nsudo service kurento-media-server start\nsudo service kurento-media-server stop", 
            "title": "Releases"
        }, 
        {
            "location": "/releases/#290", 
            "text": "", 
            "title": "2.9.0"
        }, 
        {
            "location": "/releases/#artifacts", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.9.0 \n     NPM \n     \n   \n   \n     JS file \n     2.9.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.9.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.9.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.9.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.9.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.9.0 \n     NPM \n     \n   \n\n   \n     openvidu-webcomponent \n     ZIP \n     2.9.0 \n     GitHub \n     \n   \n\n   \n     openvidu-angular \n     NPM package \n     2.9.0 \n     NPM \n     \n   \n\n   \n     openvidu-react \n     NPM package \n     2.9.0 \n     NPM \n     \n   \n\n   \n     Kurento Media Server \n     Ubuntu package \n     6.10.0 \n     Kurento Docs", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#new-features", 
            "text": "", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#ubuntu-1804-bionic-support", 
            "text": "Our team has released Kurento 6.10.0, which can now be installed in Ubuntu 18.04 systems. This is a milestone we've been working on for quite some time, and we finally believe we're ready to launch official support for the newest Ubuntu LTS version. Deployment section in OpenVidu Docs is properly updated to inform about this.  We still consider Ubuntu Bionic to be in a preliminary support state, and some bugs may appear. In fact, we know for sure there's one limitation: no OpenCV filters will work in Ubuntu 18.04 at this moment. OpenVidu has supported audio and video filters for a long time now, and it is a cool feature that allows developers to implement some advanced audio and video real-time processing in the server side. But unfortunately Kurento has not been updated yet to support it in Bionic, so no FaceOverlayFilter or ChromaFilter will work in new Ubuntu version. But you can still use GStreamer filters!", 
            "title": "Ubuntu 18.04 bionic\u00a0support"
        }, 
        {
            "location": "/releases/#openvidu-server-boot-process-greatly-improved", 
            "text": "OpenVidu Server now checks all requiered conditions at boot time, which helps solving missconfiguration problems when deploying on Ubuntu. This includes every requirement related to permissions and installed software. If something is missing, wrong or there are not enough permissions in certain path, the OpenVidu Server process immediately exits with a clear description about what happened and a possible solution to fix it.  In our experience, this makes the process of installing OpenVidu Server directly in Ubuntu so much easier and manageable.", 
            "title": "OpenVidu Server boot process greatly\u00a0improved"
        }, 
        {
            "location": "/releases/#openvidu-reconnection-to-kurento-media-server", 
            "text": "If OpenVidu Server loses its connection to Kurento Media Server, now it will try to reconnect automatically. When it does so, if it is a new instance of Kurento, every stream of every previously active session will be destroyed with reason mediaServerDisconnect and every active recording will be stopped with same reason, but your users will not be disconnected from your sessions. This way you can directly re-publish and re-subscribe any desired stream right away.  This may help in case Kurento crashes: your users will have lost their media connections, but they will still be connected to their OpenVidu sessions and will only have to re-establish streams once OpenVidu Server is connected to a new Kurento instance.", 
            "title": "OpenVidu reconnection to Kurento Media\u00a0Server"
        }, 
        {
            "location": "/releases/#openvidu-upgrade-process", 
            "text": "Do you want to upgrade your OpenVidu deployment? Now you have a section entirely dedicated to it in the documentation. If you have deployed OpenVidu in AWS, it's as easy as launching a single command. If you have chosen Ubuntu deployment, then you will have to manually run some commands. Either way, you have available proper instructions now.", 
            "title": "OpenVidu upgrade\u00a0process"
        }, 
        {
            "location": "/releases/#native-screen-sharing-for-chrome", 
            "text": "OpenVidu has supported native screen-sharing for Firefox since its inception, but Google decided to have Chrome require an extension to allow screen-sharing. Finally they changed their mind and brought Chrome up to the standard, supporting getDisplayMedia API.  So, our client library openvidu-browser now supports native screen-sharing for Chrome\u226572. No extension needed for these browsers!", 
            "title": "Native screen-sharing for\u00a0Chrome"
        }, 
        {
            "location": "/releases/#openvidu-call-improvements", 
            "text": "Our best demo application has been updated with some exciting new features:   Users can now share their webcam and their screen at the same time.  The chat is better integrated now.  You can enlarge as many videos as you want, not just one. Available space will be automatically managed by the application for best fit.  Preview window for camera and mic selection has undergone many necessary fixes. Now it works fine in every OS and client supported by OpenVidu.\nopenvidu-call-ionic (Ionic version of OpenVidu Call for mobile devices) now supports Ionic 4 and works fine in iOS.ready to", 
            "title": "OpenVidu Call improvements"
        }, 
        {
            "location": "/releases/#bug-fixes", 
            "text": "For COMPOSED recording with video, when multiple screen sharing streams were being published it crashed. Now it doesn't.  For COMPOSED recordings with video, when stopping them immediatley after started, sometimes the generated video file would not be playable. Now in this cases failed status is set to this recordings, so you can take care of them properly.  After manually stopping ALWAYS recordings (sessions that are automatically recorded once first publisher starts) in an ongoing session, now publishing a stream when no publishers are active in the session won't start automatically a new recording.  Active sessions retrieval now returns sessions created with REST API or server SDKs that have not received any client connection (before this fix they would not be returned until some user had connected to it)  Call Detail Record: recordingStopped event for INDIVIDUAL recordings wasn't updating their duration and size values (both properties had value 0)  streamPropertyChanged event was firing an exception in the browser for streams for which a user wasn't subscribed to.  Avoid 500 error when sending no body on POST operations of the REST API, such as POST /api/sessions  Minor bug fixes in openvidu-java-client.", 
            "title": "BUG FIXES"
        }, 
        {
            "location": "/releases/#openvidu-pro", 
            "text": "We are excited to announce OpenVidu Pro: a commercial tier for OpenVidu platform. Check it out  here .", 
            "title": "OpenVidu Pro"
        }, 
        {
            "location": "/releases/#280", 
            "text": "", 
            "title": "2.8.0"
        }, 
        {
            "location": "/releases/#artifacts_1", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.8.0 \n     NPM \n     \n   \n   \n     JS file \n     2.8.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.8.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.8.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.8.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.8.1 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.8.0 \n     NPM \n     \n   \n\n   \n     openvidu-webcomponent \n     ZIP \n     2.8.0 \n     GitHub \n     \n   \n\n   \n     openvidu-angular \n     NPM package \n     2.8.0 \n     NPM \n     \n   \n\n   \n     openvidu-react \n     NPM package \n     2.8.0 \n     NPM \n     \n   \n\n   \n     Kurento Media Server \n     Ubuntu package \n     6.9.0 \n     Kurento Docs", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_1", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#new-features_1", 
            "text": "", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#individual-stream-recording", 
            "text": "Finally individual stream recording is available in OpenVidu. When recording a session you can now configure it to store each published stream in its own file.  This, on the one hand, gives developers lots of freedom to compose any kind of layout and achieve any kind of result once the recording has stopped, by using some post-processing video tool. On the other hand, this type of recording has proven to be 4x more efficient in comparison with previous grid recording in our first tests, allowing a better quality and a higher number of streams per recording, and more simultaneous recordings.  We have entirely rewritten  Recording documentation  explaining all these new features. Take a look at it!", 
            "title": "Individual stream recording"
        }, 
        {
            "location": "/releases/#audio-only-and-video-only-recording", 
            "text": "Configure your recordings to be audio-only or video-only. This is available for both  COMPOSED  and  INDIVIDUAL  recordings. It is worth mentioning that audio-only  COMPOSED  recordings takes advantage of the new recording capabilities introduced in this release to make it an extremley efficient process. Check out the  full documentation  on this subject.", 
            "title": "Audio-only and video-only recording"
        }, 
        {
            "location": "/releases/#other-improvements", 
            "text": "New property  resolution  when starting recordings. With it you can set the width and height in pixels of the recorded file. This is only available for  COMPOSED  recordings.  INDIVIDUAL  recordings will always record the video files with the native resolution of each video stream  Automatic stop of recordings is greatly improved. Check it out  here  New property  Stream.creationTime  in OpenVidu Browser. This is the time when a stream was created in OpenVidu Server. Reflects the real starting time of the media stream transmission on the server side.  OpenVidu Server now destroys any stranded recording container left on the host on start up. This allows keeping the host machine clean when restarting the service  New REST method available in OpenVidu Server:  GET /config . You can consult OpenVidu Server version and all active configuration properties with it. Check it out  here .", 
            "title": "Other improvements"
        }, 
        {
            "location": "/releases/#bug-fixes_1", 
            "text": "Fixed a problem that was causing unexpected websocket disconnections from OpenVidu Server due to HttpSessions expiring after half an hour. It has been fixed by adding real reconnection capailities to websockets established from clients. This also fixes a problem with recordings longer than 30 minutes sometimes failing.  Issue  #146  Recording layout improved: default BEST_FIT layout used in COMPOSED recordings was including small black bars in the upper and left margins of the layout, that were visible in the final video file. This is now fixed.  openvidu-browser: property  Connection.creationTime  now has real value (brought from OpenVidu Server) instead of a local value. Now it reflects the real time some user connected to the Session.  Issue  #170  openvidu-call: now when setting a screen-share stream in full-screen mode, aspect ratio is preserved to avoid loss of information", 
            "title": "BUG FIXES"
        }, 
        {
            "location": "/releases/#breaking-changes", 
            "text": "Even though this is not a major update with incompatibility changes according to  semver , there are in fact a couple of changes that are worth mentioning:   Recorded files folder structure has changed: each recording is stored now in its own folder, named after the unique recording id. This doesn't affect the recordings management through REST API, openvidu-java-client or openvidu-node-client. But if you were locally managing the recordings, then a new folder structure is expected now.  openvidu-node-client: Recording properties  Recording.hasAudio ,  Recording.hasVideo  and   Recording.name  have been included into new  Recording.properties  attribute:  Recording.properties.hasAudio ,  Recording.properties.hasVideo  and  Recording.properties.name", 
            "title": "BREAKING CHANGES"
        }, 
        {
            "location": "/releases/#270", 
            "text": "", 
            "title": "2.7.0"
        }, 
        {
            "location": "/releases/#artifacts_2", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.7.0 \n     NPM \n     \n   \n   \n     JS file \n     2.7.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.7.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.7.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.7.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.5.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.5.0 \n     NPM \n     \n   \n\n   \n     openvidu-webcomponent \n     ZIP \n     2.7.0 \n     GitHub \n     \n   \n\n   \n     openvidu-angular \n     NPM package \n     2.7.1 \n     NPM \n     \n   \n\n   \n     openvidu-react \n     NPM package \n     2.7.1 \n     NPM \n     \n   \n\n   \n     Kurento Media Server \n     Ubuntu package \n     6.8.1 \n     Kurento Docs", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_2", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#new-features_2", 
            "text": "", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#safari-support", 
            "text": "OpenVidu finally brings Safari to its collection of supported platforms. Two things to take into account when developing a Safari compatible application:   If there are gonna be other types of clients rather than Safari connecting to the same session, then transcoding will be necessary in OpenVidu Server. This will bring up CPU load significantly. This behavior is due to Safari not supporting any other codec than H264, when rest of platforms usually prefer VP8. Good news is this is a problem that will soon fix on its own: Safari will support VP8 in the near future (see  Release 68 Notes )  A little hack is needed in your app if your Safari users are gonna have  SUBSCRIBER  role (only receiving video, without accessing their microphone or camera).  Learn more here", 
            "title": "Safari support"
        }, 
        {
            "location": "/releases/#ionic-support-for-ios", 
            "text": "Apple support is completed with Ionic platform for iOS. Now you can implement an Ionic app that will compile OK into an iOS native application. Our  openvidu-ionic  tutorial is now fully compatible with iPhones and iPads. We recommend to use it as a starting point for your Android/iOS application, but in openvidu-ionic tutorial you also have everything you need to integrate OpenVidu in any Ionic app. Take a look at it!", 
            "title": "Ionic support for iOS"
        }, 
        {
            "location": "/releases/#new-event-streamaudiovolumechange", 
            "text": "You can now listen to volume changes in any Publisher or Subscriber object. You can, for example, add a real-time audio wave or perform some action when certain level of noise or silence is reached. More details  here .", 
            "title": "New event streamAudioVolumeChange"
        }, 
        {
            "location": "/releases/#bug-fixes_2", 
            "text": "Recording layout now internally hides cursor (no need of styling the layout with  cursor:none ).  Issue  #138  Recording stopping process reinforced to terminate and gracefully generate video files for failed recording containers (those that do not receive any video from the session caused by a misconfiguration or a wrong custom recording layout). This will help getting rid off dead containers and keeping OpenVidu Server clean.  Issue  #148  Mirroring local video fix: when changing to screen-share, local video is now un-mirrored, and viceversa.  Issue  #13  Sessions configured with  Recording.MANUAL  now automatically stop their recording if last participant left the session and no user published to the same session in 2 minutes.  Issue  #149  Publisher.publishAudio  and  Publisher.publishVideo  may be called without having initialized a Session or having called  Session.publish(Publisher)", 
            "title": "BUG FIXES"
        }, 
        {
            "location": "/releases/#260", 
            "text": "", 
            "title": "2.6.0"
        }, 
        {
            "location": "/releases/#artifacts_3", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.6.0 \n     NPM \n     \n   \n   \n     JS file \n     2.6.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.6.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.6.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.6.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.5.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.5.0 \n     NPM \n     \n   \n\n   \n     openvidu-webcomponent \n     ZIP \n     2.6.0 \n     GitHub \n     \n   \n\n   \n     openvidu-angular \n     NPM package \n     2.6.0 \n     NPM \n     \n   \n\n   \n     openvidu-react \n     NPM package \n     2.6.0 \n     NPM \n     \n   \n\n   \n     Kurento Media Server \n     Ubuntu package \n     6.8.1 \n     Kurento Docs", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_3", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#new-features_3", 
            "text": "", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#ionic-support", 
            "text": "There's a  complete tutorial  in OpenVidu Docs to get a native Android app working with OpenVidu in just a few steps. You can just clone and use our sample application as a starting point or maybe you want to add OpenVidu to your existing Ionic app.  Here you have  the necessary configuration steps to do so (basically Android permissions stuff).  We are currently working on making OpenVidu work on iOS with Ionic.", 
            "title": "Ionic support"
        }, 
        {
            "location": "/releases/#new-types-of-filters-supported", 
            "text": "OpenVidu 2.5.0 brought a fantastic and a differentiating element:  real time audio and video filters . Now we have extended this capability to support new GStreamer based filters such as  textoverlay ,  timeoverlay  or  clockoverlay .  You can embed any text, the timestamp of the video or the current time, easily customizing its position and format. Check these filters in  GStreamer section  of filters documentation.", 
            "title": "New types of filters supported"
        }, 
        {
            "location": "/releases/#recording-service-now-generates-a-thumbnail-when-stopping-the-recording", 
            "text": "Whenever you stop the recording of a session, OpenVidu will automatically generate a thumbnail for the video, getting it from the middle of the video timeline. You can access it from\u00a0 https://OPENVIDU_SERVER_IP:4443/recordings/RECORDING_NAME.jpg  Do not worry about their lifecycle: they are linked to the video file itself. If you decide to delete the recording, thumbnail will also be deleted.", 
            "title": "Recording service now generates a thumbnail when stopping the recording"
        }, 
        {
            "location": "/releases/#bug-fixes_3", 
            "text": "", 
            "title": "BUG FIXES"
        }, 
        {
            "location": "/releases/#important-fix-for-increasing-success-rate-in-establishing-media-connections", 
            "text": "Time ago we ran into a pretty ugly bug that was causing some problems during WebRTC negotiation, resulting in some clients located in complex networks (like a company's WiFi network) not being able to connect to OpenVidu Server. What developers perceived was that in certain scenarios some users simply couldn't receive or send any media connection.  This bug has been completely solved in OpenVidu 2.6.0. Now media connections will work fine in almost every client network configuration.", 
            "title": "Important fix for increasing success rate in establishing media connections"
        }, 
        {
            "location": "/releases/#250", 
            "text": "", 
            "title": "2.5.0"
        }, 
        {
            "location": "/releases/#artifacts_4", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.5.0 \n     NPM \n     \n   \n   \n     JS file \n     2.5.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.5.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.5.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.5.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.5.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.5.0 \n     NPM \n     \n   \n\n   \n     openvidu-webcomponent \n     ZIP \n     2.5.0 \n     GitHub \n     \n   \n\n   \n     openvidu-angular \n     NPM package \n     2.5.0 \n     NPM \n     \n   \n\n   \n     openvidu-react \n     NPM package \n     2.5.0 \n     NPM", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_4", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#new-features_4", 
            "text": "", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#kurento-filters-support", 
            "text": "OpenVidu API offers a simple way of applying filters to video and audio streams in the server side by making use of Kurento Media Server capabilities. See  Voice and video filters  section to learn more.", 
            "title": "Kurento filters support"
        }, 
        {
            "location": "/releases/#individual-user-configuration-for-maximumminimum-bandwidth", 
            "text": "In version 2.3.0 we introduced  4 new configuration parameters for OpenVidu Server  that allow the limitation of the video bandwidth both sent and received to/from OpenVidu Server, affecting all video streams in a global manner. Now it is possible to specifically configure certain input and output bandwidth for every user connected to a session. This way you can customize the bandwidth for each Publisher and Subscriber object of each Connection object. Users with no specific configuration will use the global values.  You can set custom bandwidths by using  REST API ,  openvidu-java-client  or  openvidu-node-client :    REST API : in  POST /api/tokens  append a property in the json body like this  \"kurentoOptions\": {\n  \"videoMaxRecvBandwidth\": 1000,\n  \"videoMinRecvBandwidth\": 1000,\n  \"videoMaxSendBandwidth\": 1000,\n  \"videoMinSendBandwidth\": 1000\n}    openvidu-java-client : build your tokens like this  KurentoOptions kurentoOptions = new KurentoOptions.Builder()\n  .videoMaxRecvBandwidth(1000)\n  .videoMinRecvBandwidth(1000)\n  .videoMaxSendBandwidth(1000)\n  .videoMinSendBandwidth(1000)\n  .build();\nTokenOptions tokenOptions = new TokenOptions.Builder()\n  .data(\"User data\")\n  .role(OpenViduRole.PUBLISHER)\n  .kurentoOptions(kurentoOptions)\n  .build();\nString myToken = mySession.generateToken(tokenOptions);    openvidu-node-client : build your tokens like this  var tokenOptions = {\n    data: \"User data\",\n    role: OpenViduRole.PUBLISHER,\n    kurentoOptions: {\n      videoMaxRecvBandwidth: 1000,\n      videoMinRecvBandwidth: 1000,\n      videoMaxSendBandwidth: 1000,\n      videoMinSendBandwidth: 1000\n    }\n};\nmySession.generateToken(tokenOptions).then(token =  { ... } );", 
            "title": "Individual user configuration for maximum/minimum bandwidth"
        }, 
        {
            "location": "/releases/#rest-api-and-server-sdks-improvements", 
            "text": "Connection  objects have a brand new property very useful for session analysis:  platform . It carries a complete description of the platform used by the client to connect to your session. For example:  \"Chrome 69.0.3497.81 on OS X 10.13.6 64-bit\"  or  \"Firefox Mobile 62.0 on Mobile (Android 8.1.0)\"  You can get this information by retrieving session information with the REST api ( GET /api/sessions  or  GET /api/sessions/SESSION_ID ) or inspecting  openvidu-java-client  and  openvidu-node-client  Session objects: calling  Session.fetch()  or  OpenVidu.fetch()  will update the status of their  activeConnections  property. Then you can check it out in  openvidu-node-client  (property  Session.activeConnections ) or  openvidu-java-client  (method  Session.getActiveConnections() )    Session ,  Connection  and  Publisher  objects now have  createdAt  property, indicating when these objects where initialized in OpenVidu Server. This property has been integrated to maintain consistency with OpenVidu Server Call Detail Record, which has already been storing it in previous versions (check  \"timestamp\"  property of every  CDR entry ).", 
            "title": "REST API and Server SDKs improvements"
        }, 
        {
            "location": "/releases/#openvidu-browser-improvements", 
            "text": "New method  OpenVidu.checkScreenSharingCapabilities() . It allows developers to know if the client platform supports screen sharing (see its declaration in  OpenVidu Documentation )", 
            "title": "OpenVidu Browser improvements"
        }, 
        {
            "location": "/releases/#new-openvidu-angular-and-openvidu-react-libraries", 
            "text": "We introduced OpenVidu Web Component in release  2.3.0 . Now we offer native libraries for both Angular and React (latest versions) to insert the same powerful component in your applications by making use of each framework capabilities. You can check a tutorial for OpenVidu Angular ( openvidu-library-angular ) and  for OpenVidu React ( openvidu-library-react ) right now.  Of course you can keep using OpenVidu Browser library instead of these components in any frontend framework. These tutorials show a basic use of OpenVidu Browser in an Angular app ( openvidu-insecure-angular ) and in a React app ( openvidu-insecure-react ).", 
            "title": "New OpenVidu Angular and OpenVidu React libraries"
        }, 
        {
            "location": "/releases/#bug-fixes_4", 
            "text": "Local tracks now are not stopped on stream disposal if property  PublisherProperties.videoSource  was of type MediaStreamTrack (custom stream got with  OpenVidu.getUserMedia() ).  Issue  #107 , PR  #108  Deprecated  RTCPeerConnection.getRemoteStreams  and  RTCPeerConnection.getLocalStreams  to  RTCPeerConnection.getReceivers  and  RTCPeerConnection.getSenders .  Issue  #54  Allow full screen sharing in Firefox.  Issue  #103 , PR  #105  Fixed duplicated camera permissions in Firefox if  PublisherProperties.videoSource/audioSource  are provided as MediaStreamTracks.  PR  #109  openvidu-node-client now rejects with Error object upon OpenVidu Server unreachable.  Issue  #116 , PR  #117", 
            "title": "BUG FIXES"
        }, 
        {
            "location": "/releases/#240", 
            "text": "", 
            "title": "2.4.0"
        }, 
        {
            "location": "/releases/#artifacts_5", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.4.0 \n     NPM \n     \n   \n   \n     JS file \n     2.4.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.4.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.4.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.4.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.4.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.4.0 \n     NPM \n     \n   \n\n   \n     openvidu-webcomponent \n     ZIP \n     2.4.0 \n     GitHub", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_5", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#new-features_5", 
            "text": "", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#openvidu-java-client-and-openvidu-node-client-rest-api-support-for-v230", 
            "text": "Backend clients are now compatible with REST API 2.3.0, adding methods:   Session.close() : close a Session from your backend  Session.forceDisconnect() : force some user to leave a Session  Session.forceUnpublish() : force some user to unpublish a Publisher from a Session  Session.fetch() : bring Session information from OpenVidu Server  OpenVidu.fetch() : bring information from every active Session from OpenVidu Server   You can call methods  Session.fetch()  and  OpenVidu.fetch()  to bring the current status of sessions from OpenVidu Server. You can consult now directly from  OpenVidu Java Client  /  OpenVidu Node Client  all the active sessions with  OpenVidu.getActiveSessions()  /  OpenVidu.activeSessions  and the active connections of a session with  Session.getActiveConnections()  /  Session.activeConnections .", 
            "title": "OpenVidu Java Client and OpenVidu Node Client REST API support for v2.3.0"
        }, 
        {
            "location": "/releases/#openvidu-cdr-extended", 
            "text": "Event  recordingStopped  event now has  reason  property. Can be:    \"recordingStoppedByServer\" : the recording was stopped by the application (using REST API, OpenVidu Java Client or OpenVidu Node Client)  \"lastParticipantLeft\" : if the Session was configured for automatic recording ( RecordingMode.ALWAYS , check  OpenVidu Node Client  docs for more info), then it stopped because the last participant left the session  \"sessionClosedByServer\" : the recording stopped because the session was forcibly closed by the application (using REST API, OpenVidu Java Client or OpenVidu Node Client)  \"openviduServerStopped\" : the recording stopped because OpenVidu Server process unexpectedly stopped (cannot be guaranteed)", 
            "title": "OpenVidu CDR extended"
        }, 
        {
            "location": "/releases/#openvidu-webcomponent-improvements", 
            "text": "Added a generic fullscreen button which will set as fullscreen element the entire component  Local video toolbar shown on fullscreen  User's nickname update process is now less intrusive (pop-up removed, simple text input instead)  Updated every dialog: now they appear inside of the component (center position), instead of appended to DOM body  The chat component is integrated in the layout for a better experience  New close chat button (top right corner)  New send button (bottom right corner)  New avatar user in each message. A new snapshot image will be displayed with each new message", 
            "title": "OpenVidu WebComponent improvements"
        }, 
        {
            "location": "/releases/#bug-fixes_5", 
            "text": "OpenVidu Server dashboard test could sometimes fail because of a misuse of TURN server  OpenVidu Java Client: pending requests bug fixed  Remote Stream status properties are now properly updated when calling  Session.publish ,  Session.unpublish  and  Session.publish  for the same Publisher object (having unpublished audio or video in between the calls)", 
            "title": "BUG FIXES"
        }, 
        {
            "location": "/releases/#230", 
            "text": "", 
            "title": "2.3.0"
        }, 
        {
            "location": "/releases/#artifacts_6", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.3.0 \n     NPM \n     \n   \n   \n     JS file \n     2.3.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.3.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.3.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.3.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.2.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.2.0 \n     NPM \n     \n   \nmedium\n   \n     openvidu-webcomponent \n     ZIP \n     2.3.0 \n     GitHub", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_6", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#openvidu-web-component", 
            "text": "OpenVidu platform now offers an easier way to get started: just include our new Web Component into your web and start enjoying video call capabilities with just 3 new lines of code:  Add to your  index.html  OpenVidu Web Component files:  link rel= stylesheet  href= openvidu-webcomponent.css  /  script src= openvidu-webcomponent.js /script   And add your video-call element wherever you want in your application:  openvidu-webcomponent session-config='{ user : NICKNAME ,  token : TOKEN }' theme= dark /openvidu-webcomponent   Being  NICKNAME  the user's name during the call and  TOKEN  one token generated in OpenVidu Server. Of course, if you want to connect users to the same session, the tokens should be generated for the same session.\nAttribute  theme  can be  dark  or  light . Use the one that better fits your application.  OpenVidu Web Component supports a reasonable amount of different dimensions, and every video displayed inside of it will be automatically relocated and resized for its optimal position upon window resizing. You can set the position, width and height of the component by styling it like this:   Setting its property  position  to  absolute  or  fixed , depending on your web layout and the desired behavior you want the component to have.  Playing with values:  width  height  top  or  bottom  right  or  left     For example, the following CSS rule would position the upper OpenVidu Web Component in the bottom-right corner of your web, taking up half of the height of the page and a third of its width.  openvidu-webcomponent {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  width: 33vw;\n  height: 50vh;\n}  If you give enough width to the component (at least  700px ), users can communicate through an integrated chat.   To see some images of OpenVidu Web Component in action, check this post on  Medium . If you want to learn more about OpenVidu Web Component, visit  Tutorials section", 
            "title": "OPENVIDU WEB COMPONENT"
        }, 
        {
            "location": "/releases/#new-features_6", 
            "text": "", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#streampropertychangedevent-see-here", 
            "text": "OpenVidu Browser now lets users connected to a Session know when any Stream they are subscribed to undergoes any possible change in its properties. Every Session object will dispatch this new event (you can subscribe to it to every Publisher or Subscriber object too). This event can refer to the following Stream properties:   Stream.audioActive : this property may change if the user publishing the Stream calls  Publisher.pusblishAudio(bool) .  Stream.videoActive : this property may change if the user publishing the Stream calls  Publisher.publishVideo(bool) .  Stream.videoDimensions : this property may change if...  ...the user publishing the stream is screen-sharing and the shared window changes its dimensions.  ...the user is publishing from a mobile device and it is rotated (every camera from a phone will invert the resolution in the output video when rotated).     So, for example, now you can do:  var OV = new OpenVidu();\nvar session = OV.initSession();\nsession.on('streamPropertyChanged', event =  {\n    if (event.changedProperty === 'audioActive') {\n        console.log('The state of the audio of the publisher has changed. Is enabled? -  ' + event.newValue);\n    } else if (event.changedProperty === 'videoActive') {\n        console.log('The state of the video of the publisher has changed. Is enabled? -  ' + event.newValue);\n    } else if (event.changedProperty === 'videoDimensions') {\n        console.log('The video dimensions of the publisher has changed. New dimensions: ' + event.newValue);\n    }\n});  This way you can react more easily upon this variations in the published streams and update your application's layout accordingly.", 
            "title": "StreamPropertyChangedEvent (See here)"
        }, 
        {
            "location": "/releases/#sessioncapabilities-see-here", 
            "text": "You can check capabilities property of Session object to know which methods are able to invoke each one of your clients, depending on their role. Also, if a client tries to call a method for which he has no permissions, now an OpenViduError is thrown with property  name  being  OPENVIDU_PERMISSION_DENIED .", 
            "title": "Session.capabilities (See here)"
        }, 
        {
            "location": "/releases/#new-moderator-role", 
            "text": "At last developers have available the new role that has been in our roadmap for a long time. Users connecting to a session with a token configured with MODERATOR role can call every method granted for SUBSCRIBER and PUBLISHER roles, but also:   Session.forceDisconnect : you can evict any user from the Session (force the method  Session.disconnect )  Session.forceUnpublish : you can stop the Publisher of any user publishing in the Session (force the method  Session.unpublish )", 
            "title": "New MODERATOR role"
        }, 
        {
            "location": "/releases/#rest-api-extended", 
            "text": "5 new methods join the  REST API of OpenVidu Server :   Retrieve active session info:  GET /api/sessions/ SESSION_ID  Retrieve all active sessions info:  GET /api/sessions  Close a session:  DELETE /api/sessions/ SESSION_ID  Force the disconnection of a user from a session:  DELETE /api/sessions/ SESSION_ID /connection/ CONNECTION_ID  Force the unpublishing of a user's stream from a session:  DELETE /api/sessions/ SESSION_ID /stream/ STREAM_ID    Future iterations will add this capabilities to  openvidu-java-client  and  openvidu-node-client  libraries", 
            "title": "REST API extended"
        }, 
        {
            "location": "/releases/#configure-global-bandwidth-for-your-webrtc-connections", 
            "text": "We have included a first way to set the maximum and minimum bandwidths for the media connections established between browsers and OpenVidu Server. You can configure it with the following system properties, as stated in  OpenVidu Server configuration  sections:   openvidu.streams.video.max-recv-bandwidth : Maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained (default 1000)  openvidu.streams.video.min-recv-bandwidth : Minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained (default 300)  openvidu.streams.video.max-send-bandwidth : Maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained (default 1000)  openvidu.streams.video.min-send-bandwidth : Minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained (default 300)    Future iterations will study the possibility of configuring this same parameters for each session individually or even for each incoming or outgoing WebRTC connection (maybe as part of  PublisherProperties  or  SubscriberProperties )", 
            "title": "Configure global bandwidth for your WebRTC connections"
        }, 
        {
            "location": "/releases/#220", 
            "text": "", 
            "title": "2.2.0"
        }, 
        {
            "location": "/releases/#artifacts_7", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.2.0 \n     NPM \n     \n   \n   \n     JS file \n     2.2.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.2.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.2.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.2.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.2.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.2.0 \n     NPM", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_7", 
            "text": "OpenVidu now offers  integrated and automated support for TURN server . We encourage developers to check out our  post on Medium  to learn more about it.  The platform now integrates by default a COTURN server as part of its ecosystem. This means that media connections will work OK even when clients are located on restricted networks. When  deploying OpenVidu Server in Amazon Web Services  with our Cloud Formation template no changes are required at all. If you are deploying OpenVidu Server on your own in an Ubuntu machine, installation instructions have changed a little bit. You have them properly updated  here .", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#210", 
            "text": "", 
            "title": "2.1.0"
        }, 
        {
            "location": "/releases/#artifacts_8", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.1.0 \n     NPM \n     \n   \n   \n     JS file \n     2.1.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.1.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.1.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.1.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.0.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.0.0 \n     NPM", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_8", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#new-features_7", 
            "text": "OpenVidu Browser support for video management  We have implemented a new class in OpenVidu Browser aimed to better support declarative frontend frameworks such as Angular, React or Vue.js.  Now Publisher and Subscriber objects both inherit from  StreamManager , which provides 2 different methods to tell OpenVidu what DOM video players should display each specific stream ( addVideoElement  and  createVideoElement ). This allows us to let OpenVidu take control of the video elements (even if our framework dynamically creates them) and do not worry about its internals. This is all explained in detail in  Manage video players  section.  If you want to check out a real example of this behavior, explore our renovated  OpenVidu Angular tutorial .", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#200", 
            "text": "", 
            "title": "2.0.0"
        }, 
        {
            "location": "/releases/#artifacts_9", 
            "text": "Artifact \n     Type \n     Compatible Version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     2.0.0 \n     NPM \n     \n   \n   \n     JS file \n     2.0.0 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     2.0.0 \n     GitHub \n     \n   \n   \n     Docker container \n     2.0.0 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     2.0.0 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     2.0.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     2.0.0 \n     NPM", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_9", 
            "text": "This is the first breaking change update for OpenVidu, which brings in lots of new features and internal improvements.", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#new-features_8", 
            "text": "OpenVidu Browser new methods   Session.publish() : now returns a Promise so you can tell if the method was successful or not.  Session.signal() : now returns a Promise so you can tell if the method was successful or not.  Subcriber.subscribeToAudio()  and  Subscriber.subscribeToVideo() : new methods that allows you to mute the audio or video tracks of a remote stream.   OpenVidu.initPublisher() : now expects properties as interface  PublisherProperties . They include:  {\n    audioSource: undefined, // The source of audio. If undefined default audio input\n    videoSource: undefined, // The source of video. If undefined default video input\n    publishAudio: true,     // Whether you want to start publishing with your audio unmuted or muted\n    publishVideo: true,     // Whether you want to start publishing with your video enabled or not\n    resolution: '640x480',  // The resolution of your video\n    frameRate: 30,          // The frame rate of your video\n    insertMode: 'APPEND',   // How the video will be inserted in the target element\n    mirror: false           // Whether to mirror your local video or not\n}    Session.subscribe() : now expects properties as interface  SubscriberProperties . They include:  {\n    insertMode: 'APPEND',   // How the video will be inserted in the target element\n    subscribeToAudio: true, // Whether to initially subscribe to the stream's audio track or not\n    subscribeToVideo: true  // Whether to initially subscribe to the stream's video track or not\n}    OpenVidu.getDevices() : now you can use certain video or audio input device when calling  OpenVidu.initPublisher() , thanks to properties  audioSource  or  videoSource  of  PublisherProperties  object. Just set these variables to the property  deviceId  of any of the devices returned by this method.   OpenVidu.getUserMedia() : method improved. Now devs can customize a MediaStream object before calling  OpenVidu.initPublisher()  method, setting property  audioSource  or  videoSource  to a MediaStreamTrack object (see  docs  for further information)     OpenVidu Browser new properties   Stream.frameRate : new property defining the frame rate of video streams. This property will only have value if the Publisher owning the stream has set property  frameRate  of  PublisherProperties  when calling  OpenVidu.initPublisher()     OpenVidu Browser events   New events  accessDialogOpened  and  accessDialogClosed : dispatched by Publisher objects when the browser asks the user to grant permissions to camera or michrophone by opening a pop-up. You can use them to warn your users about it.  New events  recordingStarted  and  recordingStopped : dispatched by Session object when the recording of a Session starts and stops. You can customize which clients will receive this event thanks to new property  openvidu.recording.notification  (see  OpenVidu Server configuration )  Events  publisherStartSpeaking  and  publisherStopSpeaking  improved: more customizable thanks to  OpenVidu.setAdvancedConfiguration()  and better overall performance.  Events  streamDestroyed ,  connectionDestroyed  and  sessionDisconnected  have new property  reason . This gives more information about why the events have been dispatched so you can take specific actions depending on the context: maybe a stream has been destroyed because the user publishing has deliberately diposed it or maybe the network connection has unexpectedly closed (see docs for  StreamEvent ,  ConnectionEvent  and  SessionDisconnectedEvent )     Other improvements in OpenVidu Browser   Support for  custom screen sharing extensions for Chrome  Support for custom STUN and TURN servers in openvidu-browser. Use  OpenVidu.setAdvancedConfiguration()  Library size decreased in almost 30% ( openvidu-browser.min.js  from 300 KB to 216 KB)     OpenVidu Server new features   New property  name  for recordings: you can now specify which name should OpenVidu Server give to each one of your recording files. You can do it by using the  REST API  (by setting  body parameter \"name\" in POST /api/recordings/start ),  openvidu-java-client  (by using  RecordingProperties.Builder.name() ) or  openvidu-node-client  (by setting property  RecordingProperties.name )  Now support for initializing sessions with a custom  sessionId . You can take advantage of this new property to facilitate the mapping between OpenVidu Server 'session' entities and your own 'session' entities. You can set it by using the  REST API  (by setting  body parameter \"customSessionId\" in POST /api/sessions ),  openvidu-java-client  (by using  SessionProperties.Builder.customSessionId() ) or  openvidu-node-client  (by setting property  SessionProperties.customSessionId )  Call Detail Record extended: new events  recordingStarted  and  recordingStopped , property  reason  for events  sessionDestroyed ,  participantLeft  and  webrtcConnectionDestroyed .", 
            "title": "NEW FEATURES"
        }, 
        {
            "location": "/releases/#bug-fixes_6", 
            "text": "Now when any participant unexpectedly disconnects from a session (for example, due to a network failure),  connectionDestroyed  event is sent to the rest of participants with property  reason  set to  networkDisconnect .  When OpenVidu Server is stopped, it will try to gracefully finish every in progress session and recording. This way no recording file will end corrupted upon OpenVidu Server termination (this cannot be granted if the process crashes or is forcibly terminated)  Now both STUN and TURN  OpenVidu Server configuration parameters  can be set up at the same time with no overwritings.  Tons of small fixes and code refactoring that makes OpenVidu more stable and easy to test and develop", 
            "title": "BUG FIXES"
        }, 
        {
            "location": "/releases/#breaking-changes-list", 
            "text": "OpenVidu Browser   OpenVidu.initSession  now doesn't receive any input parameter.  OpenVidu.initPublisher  input parameters have changed. Now  properties  parameter must match  PublisherProperties  interface.  Session.connect  method has been promisified. Change the last mandatory  callback  parameter for a Promise implementation:  session.connect(token, (error) =  { ... })  to  session.connect(token).then(() =  {...}).catch(error =  {...});       OpenVidu Java Client   All  Archive  entities are now called  Recording . This includes: class  Archive  to  Recording , class  ArchiveMode  to  RecordingMode , class  ArchiveLayout  to  RecordingLayout , method  SessionProperties.archiveLayout()  to  SessionProperties.recordingLayout() , method  SessionProperties.archiveMode()  to  SessionProperties.recordingMode() , method  SessionProperties.Builder.archiveLayout()  to  SessionProperties.Builder.recordingLayout() , method  SessionProperties.Builder.archiveMode()  to  SessionProperties.Builder.recordingMode()  RecordingLayout  property in  SessionProperties.Builder  is now configured calling method  defaultRecordingLayout()  instead of  recordingLayout() . This means that if one Session is gonna be recorded more than once, each recording layout may be customize with  RecordingProperties.Builder.recordingLayout() , which will overwrite the default one globally configured in SessionProperties object.      OpenVidu Node Client   We have removed the builder pattern in all openvidu-node-client classes. Now objects are used instead, which includes classes  TokenOptions ,  SessionProperties  and  RecordingProperties . For example, instead of getting a TokenOptions object like this:  var tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build()  now it must be like this:  var tokenOptions = {data: serverData, role: role}  There has been a simple change in certain asynchronous call. Method  Session.getSessionId()  is now synchronous, but method  OpenVidu.createSession()  is now asynchronous (the reason is pretty simple: now method  createSession  implements the behavior that  getSessionId  was providing the first time it was called for certain  Session  object).  All callback methods have been promisified. This includes method  Session.generateToken(tokenOptions?, callback): void  (now   Session.generateToken(tokenOptions?): Promise string ) and method  Session.getSessionId(callback): void  (now  OpenVidu.createSession(): Promise Session , take also into account that the async call has changed from one method to the other as stated in the previous point).  All  Archive  entities are now called  Recording . This includes: object  Archive  to  Recording , object  ArchiveMode  to  RecordingMode , object  ArchiveLayout  to  RecordingLayout , method  SessionProperties.archiveLayout()  to  SessionProperties.recordingLayout() , method  SessionProperties.archiveMode()  to  SessionProperties.recordingMode() , method  SessionProperties.Builder.archiveLayout()  to  SessionProperties.Builder.recordingLayout() , method  SessionProperties.Builder.archiveMode()  to  SessionProperties.Builder.recordingMode()  recordingLayout  property in  SessionProperties  has changed to  defaultRecordingLayout . This means that if one Session is gonna be recorded more than once, each recording layout may be customize with  recordingLayout  property (of  RecordingProperties  interface, which will overwrite the default one globally configured in SessionProperties object.      REST API   All  Archive  entities are now called  Recording  in API REST. For example:  {\"archiveMode\": \"ARCHIVE_MODE\", \"archiveLayout\": \"ARCHIVE_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"}  now is  {\"recordingMode\": \"RECORDING_MODE\", \"recordingLayout\": \"RECORDING_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"} .  Field  recordingLayout  is now called  defaultRecordingLayout  in operation  POST /api/sessions . This means that if one Session is gonna be recorded more than once, each recording layout may be customize adding a new field  recordingLayout  in the call to  POST /api/recordings/start  of the API REST, which will overwrite the default one globally configured during  POST /api/sessions       Other breaking changes   OpenVidu Server default port from  8443  to  4443  OpenVidu Server configuration property  openvidu.recording.free-access  is now  openvidu.recording.public-access", 
            "title": "BREAKING CHANGES LIST"
        }, 
        {
            "location": "/releases/#190-beta-1", 
            "text": "", 
            "title": "1.9.0-beta-1"
        }, 
        {
            "location": "/releases/#artifacts_10", 
            "text": "Artifact \n     Type \n     Compatible version \n     Link \n     Info \n   \n\n   \n     openvidu-browser \n     NPM package \n     1.9.0-beta-1 \n     NPM \n     \n   \n   \n     JS file \n     1.9.0-beta-1 \n     GitHub \n   \n\n   \n     openvidu-server \n     JAR \n     1.9.0-beta-1 \n     GitHub \n     \n   \n   \n     Docker container \n     1.9.0-beta-1 \n     DockerHub \n   \n     \n     Docker container (+KMS) \n     1.9.0-beta-1 \n     DockerHub \n   \n\n   \n     openvidu-java-client \n     MVN package \n     1.8.0 \n     MVN Repository \n     \n   \n\n   \n     openvidu-node-client \n     NPM package \n     1.8.0 \n     NPM", 
            "title": "Artifacts"
        }, 
        {
            "location": "/releases/#release-notes_10", 
            "text": "Safari support : now OpenVidu is compatible with the most recent versions of Safari in Mac and iOS. It is necessary to use Kurento Media Server 6.7.0:  openvidu/openvidu-server-kms:1.9.0-beta-1  Docker image already incorporates KMS 6.7.0  openvidu/openvidu-server:1.9.0-beta-1  Docker image and  openvidu-server-1.9.0-beta-1.jar  need KMS 6.7.0. To install it, first be sure to completely uninstall and clean any previous version of KMS and then:     # In first command: xenial for Ubuntu 16.04, trusty for Ubuntu 14.04\nsudo echo \"deb http://ubuntu.openvidu.io/6.7.0 xenial kms6\" | sudo tee /etc/apt/sources.list.d/kurento.list\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5AFA7A83\nsudo apt-get update\nsudo apt-get -y dist-upgrade\nsudo apt-get -y install kurento-media-server\nsudo apt-get -y install openh264-gst-plugins-bad-1.5  To start and stop KMS 6.7.0:  sudo service kurento-media-server start\nsudo service kurento-media-server stop", 
            "title": "Release Notes"
        }, 
        {
            "location": "/openvidu-pro/", 
            "text": "OpenVidu Pro\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n    Current version of OpenVidu Pro matches \nversion 2.9.0\n of OpenVidu Community Edition. We are not currently charging anything for using OpenVidu Pro, as we intend these first versions to be a beta. The only price you will have to pay is the cost of the Amazon instance, as you would do when \ndeploying OpenVidu Community Edition in AWS\n\n\n\n\n\n\n\n\n    \nRun OpenVidu Pro\n\n\n\n\n\nWhy\n\n\nOpenVidu is an \nopen source project\n, and for sure will remain this way in the future. But OpenVidu team needs some source of income to continue working on this amazing project. The approach we'll be taking here is pretty straightforward: OpenVidu features themselves will always be open source, and only some tools or improvements related to \nproduction environments\n may end up being part of OpenVidu Pro stack. To sum up:\n\n\n\n\n\nYou will always be able to access OpenVidu awesome features and build whatever you want with them. Our intention is to make OpenVidu platform long-term sustainable by offering \nadvanced production stage monitoring and management tools\n for those companies interested in such capabilities\n\n\n\n\n\n\n\n\nWhat\n\n\nOpenVidu Pro consists of different modules working over OpenVidu Community Edition. The ultimate goal of OpenVidu Pro is to offer \nautomated scalability and fault-tolerance\n integrated in most popular cloud providers, so your real-time communication systems can keep up with your business growth. But this will be available in future releases. For now OpenVidu Pro offers:\n\n\n\n\nOpenVidu Inspector\n: a powerful, easy-to-use and visually attractive dashboard that will help you monitor, manage and review all your videoconferences.\n\n\nDetail session monitoring\n: the Elastic stack integration provides a powerful and flexible way to monitor your sessions.\n\n\n\n\n\n    \n\n\n\n    OpenVidu Pro users will also have priority when contacting OpenVidu team with doubts about the platform.\nRemember we also offer \ncustom professional support\n\n\n\n\n\n\n\n\n\n\n\nHow\n\n\n\n\n\nOpenVidu Pro is available now through \nAmazon Web Services\n. Check out \nDeploying OpenVidu Pro\n section to learn how to do it in just a few minutes.\n\n\n\n\n\n\nPricing\n\n\nOpenVidu Pro will be priced through AWS Marketplace. Any piece of software offered in AWS Marketplace has two different charges: the cost of the AWS resources running the software and the cost of the software itself. Software manufacturers specify this second charge, and it is the only revenue they receive from the total cost of the stack. Having made this clear:\n\n\n\n\nThe moment you cancel your OpenVidu Pro subscription in AWS Marketplace, no more charges will be applied. You only pay for the time you are running the service.\n\n\nOpenVidu Pro is considered a beta version right now, and for this reason no extra fees will be charged for the software part.\n\n\n\n\n\n\n    \nRun OpenVidu Pro", 
            "title": "Home"
        }, 
        {
            "location": "/openvidu-pro/#why", 
            "text": "OpenVidu is an  open source project , and for sure will remain this way in the future. But OpenVidu team needs some source of income to continue working on this amazing project. The approach we'll be taking here is pretty straightforward: OpenVidu features themselves will always be open source, and only some tools or improvements related to  production environments  may end up being part of OpenVidu Pro stack. To sum up:   You will always be able to access OpenVidu awesome features and build whatever you want with them. Our intention is to make OpenVidu platform long-term sustainable by offering  advanced production stage monitoring and management tools  for those companies interested in such capabilities", 
            "title": "Why"
        }, 
        {
            "location": "/openvidu-pro/#what", 
            "text": "OpenVidu Pro consists of different modules working over OpenVidu Community Edition. The ultimate goal of OpenVidu Pro is to offer  automated scalability and fault-tolerance  integrated in most popular cloud providers, so your real-time communication systems can keep up with your business growth. But this will be available in future releases. For now OpenVidu Pro offers:   OpenVidu Inspector : a powerful, easy-to-use and visually attractive dashboard that will help you monitor, manage and review all your videoconferences.  Detail session monitoring : the Elastic stack integration provides a powerful and flexible way to monitor your sessions.   \n      \n    OpenVidu Pro users will also have priority when contacting OpenVidu team with doubts about the platform. Remember we also offer  custom professional support", 
            "title": "What"
        }, 
        {
            "location": "/openvidu-pro/#how", 
            "text": "OpenVidu Pro is available now through  Amazon Web Services . Check out  Deploying OpenVidu Pro  section to learn how to do it in just a few minutes.", 
            "title": "How"
        }, 
        {
            "location": "/openvidu-pro/#pricing", 
            "text": "OpenVidu Pro will be priced through AWS Marketplace. Any piece of software offered in AWS Marketplace has two different charges: the cost of the AWS resources running the software and the cost of the software itself. Software manufacturers specify this second charge, and it is the only revenue they receive from the total cost of the stack. Having made this clear:   The moment you cancel your OpenVidu Pro subscription in AWS Marketplace, no more charges will be applied. You only pay for the time you are running the service.  OpenVidu Pro is considered a beta version right now, and for this reason no extra fees will be charged for the software part.   \n     Run OpenVidu Pro", 
            "title": "Pricing"
        }, 
        {
            "location": "/openvidu-pro/openvidu-inspector/", 
            "text": "OpenVidu Inspector\n\n\n\n\n\n\n\nA powerful, easy-to-use and visually attractive dashboard that will help you monitor, manage and review all your videoconferences. Some features already available in the current version of OpenVidu Pro are:\n\n\n\n\n\n\nFull in-depth visualization of your ongoing video sessions\n\n\nReview each client connected to a video session and the media streams each one is sending and receiving. Our intuitive graph visualization will give you a complete summary of your sessions.\n\n\n\n    \n\n        \n\n        \n\n        \n\n        \n\n    \n\n\n\n\n\n\n\nModeration capabilities of ongoing video sessions\n\n\nThrough OpenVidu Inspector you are able to administrate your video sessions just by pressing buttons: cut the video or audio of any publisher, force the disconnection of any participant, start and stop the recording of any video session and close them whenever you want.\n\n\n\n    \n\n        \n\n        \n\n        \n\n    \n\n\n\n\n\n\n\nRecording management\n\n\nOpenVidu Inspector allows you to review all your recordings in a simple way. Preview them, download them or delete those you don't need anymore. Just with a couple of clicks.\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\n\n\nSession history\n\n\nEvery OpenVidu session event-flow is stored with great detail in OpenVidu Pro. This way you can review any past session in OpenVidu Inspector: its duration, the total streaming time, the users connected to it, who published and subscribed, the recordings started for the session... Lots of data to analyse your sessions once they are closed.\n\n\n\n    \n\n        \n\n        \n\n        \n\n    \n\n\n\n\n\n\n\nClient geographic location\n\n\nOpenVidu Pro is able to locate your clients by city and country to make easier the identification of the users connecting to your sessions. You can consult this property to OpenVidu Server whenever you want with REST API or any server SDK. You also have available this info in OpenVidu Inspector:\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\n\n\n\n\nThis product includes GeoLite2 data created by MaxMind, available from \nhttp://www.maxmind.com\n\n\n\n\nProgrammatic reset\n\n\nOpenVidu Pro supports programmatic reset. You may call a \nREST API method\n to restart your OpenVidu Server process. This way you can:\n\n\n\n\nA) Change OpenVidu Server \nconfiguration properties\n\n\nB) Easily clean up any garbage process or file that may have been stranded\n\n\n\n\nYou may also restart OpenVidu Server Pro directly in OpenVidu Inspector:\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    $('.pro-gallery').slick({\n      autoplay: true,\n      arrows: false,\n      autoplaySpeed: 3000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "OpenVidu Inspector"
        }, 
        {
            "location": "/openvidu-pro/openvidu-inspector/#full-in-depth-visualization-of-your-ongoing-video-sessions", 
            "text": "Review each client connected to a video session and the media streams each one is sending and receiving. Our intuitive graph visualization will give you a complete summary of your sessions.", 
            "title": "Full in-depth visualization of your ongoing video sessions"
        }, 
        {
            "location": "/openvidu-pro/openvidu-inspector/#moderation-capabilities-of-ongoing-video-sessions", 
            "text": "Through OpenVidu Inspector you are able to administrate your video sessions just by pressing buttons: cut the video or audio of any publisher, force the disconnection of any participant, start and stop the recording of any video session and close them whenever you want.", 
            "title": "Moderation capabilities of ongoing video sessions"
        }, 
        {
            "location": "/openvidu-pro/openvidu-inspector/#recording-management", 
            "text": "OpenVidu Inspector allows you to review all your recordings in a simple way. Preview them, download them or delete those you don't need anymore. Just with a couple of clicks.", 
            "title": "Recording management"
        }, 
        {
            "location": "/openvidu-pro/openvidu-inspector/#session-history", 
            "text": "Every OpenVidu session event-flow is stored with great detail in OpenVidu Pro. This way you can review any past session in OpenVidu Inspector: its duration, the total streaming time, the users connected to it, who published and subscribed, the recordings started for the session... Lots of data to analyse your sessions once they are closed.", 
            "title": "Session history"
        }, 
        {
            "location": "/openvidu-pro/openvidu-inspector/#client-geographic-location", 
            "text": "OpenVidu Pro is able to locate your clients by city and country to make easier the identification of the users connecting to your sessions. You can consult this property to OpenVidu Server whenever you want with REST API or any server SDK. You also have available this info in OpenVidu Inspector:  \n     \n         \n         This product includes GeoLite2 data created by MaxMind, available from  http://www.maxmind.com", 
            "title": "Client geographic location"
        }, 
        {
            "location": "/openvidu-pro/openvidu-inspector/#programmatic-reset", 
            "text": "OpenVidu Pro supports programmatic reset. You may call a  REST API method  to restart your OpenVidu Server process. This way you can:   A) Change OpenVidu Server  configuration properties  B) Easily clean up any garbage process or file that may have been stranded   You may also restart OpenVidu Server Pro directly in OpenVidu Inspector:  \n     \n         \n         \n  $().fancybox({\n    selector : '[data-fancybox]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });       \n    $('.pro-gallery').slick({\n      autoplay: true,\n      arrows: false,\n      autoplaySpeed: 3000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "Programmatic reset"
        }, 
        {
            "location": "/openvidu-pro/detailed-session-monitoring/", 
            "text": "Detailed session monitoring\n\n\n\n\n\n\n\nOpenVidu Pro brings the power of \nElastic Stack\n. Events and monitoring stats are sent to \nElasticsearch\n and can be visualized through \nKibana\n.\n\n\n\n\nOpenVidu Sessions dahsboard\n\n\nThis dashboard presents a summary of your video sessions and the server resources usage. That includes:\n\n\n\n\nCPU and memory usage of the server\n\n\nThe number of session per day\n\n\nThe location of your users\n\n\nThe number of publishers and subscribers you have at any time\n\n\nThe total streamed minutes over time\n\n\nSome low-level interesting stats related to the media connections\n\n\n\n\nThe last point includes things like the average time to select a pair candidate during the negotiation process, the average milliseconds your clients take to complete the ICE gathering process with OpenVidu Server, the ratio of successful and failed connections, and some WebRTC stats for your published and subscribed streams (Jitter, packet loss, Round-Trip-Time, target bitrate...)\n\n\nAll in all, this information will help you understand better the behavior and performance of your sessions.\n\n\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\n\n\nOpenVidu Recordings dahsboard\n\n\nThis dashboard presents at a glance the status of your recordings. It includes information such as:\n\n\n\n\nThe total number of recordings per day\n\n\nAverage duration and size of your recorded files\n\n\nThe distributions of you recordings by duration and size\n\n\nThe ratio of recordings according to their output mode (\nCOMPOSED\n or \nINDIVIDUAL\n recordings) and their recorded tracks (\naudio/video recordings\n)\n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\n\n\nAccessing Kibana\n\n\nOpenVidu Pro serves Kibana through path \n/kibana\n. So, if you have deployed OpenVidu Pro with domain \nmy.domain.com\n, you will be able to access OpenVidu Inspector through \nhttps://my.domain.com:4443\n and Kibana through \nhttps://my.domain.com/kibana\n\n\nThis path is secured with Basic Auth, so when connecting to it for the first time you will have to enter the user and password specified when \ndeploying OpenVidu Pro\n.\n\n\n\n\n\n\nCreating your own visualizations and dashboards\n\n\nThe dashboards presented above, by default included in OpenVidu Pro, are just an example of what can be done thanks to Kibana. You can create your own visualizations, and set up your very own dashboards with them. To do so, you have available multiple events that OpenVidu Pro periodically stores in Elasticsearch, and you can then use them in Kibana to compose different types of graphs and other useful visual representations.\n\n\n\n  \n\n\n\n\n\nEach one of these events stored by OpenVidu Pro in Elasticsearch has an \nelastic_type\n field to identify the specific type of event. This field may be:\n\n\n\n\n\n\n\n\n\n  \n2.9.0\n\n\n\n\n\n\n\n\n\ncdr\n: event of Call Detail Record (see \nOpenVidu CDR\n)\n\n\nkms\n: Kurento Media Server event. These events are always associated to one WebRTC endpoint (a publisher or a subscriber)\n\n\nmonitoringStats\n: event of CPU, memory and network statistics usage of OpenVidu Pro host\n\n\nwebrtcStats\n: event of WebRTC statistics for each media endpoint established in Kurento Media Server\n\n\nsessionSummary\n: summary of a session, stored once it is closed\n\n\nrecordingSummary\n: summary of a recording, stored once its session is closed\n\n\nuserSummary\n: summary of a user, stored once its session is closed\n\n\nconnectionSummary\n: summary of a connection, stored once its session is closed\n\n\npublisherSummary\n: summary of a publisher, stored once its session is closed\n\n\nsubscriberSummary\n: summary of a subscriber, stored once its session is closed\n\n\n\n\n\n\n\n\n\n  \ncdr\n\n  \nkms\n\n  \nmonitoringStats\n\n  \nwebrtcStats\n\n  \nsessionSummary\n\n  \nrecordingSummary\n\n  \nuserSummary\n\n  \nconnectionSummary\n\n  \npublisherSummary\n\n  \nsubscriberSummary\n\n\n\n\n\n\n\n{\n  \nsessionId\n: \nweih6kaewklr4i05\n,\n  \ntimestamp\n: 1554191848252,\n  \nstartTime\n: 1554191765889,\n  \nduration\n: 82,\n  \nreason\n: \nlastParticipantLeft\n,\n  \nevent\n: \nsessionDestroyed\n,\n  \nelastic_type\n: \ncdr\n\n}\n\n\n\n\n\n\n\n\n{\n  \nstreamId\n: 1,\n  \ncomponentId\n: 1,\n  \nstate\n: \nREADY\n,\n  \ntype\n: \nIceComponentStateChange\n,\n  \ntimestamp\n: 1554191839098,\n  \nsession\n: \nweih6kaewklr4i05\n,\n  \nuser\n: \n6596FB7B9D1A7C25\n,\n  \nconnection\n: \newztvkfl8dttvcxk\n,\n  \nendpoint\n: \newztvkfl8dttvcxk_bahnv2b0n5fxbohy_CAMERA_XHIHV\n,\n  \nmsSinceEndpointCreation\n: 11104,\n  \nelastic_type\n: \nkms\n\n}\n\n\n\n\n\n\n\n\n{\n  \ntimestamp\n: 1554212258873,\n  \ncpu\n: 11.887875624741168,\n  \nmem\n: {\n    \nused\n: 7287344,\n    \npercentage\n: 45.13347034796033\n  },\n  \nnet\n: {\n    \nveth2b4c47c\n: {\n      \nrxBytes\n: 0,\n      \ntxBytes\n: 0\n    },\n    \nwlp58s0\n: {\n      \nrxBytes\n: 0,\n      \ntxBytes\n: 0\n    }\n  },\n  \nelastic_type\n: \nmonitoringStats\n\n}\n\n\n\n\n\n\n\n\n{\n  \nsession\n: \nweih6kaewklr4i05\n,\n  \nuser\n: \n6596FB7B9D1A7C25\n,\n  \nconnection\n: \nbahnv2b0n5fxbohy\n,\n  \nendpoint\n: \nbahnv2b0n5fxbohy_CAMERA_XHIHV\n,\n  \nmediaType\n: \nvideo\n,\n  \njitter\n: 0.005244444590061903,\n  \nbytesReceived\n: 6455233,\n  \npacketsReceived\n: 6666,\n  \npacketsLost\n: 0,\n  \ntimestamp\n: 1554191847505,\n  \nfractionLost\n: 0,\n  \nremb\n: 533208,\n  \nfirCount\n: 6,\n  \npliCount\n: 0,\n  \nnackCount\n: 0,\n  \nsliCount\n: 0,\n  \nelastic_type\n: \nwebrtcStats\n\n}\n\n\n\n\n\n\n\n\n{\n  \ncreatedAt\n: 1554191765889,\n  \ndestroyedAt\n: 1554191848252,\n  \nsessionId\n: \nweih6kaewklr4i05\n,\n  \ncustomSessionId\n: \n,\n  \nmediaMode\n: \nROUTED\n,\n  \nrecordingMode\n: \nMANUAL\n,\n  \nduration\n: 82,\n  \nreason\n: \nlastParticipantLeft\n,\n  \nusers\n: {\n    \nnumberOfElements\n: 1,\n    \ncontent\n: [\n      {\n        \nid\n: \n6596FB7B9D1A7C25\n,\n        \nlocation\n: \nMumbai, India\n,\n        \nplatform\n: \nChrome 72.0.3626.109 on Linux 64-bit\n,\n        \nconnections\n: {\n          \nnumberOfElements\n: 1,\n          \ncontent\n: [\n            {\n              \ncreatedAt\n: 1554191765994,\n              \ndestroyedAt\n: 1554191848249,\n              \nconnectionId\n: \nbahnv2b0n5fxbohy\n,\n              \nclientData\n: \n,\n              \nserverData\n: \n,\n              \nduration\n: 82,\n              \nreason\n: \ndisconnect\n,\n              \npublishers\n: {\n                \nnumberOfElements\n: 1,\n                \ncontent\n: [\n                  {\n                    \nsessionId\n: \nweih6kaewklr4i05\n,\n                    \ntimestamp\n: 1554191848247,\n                    \nstartTime\n: 1554191767577,\n                    \nduration\n: 80,\n                    \nreason\n: \ndisconnect\n,\n                    \nstreamId\n: \nbahnv2b0n5fxbohy_CAMERA_XHIHV\n,\n                    \nvideoSource\n: \nCAMERA\n,\n                    \nvideoFramerate\n: -1,\n                    \nvideoDimensions\n: \n{\\\nwidth\\\n:640,\\\nheight\\\n:480}\n,\n                    \naudioEnabled\n: true,\n                    \nvideoEnabled\n: true,\n                    \nsession\n: \nweih6kaewklr4i05\n,\n                    \nuser\n: \n6596FB7B9D1A7C25\n,\n                    \nconnection\n: \nbahnv2b0n5fxbohy\n,\n                    \nelastic_type\n: \npublisherSummary\n\n                  }\n                ]\n              },\n              \nsubscribers\n: {\n                \nnumberOfElements\n: 0,\n                \ncontent\n: []\n              },\n              \ngeoPoints\n: \n19.09,72.87\n,\n              \nsession\n: \nweih6kaewklr4i05\n,\n              \nuser\n: \n6596FB7B9D1A7C25\n,\n              \ntimestamp\n: 1554191848252,\n              \nelastic_type\n: \nconnectionSummary\n\n            }\n          ]\n        },\n        \nsession\n: \nweih6kaewklr4i05\n,\n        \ntimestamp\n: 1554191848252,\n        \nelastic_type\n: \nuserSummary\n\n      }\n    ]\n  },\n  \nrecordings\n: {\n    \nnumberOfElements\n: 1,\n    \ncontent\n: [\n      {\n        \nsessionId\n: \nweih6kaewklr4i05\n,\n        \ntimestamp\n: 1554191784531,\n        \nstartTime\n: 1554191770662,\n        \nduration\n: 9.734,\n        \nreason\n: \nrecordingStoppedByServer\n,\n        \nid\n: \nweih6kaewklr4i05\n,\n        \nname\n: \nRecordingTest\n,\n        \noutputMode\n: \nCOMPOSED\n,\n        \nresolution\n: \n1920x1080\n,\n        \nrecordingLayout\n: \nBEST_FIT\n,\n        \nhasAudio\n: true,\n        \nhasVideo\n: true,\n        \nsize\n: 1968384,\n        \nelastic_type\n: \nrecordingSummary\n\n      }\n    ]\n  }\n}\n\n\n\n\n\n\n\n\n{\n  \nsessionId\n: \nweih6kaewklr4i05\n,\n  \ntimestamp\n: 1554191784531,\n  \nstartTime\n: 1554191770662,\n  \nduration\n: 9.734,\n  \nreason\n: \nrecordingStoppedByServer\n,\n  \nid\n: \nweih6kaewklr4i05\n,\n  \nname\n: \nRecordingTest\n,\n  \noutputMode\n: \nCOMPOSED\n,\n  \nresolution\n: \n1920x1080\n,\n  \nrecordingLayout\n: \nBEST_FIT\n,\n  \nhasAudio\n: true,\n  \nhasVideo\n: true,\n  \nsize\n: 1968384,\n  \nelastic_type\n: \nrecordingSummary\n\n}\n\n\n\n\n\n\n\n\n{\n  \nid\n: \n6596FB7B9D1A7C25\n,\n  \nlocation\n: \nMumbai, India\n,\n  \nplatform\n: \nChrome 72.0.3626.109 on Linux 64-bit\n,\n  \nconnections\n: {\n    \nnumberOfElements\n: 1,\n    \ncontent\n: [\n      {\n        \ncreatedAt\n: 1554191765994,\n        \ndestroyedAt\n: 1554191848249,\n        \nconnectionId\n: \nbahnv2b0n5fxbohy\n,\n        \nclientData\n: \n,\n        \nserverData\n: \n,\n        \nduration\n: 82,\n        \nreason\n: \ndisconnect\n,\n        \npublishers\n: {\n          \nnumberOfElements\n: 1,\n          \ncontent\n: [\n            {\n              \nsessionId\n: \nweih6kaewklr4i05\n,\n              \ntimestamp\n: 1554191848247,\n              \nstartTime\n: 1554191767577,\n              \nduration\n: 80,\n              \nreason\n: \ndisconnect\n,\n              \nstreamId\n: \nbahnv2b0n5fxbohy_CAMERA_XHIHV\n,\n              \nvideoSource\n: \nCAMERA\n,\n              \nvideoFramerate\n: -1,\n              \nvideoDimensions\n: \n{\\\nwidth\\\n:640,\\\nheight\\\n:480}\n,\n              \naudioEnabled\n: true,\n              \nvideoEnabled\n: true,\n              \nsession\n: \nweih6kaewklr4i05\n,\n              \nuser\n: \n6596FB7B9D1A7C25\n,\n              \nconnection\n: \nbahnv2b0n5fxbohy\n,\n              \nelastic_type\n: \npublisherSummary\n\n            }\n          ]\n        },\n        \nsubscribers\n: {\n          \nnumberOfElements\n: 0,\n          \ncontent\n: []\n        },\n        \ngeoPoints\n: \n19.09,72.87\n,\n        \nsession\n: \nweih6kaewklr4i05\n,\n        \nuser\n: \n6596FB7B9D1A7C25\n,\n        \ntimestamp\n: 1554191848252,\n        \nelastic_type\n: \nconnectionSummary\n\n      }\n    ]\n  },\n  \nsession\n: \nweih6kaewklr4i05\n,\n  \ntimestamp\n: 1554191848252,\n  \nelastic_type\n: \nuserSummary\n\n}\n\n\n\n\n\n\n\n\n{\n  \ncreatedAt\n: 1554191765994,\n  \ndestroyedAt\n: 1554191848249,\n  \nconnectionId\n: \nbahnv2b0n5fxbohy\n,\n  \nclientData\n: \n,\n  \nserverData\n: \n,\n  \nduration\n: 82,\n  \nreason\n: \ndisconnect\n,\n  \npublishers\n: {\n    \nnumberOfElements\n: 1,\n    \ncontent\n: [\n      {\n        \nsessionId\n: \nweih6kaewklr4i05\n,\n        \ntimestamp\n: 1554191848247,\n        \nstartTime\n: 1554191767577,\n        \nduration\n: 80,\n        \nreason\n: \ndisconnect\n,\n        \nstreamId\n: \nbahnv2b0n5fxbohy_CAMERA_XHIHV\n,\n        \nvideoSource\n: \nCAMERA\n,\n        \nvideoFramerate\n: -1,\n        \nvideoDimensions\n: \n{\\\nwidth\\\n:640,\\\nheight\\\n:480}\n,\n        \naudioEnabled\n: true,\n        \nvideoEnabled\n: true,\n        \nsession\n: \nweih6kaewklr4i05\n,\n        \nuser\n: \n6596FB7B9D1A7C25\n,\n        \nconnection\n: \nbahnv2b0n5fxbohy\n,\n        \nelastic_type\n: \npublisherSummary\n\n      }\n    ]\n  },\n  \nsubscribers\n: {\n    \nnumberOfElements\n: 0,\n    \ncontent\n: []\n  },\n  \nsession\n: \nweih6kaewklr4i05\n,\n  \nuser\n: \n6596FB7B9D1A7C25\n,\n  \ntimestamp\n: 1554191848252,\n  \nelastic_type\n: \nconnectionSummary\n\n}\n\n\n\n\n\n\n\n\n{\n  \nsessionId\n: \nweih6kaewklr4i05\n,\n  \ntimestamp\n: 1554191848247,\n  \nstartTime\n: 1554191767577,\n  \nduration\n: 80,\n  \nreason\n: \ndisconnect\n,\n  \nstreamId\n: \nbahnv2b0n5fxbohy_CAMERA_XHIHV\n,\n  \nvideoSource\n: \nCAMERA\n,\n  \nvideoFramerate\n: -1,\n  \nvideoDimensions\n: \n{\\\nwidth\\\n:640,\\\nheight\\\n:480}\n,\n  \naudioEnabled\n: true,\n  \nvideoEnabled\n: true,\n  \nsession\n: \nweih6kaewklr4i05\n,\n  \nuser\n: \n6596FB7B9D1A7C25\n,\n  \nconnection\n: \nbahnv2b0n5fxbohy\n,\n  \nelastic_type\n: \npublisherSummary\n\n}\n\n\n\n\n\n\n\n\n{\n  \nsessionId\n: \nweih6kaewklr4i05\n,\n  \ntimestamp\n: 1553694100398,\n  \nstartTime\n: 1553693956035,\n  \nduration\n: 144,\n  \nreason\n: \ndisconnect\n,\n  \nstreamId\n: \ndbslbhe2jzhhybvj_CAMERA_CSBVI\n,\n  \nreceivingFrom\n: \ndbslbhe2jzhhybvj\n,\n  \nvideoSource\n: \nCAMERA\n,\n  \nvideoFramerate\n: 30,\n  \nvideoDimensions\n: \n{\\\nwidth\\\n:640,\\\nheight\\\n:480}\n,\n  \naudioEnabled\n: true,\n  \nvideoEnabled\n: true,\n  \nsession\n: \nTestSession\n,\n  \nuser\n: \nA06BB386A40BBC83\n,\n  \nconnection\n: \nc1tgrtyzlmeix6l3\n,\n  \nelastic_type\n: \nsubscriberSummary\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsessionSummary\n contains all the information available in the rest of summary documents, including an array of \nrecordingSummary\n and an array of \nuserSummary\n. In turn \nuserSummary\n contains an array of \nconnectionSummary\n, that finally contains an array of \npublisherSummary\n and other of \nsubscriberSummary\n.\nTo sum up, this is just a denormalization of the \nsessionSummary\n document, so Elasticsearch requests and Kibana visualizations are more flexible and easier to accomplish\n\n\n\n\n\n\nYou can create powerful visualizations and dashboards by using these documents. Let's see a quick example. Imagine that you are interested in knowing \nhow many users are connected to your OpenVidu sessions over time\n.\n\n\n\n    \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n    \n\n    \n\n      \nFirst thing is navigating to \nVisualize\n section in Kibana and clicking on the button to add a new visualization\n\n      \nThen we have to choose a visualization type. In this case a vertical bar graph might be a pretty good choice\n\n      \nWe select \nopenvidu\n index, because that's the index of every OpenVidu Pro event stored in Elasticsearch\n\n      \nThe visualization page will be shown. Now we have to filter the desired events. In this case, we just want the \nuserSummary\n event, as it gathers all the information about the final users connecting to our sessions. So, we make sure that field \nelastic_type.keyword\n is \nuserSummary\n\n      \nFinally we have to configure the data passed to our graph. The metric we want (Y-axis) is simply \nCount\n, because there is one \"userSummary\" event for each final user connecting to a session. And as Bucket (X-axis) we configure a Date Histogram by using \ntimestamp\n field of the event\n\n      \nTo store the new visualization just click on \nSave\n button in the upper menu and give it a meaningful name\n\n    \n\n\n\n\n\n\n\nThe example above is a very simple visualization, but you can apply any metric to any property (or set of properties) of any event (or set of events). You can explore pre-existing visualizations included by default in OpenVidu Pro, and for further info visit \nKibana docs\n\n\n\n\n\n\n\nfunction changeVersion(event) {\n  var parent = event.target.parentNode.parentNode;\n  var txt = event.target.textContent || event.target.innerText;\n  var txt = txt.replace(/\\./g, '');\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n    // Change appearance of version buttons\n    if (child.classList.contains('version-buttons')) {\n        for (var j = 0; j < child.children.length; j++) {\n          var a = child.children[j];\n          if (a === event.target) {\n            a.classList.add('pressed-btn');\n          } else {\n            a.classList.remove('pressed-btn');\n          }\n        }\n    }\n    // Change visibility of version content\n    if (child.classList.contains('version-container')) {\n      if (child.id === ('list-' + txt) || child.id === ('content-' + txt)) {\n        child.style.display = 'block';\n      } else {\n        child.style.display = 'none';\n      }\n    }\n  }\n}\n\n\n\n\n\nfunction changeLangTab(event) {\n  var parent = event.target.parentNode.parentNode;\n  var txt = event.target.textContent || event.target.innerText;\n  var txt = txt.replace(/\\s/g, \"-\").toLowerCase();\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n    // Change appearance of language buttons\n    if (child.classList.contains('lang-tabs-header')) {\n        for (var j = 0; j < child.children.length; j++) {\n            var btn = child.children[j];\n            if (btn.classList.contains('lang-tabs-btn')) {\n                btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9';\n                btn.style.fontWeight = btn === event.target ? 'bold' : 'normal';\n            }\n        }\n    }\n    // Change visibility of language content\n    if (child.classList.contains('lang-tabs-content')) {\n        if (child.id === txt) {\n            child.style.display = 'block';\n        } else {\n            child.style.display = 'none';\n        }\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    $('.slick-captions').slick({\n      asNavFor: '.pro-gallery-steps',\n      arrows: false,\n      infinite: false,\n      speed: 200,\n      fade: true,\n      dots: false\n    });\n    $('.pro-gallery-steps').slick({\n      asNavFor: '.slick-captions',\n      autoplay: false,\n      arrows: true,\n      prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>',\n      nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>',\n      infinite: false,\n      dots: true,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: true,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "Detailed session monitoring"
        }, 
        {
            "location": "/openvidu-pro/detailed-session-monitoring/#openvidu-sessions-dahsboard", 
            "text": "This dashboard presents a summary of your video sessions and the server resources usage. That includes:   CPU and memory usage of the server  The number of session per day  The location of your users  The number of publishers and subscribers you have at any time  The total streamed minutes over time  Some low-level interesting stats related to the media connections   The last point includes things like the average time to select a pair candidate during the negotiation process, the average milliseconds your clients take to complete the ICE gathering process with OpenVidu Server, the ratio of successful and failed connections, and some WebRTC stats for your published and subscribed streams (Jitter, packet loss, Round-Trip-Time, target bitrate...)  All in all, this information will help you understand better the behavior and performance of your sessions.", 
            "title": "OpenVidu Sessions dahsboard"
        }, 
        {
            "location": "/openvidu-pro/detailed-session-monitoring/#openvidu-recordings-dahsboard", 
            "text": "This dashboard presents at a glance the status of your recordings. It includes information such as:   The total number of recordings per day  Average duration and size of your recorded files  The distributions of you recordings by duration and size  The ratio of recordings according to their output mode ( COMPOSED  or  INDIVIDUAL  recordings) and their recorded tracks ( audio/video recordings )", 
            "title": "OpenVidu Recordings dahsboard"
        }, 
        {
            "location": "/openvidu-pro/detailed-session-monitoring/#accessing-kibana", 
            "text": "OpenVidu Pro serves Kibana through path  /kibana . So, if you have deployed OpenVidu Pro with domain  my.domain.com , you will be able to access OpenVidu Inspector through  https://my.domain.com:4443  and Kibana through  https://my.domain.com/kibana  This path is secured with Basic Auth, so when connecting to it for the first time you will have to enter the user and password specified when  deploying OpenVidu Pro .", 
            "title": "Accessing Kibana"
        }, 
        {
            "location": "/openvidu-pro/detailed-session-monitoring/#creating-your-own-visualizations-and-dashboards", 
            "text": "The dashboards presented above, by default included in OpenVidu Pro, are just an example of what can be done thanks to Kibana. You can create your own visualizations, and set up your very own dashboards with them. To do so, you have available multiple events that OpenVidu Pro periodically stores in Elasticsearch, and you can then use them in Kibana to compose different types of graphs and other useful visual representations.  \n     Each one of these events stored by OpenVidu Pro in Elasticsearch has an  elastic_type  field to identify the specific type of event. This field may be:    \n   2.9.0     cdr : event of Call Detail Record (see  OpenVidu CDR )  kms : Kurento Media Server event. These events are always associated to one WebRTC endpoint (a publisher or a subscriber)  monitoringStats : event of CPU, memory and network statistics usage of OpenVidu Pro host  webrtcStats : event of WebRTC statistics for each media endpoint established in Kurento Media Server  sessionSummary : summary of a session, stored once it is closed  recordingSummary : summary of a recording, stored once its session is closed  userSummary : summary of a user, stored once its session is closed  connectionSummary : summary of a connection, stored once its session is closed  publisherSummary : summary of a publisher, stored once its session is closed  subscriberSummary : summary of a subscriber, stored once its session is closed     \n   cdr \n   kms \n   monitoringStats \n   webrtcStats \n   sessionSummary \n   recordingSummary \n   userSummary \n   connectionSummary \n   publisherSummary \n   subscriberSummary    {\n   sessionId :  weih6kaewklr4i05 ,\n   timestamp : 1554191848252,\n   startTime : 1554191765889,\n   duration : 82,\n   reason :  lastParticipantLeft ,\n   event :  sessionDestroyed ,\n   elastic_type :  cdr \n}    {\n   streamId : 1,\n   componentId : 1,\n   state :  READY ,\n   type :  IceComponentStateChange ,\n   timestamp : 1554191839098,\n   session :  weih6kaewklr4i05 ,\n   user :  6596FB7B9D1A7C25 ,\n   connection :  ewztvkfl8dttvcxk ,\n   endpoint :  ewztvkfl8dttvcxk_bahnv2b0n5fxbohy_CAMERA_XHIHV ,\n   msSinceEndpointCreation : 11104,\n   elastic_type :  kms \n}    {\n   timestamp : 1554212258873,\n   cpu : 11.887875624741168,\n   mem : {\n     used : 7287344,\n     percentage : 45.13347034796033\n  },\n   net : {\n     veth2b4c47c : {\n       rxBytes : 0,\n       txBytes : 0\n    },\n     wlp58s0 : {\n       rxBytes : 0,\n       txBytes : 0\n    }\n  },\n   elastic_type :  monitoringStats \n}    {\n   session :  weih6kaewklr4i05 ,\n   user :  6596FB7B9D1A7C25 ,\n   connection :  bahnv2b0n5fxbohy ,\n   endpoint :  bahnv2b0n5fxbohy_CAMERA_XHIHV ,\n   mediaType :  video ,\n   jitter : 0.005244444590061903,\n   bytesReceived : 6455233,\n   packetsReceived : 6666,\n   packetsLost : 0,\n   timestamp : 1554191847505,\n   fractionLost : 0,\n   remb : 533208,\n   firCount : 6,\n   pliCount : 0,\n   nackCount : 0,\n   sliCount : 0,\n   elastic_type :  webrtcStats \n}    {\n   createdAt : 1554191765889,\n   destroyedAt : 1554191848252,\n   sessionId :  weih6kaewklr4i05 ,\n   customSessionId :  ,\n   mediaMode :  ROUTED ,\n   recordingMode :  MANUAL ,\n   duration : 82,\n   reason :  lastParticipantLeft ,\n   users : {\n     numberOfElements : 1,\n     content : [\n      {\n         id :  6596FB7B9D1A7C25 ,\n         location :  Mumbai, India ,\n         platform :  Chrome 72.0.3626.109 on Linux 64-bit ,\n         connections : {\n           numberOfElements : 1,\n           content : [\n            {\n               createdAt : 1554191765994,\n               destroyedAt : 1554191848249,\n               connectionId :  bahnv2b0n5fxbohy ,\n               clientData :  ,\n               serverData :  ,\n               duration : 82,\n               reason :  disconnect ,\n               publishers : {\n                 numberOfElements : 1,\n                 content : [\n                  {\n                     sessionId :  weih6kaewklr4i05 ,\n                     timestamp : 1554191848247,\n                     startTime : 1554191767577,\n                     duration : 80,\n                     reason :  disconnect ,\n                     streamId :  bahnv2b0n5fxbohy_CAMERA_XHIHV ,\n                     videoSource :  CAMERA ,\n                     videoFramerate : -1,\n                     videoDimensions :  {\\ width\\ :640,\\ height\\ :480} ,\n                     audioEnabled : true,\n                     videoEnabled : true,\n                     session :  weih6kaewklr4i05 ,\n                     user :  6596FB7B9D1A7C25 ,\n                     connection :  bahnv2b0n5fxbohy ,\n                     elastic_type :  publisherSummary \n                  }\n                ]\n              },\n               subscribers : {\n                 numberOfElements : 0,\n                 content : []\n              },\n               geoPoints :  19.09,72.87 ,\n               session :  weih6kaewklr4i05 ,\n               user :  6596FB7B9D1A7C25 ,\n               timestamp : 1554191848252,\n               elastic_type :  connectionSummary \n            }\n          ]\n        },\n         session :  weih6kaewklr4i05 ,\n         timestamp : 1554191848252,\n         elastic_type :  userSummary \n      }\n    ]\n  },\n   recordings : {\n     numberOfElements : 1,\n     content : [\n      {\n         sessionId :  weih6kaewklr4i05 ,\n         timestamp : 1554191784531,\n         startTime : 1554191770662,\n         duration : 9.734,\n         reason :  recordingStoppedByServer ,\n         id :  weih6kaewklr4i05 ,\n         name :  RecordingTest ,\n         outputMode :  COMPOSED ,\n         resolution :  1920x1080 ,\n         recordingLayout :  BEST_FIT ,\n         hasAudio : true,\n         hasVideo : true,\n         size : 1968384,\n         elastic_type :  recordingSummary \n      }\n    ]\n  }\n}    {\n   sessionId :  weih6kaewklr4i05 ,\n   timestamp : 1554191784531,\n   startTime : 1554191770662,\n   duration : 9.734,\n   reason :  recordingStoppedByServer ,\n   id :  weih6kaewklr4i05 ,\n   name :  RecordingTest ,\n   outputMode :  COMPOSED ,\n   resolution :  1920x1080 ,\n   recordingLayout :  BEST_FIT ,\n   hasAudio : true,\n   hasVideo : true,\n   size : 1968384,\n   elastic_type :  recordingSummary \n}    {\n   id :  6596FB7B9D1A7C25 ,\n   location :  Mumbai, India ,\n   platform :  Chrome 72.0.3626.109 on Linux 64-bit ,\n   connections : {\n     numberOfElements : 1,\n     content : [\n      {\n         createdAt : 1554191765994,\n         destroyedAt : 1554191848249,\n         connectionId :  bahnv2b0n5fxbohy ,\n         clientData :  ,\n         serverData :  ,\n         duration : 82,\n         reason :  disconnect ,\n         publishers : {\n           numberOfElements : 1,\n           content : [\n            {\n               sessionId :  weih6kaewklr4i05 ,\n               timestamp : 1554191848247,\n               startTime : 1554191767577,\n               duration : 80,\n               reason :  disconnect ,\n               streamId :  bahnv2b0n5fxbohy_CAMERA_XHIHV ,\n               videoSource :  CAMERA ,\n               videoFramerate : -1,\n               videoDimensions :  {\\ width\\ :640,\\ height\\ :480} ,\n               audioEnabled : true,\n               videoEnabled : true,\n               session :  weih6kaewklr4i05 ,\n               user :  6596FB7B9D1A7C25 ,\n               connection :  bahnv2b0n5fxbohy ,\n               elastic_type :  publisherSummary \n            }\n          ]\n        },\n         subscribers : {\n           numberOfElements : 0,\n           content : []\n        },\n         geoPoints :  19.09,72.87 ,\n         session :  weih6kaewklr4i05 ,\n         user :  6596FB7B9D1A7C25 ,\n         timestamp : 1554191848252,\n         elastic_type :  connectionSummary \n      }\n    ]\n  },\n   session :  weih6kaewklr4i05 ,\n   timestamp : 1554191848252,\n   elastic_type :  userSummary \n}    {\n   createdAt : 1554191765994,\n   destroyedAt : 1554191848249,\n   connectionId :  bahnv2b0n5fxbohy ,\n   clientData :  ,\n   serverData :  ,\n   duration : 82,\n   reason :  disconnect ,\n   publishers : {\n     numberOfElements : 1,\n     content : [\n      {\n         sessionId :  weih6kaewklr4i05 ,\n         timestamp : 1554191848247,\n         startTime : 1554191767577,\n         duration : 80,\n         reason :  disconnect ,\n         streamId :  bahnv2b0n5fxbohy_CAMERA_XHIHV ,\n         videoSource :  CAMERA ,\n         videoFramerate : -1,\n         videoDimensions :  {\\ width\\ :640,\\ height\\ :480} ,\n         audioEnabled : true,\n         videoEnabled : true,\n         session :  weih6kaewklr4i05 ,\n         user :  6596FB7B9D1A7C25 ,\n         connection :  bahnv2b0n5fxbohy ,\n         elastic_type :  publisherSummary \n      }\n    ]\n  },\n   subscribers : {\n     numberOfElements : 0,\n     content : []\n  },\n   session :  weih6kaewklr4i05 ,\n   user :  6596FB7B9D1A7C25 ,\n   timestamp : 1554191848252,\n   elastic_type :  connectionSummary \n}    {\n   sessionId :  weih6kaewklr4i05 ,\n   timestamp : 1554191848247,\n   startTime : 1554191767577,\n   duration : 80,\n   reason :  disconnect ,\n   streamId :  bahnv2b0n5fxbohy_CAMERA_XHIHV ,\n   videoSource :  CAMERA ,\n   videoFramerate : -1,\n   videoDimensions :  {\\ width\\ :640,\\ height\\ :480} ,\n   audioEnabled : true,\n   videoEnabled : true,\n   session :  weih6kaewklr4i05 ,\n   user :  6596FB7B9D1A7C25 ,\n   connection :  bahnv2b0n5fxbohy ,\n   elastic_type :  publisherSummary \n}    {\n   sessionId :  weih6kaewklr4i05 ,\n   timestamp : 1553694100398,\n   startTime : 1553693956035,\n   duration : 144,\n   reason :  disconnect ,\n   streamId :  dbslbhe2jzhhybvj_CAMERA_CSBVI ,\n   receivingFrom :  dbslbhe2jzhhybvj ,\n   videoSource :  CAMERA ,\n   videoFramerate : 30,\n   videoDimensions :  {\\ width\\ :640,\\ height\\ :480} ,\n   audioEnabled : true,\n   videoEnabled : true,\n   session :  TestSession ,\n   user :  A06BB386A40BBC83 ,\n   connection :  c1tgrtyzlmeix6l3 ,\n   elastic_type :  subscriberSummary \n}         sessionSummary  contains all the information available in the rest of summary documents, including an array of  recordingSummary  and an array of  userSummary . In turn  userSummary  contains an array of  connectionSummary , that finally contains an array of  publisherSummary  and other of  subscriberSummary .\nTo sum up, this is just a denormalization of the  sessionSummary  document, so Elasticsearch requests and Kibana visualizations are more flexible and easier to accomplish    You can create powerful visualizations and dashboards by using these documents. Let's see a quick example. Imagine that you are interested in knowing  how many users are connected to your OpenVidu sessions over time .  \n     \n         \n         \n         \n         \n         \n         \n     \n     \n       First thing is navigating to  Visualize  section in Kibana and clicking on the button to add a new visualization \n       Then we have to choose a visualization type. In this case a vertical bar graph might be a pretty good choice \n       We select  openvidu  index, because that's the index of every OpenVidu Pro event stored in Elasticsearch \n       The visualization page will be shown. Now we have to filter the desired events. In this case, we just want the  userSummary  event, as it gathers all the information about the final users connecting to our sessions. So, we make sure that field  elastic_type.keyword  is  userSummary \n       Finally we have to configure the data passed to our graph. The metric we want (Y-axis) is simply  Count , because there is one \"userSummary\" event for each final user connecting to a session. And as Bucket (X-axis) we configure a Date Histogram by using  timestamp  field of the event \n       To store the new visualization just click on  Save  button in the upper menu and give it a meaningful name \n        The example above is a very simple visualization, but you can apply any metric to any property (or set of properties) of any event (or set of events). You can explore pre-existing visualizations included by default in OpenVidu Pro, and for further info visit  Kibana docs    \nfunction changeVersion(event) {\n  var parent = event.target.parentNode.parentNode;\n  var txt = event.target.textContent || event.target.innerText;\n  var txt = txt.replace(/\\./g, '');\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n    // Change appearance of version buttons\n    if (child.classList.contains('version-buttons')) {\n        for (var j = 0; j < child.children.length; j++) {\n          var a = child.children[j];\n          if (a === event.target) {\n            a.classList.add('pressed-btn');\n          } else {\n            a.classList.remove('pressed-btn');\n          }\n        }\n    }\n    // Change visibility of version content\n    if (child.classList.contains('version-container')) {\n      if (child.id === ('list-' + txt) || child.id === ('content-' + txt)) {\n        child.style.display = 'block';\n      } else {\n        child.style.display = 'none';\n      }\n    }\n  }\n}  \nfunction changeLangTab(event) {\n  var parent = event.target.parentNode.parentNode;\n  var txt = event.target.textContent || event.target.innerText;\n  var txt = txt.replace(/\\s/g, \"-\").toLowerCase();\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n    // Change appearance of language buttons\n    if (child.classList.contains('lang-tabs-header')) {\n        for (var j = 0; j < child.children.length; j++) {\n            var btn = child.children[j];\n            if (btn.classList.contains('lang-tabs-btn')) {\n                btn.style.backgroundColor = btn === event.target ? '#e8e8e8' : '#f9f9f9';\n                btn.style.fontWeight = btn === event.target ? 'bold' : 'normal';\n            }\n        }\n    }\n    // Change visibility of language content\n    if (child.classList.contains('lang-tabs-content')) {\n        if (child.id === txt) {\n            child.style.display = 'block';\n        } else {\n            child.style.display = 'none';\n        }\n    }\n  }\n}    \n  $().fancybox({\n    selector : '[data-fancybox]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });       \n    $('.slick-captions').slick({\n      asNavFor: '.pro-gallery-steps',\n      arrows: false,\n      infinite: false,\n      speed: 200,\n      fade: true,\n      dots: false\n    });\n    $('.pro-gallery-steps').slick({\n      asNavFor: '.slick-captions',\n      autoplay: false,\n      arrows: true,\n      prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>',\n      nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>',\n      infinite: false,\n      dots: true,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: true,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "Creating your own visualizations and dashboards"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/", 
            "text": "Deploying OpenVidu Pro\n\n\n\n\n\n\n\nOpenVidu Pro is available through \nAmazon Web Services\n (you will need an \nAWS account\n)\n\n\n\n\n\n\n\n1) Steps towards configuration\n\n\n\n\nA) Access to the console of AWS Cloud Formation\n\n\nGo to CloudFormation\n\n\n\n\nB) Click on \nCreate Stack\n\n\n\n    \n\n  \n\n\n\n\nC) Option \nSpecify an Amazon S3 template URL\n with the following URL\n\n\nhttps://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-latest.json\n\n  \nCopy\n\n\n\n    \n\n  \n\n\n\n\n2) Configure your OpenVidu Server Pro\n\n\nFill the form with the appropriate values as stated below\n\n\nStack name\n\n\nThe name of your deployment\n\n\nSSL Certificate Configuration\n\n\nThis is the kind of certificate you will be using in your deployment. Three different options are offered:\n\n\n\n\nselfsigned\n: use a selfsigned certificate. This options is meant for testing and developing environments. Leave the rest of the fields with their default value\n\n\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\n\n\nletsencrypt\n: use an automatic certificate by Let's Encrypt. This way you don't have to worry about providing your own certificate. You simply have to enter an email account where Let's Encrypt will send its messages, your fully qualified domain name and one AWS Elastic IP for the same region you selected before (\nallocate one if you don't have it\n). Of course, \nyou will need to register this Elastic IP in your DNS hosting service and associate it with your fully qualified domain name\n. Only after this association between the Elastic IP and your domain name is effective your deployment with Let's Encrypt will work fine.\n\n\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\n\n\nowncert\n: use your own certificate. You must provide one AWS Elastic IP for the same region you selected before (\nallocate one if you don't have it\n), and your public certificate and private key, both accessible through uris (an Amazon S3 bucket is the best way to do it). Leave the default values for \nEmail\n and \nFully qualified domain name\n fields.\n\n\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\nOpenVidu Configuration\n\n\nThese fields respectively configure the following \nsystem properties\n of OpenVidu Server: \nopenvidu.secret\n, \nopenvidu.recording.public-access\n, \nopenvidu.recording.notification\n, \nopenvidu.streams.video.max-recv-bandwidth\n, \nopenvidu.streams.video.min-recv-bandwidth\n, \nopenvidu.streams.video.max-send-bandwidth\n, \nopenvidu.streams.video.min-send-bandwidth\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\nOpenvidu Security Group\n\n\nThese fields allow you to limit the IPs that will be able to connect to OpenVidu Server Pro.\n\n\n\n\nWARNING\n: be careful when limiting these IP ranges\n\n\n\n\nPort 4443 access Range\n: OpenVidu Server Pro REST API and client access point. This should be set to \n0.0.0.0/0\n if you want any client to be able to use your deployment\n\n\nPort 3478 access Range\n: TURN server port. This should be set to \n0.0.0.0/0\n if you want any client to be able to use your deployment, as you never know which user might need a TURN connection to be able to send and receive media\n\n\nUDP Port access Range\n and \nTCP Port access Range\n: limits the clients that will be able to establish TCP and UDP connections to your OpenVidu Server Pro. So again, if you want to provide service to any client these should be set to \n0.0.0.0/0\n\n\nMinOpenPort\n and \nMaxOpenPort\n: determine what ports will be available to establish the media connections, so the generous default value is a good choice\n\n\nPort 80 access Range\n: if you are using Let's Encrypt SSL configuration, set it to \n0.0.0.0/0\n, as Let's Encrypt will need to access your server through port 80\n\n\nSSH Port access Range\n can be limited as you want, as it provides SSH access to the server with the proper private key through port 22\n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\nOther parameters\n\n\nChoose the size of your instance (see \nOpenVidu performance FAQ\n) and a Key Pair (\ncreate one if you don't have any\n).\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\nYou are ready to go. Click on \nNext\n \ud83e\udc46 \nNext\n \ud83e\udc46 \nCreate stack\n to finally deploy your OpenVidu Server Pro.\n\n\nWait until Stack status is set to \nCREATE_COMPLETE\n. Then you will have a production-ready setup with all the advanced features provided by OpenVidu Pro.\n\n\n\n\n\n\nRegarding the compatibility of \nopenvidu-browser\n and \nserver SDKs\n (REST API, openvidu-java-client, openvidu-node-client), use the same version numbers as stated for openvidu-server in \nReleases page\n. For example, for OpenVidu Pro 2.8.0, use the artifact versions indicated in \n2.8.0 release table\n\n\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    $('.pro-gallery').slick({\n      autoplay: true,\n      arrows: false,\n      autoplaySpeed: 3000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });\n    $('.pro-gallery-steps').slick({\n      autoplay: false,\n      arrows: true,\n      prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>',\n      nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>',\n      dots: true,\n      infinite: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: true,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "Deploying OpenVidu Pro"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#1-steps-towards-configuration", 
            "text": "", 
            "title": "1) Steps towards configuration"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#a-access-to-the-console-of-aws-cloud-formation", 
            "text": "Go to CloudFormation", 
            "title": "A) Access to the console of AWS Cloud Formation"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#b-click-on-create-stack", 
            "text": "", 
            "title": "B) Click on Create Stack"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#c-option-specify-an-amazon-s3-template-url-with-the-following-url", 
            "text": "https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-latest.json \n   Copy", 
            "title": "C) Option Specify an Amazon S3 template URL with the following URL"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#2-configure-your-openvidu-server-pro", 
            "text": "Fill the form with the appropriate values as stated below", 
            "title": "2) Configure your OpenVidu Server Pro"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#stack-name", 
            "text": "The name of your deployment", 
            "title": "Stack name"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#ssl-certificate-configuration", 
            "text": "This is the kind of certificate you will be using in your deployment. Three different options are offered:   selfsigned : use a selfsigned certificate. This options is meant for testing and developing environments. Leave the rest of the fields with their default value   \n     \n         \n        letsencrypt : use an automatic certificate by Let's Encrypt. This way you don't have to worry about providing your own certificate. You simply have to enter an email account where Let's Encrypt will send its messages, your fully qualified domain name and one AWS Elastic IP for the same region you selected before ( allocate one if you don't have it ). Of course,  you will need to register this Elastic IP in your DNS hosting service and associate it with your fully qualified domain name . Only after this association between the Elastic IP and your domain name is effective your deployment with Let's Encrypt will work fine.   \n     \n         \n        owncert : use your own certificate. You must provide one AWS Elastic IP for the same region you selected before ( allocate one if you don't have it ), and your public certificate and private key, both accessible through uris (an Amazon S3 bucket is the best way to do it). Leave the default values for  Email  and  Fully qualified domain name  fields.", 
            "title": "SSL Certificate Configuration"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#openvidu-configuration", 
            "text": "These fields respectively configure the following  system properties  of OpenVidu Server:  openvidu.secret ,  openvidu.recording.public-access ,  openvidu.recording.notification ,  openvidu.streams.video.max-recv-bandwidth ,  openvidu.streams.video.min-recv-bandwidth ,  openvidu.streams.video.max-send-bandwidth ,  openvidu.streams.video.min-send-bandwidth", 
            "title": "OpenVidu Configuration"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#openvidu-security-group", 
            "text": "These fields allow you to limit the IPs that will be able to connect to OpenVidu Server Pro.   WARNING : be careful when limiting these IP ranges   Port 4443 access Range : OpenVidu Server Pro REST API and client access point. This should be set to  0.0.0.0/0  if you want any client to be able to use your deployment  Port 3478 access Range : TURN server port. This should be set to  0.0.0.0/0  if you want any client to be able to use your deployment, as you never know which user might need a TURN connection to be able to send and receive media  UDP Port access Range  and  TCP Port access Range : limits the clients that will be able to establish TCP and UDP connections to your OpenVidu Server Pro. So again, if you want to provide service to any client these should be set to  0.0.0.0/0  MinOpenPort  and  MaxOpenPort : determine what ports will be available to establish the media connections, so the generous default value is a good choice  Port 80 access Range : if you are using Let's Encrypt SSL configuration, set it to  0.0.0.0/0 , as Let's Encrypt will need to access your server through port 80  SSH Port access Range  can be limited as you want, as it provides SSH access to the server with the proper private key through port 22", 
            "title": "Openvidu Security Group"
        }, 
        {
            "location": "/openvidu-pro/deploying-openvidu-pro/#other-parameters", 
            "text": "Choose the size of your instance (see  OpenVidu performance FAQ ) and a Key Pair ( create one if you don't have any ).  \n     \n         \n       You are ready to go. Click on  Next  \ud83e\udc46  Next  \ud83e\udc46  Create stack  to finally deploy your OpenVidu Server Pro.  Wait until Stack status is set to  CREATE_COMPLETE . Then you will have a production-ready setup with all the advanced features provided by OpenVidu Pro.    Regarding the compatibility of  openvidu-browser  and  server SDKs  (REST API, openvidu-java-client, openvidu-node-client), use the same version numbers as stated for openvidu-server in  Releases page . For example, for OpenVidu Pro 2.8.0, use the artifact versions indicated in  2.8.0 release table      \n  $().fancybox({\n    selector : '[data-fancybox]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });       \n    $('.pro-gallery').slick({\n      autoplay: true,\n      arrows: false,\n      autoplaySpeed: 3000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });\n    $('.pro-gallery-steps').slick({\n      autoplay: false,\n      arrows: true,\n      prevArrow: '<div class=\"slick-btn slick-btn-prev\"><i class=\"icon ion-chevron-left\"></i></div>',\n      nextArrow: '<div class=\"slick-btn slick-btn-next\"><i class=\"icon ion-chevron-right\"></i></div>',\n      dots: true,\n      infinite: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: true,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "Other parameters"
        }, 
        {
            "location": "/openvidu-pro/REST-API-pro/", 
            "text": "REST API Pro\n\n\n\n\n\n\nOpenVidu Pro provides all of \nOpenVidu Community Edition REST operations\n, but also includes some extra REST operations of its own.\n\n\nAll REST operations have in common the header referred to authorization. It is implemented via Basic Auth, and it is as simple as applying Base64 encoding to the username (always \"OPENVIDUAPP\") and the password (your \nsecret\n shared with openvidu-server). If authorization header is wrong, every call to any REST API operation will return HTTP status \n401\n.\n\n\nFor example, for secret \"MY_SECRET\", the final valid HTTP header would be\n\n\n\n\nAuthorization: Basic T1BFTlZJRFVBUFA6TVlfU0VDUkVU\n\n\n\n\nList of available operations\n\n\n\n\n\n\nGet OpenVidu Pro active configuration: \nGET /pro/config\n\n\nRestart OpenVidu Pro: \nPOST /pro/restart\n\n\n\n\nGET \n/pro/config\n\n\n\n\n\n\n\n\nGET OPENVIDU PRO CONFIGURATION\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nGET\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/pro/config\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\n\n\n\n\n\n\nSample return\n\n\n{\"version\": \"2.9.0\", \"openviduServerDependencyVersion\": \"2.9.0\", \"openviduProStatsMonitoringInterval\": 30, \"openviduProStatsWebrtcInterval\": 20, \"openviduPublicurl\": \"https://localhost:4443/\", \"openviduCdr\": false, \"maxRecvBandwidth\": 1000, \"minRecvBandwidth\": 300, \"maxSendBandwidth\": 1000, \"minSendBandwidth\": 300, \"openviduRecording\": true, \"openviduRecordingVersion\": \"2.9.0\", \"openviduRecordingPath\": \"/opt/openvidu/recordings/\", \"openviduRecordingPublicAccess\": true, \"openviduRecordingNotification\": \"publisher_moderator\", \"openviduRecordingCustomLayout\": \"/opt/openvidu/custom-layout/\", \"openviduRecordingAutostopTimeout\": 120}\n\n\n\n\n\n\n\n\n\n\nReturned JSON\n\n\n\n\nversion\n: version of OpenVidu Server Pro\n\n\nopenviduServerDependencyVersion\n: version of OpenVidu Server Community Edition upon which this version of OpenVidu Server Pro is built on\n\n\nopenviduProStatsMonitoringInterval\n: interval in seconds for CPU, memory and net usage stats gathering in OpenVidu Server Pro host machine\n\n\nopenviduProStatsWebrtcInterval\n: interval in seconds for WebRTC stats gathering from Kurento Media Server WebRTC endpoints\n\n\nRest of properties\n: values given to \nsystem properties\n on OpenVidu Server Pro launch. These properties are common to method \nGET /config\n of OpenVidu Server Community Edition\n\n\n\n\n\n\n\n\nPOST \n/pro/restart\n\n\n\n\n\n\n\n\nRESTART OPENVIDU PRO\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nPOST\n\n\n\n\n\n\nURL\n\n\nhttps://\nYOUR_OPENVIDUSERVER_IP\n/pro/restart/\n\n\n\n\n\n\nHeaders\n\n\nAuthorization: Basic \nEncodeBase64(OPENVIDUAPP:\nYOUR_SECRET\n)\nContent-Type: application/json\n\n\n\n\n\n\nBody\n\n\n{\"openvidu.secret\": \"MY_SECRET\", \"openvidu.cdr\": true, \"openvidu.recording\": true, \"openvidu.recording.public-access\": true, \"openvidu.recording.notification\": \"publisher_moderator\", \"openvidu.recording.path\": \"/opt/openvidu/recordings\", \"openvidu.recording.custom-layout\": \"/opt/openvidu/custom-layout\", \"openvidu.recording.autostop-timeout\": 120, \"openvidu.streams.video.max-recv-bandwidth\": 1000, \"openvidu.streams.video.min-recv-bandwidth\": 300, \"openvidu.streams.video.max-send-bandwidth\": 1000, \"openvidu.streams.video.min-send-bandwidth\": 300, \"openvidu.pro.stats.monitoring-interval\": 30, \"openvidu.pro.stats.webrtc-interval\": 20}\n\n\n\n\n\n\n\n\n\n\nBody parameters\n\n\nThe body of the POST request is a JSON object with the new \nOpenVidu system properties\n to be applied on the restart process. Not all of them are available, and a few are exclusive to OpenVidu Pro (\nopenvidu.pro.stats.monitoring-interval\n, \nopenvidu.pro.stats.webrtc-interval\n). The complete list of available properties is listed below\n\n\n\n\n\n\nopenvidu.secret\n \n(optional string)\n : new secret to secure OpenVidu Pro\n\n\nopenvidu.cdr\n \n(optional boolean)\n : whether to enable OpenVidu Call Detail Record or not\n\n\nopenvidu.recording\n \n(optional boolean)\n : whether to enable OpenVidu recording module or not\n\n\nopenvidu.recording.public-access\n \n(optional boolean)\n : whether to allow free http access to recorded sessions or not\n\n\nopenvidu.recording.notification\n \n(optional string)\n : which users should receive the recording events in the client side (\n\"all\"\n, \n\"publisher_moderator\"\n, \n\"moderator\"\n or \n\"none\"\n)\n\n\nopenvidu.recording.path\n \n(optional string)\n : system path where to store the video files of recorded session\n\n\nopenvidu.recording.custom-layout\n \n(optional string)\n : sytem path where OpenVidu Server should look for custom recording layouts\n\n\nopenvidu.recording.autostop-timeout\n \n(optional number)\n : timeout in seconds for recordings to automatically stop\n\n\nopenvidu.streams.video.max-recv-bandwidth\n \n(optional number)\n : maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained\n\n\nopenvidu.streams.video.min-recv-bandwidth\n \n(optional number)\n : minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained\n\n\nopenvidu.streams.video.max-send-bandwidth\n \n(optional number)\n : maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained\n\n\nopenvidu.streams.video.min-send-bandwidth\n \n(optional number)\n : minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained\n\n\nopenvidu.pro.stats.monitoring-interval\n \n(optional number)\n : interval in seconds for CPU, memory and net usage stats gathering in OpenVidu Server Pro host machine. 0 means no gathering at all\n\n\nopenvidu.pro.stats.webrtc-interval\n \n(optional number)\n : interval in seconds for WebRTC stats gathering from Kurento Media Server WebRTC endpoints. 0 means no gathering at all\n\n\n\n\n\n\n\n\n\n\n\nHTTP responses\n\n\n\n\n200\n: the restarting process has been initialized. All properties are valid and OpenVidu Server should restart properly\n\n\n400\n: there's some problem with a body parameter. The response message will provide further details", 
            "title": "REST API Pro"
        }, 
        {
            "location": "/openvidu-pro/REST-API-pro/#list-of-available-operations", 
            "text": "Get OpenVidu Pro active configuration:  GET /pro/config  Restart OpenVidu Pro:  POST /pro/restart", 
            "title": "List of available operations"
        }, 
        {
            "location": "/openvidu-pro/REST-API-pro/#get-proconfig", 
            "text": "GET OPENVIDU PRO CONFIGURATION  PARAMETERS      Operation  GET    URL  https:// YOUR_OPENVIDUSERVER_IP /pro/config    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET )    Sample return  {\"version\": \"2.9.0\", \"openviduServerDependencyVersion\": \"2.9.0\", \"openviduProStatsMonitoringInterval\": 30, \"openviduProStatsWebrtcInterval\": 20, \"openviduPublicurl\": \"https://localhost:4443/\", \"openviduCdr\": false, \"maxRecvBandwidth\": 1000, \"minRecvBandwidth\": 300, \"maxSendBandwidth\": 1000, \"minSendBandwidth\": 300, \"openviduRecording\": true, \"openviduRecordingVersion\": \"2.9.0\", \"openviduRecordingPath\": \"/opt/openvidu/recordings/\", \"openviduRecordingPublicAccess\": true, \"openviduRecordingNotification\": \"publisher_moderator\", \"openviduRecordingCustomLayout\": \"/opt/openvidu/custom-layout/\", \"openviduRecordingAutostopTimeout\": 120}      Returned JSON   version : version of OpenVidu Server Pro  openviduServerDependencyVersion : version of OpenVidu Server Community Edition upon which this version of OpenVidu Server Pro is built on  openviduProStatsMonitoringInterval : interval in seconds for CPU, memory and net usage stats gathering in OpenVidu Server Pro host machine  openviduProStatsWebrtcInterval : interval in seconds for WebRTC stats gathering from Kurento Media Server WebRTC endpoints  Rest of properties : values given to  system properties  on OpenVidu Server Pro launch. These properties are common to method  GET /config  of OpenVidu Server Community Edition", 
            "title": "GET /pro/config"
        }, 
        {
            "location": "/openvidu-pro/REST-API-pro/#post-prorestart", 
            "text": "RESTART OPENVIDU PRO  PARAMETERS      Operation  POST    URL  https:// YOUR_OPENVIDUSERVER_IP /pro/restart/    Headers  Authorization: Basic  EncodeBase64(OPENVIDUAPP: YOUR_SECRET ) Content-Type: application/json    Body  {\"openvidu.secret\": \"MY_SECRET\", \"openvidu.cdr\": true, \"openvidu.recording\": true, \"openvidu.recording.public-access\": true, \"openvidu.recording.notification\": \"publisher_moderator\", \"openvidu.recording.path\": \"/opt/openvidu/recordings\", \"openvidu.recording.custom-layout\": \"/opt/openvidu/custom-layout\", \"openvidu.recording.autostop-timeout\": 120, \"openvidu.streams.video.max-recv-bandwidth\": 1000, \"openvidu.streams.video.min-recv-bandwidth\": 300, \"openvidu.streams.video.max-send-bandwidth\": 1000, \"openvidu.streams.video.min-send-bandwidth\": 300, \"openvidu.pro.stats.monitoring-interval\": 30, \"openvidu.pro.stats.webrtc-interval\": 20}      Body parameters  The body of the POST request is a JSON object with the new  OpenVidu system properties  to be applied on the restart process. Not all of them are available, and a few are exclusive to OpenVidu Pro ( openvidu.pro.stats.monitoring-interval ,  openvidu.pro.stats.webrtc-interval ). The complete list of available properties is listed below    openvidu.secret   (optional string)  : new secret to secure OpenVidu Pro  openvidu.cdr   (optional boolean)  : whether to enable OpenVidu Call Detail Record or not  openvidu.recording   (optional boolean)  : whether to enable OpenVidu recording module or not  openvidu.recording.public-access   (optional boolean)  : whether to allow free http access to recorded sessions or not  openvidu.recording.notification   (optional string)  : which users should receive the recording events in the client side ( \"all\" ,  \"publisher_moderator\" ,  \"moderator\"  or  \"none\" )  openvidu.recording.path   (optional string)  : system path where to store the video files of recorded session  openvidu.recording.custom-layout   (optional string)  : sytem path where OpenVidu Server should look for custom recording layouts  openvidu.recording.autostop-timeout   (optional number)  : timeout in seconds for recordings to automatically stop  openvidu.streams.video.max-recv-bandwidth   (optional number)  : maximum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained  openvidu.streams.video.min-recv-bandwidth   (optional number)  : minimum video bandwidth sent from clients to OpenVidu Server, in kbps. 0 means unconstrained  openvidu.streams.video.max-send-bandwidth   (optional number)  : maximum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained  openvidu.streams.video.min-send-bandwidth   (optional number)  : minimum video bandwidth sent from OpenVidu Server to clients, in kbps. 0 means unconstrained  openvidu.pro.stats.monitoring-interval   (optional number)  : interval in seconds for CPU, memory and net usage stats gathering in OpenVidu Server Pro host machine. 0 means no gathering at all  openvidu.pro.stats.webrtc-interval   (optional number)  : interval in seconds for WebRTC stats gathering from Kurento Media Server WebRTC endpoints. 0 means no gathering at all      HTTP responses   200 : the restarting process has been initialized. All properties are valid and OpenVidu Server should restart properly  400 : there's some problem with a body parameter. The response message will provide further details", 
            "title": "POST /pro/restart"
        }
    ]
}